import { g as Ife, c as _fe, b as ut, B as Fe } from "./main.3b3cef45.js";
function Afe(Md, zd) {
  for (var Oi = 0; Oi < zd.length; Oi++) {
    const qt = zd[Oi];
    if (typeof qt != "string" && !Array.isArray(qt)) {
      for (const So in qt)
        if (So !== "default" && !(So in Md)) {
          const za = Object.getOwnPropertyDescriptor(qt, So);
          za &&
            Object.defineProperty(
              Md,
              So,
              za.get ? za : { enumerable: !0, get: () => qt[So] }
            );
        }
    }
  }
  return Object.freeze(
    Object.defineProperty(Md, Symbol.toStringTag, { value: "Module" })
  );
}
var rg = { exports: {} },
  fv,
  eA;
function Sfe() {
  return (
    eA ||
      ((eA = 1),
      (fv = function () {
        throw new Error(
          "ws does not work in the browser. Browser clients must use the native WebSocket object"
        );
      })),
    fv
  );
}
(function (Md, zd) {
  (function (Oi, qt) {
    qt(zd);
  })(_fe, function (Oi) {
    var qt =
      typeof globalThis < "u"
        ? globalThis
        : typeof window < "u"
        ? window
        : typeof globalThis < "u"
        ? globalThis
        : typeof self < "u"
        ? self
        : {};
    function So(t) {
      return t &&
        t.__esModule &&
        Object.prototype.hasOwnProperty.call(t, "default")
        ? t.default
        : t;
    }
    function za(t) {
      var e = t.default;
      if (typeof e == "function") {
        var r = function () {
          return e.apply(this, arguments);
        };
        r.prototype = e.prototype;
      } else r = {};
      return (
        Object.defineProperty(r, "__esModule", { value: !0 }),
        Object.keys(t).forEach(function (i) {
          var s = Object.getOwnPropertyDescriptor(t, i);
          Object.defineProperty(
            r,
            i,
            s.get
              ? s
              : {
                  enumerable: !0,
                  get: function () {
                    return t[i];
                  },
                }
          );
        }),
        r
      );
    }
    var rt = { exports: {} },
      qa = typeof Reflect == "object" ? Reflect : null,
      gv =
        qa && typeof qa.apply == "function"
          ? qa.apply
          : function (t, e, r) {
              return Function.prototype.apply.call(t, e, r);
            },
      qd;
    qa && typeof qa.ownKeys == "function"
      ? (qd = qa.ownKeys)
      : Object.getOwnPropertySymbols
      ? (qd = function (t) {
          return Object.getOwnPropertyNames(t).concat(
            Object.getOwnPropertySymbols(t)
          );
        })
      : (qd = function (t) {
          return Object.getOwnPropertyNames(t);
        });
    function tA(t) {
      console && console.warn && console.warn(t);
    }
    var wv =
      Number.isNaN ||
      function (t) {
        return t !== t;
      };
    function Xe() {
      Xe.init.call(this);
    }
    (rt.exports = Xe),
      (rt.exports.once = nA),
      (Xe.EventEmitter = Xe),
      (Xe.prototype._events = void 0),
      (Xe.prototype._eventsCount = 0),
      (Xe.prototype._maxListeners = void 0);
    var mv = 10;
    function Hd(t) {
      if (typeof t != "function")
        throw new TypeError(
          'The "listener" argument must be of type Function. Received type ' +
            typeof t
        );
    }
    Object.defineProperty(Xe, "defaultMaxListeners", {
      enumerable: !0,
      get: function () {
        return mv;
      },
      set: function (t) {
        if (typeof t != "number" || t < 0 || wv(t))
          throw new RangeError(
            'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
              t +
              "."
          );
        mv = t;
      },
    }),
      (Xe.init = function () {
        (this._events === void 0 ||
          this._events === Object.getPrototypeOf(this)._events) &&
          ((this._events = Object.create(null)), (this._eventsCount = 0)),
          (this._maxListeners = this._maxListeners || void 0);
      }),
      (Xe.prototype.setMaxListeners = function (t) {
        if (typeof t != "number" || t < 0 || wv(t))
          throw new RangeError(
            'The value of "n" is out of range. It must be a non-negative number. Received ' +
              t +
              "."
          );
        return (this._maxListeners = t), this;
      });
    function yv(t) {
      return t._maxListeners === void 0
        ? Xe.defaultMaxListeners
        : t._maxListeners;
    }
    (Xe.prototype.getMaxListeners = function () {
      return yv(this);
    }),
      (Xe.prototype.emit = function (t) {
        for (var e = [], r = 1; r < arguments.length; r++) e.push(arguments[r]);
        var i = t === "error",
          s = this._events;
        if (s !== void 0) i = i && s.error === void 0;
        else if (!i) return !1;
        if (i) {
          var n;
          if ((e.length > 0 && (n = e[0]), n instanceof Error)) throw n;
          var o = new Error(
            "Unhandled error." + (n ? " (" + n.message + ")" : "")
          );
          throw ((o.context = n), o);
        }
        var a = s[t];
        if (a === void 0) return !1;
        if (typeof a == "function") gv(a, this, e);
        else
          for (var c = a.length, l = xv(a, c), r = 0; r < c; ++r)
            gv(l[r], this, e);
        return !0;
      });
    function bv(t, e, r, i) {
      var s, n, o;
      if (
        (Hd(r),
        (n = t._events),
        n === void 0
          ? ((n = t._events = Object.create(null)), (t._eventsCount = 0))
          : (n.newListener !== void 0 &&
              (t.emit("newListener", e, r.listener ? r.listener : r),
              (n = t._events)),
            (o = n[e])),
        o === void 0)
      )
        (o = n[e] = r), ++t._eventsCount;
      else if (
        (typeof o == "function"
          ? (o = n[e] = i ? [r, o] : [o, r])
          : i
          ? o.unshift(r)
          : o.push(r),
        (s = yv(t)),
        s > 0 && o.length > s && !o.warned)
      ) {
        o.warned = !0;
        var a = new Error(
          "Possible EventEmitter memory leak detected. " +
            o.length +
            " " +
            String(e) +
            " listeners added. Use emitter.setMaxListeners() to increase limit"
        );
        (a.name = "MaxListenersExceededWarning"),
          (a.emitter = t),
          (a.type = e),
          (a.count = o.length),
          tA(a);
      }
      return t;
    }
    (Xe.prototype.addListener = function (t, e) {
      return bv(this, t, e, !1);
    }),
      (Xe.prototype.on = Xe.prototype.addListener),
      (Xe.prototype.prependListener = function (t, e) {
        return bv(this, t, e, !0);
      });
    function rA() {
      if (!this.fired)
        return (
          this.target.removeListener(this.type, this.wrapFn),
          (this.fired = !0),
          arguments.length === 0
            ? this.listener.call(this.target)
            : this.listener.apply(this.target, arguments)
        );
    }
    function vv(t, e, r) {
      var i = { fired: !1, wrapFn: void 0, target: t, type: e, listener: r },
        s = rA.bind(i);
      return (s.listener = r), (i.wrapFn = s), s;
    }
    (Xe.prototype.once = function (t, e) {
      return Hd(e), this.on(t, vv(this, t, e)), this;
    }),
      (Xe.prototype.prependOnceListener = function (t, e) {
        return Hd(e), this.prependListener(t, vv(this, t, e)), this;
      }),
      (Xe.prototype.removeListener = function (t, e) {
        var r, i, s, n, o;
        if ((Hd(e), (i = this._events), i === void 0)) return this;
        if (((r = i[t]), r === void 0)) return this;
        if (r === e || r.listener === e)
          --this._eventsCount === 0
            ? (this._events = Object.create(null))
            : (delete i[t],
              i.removeListener &&
                this.emit("removeListener", t, r.listener || e));
        else if (typeof r != "function") {
          for (s = -1, n = r.length - 1; n >= 0; n--)
            if (r[n] === e || r[n].listener === e) {
              (o = r[n].listener), (s = n);
              break;
            }
          if (s < 0) return this;
          s === 0 ? r.shift() : iA(r, s),
            r.length === 1 && (i[t] = r[0]),
            i.removeListener !== void 0 &&
              this.emit("removeListener", t, o || e);
        }
        return this;
      }),
      (Xe.prototype.off = Xe.prototype.removeListener),
      (Xe.prototype.removeAllListeners = function (t) {
        var e, r, i;
        if (((r = this._events), r === void 0)) return this;
        if (r.removeListener === void 0)
          return (
            arguments.length === 0
              ? ((this._events = Object.create(null)), (this._eventsCount = 0))
              : r[t] !== void 0 &&
                (--this._eventsCount === 0
                  ? (this._events = Object.create(null))
                  : delete r[t]),
            this
          );
        if (arguments.length === 0) {
          var s = Object.keys(r),
            n;
          for (i = 0; i < s.length; ++i)
            (n = s[i]), n !== "removeListener" && this.removeAllListeners(n);
          return (
            this.removeAllListeners("removeListener"),
            (this._events = Object.create(null)),
            (this._eventsCount = 0),
            this
          );
        }
        if (((e = r[t]), typeof e == "function")) this.removeListener(t, e);
        else if (e !== void 0)
          for (i = e.length - 1; i >= 0; i--) this.removeListener(t, e[i]);
        return this;
      });
    function Ev(t, e, r) {
      var i = t._events;
      if (i === void 0) return [];
      var s = i[e];
      return s === void 0
        ? []
        : typeof s == "function"
        ? r
          ? [s.listener || s]
          : [s]
        : r
        ? sA(s)
        : xv(s, s.length);
    }
    (Xe.prototype.listeners = function (t) {
      return Ev(this, t, !0);
    }),
      (Xe.prototype.rawListeners = function (t) {
        return Ev(this, t, !1);
      }),
      (Xe.listenerCount = function (t, e) {
        return typeof t.listenerCount == "function"
          ? t.listenerCount(e)
          : Cv.call(t, e);
      }),
      (Xe.prototype.listenerCount = Cv);
    function Cv(t) {
      var e = this._events;
      if (e !== void 0) {
        var r = e[t];
        if (typeof r == "function") return 1;
        if (r !== void 0) return r.length;
      }
      return 0;
    }
    Xe.prototype.eventNames = function () {
      return this._eventsCount > 0 ? qd(this._events) : [];
    };
    function xv(t, e) {
      for (var r = new Array(e), i = 0; i < e; ++i) r[i] = t[i];
      return r;
    }
    function iA(t, e) {
      for (; e + 1 < t.length; e++) t[e] = t[e + 1];
      t.pop();
    }
    function sA(t) {
      for (var e = new Array(t.length), r = 0; r < e.length; ++r)
        e[r] = t[r].listener || t[r];
      return e;
    }
    function nA(t, e) {
      return new Promise(function (r, i) {
        function s(o) {
          t.removeListener(e, n), i(o);
        }
        function n() {
          typeof t.removeListener == "function" && t.removeListener("error", s),
            r([].slice.call(arguments));
        }
        Iv(t, e, n, { once: !0 }), e !== "error" && oA(t, s, { once: !0 });
      });
    }
    function oA(t, e, r) {
      typeof t.on == "function" && Iv(t, "error", e, r);
    }
    function Iv(t, e, r, i) {
      if (typeof t.on == "function") i.once ? t.once(e, r) : t.on(e, r);
      else if (typeof t.addEventListener == "function")
        t.addEventListener(e, function s(n) {
          i.once && t.removeEventListener(e, s), r(n);
        });
      else
        throw new TypeError(
          'The "emitter" argument must be of type EventEmitter. Received type ' +
            typeof t
        );
    }
    var _v = function (t, e, r) {
        if (r || arguments.length === 2)
          for (var i = 0, s = e.length, n; i < s; i++)
            (n || !(i in e)) &&
              (n || (n = Array.prototype.slice.call(e, 0, i)), (n[i] = e[i]));
        return t.concat(n || Array.prototype.slice.call(e));
      },
      aA = (function () {
        function t(e, r, i) {
          (this.name = e),
            (this.version = r),
            (this.os = i),
            (this.type = "browser");
        }
        return t;
      })(),
      cA = (function () {
        function t(e) {
          (this.version = e),
            (this.type = "node"),
            (this.name = "node"),
            (this.os = ut.platform);
        }
        return t;
      })(),
      lA = (function () {
        function t(e, r, i, s) {
          (this.name = e),
            (this.version = r),
            (this.os = i),
            (this.bot = s),
            (this.type = "bot-device");
        }
        return t;
      })(),
      uA = (function () {
        function t() {
          (this.type = "bot"),
            (this.bot = !0),
            (this.name = "bot"),
            (this.version = null),
            (this.os = null);
        }
        return t;
      })(),
      hA = (function () {
        function t() {
          (this.type = "react-native"),
            (this.name = "react-native"),
            (this.version = null),
            (this.os = null);
        }
        return t;
      })(),
      dA =
        /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,
      pA =
        /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,
      Av = 3,
      fA = [
        ["aol", /AOLShield\/([0-9\._]+)/],
        ["edge", /Edge\/([0-9\._]+)/],
        ["edge-ios", /EdgiOS\/([0-9\._]+)/],
        ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
        ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
        ["samsung", /SamsungBrowser\/([0-9\.]+)/],
        ["silk", /\bSilk\/([0-9._-]+)\b/],
        ["miui", /MiuiBrowser\/([0-9\.]+)$/],
        ["beaker", /BeakerBrowser\/([0-9\.]+)/],
        ["edge-chromium", /EdgA?\/([0-9\.]+)/],
        [
          "chromium-webview",
          /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/,
        ],
        ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
        ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
        ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
        ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
        ["fxios", /FxiOS\/([0-9\.]+)/],
        ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
        ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
        ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
        ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
        [
          "pie",
          /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/,
        ],
        ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
        ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
        ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
        ["ie", /MSIE\s(7\.0)/],
        ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
        ["android", /Android\s([0-9\.]+)/],
        ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
        ["safari", /Version\/([0-9\._]+).*Safari/],
        ["facebook", /FB[AS]V\/([0-9\.]+)/],
        ["instagram", /Instagram\s([0-9\.]+)/],
        ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
        ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
        ["curl", /^curl\/([0-9\.]+)$/],
        ["searchbot", dA],
      ],
      Sv = [
        ["iOS", /iP(hone|od|ad)/],
        ["Android OS", /Android/],
        ["BlackBerry OS", /BlackBerry|BB10/],
        ["Windows Mobile", /IEMobile/],
        ["Amazon OS", /Kindle/],
        ["Windows 3.11", /Win16/],
        ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
        ["Windows 98", /(Windows 98)|(Win98)/],
        ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
        ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
        ["Windows Server 2003", /(Windows NT 5.2)/],
        ["Windows Vista", /(Windows NT 6.0)/],
        ["Windows 7", /(Windows NT 6.1)/],
        ["Windows 8", /(Windows NT 6.2)/],
        ["Windows 8.1", /(Windows NT 6.3)/],
        ["Windows 10", /(Windows NT 10.0)/],
        ["Windows ME", /Windows ME/],
        ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
        ["Open BSD", /OpenBSD/],
        ["Sun OS", /SunOS/],
        ["Chrome OS", /CrOS/],
        ["Linux", /(Linux)|(X11)/],
        ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
        ["QNX", /QNX/],
        ["BeOS", /BeOS/],
        ["OS/2", /OS\/2/],
      ];
    function Pv(t) {
      return t
        ? Ov(t)
        : typeof document > "u" &&
          typeof navigator < "u" &&
          navigator.product === "ReactNative"
        ? new hA()
        : typeof navigator < "u"
        ? Ov(navigator.userAgent)
        : mA();
    }
    function gA(t) {
      return (
        t !== "" &&
        fA.reduce(function (e, r) {
          var i = r[0],
            s = r[1];
          if (e) return e;
          var n = s.exec(t);
          return !!n && [i, n];
        }, !1)
      );
    }
    function Ov(t) {
      var e = gA(t);
      if (!e) return null;
      var r = e[0],
        i = e[1];
      if (r === "searchbot") return new uA();
      var s = i[1] && i[1].split(".").join("_").split("_").slice(0, 3);
      s
        ? s.length < Av && (s = _v(_v([], s, !0), yA(Av - s.length), !0))
        : (s = []);
      var n = s.join("."),
        o = wA(t),
        a = pA.exec(t);
      return a && a[1] ? new lA(r, n, o, a[1]) : new aA(r, n, o);
    }
    function wA(t) {
      for (var e = 0, r = Sv.length; e < r; e++) {
        var i = Sv[e],
          s = i[0],
          n = i[1],
          o = n.exec(t);
        if (o) return s;
      }
      return null;
    }
    function mA() {
      var t = typeof ut < "u" && ut.version;
      return t ? new cA(ut.version.slice(1)) : null;
    }
    function yA(t) {
      for (var e = [], r = 0; r < t; r++) e.push("0");
      return e;
    }
    var z = {};
    /*! *****************************************************************************
		Copyright (c) Microsoft Corporation.

		Permission to use, copy, modify, and/or distribute this software for any
		purpose with or without fee is hereby granted.

		THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
		REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
		AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
		INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
		LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
		OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
		PERFORMANCE OF THIS SOFTWARE.
		***************************************************************************** */ var ig =
      function (t, e) {
        return (
          (ig =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (r, i) {
                r.__proto__ = i;
              }) ||
            function (r, i) {
              for (var s in i) i.hasOwnProperty(s) && (r[s] = i[s]);
            }),
          ig(t, e)
        );
      };
    function bA(t, e) {
      ig(t, e);
      function r() {
        this.constructor = t;
      }
      t.prototype =
        e === null ? Object.create(e) : ((r.prototype = e.prototype), new r());
    }
    var sg = function () {
      return (
        (sg =
          Object.assign ||
          function (t) {
            for (var e, r = 1, i = arguments.length; r < i; r++) {
              e = arguments[r];
              for (var s in e)
                Object.prototype.hasOwnProperty.call(e, s) && (t[s] = e[s]);
            }
            return t;
          }),
        sg.apply(this, arguments)
      );
    };
    function vA(t, e) {
      var r = {};
      for (var i in t)
        Object.prototype.hasOwnProperty.call(t, i) &&
          e.indexOf(i) < 0 &&
          (r[i] = t[i]);
      if (t != null && typeof Object.getOwnPropertySymbols == "function")
        for (var s = 0, i = Object.getOwnPropertySymbols(t); s < i.length; s++)
          e.indexOf(i[s]) < 0 &&
            Object.prototype.propertyIsEnumerable.call(t, i[s]) &&
            (r[i[s]] = t[i[s]]);
      return r;
    }
    function EA(t, e, r, i) {
      var s = arguments.length,
        n =
          s < 3
            ? e
            : i === null
            ? (i = Object.getOwnPropertyDescriptor(e, r))
            : i,
        o;
      if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        n = Reflect.decorate(t, e, r, i);
      else
        for (var a = t.length - 1; a >= 0; a--)
          (o = t[a]) &&
            (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
      return s > 3 && n && Object.defineProperty(e, r, n), n;
    }
    function CA(t, e) {
      return function (r, i) {
        e(r, i, t);
      };
    }
    function xA(t, e) {
      if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
        return Reflect.metadata(t, e);
    }
    function IA(t, e, r, i) {
      function s(n) {
        return n instanceof r
          ? n
          : new r(function (o) {
              o(n);
            });
      }
      return new (r || (r = Promise))(function (n, o) {
        function a(u) {
          try {
            l(i.next(u));
          } catch (h) {
            o(h);
          }
        }
        function c(u) {
          try {
            l(i.throw(u));
          } catch (h) {
            o(h);
          }
        }
        function l(u) {
          u.done ? n(u.value) : s(u.value).then(a, c);
        }
        l((i = i.apply(t, e || [])).next());
      });
    }
    function _A(t, e) {
      var r = {
          label: 0,
          sent: function () {
            if (n[0] & 1) throw n[1];
            return n[1];
          },
          trys: [],
          ops: [],
        },
        i,
        s,
        n,
        o;
      return (
        (o = { next: a(0), throw: a(1), return: a(2) }),
        typeof Symbol == "function" &&
          (o[Symbol.iterator] = function () {
            return this;
          }),
        o
      );
      function a(l) {
        return function (u) {
          return c([l, u]);
        };
      }
      function c(l) {
        if (i) throw new TypeError("Generator is already executing.");
        for (; r; )
          try {
            if (
              ((i = 1),
              s &&
                (n =
                  l[0] & 2
                    ? s.return
                    : l[0]
                    ? s.throw || ((n = s.return) && n.call(s), 0)
                    : s.next) &&
                !(n = n.call(s, l[1])).done)
            )
              return n;
            switch (((s = 0), n && (l = [l[0] & 2, n.value]), l[0])) {
              case 0:
              case 1:
                n = l;
                break;
              case 4:
                return r.label++, { value: l[1], done: !1 };
              case 5:
                r.label++, (s = l[1]), (l = [0]);
                continue;
              case 7:
                (l = r.ops.pop()), r.trys.pop();
                continue;
              default:
                if (
                  ((n = r.trys),
                  !(n = n.length > 0 && n[n.length - 1]) &&
                    (l[0] === 6 || l[0] === 2))
                ) {
                  r = 0;
                  continue;
                }
                if (l[0] === 3 && (!n || (l[1] > n[0] && l[1] < n[3]))) {
                  r.label = l[1];
                  break;
                }
                if (l[0] === 6 && r.label < n[1]) {
                  (r.label = n[1]), (n = l);
                  break;
                }
                if (n && r.label < n[2]) {
                  (r.label = n[2]), r.ops.push(l);
                  break;
                }
                n[2] && r.ops.pop(), r.trys.pop();
                continue;
            }
            l = e.call(t, r);
          } catch (u) {
            (l = [6, u]), (s = 0);
          } finally {
            i = n = 0;
          }
        if (l[0] & 5) throw l[1];
        return { value: l[0] ? l[1] : void 0, done: !0 };
      }
    }
    function AA(t, e, r, i) {
      i === void 0 && (i = r), (t[i] = e[r]);
    }
    function SA(t, e) {
      for (var r in t) r !== "default" && !e.hasOwnProperty(r) && (e[r] = t[r]);
    }
    function ng(t) {
      var e = typeof Symbol == "function" && Symbol.iterator,
        r = e && t[e],
        i = 0;
      if (r) return r.call(t);
      if (t && typeof t.length == "number")
        return {
          next: function () {
            return (
              t && i >= t.length && (t = void 0),
              { value: t && t[i++], done: !t }
            );
          },
        };
      throw new TypeError(
        e ? "Object is not iterable." : "Symbol.iterator is not defined."
      );
    }
    function Nv(t, e) {
      var r = typeof Symbol == "function" && t[Symbol.iterator];
      if (!r) return t;
      var i = r.call(t),
        s,
        n = [],
        o;
      try {
        for (; (e === void 0 || e-- > 0) && !(s = i.next()).done; )
          n.push(s.value);
      } catch (a) {
        o = { error: a };
      } finally {
        try {
          s && !s.done && (r = i.return) && r.call(i);
        } finally {
          if (o) throw o.error;
        }
      }
      return n;
    }
    function PA() {
      for (var t = [], e = 0; e < arguments.length; e++)
        t = t.concat(Nv(arguments[e]));
      return t;
    }
    function OA() {
      for (var t = 0, e = 0, r = arguments.length; e < r; e++)
        t += arguments[e].length;
      for (var i = Array(t), s = 0, e = 0; e < r; e++)
        for (var n = arguments[e], o = 0, a = n.length; o < a; o++, s++)
          i[s] = n[o];
      return i;
    }
    function Xl(t) {
      return this instanceof Xl ? ((this.v = t), this) : new Xl(t);
    }
    function NA(t, e, r) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var i = r.apply(t, e || []),
        s,
        n = [];
      return (
        (s = {}),
        o("next"),
        o("throw"),
        o("return"),
        (s[Symbol.asyncIterator] = function () {
          return this;
        }),
        s
      );
      function o(d) {
        i[d] &&
          (s[d] = function (g) {
            return new Promise(function (p, w) {
              n.push([d, g, p, w]) > 1 || a(d, g);
            });
          });
      }
      function a(d, g) {
        try {
          c(i[d](g));
        } catch (p) {
          h(n[0][3], p);
        }
      }
      function c(d) {
        d.value instanceof Xl
          ? Promise.resolve(d.value.v).then(l, u)
          : h(n[0][2], d);
      }
      function l(d) {
        a("next", d);
      }
      function u(d) {
        a("throw", d);
      }
      function h(d, g) {
        d(g), n.shift(), n.length && a(n[0][0], n[0][1]);
      }
    }
    function TA(t) {
      var e, r;
      return (
        (e = {}),
        i("next"),
        i("throw", function (s) {
          throw s;
        }),
        i("return"),
        (e[Symbol.iterator] = function () {
          return this;
        }),
        e
      );
      function i(s, n) {
        e[s] = t[s]
          ? function (o) {
              return (r = !r)
                ? { value: Xl(t[s](o)), done: s === "return" }
                : n
                ? n(o)
                : o;
            }
          : n;
      }
    }
    function kA(t) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var e = t[Symbol.asyncIterator],
        r;
      return e
        ? e.call(t)
        : ((t = typeof ng == "function" ? ng(t) : t[Symbol.iterator]()),
          (r = {}),
          i("next"),
          i("throw"),
          i("return"),
          (r[Symbol.asyncIterator] = function () {
            return this;
          }),
          r);
      function i(n) {
        r[n] =
          t[n] &&
          function (o) {
            return new Promise(function (a, c) {
              (o = t[n](o)), s(a, c, o.done, o.value);
            });
          };
      }
      function s(n, o, a, c) {
        Promise.resolve(c).then(function (l) {
          n({ value: l, done: a });
        }, o);
      }
    }
    function RA(t, e) {
      return (
        Object.defineProperty
          ? Object.defineProperty(t, "raw", { value: e })
          : (t.raw = e),
        t
      );
    }
    function $A(t) {
      if (t && t.__esModule) return t;
      var e = {};
      if (t != null)
        for (var r in t) Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      return (e.default = t), e;
    }
    function FA(t) {
      return t && t.__esModule ? t : { default: t };
    }
    function BA(t, e) {
      if (!e.has(t))
        throw new TypeError("attempted to get private field on non-instance");
      return e.get(t);
    }
    function LA(t, e, r) {
      if (!e.has(t))
        throw new TypeError("attempted to set private field on non-instance");
      return e.set(t, r), r;
    }
    var UA = Object.freeze({
        __proto__: null,
        __extends: bA,
        get __assign() {
          return sg;
        },
        __rest: vA,
        __decorate: EA,
        __param: CA,
        __metadata: xA,
        __awaiter: IA,
        __generator: _A,
        __createBinding: AA,
        __exportStar: SA,
        __values: ng,
        __read: Nv,
        __spread: PA,
        __spreadArrays: OA,
        __await: Xl,
        __asyncGenerator: NA,
        __asyncDelegator: TA,
        __asyncValues: kA,
        __makeTemplateObject: RA,
        __importStar: $A,
        __importDefault: FA,
        __classPrivateFieldGet: BA,
        __classPrivateFieldSet: LA,
      }),
      Vd = za(UA),
      Tv = {},
      Ql = {},
      kv;
    function DA() {
      if (kv) return Ql;
      (kv = 1),
        Object.defineProperty(Ql, "__esModule", { value: !0 }),
        (Ql.delay = void 0);
      function t(e) {
        return new Promise((r) => {
          setTimeout(() => {
            r(!0);
          }, e);
        });
      }
      return (Ql.delay = t), Ql;
    }
    var Po = {},
      Rv = {},
      Ha = {},
      $v;
    function jA() {
      return (
        $v ||
          (($v = 1),
          Object.defineProperty(Ha, "__esModule", { value: !0 }),
          (Ha.ONE_THOUSAND = Ha.ONE_HUNDRED = void 0),
          (Ha.ONE_HUNDRED = 100),
          (Ha.ONE_THOUSAND = 1e3)),
        Ha
      );
    }
    var Fv = {},
      Bv;
    function MA() {
      return (
        Bv ||
          ((Bv = 1),
          (function (t) {
            Object.defineProperty(t, "__esModule", { value: !0 }),
              (t.ONE_YEAR =
                t.FOUR_WEEKS =
                t.THREE_WEEKS =
                t.TWO_WEEKS =
                t.ONE_WEEK =
                t.THIRTY_DAYS =
                t.SEVEN_DAYS =
                t.FIVE_DAYS =
                t.THREE_DAYS =
                t.ONE_DAY =
                t.TWENTY_FOUR_HOURS =
                t.TWELVE_HOURS =
                t.SIX_HOURS =
                t.THREE_HOURS =
                t.ONE_HOUR =
                t.SIXTY_MINUTES =
                t.THIRTY_MINUTES =
                t.TEN_MINUTES =
                t.FIVE_MINUTES =
                t.ONE_MINUTE =
                t.SIXTY_SECONDS =
                t.THIRTY_SECONDS =
                t.TEN_SECONDS =
                t.FIVE_SECONDS =
                t.ONE_SECOND =
                  void 0),
              (t.ONE_SECOND = 1),
              (t.FIVE_SECONDS = 5),
              (t.TEN_SECONDS = 10),
              (t.THIRTY_SECONDS = 30),
              (t.SIXTY_SECONDS = 60),
              (t.ONE_MINUTE = t.SIXTY_SECONDS),
              (t.FIVE_MINUTES = t.ONE_MINUTE * 5),
              (t.TEN_MINUTES = t.ONE_MINUTE * 10),
              (t.THIRTY_MINUTES = t.ONE_MINUTE * 30),
              (t.SIXTY_MINUTES = t.ONE_MINUTE * 60),
              (t.ONE_HOUR = t.SIXTY_MINUTES),
              (t.THREE_HOURS = t.ONE_HOUR * 3),
              (t.SIX_HOURS = t.ONE_HOUR * 6),
              (t.TWELVE_HOURS = t.ONE_HOUR * 12),
              (t.TWENTY_FOUR_HOURS = t.ONE_HOUR * 24),
              (t.ONE_DAY = t.TWENTY_FOUR_HOURS),
              (t.THREE_DAYS = t.ONE_DAY * 3),
              (t.FIVE_DAYS = t.ONE_DAY * 5),
              (t.SEVEN_DAYS = t.ONE_DAY * 7),
              (t.THIRTY_DAYS = t.ONE_DAY * 30),
              (t.ONE_WEEK = t.SEVEN_DAYS),
              (t.TWO_WEEKS = t.ONE_WEEK * 2),
              (t.THREE_WEEKS = t.ONE_WEEK * 3),
              (t.FOUR_WEEKS = t.ONE_WEEK * 4),
              (t.ONE_YEAR = t.ONE_DAY * 365);
          })(Fv)),
        Fv
      );
    }
    var Lv;
    function Uv() {
      return (
        Lv ||
          ((Lv = 1),
          (function (t) {
            Object.defineProperty(t, "__esModule", { value: !0 });
            const e = Vd;
            e.__exportStar(jA(), t), e.__exportStar(MA(), t);
          })(Rv)),
        Rv
      );
    }
    var Dv;
    function zA() {
      if (Dv) return Po;
      (Dv = 1),
        Object.defineProperty(Po, "__esModule", { value: !0 }),
        (Po.fromMiliseconds = Po.toMiliseconds = void 0);
      const t = Uv();
      function e(i) {
        return i * t.ONE_THOUSAND;
      }
      Po.toMiliseconds = e;
      function r(i) {
        return Math.floor(i / t.ONE_THOUSAND);
      }
      return (Po.fromMiliseconds = r), Po;
    }
    var jv;
    function qA() {
      return (
        jv ||
          ((jv = 1),
          (function (t) {
            Object.defineProperty(t, "__esModule", { value: !0 });
            const e = Vd;
            e.__exportStar(DA(), t), e.__exportStar(zA(), t);
          })(Tv)),
        Tv
      );
    }
    var Va = {},
      Mv;
    function HA() {
      if (Mv) return Va;
      (Mv = 1),
        Object.defineProperty(Va, "__esModule", { value: !0 }),
        (Va.Watch = void 0);
      class t {
        constructor() {
          this.timestamps = new Map();
        }
        start(r) {
          if (this.timestamps.has(r))
            throw new Error(`Watch already started for label: ${r}`);
          this.timestamps.set(r, { started: Date.now() });
        }
        stop(r) {
          const i = this.get(r);
          if (typeof i.elapsed < "u")
            throw new Error(`Watch already stopped for label: ${r}`);
          const s = Date.now() - i.started;
          this.timestamps.set(r, { started: i.started, elapsed: s });
        }
        get(r) {
          const i = this.timestamps.get(r);
          if (typeof i > "u")
            throw new Error(`No timestamp found for label: ${r}`);
          return i;
        }
        elapsed(r) {
          const i = this.get(r);
          return i.elapsed || Date.now() - i.started;
        }
      }
      return (Va.Watch = t), (Va.default = t), Va;
    }
    var zv = {},
      eu = {},
      qv;
    function VA() {
      if (qv) return eu;
      (qv = 1),
        Object.defineProperty(eu, "__esModule", { value: !0 }),
        (eu.IWatch = void 0);
      class t {}
      return (eu.IWatch = t), eu;
    }
    var Hv;
    function WA() {
      return (
        Hv ||
          ((Hv = 1),
          (function (t) {
            Object.defineProperty(t, "__esModule", { value: !0 }),
              Vd.__exportStar(VA(), t);
          })(zv)),
        zv
      );
    }
    (function (t) {
      Object.defineProperty(t, "__esModule", { value: !0 });
      const e = Vd;
      e.__exportStar(qA(), t),
        e.__exportStar(HA(), t),
        e.__exportStar(WA(), t),
        e.__exportStar(Uv(), t);
    })(z);
    var ht = {};
    Object.defineProperty(ht, "__esModule", { value: !0 }),
      (ht.getLocalStorage =
        ht.getLocalStorageOrThrow =
        ht.getCrypto =
        ht.getCryptoOrThrow =
        og =
        ht.getLocation =
        ht.getLocationOrThrow =
        tu =
        ht.getNavigator =
        ht.getNavigatorOrThrow =
        Gi =
        ht.getDocument =
        ht.getDocumentOrThrow =
        ht.getFromWindowOrThrow =
        ht.getFromWindow =
          void 0);
    function Oo(t) {
      let e;
      return (
        typeof window < "u" && typeof window[t] < "u" && (e = window[t]), e
      );
    }
    ht.getFromWindow = Oo;
    function Wa(t) {
      const e = Oo(t);
      if (!e) throw new Error(`${t} is not defined in Window`);
      return e;
    }
    ht.getFromWindowOrThrow = Wa;
    function KA() {
      return Wa("document");
    }
    ht.getDocumentOrThrow = KA;
    function GA() {
      return Oo("document");
    }
    var Gi = (ht.getDocument = GA);
    function ZA() {
      return Wa("navigator");
    }
    ht.getNavigatorOrThrow = ZA;
    function YA() {
      return Oo("navigator");
    }
    var tu = (ht.getNavigator = YA);
    function JA() {
      return Wa("location");
    }
    ht.getLocationOrThrow = JA;
    function XA() {
      return Oo("location");
    }
    var og = (ht.getLocation = XA);
    function QA() {
      return Wa("crypto");
    }
    ht.getCryptoOrThrow = QA;
    function eS() {
      return Oo("crypto");
    }
    ht.getCrypto = eS;
    function tS() {
      return Wa("localStorage");
    }
    ht.getLocalStorageOrThrow = tS;
    function rS() {
      return Oo("localStorage");
    }
    ht.getLocalStorage = rS;
    var ag = {};
    Object.defineProperty(ag, "__esModule", { value: !0 });
    var cg = (ag.getWindowMetadata = void 0);
    const Vv = ht;
    function iS() {
      let t, e;
      try {
        (t = Vv.getDocumentOrThrow()), (e = Vv.getLocationOrThrow());
      } catch {
        return null;
      }
      function r() {
        const u = t.getElementsByTagName("link"),
          h = [];
        for (let d = 0; d < u.length; d++) {
          const g = u[d],
            p = g.getAttribute("rel");
          if (p && p.toLowerCase().indexOf("icon") > -1) {
            const w = g.getAttribute("href");
            if (w)
              if (
                w.toLowerCase().indexOf("https:") === -1 &&
                w.toLowerCase().indexOf("http:") === -1 &&
                w.indexOf("//") !== 0
              ) {
                let f = e.protocol + "//" + e.host;
                if (w.indexOf("/") === 0) f += w;
                else {
                  const m = e.pathname.split("/");
                  m.pop();
                  const y = m.join("/");
                  f += y + "/" + w;
                }
                h.push(f);
              } else if (w.indexOf("//") === 0) {
                const f = e.protocol + w;
                h.push(f);
              } else h.push(w);
          }
        }
        return h;
      }
      function i(...u) {
        const h = t.getElementsByTagName("meta");
        for (let d = 0; d < h.length; d++) {
          const g = h[d],
            p = ["itemprop", "property", "name"]
              .map((w) => g.getAttribute(w))
              .filter((w) => (w ? u.includes(w) : !1));
          if (p.length && p) {
            const w = g.getAttribute("content");
            if (w) return w;
          }
        }
        return "";
      }
      function s() {
        let u = i("name", "og:site_name", "og:title", "twitter:title");
        return u || (u = t.title), u;
      }
      function n() {
        return i(
          "description",
          "og:description",
          "twitter:description",
          "keywords"
        );
      }
      const o = s(),
        a = n(),
        c = e.origin,
        l = r();
      return { description: a, url: c, icons: l, name: o };
    }
    cg = ag.getWindowMetadata = iS;
    function ru(t, { strict: e = !0 } = {}) {
      return !t || typeof t != "string"
        ? !1
        : e
        ? /^0x[0-9a-fA-F]*$/.test(t)
        : t.startsWith("0x");
    }
    function Wv(t) {
      return ru(t, { strict: !1 }) ? Math.ceil((t.length - 2) / 2) : t.length;
    }
    const Kv = "2.23.2";
    let lg = {
      getDocsUrl: ({ docsBaseUrl: t, docsPath: e = "", docsSlug: r }) =>
        e ? `${t ?? "https://viem.sh"}${e}${r ? `#${r}` : ""}` : void 0,
      version: `viem@${Kv}`,
    };
    class No extends Error {
      constructor(e, r = {}) {
        const i =
            r.cause instanceof No
              ? r.cause.details
              : r.cause?.message
              ? r.cause.message
              : r.details,
          s = (r.cause instanceof No && r.cause.docsPath) || r.docsPath,
          n = lg.getDocsUrl?.({ ...r, docsPath: s }),
          o = [
            e || "An error occurred.",
            "",
            ...(r.metaMessages ? [...r.metaMessages, ""] : []),
            ...(n ? [`Docs: ${n}`] : []),
            ...(i ? [`Details: ${i}`] : []),
            ...(lg.version ? [`Version: ${lg.version}`] : []),
          ].join(`
`);
        super(o, r.cause ? { cause: r.cause } : void 0),
          Object.defineProperty(this, "details", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "docsPath", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "metaMessages", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "shortMessage", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "version", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "BaseError",
          }),
          (this.details = i),
          (this.docsPath = s),
          (this.metaMessages = r.metaMessages),
          (this.name = r.name ?? this.name),
          (this.shortMessage = e),
          (this.version = Kv);
      }
      walk(e) {
        return Gv(this, e);
      }
    }
    function Gv(t, e) {
      return e?.(t)
        ? t
        : t && typeof t == "object" && "cause" in t && t.cause !== void 0
        ? Gv(t.cause, e)
        : e
        ? null
        : t;
    }
    class Zv extends No {
      constructor({ size: e, targetSize: r, type: i }) {
        super(
          `${i.charAt(0).toUpperCase()}${i
            .slice(1)
            .toLowerCase()} size (${e}) exceeds padding size (${r}).`,
          { name: "SizeExceedsPaddingSizeError" }
        );
      }
    }
    function Ka(t, { dir: e, size: r = 32 } = {}) {
      return typeof t == "string"
        ? sS(t, { dir: e, size: r })
        : nS(t, { dir: e, size: r });
    }
    function sS(t, { dir: e, size: r = 32 } = {}) {
      if (r === null) return t;
      const i = t.replace("0x", "");
      if (i.length > r * 2)
        throw new Zv({
          size: Math.ceil(i.length / 2),
          targetSize: r,
          type: "hex",
        });
      return `0x${i[e === "right" ? "padEnd" : "padStart"](r * 2, "0")}`;
    }
    function nS(t, { dir: e, size: r = 32 } = {}) {
      if (r === null) return t;
      if (t.length > r)
        throw new Zv({ size: t.length, targetSize: r, type: "bytes" });
      const i = new Uint8Array(r);
      for (let s = 0; s < r; s++) {
        const n = e === "right";
        i[n ? s : r - s - 1] = t[n ? s : t.length - s - 1];
      }
      return i;
    }
    class oS extends No {
      constructor({ max: e, min: r, signed: i, size: s, value: n }) {
        super(
          `Number "${n}" is not in safe ${
            s ? `${s * 8}-bit ${i ? "signed" : "unsigned"} ` : ""
          }integer range ${e ? `(${r} to ${e})` : `(above ${r})`}`,
          { name: "IntegerOutOfRangeError" }
        );
      }
    }
    class aS extends No {
      constructor({ givenSize: e, maxSize: r }) {
        super(`Size cannot exceed ${r} bytes. Given size: ${e} bytes.`, {
          name: "SizeOverflowError",
        });
      }
    }
    function Ga(t, { size: e }) {
      if (Wv(t) > e) throw new aS({ givenSize: Wv(t), maxSize: e });
    }
    function ug(t, e = {}) {
      const { signed: r } = e;
      e.size && Ga(t, { size: e.size });
      const i = BigInt(t);
      if (!r) return i;
      const s = (t.length - 2) / 2,
        n = (1n << (BigInt(s) * 8n - 1n)) - 1n;
      return i <= n ? i : i - BigInt(`0x${"f".padStart(s * 2, "f")}`) - 1n;
    }
    function cS(t, e = {}) {
      return Number(ug(t, e));
    }
    const lS = Array.from({ length: 256 }, (t, e) =>
      e.toString(16).padStart(2, "0")
    );
    function hg(t, e = {}) {
      return typeof t == "number" || typeof t == "bigint"
        ? Jv(t, e)
        : typeof t == "string"
        ? dS(t, e)
        : typeof t == "boolean"
        ? uS(t, e)
        : Yv(t, e);
    }
    function uS(t, e = {}) {
      const r = `0x${Number(t)}`;
      return typeof e.size == "number"
        ? (Ga(r, { size: e.size }), Ka(r, { size: e.size }))
        : r;
    }
    function Yv(t, e = {}) {
      let r = "";
      for (let s = 0; s < t.length; s++) r += lS[t[s]];
      const i = `0x${r}`;
      return typeof e.size == "number"
        ? (Ga(i, { size: e.size }), Ka(i, { dir: "right", size: e.size }))
        : i;
    }
    function Jv(t, e = {}) {
      const { signed: r, size: i } = e,
        s = BigInt(t);
      let n;
      i
        ? r
          ? (n = (1n << (BigInt(i) * 8n - 1n)) - 1n)
          : (n = 2n ** (BigInt(i) * 8n) - 1n)
        : typeof t == "number" && (n = BigInt(Number.MAX_SAFE_INTEGER));
      const o = typeof n == "bigint" && r ? -n - 1n : 0;
      if ((n && s > n) || s < o) {
        const c = typeof t == "bigint" ? "n" : "";
        throw new oS({
          max: n ? `${n}${c}` : void 0,
          min: `${o}${c}`,
          signed: r,
          size: i,
          value: `${t}${c}`,
        });
      }
      const a = `0x${(r && s < 0
        ? (1n << BigInt(i * 8)) + BigInt(s)
        : s
      ).toString(16)}`;
      return i ? Ka(a, { size: i }) : a;
    }
    const hS = new TextEncoder();
    function dS(t, e = {}) {
      const r = hS.encode(t);
      return Yv(r, e);
    }
    const pS = new TextEncoder();
    function fS(t, e = {}) {
      return typeof t == "number" || typeof t == "bigint"
        ? wS(t, e)
        : typeof t == "boolean"
        ? gS(t, e)
        : ru(t)
        ? Qv(t, e)
        : e2(t, e);
    }
    function gS(t, e = {}) {
      const r = new Uint8Array(1);
      return (
        (r[0] = Number(t)),
        typeof e.size == "number"
          ? (Ga(r, { size: e.size }), Ka(r, { size: e.size }))
          : r
      );
    }
    const zs = { zero: 48, nine: 57, A: 65, F: 70, a: 97, f: 102 };
    function Xv(t) {
      if (t >= zs.zero && t <= zs.nine) return t - zs.zero;
      if (t >= zs.A && t <= zs.F) return t - (zs.A - 10);
      if (t >= zs.a && t <= zs.f) return t - (zs.a - 10);
    }
    function Qv(t, e = {}) {
      let r = t;
      e.size &&
        (Ga(r, { size: e.size }), (r = Ka(r, { dir: "right", size: e.size })));
      let i = r.slice(2);
      i.length % 2 && (i = `0${i}`);
      const s = i.length / 2,
        n = new Uint8Array(s);
      for (let o = 0, a = 0; o < s; o++) {
        const c = Xv(i.charCodeAt(a++)),
          l = Xv(i.charCodeAt(a++));
        if (c === void 0 || l === void 0)
          throw new No(
            `Invalid byte sequence ("${i[a - 2]}${i[a - 1]}" in "${i}").`
          );
        n[o] = c * 16 + l;
      }
      return n;
    }
    function wS(t, e) {
      const r = Jv(t, e);
      return Qv(r);
    }
    function e2(t, e = {}) {
      const r = pS.encode(t);
      return typeof e.size == "number"
        ? (Ga(r, { size: e.size }), Ka(r, { dir: "right", size: e.size }))
        : r;
    }
    function Wd(t) {
      if (!Number.isSafeInteger(t) || t < 0)
        throw new Error("positive integer expected, got " + t);
    }
    function mS(t) {
      return (
        t instanceof Uint8Array ||
        (ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array")
      );
    }
    function iu(t, ...e) {
      if (!mS(t)) throw new Error("Uint8Array expected");
      if (e.length > 0 && !e.includes(t.length))
        throw new Error(
          "Uint8Array expected of length " + e + ", got length=" + t.length
        );
    }
    function yS(t) {
      if (typeof t != "function" || typeof t.create != "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      Wd(t.outputLen), Wd(t.blockLen);
    }
    function Za(t, e = !0) {
      if (t.destroyed) throw new Error("Hash instance has been destroyed");
      if (e && t.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function t2(t, e) {
      iu(t);
      const r = e.outputLen;
      if (t.length < r)
        throw new Error(
          "digestInto() expects output buffer of length at least " + r
        );
    }
    const Kd = BigInt(2 ** 32 - 1),
      r2 = BigInt(32);
    function bS(t, e = !1) {
      return e
        ? { h: Number(t & Kd), l: Number((t >> r2) & Kd) }
        : { h: Number((t >> r2) & Kd) | 0, l: Number(t & Kd) | 0 };
    }
    function vS(t, e = !1) {
      let r = new Uint32Array(t.length),
        i = new Uint32Array(t.length);
      for (let s = 0; s < t.length; s++) {
        const { h: n, l: o } = bS(t[s], e);
        [r[s], i[s]] = [n, o];
      }
      return [r, i];
    }
    const ES = (t, e, r) => (t << r) | (e >>> (32 - r)),
      CS = (t, e, r) => (e << r) | (t >>> (32 - r)),
      xS = (t, e, r) => (e << (r - 32)) | (t >>> (64 - r)),
      IS = (t, e, r) => (t << (r - 32)) | (e >>> (64 - r)),
      Ya =
        typeof globalThis == "object" && "crypto" in globalThis
          ? globalThis.crypto
          : void 0;
    function _S(t) {
      return new Uint32Array(
        t.buffer,
        t.byteOffset,
        Math.floor(t.byteLength / 4)
      );
    }
    function dg(t) {
      return new DataView(t.buffer, t.byteOffset, t.byteLength);
    }
    function gs(t, e) {
      return (t << (32 - e)) | (t >>> e);
    }
    const i2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    function AS(t) {
      return (
        ((t << 24) & 4278190080) |
        ((t << 8) & 16711680) |
        ((t >>> 8) & 65280) |
        ((t >>> 24) & 255)
      );
    }
    function s2(t) {
      for (let e = 0; e < t.length; e++) t[e] = AS(t[e]);
    }
    function SS(t) {
      if (typeof t != "string")
        throw new Error("utf8ToBytes expected string, got " + typeof t);
      return new Uint8Array(new TextEncoder().encode(t));
    }
    function Gd(t) {
      return typeof t == "string" && (t = SS(t)), iu(t), t;
    }
    function PS(...t) {
      let e = 0;
      for (let i = 0; i < t.length; i++) {
        const s = t[i];
        iu(s), (e += s.length);
      }
      const r = new Uint8Array(e);
      for (let i = 0, s = 0; i < t.length; i++) {
        const n = t[i];
        r.set(n, s), (s += n.length);
      }
      return r;
    }
    class pg {
      clone() {
        return this._cloneInto();
      }
    }
    function n2(t) {
      const e = (i) => t().update(Gd(i)).digest(),
        r = t();
      return (
        (e.outputLen = r.outputLen),
        (e.blockLen = r.blockLen),
        (e.create = () => t()),
        e
      );
    }
    function o2(t = 32) {
      if (Ya && typeof Ya.getRandomValues == "function")
        return Ya.getRandomValues(new Uint8Array(t));
      if (Ya && typeof Ya.randomBytes == "function") return Ya.randomBytes(t);
      throw new Error("crypto.getRandomValues must be defined");
    }
    const a2 = [],
      c2 = [],
      l2 = [],
      OS = BigInt(0),
      su = BigInt(1),
      NS = BigInt(2),
      TS = BigInt(7),
      kS = BigInt(256),
      RS = BigInt(113);
    for (let t = 0, e = su, r = 1, i = 0; t < 24; t++) {
      ([r, i] = [i, (2 * r + 3 * i) % 5]),
        a2.push(2 * (5 * i + r)),
        c2.push((((t + 1) * (t + 2)) / 2) % 64);
      let s = OS;
      for (let n = 0; n < 7; n++)
        (e = ((e << su) ^ ((e >> TS) * RS)) % kS),
          e & NS && (s ^= su << ((su << BigInt(n)) - su));
      l2.push(s);
    }
    const [$S, FS] = vS(l2, !0),
      u2 = (t, e, r) => (r > 32 ? xS(t, e, r) : ES(t, e, r)),
      h2 = (t, e, r) => (r > 32 ? IS(t, e, r) : CS(t, e, r));
    function BS(t, e = 24) {
      const r = new Uint32Array(10);
      for (let i = 24 - e; i < 24; i++) {
        for (let o = 0; o < 10; o++)
          r[o] = t[o] ^ t[o + 10] ^ t[o + 20] ^ t[o + 30] ^ t[o + 40];
        for (let o = 0; o < 10; o += 2) {
          const a = (o + 8) % 10,
            c = (o + 2) % 10,
            l = r[c],
            u = r[c + 1],
            h = u2(l, u, 1) ^ r[a],
            d = h2(l, u, 1) ^ r[a + 1];
          for (let g = 0; g < 50; g += 10) (t[o + g] ^= h), (t[o + g + 1] ^= d);
        }
        let s = t[2],
          n = t[3];
        for (let o = 0; o < 24; o++) {
          const a = c2[o],
            c = u2(s, n, a),
            l = h2(s, n, a),
            u = a2[o];
          (s = t[u]), (n = t[u + 1]), (t[u] = c), (t[u + 1] = l);
        }
        for (let o = 0; o < 50; o += 10) {
          for (let a = 0; a < 10; a++) r[a] = t[o + a];
          for (let a = 0; a < 10; a++)
            t[o + a] ^= ~r[(a + 2) % 10] & r[(a + 4) % 10];
        }
        (t[0] ^= $S[i]), (t[1] ^= FS[i]);
      }
      r.fill(0);
    }
    class fg extends pg {
      constructor(e, r, i, s = !1, n = 24) {
        if (
          (super(),
          (this.blockLen = e),
          (this.suffix = r),
          (this.outputLen = i),
          (this.enableXOF = s),
          (this.rounds = n),
          (this.pos = 0),
          (this.posOut = 0),
          (this.finished = !1),
          (this.destroyed = !1),
          Wd(i),
          0 >= this.blockLen || this.blockLen >= 200)
        )
          throw new Error("Sha3 supports only keccak-f1600 function");
        (this.state = new Uint8Array(200)), (this.state32 = _S(this.state));
      }
      keccak() {
        i2 || s2(this.state32),
          BS(this.state32, this.rounds),
          i2 || s2(this.state32),
          (this.posOut = 0),
          (this.pos = 0);
      }
      update(e) {
        Za(this);
        const { blockLen: r, state: i } = this;
        e = Gd(e);
        const s = e.length;
        for (let n = 0; n < s; ) {
          const o = Math.min(r - this.pos, s - n);
          for (let a = 0; a < o; a++) i[this.pos++] ^= e[n++];
          this.pos === r && this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished) return;
        this.finished = !0;
        const { state: e, suffix: r, pos: i, blockLen: s } = this;
        (e[i] ^= r),
          (r & 128) !== 0 && i === s - 1 && this.keccak(),
          (e[s - 1] ^= 128),
          this.keccak();
      }
      writeInto(e) {
        Za(this, !1), iu(e), this.finish();
        const r = this.state,
          { blockLen: i } = this;
        for (let s = 0, n = e.length; s < n; ) {
          this.posOut >= i && this.keccak();
          const o = Math.min(i - this.posOut, n - s);
          e.set(r.subarray(this.posOut, this.posOut + o), s),
            (this.posOut += o),
            (s += o);
        }
        return e;
      }
      xofInto(e) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(e);
      }
      xof(e) {
        return Wd(e), this.xofInto(new Uint8Array(e));
      }
      digestInto(e) {
        if ((t2(e, this), this.finished))
          throw new Error("digest() was already called");
        return this.writeInto(e), this.destroy(), e;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        (this.destroyed = !0), this.state.fill(0);
      }
      _cloneInto(e) {
        const {
          blockLen: r,
          suffix: i,
          outputLen: s,
          rounds: n,
          enableXOF: o,
        } = this;
        return (
          e || (e = new fg(r, i, s, o, n)),
          e.state32.set(this.state32),
          (e.pos = this.pos),
          (e.posOut = this.posOut),
          (e.finished = this.finished),
          (e.rounds = n),
          (e.suffix = i),
          (e.outputLen = s),
          (e.enableXOF = o),
          (e.destroyed = this.destroyed),
          e
        );
      }
    }
    const To = ((t, e, r) => n2(() => new fg(e, t, r)))(1, 136, 256 / 8);
    function d2(t, e) {
      const r = e || "hex",
        i = To(ru(t, { strict: !1 }) ? fS(t) : t);
      return r === "bytes" ? i : hg(i);
    }
    class p2 extends Map {
      constructor(e) {
        super(),
          Object.defineProperty(this, "maxSize", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          (this.maxSize = e);
      }
      get(e) {
        const r = super.get(e);
        return (
          super.has(e) && r !== void 0 && (this.delete(e), super.set(e, r)), r
        );
      }
      set(e, r) {
        if ((super.set(e, r), this.maxSize && this.size > this.maxSize)) {
          const i = this.keys().next().value;
          i && this.delete(i);
        }
        return this;
      }
    }
    const gg = new p2(8192);
    function LS(t, e) {
      if (gg.has(`${t}.${e}`)) return gg.get(`${t}.${e}`);
      const r = e ? `${e}${t.toLowerCase()}` : t.substring(2).toLowerCase(),
        i = d2(e2(r), "bytes"),
        s = (e ? r.substring(`${e}0x`.length) : r).split("");
      for (let o = 0; o < 40; o += 2)
        i[o >> 1] >> 4 >= 8 && s[o] && (s[o] = s[o].toUpperCase()),
          (i[o >> 1] & 15) >= 8 &&
            s[o + 1] &&
            (s[o + 1] = s[o + 1].toUpperCase());
      const n = `0x${s.join("")}`;
      return gg.set(`${t}.${e}`, n), n;
    }
    function US(t) {
      const e = d2(`0x${t.substring(4)}`).substring(26);
      return LS(`0x${e}`);
    }
    async function DS({ hash: t, signature: e }) {
      const r = ru(t) ? t : hg(t),
        { secp256k1: i } = await Promise.resolve().then(function () {
          return X2;
        });
      return `0x${(() => {
        if (typeof e == "object" && "r" in e && "s" in e) {
          const { r: a, s: c, v: l, yParity: u } = e,
            h = Number(u ?? l),
            d = f2(h);
          return new i.Signature(ug(a), ug(c)).addRecoveryBit(d);
        }
        const s = ru(e) ? e : hg(e),
          n = cS(`0x${s.slice(130)}`),
          o = f2(n);
        return i.Signature.fromCompact(s.substring(2, 130)).addRecoveryBit(o);
      })()
        .recoverPublicKey(r.substring(2))
        .toHex(!1)}`;
    }
    function f2(t) {
      if (t === 0 || t === 1) return t;
      if (t === 27) return 0;
      if (t === 28) return 1;
      throw new Error("Invalid yParityOrV value");
    }
    async function jS({ hash: t, signature: e }) {
      return US(await DS({ hash: t, signature: e }));
    }
    function MS(t, e, r, i) {
      if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, r, i);
      const s = BigInt(32),
        n = BigInt(4294967295),
        o = Number((r >> s) & n),
        a = Number(r & n),
        c = i ? 4 : 0,
        l = i ? 0 : 4;
      t.setUint32(e + c, o, i), t.setUint32(e + l, a, i);
    }
    function zS(t, e, r) {
      return (t & e) ^ (~t & r);
    }
    function qS(t, e, r) {
      return (t & e) ^ (t & r) ^ (e & r);
    }
    class HS extends pg {
      constructor(e, r, i, s) {
        super(),
          (this.blockLen = e),
          (this.outputLen = r),
          (this.padOffset = i),
          (this.isLE = s),
          (this.finished = !1),
          (this.length = 0),
          (this.pos = 0),
          (this.destroyed = !1),
          (this.buffer = new Uint8Array(e)),
          (this.view = dg(this.buffer));
      }
      update(e) {
        Za(this);
        const { view: r, buffer: i, blockLen: s } = this;
        e = Gd(e);
        const n = e.length;
        for (let o = 0; o < n; ) {
          const a = Math.min(s - this.pos, n - o);
          if (a === s) {
            const c = dg(e);
            for (; s <= n - o; o += s) this.process(c, o);
            continue;
          }
          i.set(e.subarray(o, o + a), this.pos),
            (this.pos += a),
            (o += a),
            this.pos === s && (this.process(r, 0), (this.pos = 0));
        }
        return (this.length += e.length), this.roundClean(), this;
      }
      digestInto(e) {
        Za(this), t2(e, this), (this.finished = !0);
        const { buffer: r, view: i, blockLen: s, isLE: n } = this;
        let { pos: o } = this;
        (r[o++] = 128),
          this.buffer.subarray(o).fill(0),
          this.padOffset > s - o && (this.process(i, 0), (o = 0));
        for (let h = o; h < s; h++) r[h] = 0;
        MS(i, s - 8, BigInt(this.length * 8), n), this.process(i, 0);
        const a = dg(e),
          c = this.outputLen;
        if (c % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const l = c / 4,
          u = this.get();
        if (l > u.length) throw new Error("_sha2: outputLen bigger than state");
        for (let h = 0; h < l; h++) a.setUint32(4 * h, u[h], n);
      }
      digest() {
        const { buffer: e, outputLen: r } = this;
        this.digestInto(e);
        const i = e.slice(0, r);
        return this.destroy(), i;
      }
      _cloneInto(e) {
        e || (e = new this.constructor()), e.set(...this.get());
        const {
          blockLen: r,
          buffer: i,
          length: s,
          finished: n,
          destroyed: o,
          pos: a,
        } = this;
        return (
          (e.length = s),
          (e.pos = a),
          (e.finished = n),
          (e.destroyed = o),
          s % r && e.buffer.set(i),
          e
        );
      }
    }
    const VS = new Uint32Array([
        1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
        2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
        1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
        264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
        2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
        113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
        1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
        3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
        430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
        1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
        2428436474, 2756734187, 3204031479, 3329325298,
      ]),
      Fn = new Uint32Array([
        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924,
        528734635, 1541459225,
      ]),
      Bn = new Uint32Array(64);
    class WS extends HS {
      constructor() {
        super(64, 32, 8, !1),
          (this.A = Fn[0] | 0),
          (this.B = Fn[1] | 0),
          (this.C = Fn[2] | 0),
          (this.D = Fn[3] | 0),
          (this.E = Fn[4] | 0),
          (this.F = Fn[5] | 0),
          (this.G = Fn[6] | 0),
          (this.H = Fn[7] | 0);
      }
      get() {
        const { A: e, B: r, C: i, D: s, E: n, F: o, G: a, H: c } = this;
        return [e, r, i, s, n, o, a, c];
      }
      set(e, r, i, s, n, o, a, c) {
        (this.A = e | 0),
          (this.B = r | 0),
          (this.C = i | 0),
          (this.D = s | 0),
          (this.E = n | 0),
          (this.F = o | 0),
          (this.G = a | 0),
          (this.H = c | 0);
      }
      process(e, r) {
        for (let h = 0; h < 16; h++, r += 4) Bn[h] = e.getUint32(r, !1);
        for (let h = 16; h < 64; h++) {
          const d = Bn[h - 15],
            g = Bn[h - 2],
            p = gs(d, 7) ^ gs(d, 18) ^ (d >>> 3),
            w = gs(g, 17) ^ gs(g, 19) ^ (g >>> 10);
          Bn[h] = (w + Bn[h - 7] + p + Bn[h - 16]) | 0;
        }
        let { A: i, B: s, C: n, D: o, E: a, F: c, G: l, H: u } = this;
        for (let h = 0; h < 64; h++) {
          const d = gs(a, 6) ^ gs(a, 11) ^ gs(a, 25),
            g = (u + d + zS(a, c, l) + VS[h] + Bn[h]) | 0,
            p = ((gs(i, 2) ^ gs(i, 13) ^ gs(i, 22)) + qS(i, s, n)) | 0;
          (u = l),
            (l = c),
            (c = a),
            (a = (o + g) | 0),
            (o = n),
            (n = s),
            (s = i),
            (i = (g + p) | 0);
        }
        (i = (i + this.A) | 0),
          (s = (s + this.B) | 0),
          (n = (n + this.C) | 0),
          (o = (o + this.D) | 0),
          (a = (a + this.E) | 0),
          (c = (c + this.F) | 0),
          (l = (l + this.G) | 0),
          (u = (u + this.H) | 0),
          this.set(i, s, n, o, a, c, l, u);
      }
      roundClean() {
        Bn.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
      }
    }
    const nu = n2(() => new WS());
    new p2(128);
    const KS = new Uint8Array([
        7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
      ]),
      g2 = new Uint8Array(new Array(16).fill(0).map((t, e) => e)),
      GS = g2.map((t) => (9 * t + 5) % 16);
    let ZS = [g2],
      YS = [GS];
    for (let t = 0; t < 4; t++)
      for (let e of [ZS, YS]) e.push(e[t].map((r) => KS[r]));
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Zd =
        BigInt(0),
      Yd = BigInt(1),
      JS = BigInt(2);
    function ko(t) {
      return (
        t instanceof Uint8Array ||
        (ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array")
      );
    }
    function ws(t) {
      if (!ko(t)) throw new Error("Uint8Array expected");
    }
    function Ja(t, e) {
      if (typeof e != "boolean")
        throw new Error(t + " boolean expected, got " + e);
    }
    const XS = Array.from({ length: 256 }, (t, e) =>
      e.toString(16).padStart(2, "0")
    );
    function Xa(t) {
      ws(t);
      let e = "";
      for (let r = 0; r < t.length; r++) e += XS[t[r]];
      return e;
    }
    function Qa(t) {
      const e = t.toString(16);
      return e.length & 1 ? "0" + e : e;
    }
    function wg(t) {
      if (typeof t != "string")
        throw new Error("hex string expected, got " + typeof t);
      return t === "" ? Zd : BigInt("0x" + t);
    }
    const qs = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function w2(t) {
      if (t >= qs._0 && t <= qs._9) return t - qs._0;
      if (t >= qs.A && t <= qs.F) return t - (qs.A - 10);
      if (t >= qs.a && t <= qs.f) return t - (qs.a - 10);
    }
    function ec(t) {
      if (typeof t != "string")
        throw new Error("hex string expected, got " + typeof t);
      const e = t.length,
        r = e / 2;
      if (e % 2)
        throw new Error("hex string expected, got unpadded hex of length " + e);
      const i = new Uint8Array(r);
      for (let s = 0, n = 0; s < r; s++, n += 2) {
        const o = w2(t.charCodeAt(n)),
          a = w2(t.charCodeAt(n + 1));
        if (o === void 0 || a === void 0) {
          const c = t[n] + t[n + 1];
          throw new Error(
            'hex string expected, got non-hex character "' +
              c +
              '" at index ' +
              n
          );
        }
        i[s] = o * 16 + a;
      }
      return i;
    }
    function ms(t) {
      return wg(Xa(t));
    }
    function mg(t) {
      return ws(t), wg(Xa(Uint8Array.from(t).reverse()));
    }
    function Ln(t, e) {
      return ec(t.toString(16).padStart(e * 2, "0"));
    }
    function yg(t, e) {
      return Ln(t, e).reverse();
    }
    function QS(t) {
      return ec(Qa(t));
    }
    function _r(t, e, r) {
      let i;
      if (typeof e == "string")
        try {
          i = ec(e);
        } catch (n) {
          throw new Error(t + " must be hex string or Uint8Array, cause: " + n);
        }
      else if (ko(e)) i = Uint8Array.from(e);
      else throw new Error(t + " must be hex string or Uint8Array");
      const s = i.length;
      if (typeof r == "number" && s !== r)
        throw new Error(t + " of length " + r + " expected, got " + s);
      return i;
    }
    function si(...t) {
      let e = 0;
      for (let i = 0; i < t.length; i++) {
        const s = t[i];
        ws(s), (e += s.length);
      }
      const r = new Uint8Array(e);
      for (let i = 0, s = 0; i < t.length; i++) {
        const n = t[i];
        r.set(n, s), (s += n.length);
      }
      return r;
    }
    function eP(t, e) {
      if (t.length !== e.length) return !1;
      let r = 0;
      for (let i = 0; i < t.length; i++) r |= t[i] ^ e[i];
      return r === 0;
    }
    function Jd(t) {
      if (typeof t != "string") throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(t));
    }
    const bg = (t) => typeof t == "bigint" && Zd <= t;
    function tc(t, e, r) {
      return bg(t) && bg(e) && bg(r) && e <= t && t < r;
    }
    function Un(t, e, r, i) {
      if (!tc(e, r, i))
        throw new Error(
          "expected valid " + t + ": " + r + " <= n < " + i + ", got " + e
        );
    }
    function m2(t) {
      let e;
      for (e = 0; t > Zd; t >>= Yd, e += 1);
      return e;
    }
    function tP(t, e) {
      return (t >> BigInt(e)) & Yd;
    }
    function rP(t, e, r) {
      return t | ((r ? Yd : Zd) << BigInt(e));
    }
    const vg = (t) => (JS << BigInt(t - 1)) - Yd,
      Eg = (t) => new Uint8Array(t),
      y2 = (t) => Uint8Array.from(t);
    function b2(t, e, r) {
      if (typeof t != "number" || t < 2)
        throw new Error("hashLen must be a number");
      if (typeof e != "number" || e < 2)
        throw new Error("qByteLen must be a number");
      if (typeof r != "function") throw new Error("hmacFn must be a function");
      let i = Eg(t),
        s = Eg(t),
        n = 0;
      const o = () => {
          i.fill(1), s.fill(0), (n = 0);
        },
        a = (...u) => r(s, i, ...u),
        c = (u = Eg()) => {
          (s = a(y2([0]), u)),
            (i = a()),
            u.length !== 0 && ((s = a(y2([1]), u)), (i = a()));
        },
        l = () => {
          if (n++ >= 1e3) throw new Error("drbg: tried 1000 values");
          let u = 0;
          const h = [];
          for (; u < e; ) {
            i = a();
            const d = i.slice();
            h.push(d), (u += i.length);
          }
          return si(...h);
        };
      return (u, h) => {
        o(), c(u);
        let d;
        for (; !(d = h(l())); ) c();
        return o(), d;
      };
    }
    const iP = {
      bigint: (t) => typeof t == "bigint",
      function: (t) => typeof t == "function",
      boolean: (t) => typeof t == "boolean",
      string: (t) => typeof t == "string",
      stringOrUint8Array: (t) => typeof t == "string" || ko(t),
      isSafeInteger: (t) => Number.isSafeInteger(t),
      array: (t) => Array.isArray(t),
      field: (t, e) => e.Fp.isValid(t),
      hash: (t) => typeof t == "function" && Number.isSafeInteger(t.outputLen),
    };
    function rc(t, e, r = {}) {
      const i = (s, n, o) => {
        const a = iP[n];
        if (typeof a != "function")
          throw new Error("invalid validator function");
        const c = t[s];
        if (!(o && c === void 0) && !a(c, t))
          throw new Error(
            "param " + String(s) + " is invalid. Expected " + n + ", got " + c
          );
      };
      for (const [s, n] of Object.entries(e)) i(s, n, !1);
      for (const [s, n] of Object.entries(r)) i(s, n, !0);
      return t;
    }
    const sP = () => {
      throw new Error("not implemented");
    };
    function Cg(t) {
      const e = new WeakMap();
      return (r, ...i) => {
        const s = e.get(r);
        if (s !== void 0) return s;
        const n = t(r, ...i);
        return e.set(r, n), n;
      };
    }
    var nP = Object.freeze({
      __proto__: null,
      isBytes: ko,
      abytes: ws,
      abool: Ja,
      bytesToHex: Xa,
      numberToHexUnpadded: Qa,
      hexToNumber: wg,
      hexToBytes: ec,
      bytesToNumberBE: ms,
      bytesToNumberLE: mg,
      numberToBytesBE: Ln,
      numberToBytesLE: yg,
      numberToVarBytesBE: QS,
      ensureBytes: _r,
      concatBytes: si,
      equalBytes: eP,
      utf8ToBytes: Jd,
      inRange: tc,
      aInRange: Un,
      bitLen: m2,
      bitGet: tP,
      bitSet: rP,
      bitMask: vg,
      createHmacDrbg: b2,
      validateObject: rc,
      notImplemented: sP,
      memoized: Cg,
    });
    const oP = "0.1.1";
    function aP() {
      return oP;
    }
    class Nr extends Error {
      constructor(e, r = {}) {
        const i = (() => {
            if (r.cause instanceof Nr) {
              if (r.cause.details) return r.cause.details;
              if (r.cause.shortMessage) return r.cause.shortMessage;
            }
            return r.cause?.message ? r.cause.message : r.details;
          })(),
          s = (r.cause instanceof Nr && r.cause.docsPath) || r.docsPath,
          n = `https://oxlib.sh${s ?? ""}`,
          o = [
            e || "An error occurred.",
            ...(r.metaMessages ? ["", ...r.metaMessages] : []),
            ...(i || s
              ? ["", i ? `Details: ${i}` : void 0, s ? `See: ${n}` : void 0]
              : []),
          ].filter((a) => typeof a == "string").join(`
`);
        super(o, r.cause ? { cause: r.cause } : void 0),
          Object.defineProperty(this, "details", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "docs", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "docsPath", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "shortMessage", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "cause", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "BaseError",
          }),
          Object.defineProperty(this, "version", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: `ox@${aP()}`,
          }),
          (this.cause = r.cause),
          (this.details = i),
          (this.docs = n),
          (this.docsPath = s),
          (this.shortMessage = e);
      }
      walk(e) {
        return v2(this, e);
      }
    }
    function v2(t, e) {
      return e?.(t)
        ? t
        : t && typeof t == "object" && "cause" in t && t.cause
        ? v2(t.cause, e)
        : e
        ? null
        : t;
    }
    function cP(t, e) {
      if (x2(t) > e) throw new wP({ givenSize: x2(t), maxSize: e });
    }
    const Hs = { zero: 48, nine: 57, A: 65, F: 70, a: 97, f: 102 };
    function E2(t) {
      if (t >= Hs.zero && t <= Hs.nine) return t - Hs.zero;
      if (t >= Hs.A && t <= Hs.F) return t - (Hs.A - 10);
      if (t >= Hs.a && t <= Hs.f) return t - (Hs.a - 10);
    }
    function lP(t, e = {}) {
      const { dir: r, size: i = 32 } = e;
      if (i === 0) return t;
      if (t.length > i)
        throw new mP({ size: t.length, targetSize: i, type: "Bytes" });
      const s = new Uint8Array(i);
      for (let n = 0; n < i; n++) {
        const o = r === "right";
        s[o ? n : i - n - 1] = t[o ? n : t.length - n - 1];
      }
      return s;
    }
    function xg(t, e) {
      if (_g(t) > e) throw new IP({ givenSize: _g(t), maxSize: e });
    }
    function C2(t, e = {}) {
      const { dir: r, size: i = 32 } = e;
      if (i === 0) return t;
      const s = t.replace("0x", "");
      if (s.length > i * 2)
        throw new _P({
          size: Math.ceil(s.length / 2),
          targetSize: i,
          type: "Hex",
        });
      return `0x${s[r === "right" ? "padEnd" : "padStart"](i * 2, "0")}`;
    }
    const uP = new TextEncoder();
    function hP(t) {
      return t instanceof Uint8Array ? t : typeof t == "string" ? pP(t) : dP(t);
    }
    function dP(t) {
      return t instanceof Uint8Array ? t : new Uint8Array(t);
    }
    function pP(t, e = {}) {
      const { size: r } = e;
      let i = t;
      r && (xg(t, r), (i = Ig(t, r)));
      let s = i.slice(2);
      s.length % 2 && (s = `0${s}`);
      const n = s.length / 2,
        o = new Uint8Array(n);
      for (let a = 0, c = 0; a < n; a++) {
        const l = E2(s.charCodeAt(c++)),
          u = E2(s.charCodeAt(c++));
        if (l === void 0 || u === void 0)
          throw new Nr(
            `Invalid byte sequence ("${s[c - 2]}${s[c - 1]}" in "${s}").`
          );
        o[a] = l * 16 + u;
      }
      return o;
    }
    function fP(t, e = {}) {
      const { size: r } = e,
        i = uP.encode(t);
      return typeof r == "number" ? (cP(i, r), gP(i, r)) : i;
    }
    function gP(t, e) {
      return lP(t, { dir: "right", size: e });
    }
    function x2(t) {
      return t.length;
    }
    class wP extends Nr {
      constructor({ givenSize: e, maxSize: r }) {
        super(`Size cannot exceed \`${r}\` bytes. Given size: \`${e}\` bytes.`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Bytes.SizeOverflowError",
          });
      }
    }
    class mP extends Nr {
      constructor({ size: e, targetSize: r, type: i }) {
        super(
          `${i.charAt(0).toUpperCase()}${i
            .slice(1)
            .toLowerCase()} size (\`${e}\`) exceeds padding size (\`${r}\`).`
        ),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Bytes.SizeExceedsPaddingSizeError",
          });
      }
    }
    const yP = new TextEncoder(),
      bP = Array.from({ length: 256 }, (t, e) =>
        e.toString(16).padStart(2, "0")
      );
    function I2(...t) {
      return `0x${t.reduce((e, r) => e + r.replace("0x", ""), "")}`;
    }
    function vP(t, e = {}) {
      const r = `0x${Number(t)}`;
      return typeof e.size == "number" ? (xg(r, e.size), Xd(r, e.size)) : r;
    }
    function _2(t, e = {}) {
      let r = "";
      for (let s = 0; s < t.length; s++) r += bP[t[s]];
      const i = `0x${r}`;
      return typeof e.size == "number" ? (xg(i, e.size), Ig(i, e.size)) : i;
    }
    function EP(t, e = {}) {
      const { signed: r, size: i } = e,
        s = BigInt(t);
      let n;
      i
        ? r
          ? (n = (1n << (BigInt(i) * 8n - 1n)) - 1n)
          : (n = 2n ** (BigInt(i) * 8n) - 1n)
        : typeof t == "number" && (n = BigInt(Number.MAX_SAFE_INTEGER));
      const o = typeof n == "bigint" && r ? -n - 1n : 0;
      if ((n && s > n) || s < o) {
        const c = typeof t == "bigint" ? "n" : "";
        throw new xP({
          max: n ? `${n}${c}` : void 0,
          min: `${o}${c}`,
          signed: r,
          size: i,
          value: `${t}${c}`,
        });
      }
      const a = `0x${(r && s < 0
        ? (1n << BigInt(i * 8)) + BigInt(s)
        : s
      ).toString(16)}`;
      return i ? Xd(a, i) : a;
    }
    function CP(t, e = {}) {
      return _2(yP.encode(t), e);
    }
    function Xd(t, e) {
      return C2(t, { dir: "left", size: e });
    }
    function Ig(t, e) {
      return C2(t, { dir: "right", size: e });
    }
    function _g(t) {
      return Math.ceil((t.length - 2) / 2);
    }
    class xP extends Nr {
      constructor({ max: e, min: r, signed: i, size: s, value: n }) {
        super(
          `Number \`${n}\` is not in safe${s ? ` ${s * 8}-bit` : ""}${
            i ? " signed" : " unsigned"
          } integer range ${e ? `(\`${r}\` to \`${e}\`)` : `(above \`${r}\`)`}`
        ),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Hex.IntegerOutOfRangeError",
          });
      }
    }
    class IP extends Nr {
      constructor({ givenSize: e, maxSize: r }) {
        super(`Size cannot exceed \`${r}\` bytes. Given size: \`${e}\` bytes.`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Hex.SizeOverflowError",
          });
      }
    }
    class _P extends Nr {
      constructor({ size: e, targetSize: r, type: i }) {
        super(
          `${i.charAt(0).toUpperCase()}${i
            .slice(1)
            .toLowerCase()} size (\`${e}\`) exceeds padding size (\`${r}\`).`
        ),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Hex.SizeExceedsPaddingSizeError",
          });
      }
    }
    function AP(t, e = {}) {
      const { as: r = typeof t == "string" ? "Hex" : "Bytes" } = e,
        i = To(hP(t));
      return r === "Bytes" ? i : _2(i);
    }
    class SP extends Map {
      constructor(e) {
        super(),
          Object.defineProperty(this, "maxSize", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          (this.maxSize = e);
      }
      get(e) {
        const r = super.get(e);
        return (
          super.has(e) && r !== void 0 && (this.delete(e), super.set(e, r)), r
        );
      }
      set(e, r) {
        if ((super.set(e, r), this.maxSize && this.size > this.maxSize)) {
          const i = this.keys().next().value;
          i && this.delete(i);
        }
        return this;
      }
    }
    const Ag = { checksum: new SP(8192) }.checksum,
      PP = /^0x[a-fA-F0-9]{40}$/;
    function A2(t, e = {}) {
      const { strict: r = !0 } = e;
      if (!PP.test(t)) throw new S2({ address: t, cause: new NP() });
      if (r) {
        if (t.toLowerCase() === t) return;
        if (OP(t) !== t) throw new S2({ address: t, cause: new TP() });
      }
    }
    function OP(t) {
      if (Ag.has(t)) return Ag.get(t);
      A2(t, { strict: !1 });
      const e = t.substring(2).toLowerCase(),
        r = AP(fP(e), { as: "Bytes" }),
        i = e.split("");
      for (let n = 0; n < 40; n += 2)
        r[n >> 1] >> 4 >= 8 && i[n] && (i[n] = i[n].toUpperCase()),
          (r[n >> 1] & 15) >= 8 &&
            i[n + 1] &&
            (i[n + 1] = i[n + 1].toUpperCase());
      const s = `0x${i.join("")}`;
      return Ag.set(t, s), s;
    }
    class S2 extends Nr {
      constructor({ address: e, cause: r }) {
        super(`Address "${e}" is invalid.`, { cause: r }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Address.InvalidAddressError",
          });
      }
    }
    class NP extends Nr {
      constructor() {
        super("Address is not a 20 byte (40 hexadecimal character) value."),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Address.InvalidInputError",
          });
      }
    }
    class TP extends Nr {
      constructor() {
        super("Address does not match its checksum counterpart."),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Address.InvalidChecksumError",
          });
      }
    }
    const kP = /^(.*)\[([0-9]*)\]$/,
      RP = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,
      $P =
        /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
    function Sg(t, e) {
      if (t.length !== e.length)
        throw new BP({ expectedLength: t.length, givenLength: e.length });
      const r = [];
      for (let i = 0; i < t.length; i++) {
        const s = t[i],
          n = e[i];
        r.push(Sg.encode(s, n));
      }
      return I2(...r);
    }
    (function (t) {
      function e(r, i, s = !1) {
        if (r === "address") {
          const c = i;
          return A2(c), Xd(c.toLowerCase(), s ? 32 : 0);
        }
        if (r === "string") return CP(i);
        if (r === "bytes") return i;
        if (r === "bool") return Xd(vP(i), s ? 32 : 1);
        const n = r.match($P);
        if (n) {
          const [c, l, u = "256"] = n,
            h = Number.parseInt(u) / 8;
          return EP(i, { size: s ? 32 : h, signed: l === "int" });
        }
        const o = r.match(RP);
        if (o) {
          const [c, l] = o;
          if (Number.parseInt(l) !== (i.length - 2) / 2)
            throw new FP({ expectedSize: Number.parseInt(l), value: i });
          return Ig(i, s ? 32 : 0);
        }
        const a = r.match(kP);
        if (a && Array.isArray(i)) {
          const [c, l] = a,
            u = [];
          for (let h = 0; h < i.length; h++) u.push(e(l, i[h], !0));
          return u.length === 0 ? "0x" : I2(...u);
        }
        throw new LP(r);
      }
      t.encode = e;
    })(Sg || (Sg = {}));
    class FP extends Nr {
      constructor({ expectedSize: e, value: r }) {
        super(
          `Size of bytes "${r}" (bytes${_g(
            r
          )}) does not match expected size (bytes${e}).`
        ),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiParameters.BytesSizeMismatchError",
          });
      }
    }
    class BP extends Nr {
      constructor({ expectedLength: e, givenLength: r }) {
        super(
          [
            "ABI encoding parameters/values length mismatch.",
            `Expected length (parameters): ${e}`,
            `Given length (values): ${r}`,
          ].join(`
`)
        ),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiParameters.LengthMismatchError",
          });
      }
    }
    class LP extends Nr {
      constructor(e) {
        super(`Type \`${e}\` is not a valid ABI Type.`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiParameters.InvalidTypeError",
          });
      }
    }
    class P2 extends pg {
      constructor(e, r) {
        super(), (this.finished = !1), (this.destroyed = !1), yS(e);
        const i = Gd(r);
        if (((this.iHash = e.create()), typeof this.iHash.update != "function"))
          throw new Error(
            "Expected instance of class which extends utils.Hash"
          );
        (this.blockLen = this.iHash.blockLen),
          (this.outputLen = this.iHash.outputLen);
        const s = this.blockLen,
          n = new Uint8Array(s);
        n.set(i.length > s ? e.create().update(i).digest() : i);
        for (let o = 0; o < n.length; o++) n[o] ^= 54;
        this.iHash.update(n), (this.oHash = e.create());
        for (let o = 0; o < n.length; o++) n[o] ^= 106;
        this.oHash.update(n), n.fill(0);
      }
      update(e) {
        return Za(this), this.iHash.update(e), this;
      }
      digestInto(e) {
        Za(this),
          iu(e, this.outputLen),
          (this.finished = !0),
          this.iHash.digestInto(e),
          this.oHash.update(e),
          this.oHash.digestInto(e),
          this.destroy();
      }
      digest() {
        const e = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(e), e;
      }
      _cloneInto(e) {
        e || (e = Object.create(Object.getPrototypeOf(this), {}));
        const {
          oHash: r,
          iHash: i,
          finished: s,
          destroyed: n,
          blockLen: o,
          outputLen: a,
        } = this;
        return (
          (e = e),
          (e.finished = s),
          (e.destroyed = n),
          (e.blockLen = o),
          (e.outputLen = a),
          (e.oHash = r._cloneInto(e.oHash)),
          (e.iHash = i._cloneInto(e.iHash)),
          e
        );
      }
      destroy() {
        (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
      }
    }
    const O2 = (t, e, r) => new P2(t, e).update(r).digest();
    O2.create = (t, e) => new P2(t, e);
    const Ht = BigInt(0),
      It = BigInt(1),
      Ro = BigInt(2),
      UP = BigInt(3),
      Pg = BigInt(4),
      N2 = BigInt(5),
      T2 = BigInt(8);
    function Vt(t, e) {
      const r = t % e;
      return r >= Ht ? r : e + r;
    }
    function DP(t, e, r) {
      if (e < Ht) throw new Error("invalid exponent, negatives unsupported");
      if (r <= Ht) throw new Error("invalid modulus");
      if (r === It) return Ht;
      let i = It;
      for (; e > Ht; )
        e & It && (i = (i * t) % r), (t = (t * t) % r), (e >>= It);
      return i;
    }
    function Ni(t, e, r) {
      let i = t;
      for (; e-- > Ht; ) (i *= i), (i %= r);
      return i;
    }
    function Og(t, e) {
      if (t === Ht) throw new Error("invert: expected non-zero number");
      if (e <= Ht)
        throw new Error("invert: expected positive modulus, got " + e);
      let r = Vt(t, e),
        i = e,
        s = Ht,
        n = It;
      for (; r !== Ht; ) {
        const o = i / r,
          a = i % r,
          c = s - n * o;
        (i = r), (r = a), (s = n), (n = c);
      }
      if (i !== It) throw new Error("invert: does not exist");
      return Vt(s, e);
    }
    function jP(t) {
      const e = (t - It) / Ro;
      let r, i, s;
      for (r = t - It, i = 0; r % Ro === Ht; r /= Ro, i++);
      for (s = Ro; s < t && DP(s, e, t) !== t - It; s++)
        if (s > 1e3)
          throw new Error("Cannot find square root: likely non-prime P");
      if (i === 1) {
        const o = (t + It) / Pg;
        return function (a, c) {
          const l = a.pow(c, o);
          if (!a.eql(a.sqr(l), c)) throw new Error("Cannot find square root");
          return l;
        };
      }
      const n = (r + It) / Ro;
      return function (o, a) {
        if (o.pow(a, e) === o.neg(o.ONE))
          throw new Error("Cannot find square root");
        let c = i,
          l = o.pow(o.mul(o.ONE, s), r),
          u = o.pow(a, n),
          h = o.pow(a, r);
        for (; !o.eql(h, o.ONE); ) {
          if (o.eql(h, o.ZERO)) return o.ZERO;
          let d = 1;
          for (let p = o.sqr(h); d < c && !o.eql(p, o.ONE); d++) p = o.sqr(p);
          const g = o.pow(l, It << BigInt(c - d - 1));
          (l = o.sqr(g)), (u = o.mul(u, g)), (h = o.mul(h, l)), (c = d);
        }
        return u;
      };
    }
    function MP(t) {
      if (t % Pg === UP) {
        const e = (t + It) / Pg;
        return function (r, i) {
          const s = r.pow(i, e);
          if (!r.eql(r.sqr(s), i)) throw new Error("Cannot find square root");
          return s;
        };
      }
      if (t % T2 === N2) {
        const e = (t - N2) / T2;
        return function (r, i) {
          const s = r.mul(i, Ro),
            n = r.pow(s, e),
            o = r.mul(i, n),
            a = r.mul(r.mul(o, Ro), n),
            c = r.mul(o, r.sub(a, r.ONE));
          if (!r.eql(r.sqr(c), i)) throw new Error("Cannot find square root");
          return c;
        };
      }
      return jP(t);
    }
    const zP = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN",
    ];
    function k2(t) {
      const e = {
          ORDER: "bigint",
          MASK: "bigint",
          BYTES: "isSafeInteger",
          BITS: "isSafeInteger",
        },
        r = zP.reduce((i, s) => ((i[s] = "function"), i), e);
      return rc(t, r);
    }
    function qP(t, e, r) {
      if (r < Ht) throw new Error("invalid exponent, negatives unsupported");
      if (r === Ht) return t.ONE;
      if (r === It) return e;
      let i = t.ONE,
        s = e;
      for (; r > Ht; ) r & It && (i = t.mul(i, s)), (s = t.sqr(s)), (r >>= It);
      return i;
    }
    function HP(t, e) {
      const r = new Array(e.length),
        i = e.reduce(
          (n, o, a) => (t.is0(o) ? n : ((r[a] = n), t.mul(n, o))),
          t.ONE
        ),
        s = t.inv(i);
      return (
        e.reduceRight(
          (n, o, a) => (t.is0(o) ? n : ((r[a] = t.mul(n, r[a])), t.mul(n, o))),
          s
        ),
        r
      );
    }
    function R2(t, e) {
      const r = e !== void 0 ? e : t.toString(2).length,
        i = Math.ceil(r / 8);
      return { nBitLength: r, nByteLength: i };
    }
    function $2(t, e, r = !1, i = {}) {
      if (t <= Ht)
        throw new Error("invalid field: expected ORDER > 0, got " + t);
      const { nBitLength: s, nByteLength: n } = R2(t, e);
      if (n > 2048)
        throw new Error("invalid field: expected ORDER of <= 2048 bytes");
      let o;
      const a = Object.freeze({
        ORDER: t,
        isLE: r,
        BITS: s,
        BYTES: n,
        MASK: vg(s),
        ZERO: Ht,
        ONE: It,
        create: (c) => Vt(c, t),
        isValid: (c) => {
          if (typeof c != "bigint")
            throw new Error(
              "invalid field element: expected bigint, got " + typeof c
            );
          return Ht <= c && c < t;
        },
        is0: (c) => c === Ht,
        isOdd: (c) => (c & It) === It,
        neg: (c) => Vt(-c, t),
        eql: (c, l) => c === l,
        sqr: (c) => Vt(c * c, t),
        add: (c, l) => Vt(c + l, t),
        sub: (c, l) => Vt(c - l, t),
        mul: (c, l) => Vt(c * l, t),
        pow: (c, l) => qP(a, c, l),
        div: (c, l) => Vt(c * Og(l, t), t),
        sqrN: (c) => c * c,
        addN: (c, l) => c + l,
        subN: (c, l) => c - l,
        mulN: (c, l) => c * l,
        inv: (c) => Og(c, t),
        sqrt: i.sqrt || ((c) => (o || (o = MP(t)), o(a, c))),
        invertBatch: (c) => HP(a, c),
        cmov: (c, l, u) => (u ? l : c),
        toBytes: (c) => (r ? yg(c, n) : Ln(c, n)),
        fromBytes: (c) => {
          if (c.length !== n)
            throw new Error(
              "Field.fromBytes: expected " + n + " bytes, got " + c.length
            );
          return r ? mg(c) : ms(c);
        },
      });
      return Object.freeze(a);
    }
    function F2(t) {
      if (typeof t != "bigint") throw new Error("field order must be bigint");
      const e = t.toString(2).length;
      return Math.ceil(e / 8);
    }
    function B2(t) {
      const e = F2(t);
      return e + Math.ceil(e / 2);
    }
    function VP(t, e, r = !1) {
      const i = t.length,
        s = F2(e),
        n = B2(e);
      if (i < 16 || i < n || i > 1024)
        throw new Error("expected " + n + "-1024 bytes of input, got " + i);
      const o = r ? mg(t) : ms(t),
        a = Vt(o, e - It) + It;
      return r ? yg(a, s) : Ln(a, s);
    }
    const L2 = BigInt(0),
      Qd = BigInt(1);
    function Ng(t, e) {
      const r = e.negate();
      return t ? r : e;
    }
    function U2(t, e) {
      if (!Number.isSafeInteger(t) || t <= 0 || t > e)
        throw new Error(
          "invalid window size, expected [1.." + e + "], got W=" + t
        );
    }
    function Tg(t, e) {
      U2(t, e);
      const r = Math.ceil(e / t) + 1,
        i = 2 ** (t - 1);
      return { windows: r, windowSize: i };
    }
    function WP(t, e) {
      if (!Array.isArray(t)) throw new Error("array expected");
      t.forEach((r, i) => {
        if (!(r instanceof e)) throw new Error("invalid point at index " + i);
      });
    }
    function KP(t, e) {
      if (!Array.isArray(t)) throw new Error("array of scalars expected");
      t.forEach((r, i) => {
        if (!e.isValid(r)) throw new Error("invalid scalar at index " + i);
      });
    }
    const kg = new WeakMap(),
      D2 = new WeakMap();
    function Rg(t) {
      return D2.get(t) || 1;
    }
    function GP(t, e) {
      return {
        constTimeNegate: Ng,
        hasPrecomputes(r) {
          return Rg(r) !== 1;
        },
        unsafeLadder(r, i, s = t.ZERO) {
          let n = r;
          for (; i > L2; )
            i & Qd && (s = s.add(n)), (n = n.double()), (i >>= Qd);
          return s;
        },
        precomputeWindow(r, i) {
          const { windows: s, windowSize: n } = Tg(i, e),
            o = [];
          let a = r,
            c = a;
          for (let l = 0; l < s; l++) {
            (c = a), o.push(c);
            for (let u = 1; u < n; u++) (c = c.add(a)), o.push(c);
            a = c.double();
          }
          return o;
        },
        wNAF(r, i, s) {
          const { windows: n, windowSize: o } = Tg(r, e);
          let a = t.ZERO,
            c = t.BASE;
          const l = BigInt(2 ** r - 1),
            u = 2 ** r,
            h = BigInt(r);
          for (let d = 0; d < n; d++) {
            const g = d * o;
            let p = Number(s & l);
            (s >>= h), p > o && ((p -= u), (s += Qd));
            const w = g,
              f = g + Math.abs(p) - 1,
              m = d % 2 !== 0,
              y = p < 0;
            p === 0 ? (c = c.add(Ng(m, i[w]))) : (a = a.add(Ng(y, i[f])));
          }
          return { p: a, f: c };
        },
        wNAFUnsafe(r, i, s, n = t.ZERO) {
          const { windows: o, windowSize: a } = Tg(r, e),
            c = BigInt(2 ** r - 1),
            l = 2 ** r,
            u = BigInt(r);
          for (let h = 0; h < o; h++) {
            const d = h * a;
            if (s === L2) break;
            let g = Number(s & c);
            if (((s >>= u), g > a && ((g -= l), (s += Qd)), g === 0)) continue;
            let p = i[d + Math.abs(g) - 1];
            g < 0 && (p = p.negate()), (n = n.add(p));
          }
          return n;
        },
        getPrecomputes(r, i, s) {
          let n = kg.get(i);
          return (
            n ||
              ((n = this.precomputeWindow(i, r)), r !== 1 && kg.set(i, s(n))),
            n
          );
        },
        wNAFCached(r, i, s) {
          const n = Rg(r);
          return this.wNAF(n, this.getPrecomputes(n, r, s), i);
        },
        wNAFCachedUnsafe(r, i, s, n) {
          const o = Rg(r);
          return o === 1
            ? this.unsafeLadder(r, i, n)
            : this.wNAFUnsafe(o, this.getPrecomputes(o, r, s), i, n);
        },
        setWindowSize(r, i) {
          U2(i, e), D2.set(r, i), kg.delete(r);
        },
      };
    }
    function ZP(t, e, r, i) {
      if ((WP(r, t), KP(i, e), r.length !== i.length))
        throw new Error("arrays of points and scalars must have equal length");
      const s = t.ZERO,
        n = m2(BigInt(r.length)),
        o = n > 12 ? n - 3 : n > 4 ? n - 2 : n ? 2 : 1,
        a = (1 << o) - 1,
        c = new Array(a + 1).fill(s),
        l = Math.floor((e.BITS - 1) / o) * o;
      let u = s;
      for (let h = l; h >= 0; h -= o) {
        c.fill(s);
        for (let g = 0; g < i.length; g++) {
          const p = i[g],
            w = Number((p >> BigInt(h)) & BigInt(a));
          c[w] = c[w].add(r[g]);
        }
        let d = s;
        for (let g = c.length - 1, p = s; g > 0; g--)
          (p = p.add(c[g])), (d = d.add(p));
        if (((u = u.add(d)), h !== 0))
          for (let g = 0; g < o; g++) u = u.double();
      }
      return u;
    }
    function j2(t) {
      return (
        k2(t.Fp),
        rc(
          t,
          { n: "bigint", h: "bigint", Gx: "field", Gy: "field" },
          { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }
        ),
        Object.freeze({ ...R2(t.n, t.nBitLength), ...t, p: t.Fp.ORDER })
      );
    }
    function M2(t) {
      t.lowS !== void 0 && Ja("lowS", t.lowS),
        t.prehash !== void 0 && Ja("prehash", t.prehash);
    }
    function YP(t) {
      const e = j2(t);
      rc(
        e,
        { a: "field", b: "field" },
        {
          allowedPrivateKeyLengths: "array",
          wrapPrivateKey: "boolean",
          isTorsionFree: "function",
          clearCofactor: "function",
          allowInfinityPoint: "boolean",
          fromBytes: "function",
          toBytes: "function",
        }
      );
      const { endo: r, Fp: i, a: s } = e;
      if (r) {
        if (!i.eql(s, i.ZERO))
          throw new Error(
            "invalid endomorphism, can only be defined for Koblitz curves that have a=0"
          );
        if (
          typeof r != "object" ||
          typeof r.beta != "bigint" ||
          typeof r.splitScalar != "function"
        )
          throw new Error(
            "invalid endomorphism, expected beta: bigint and splitScalar: function"
          );
      }
      return Object.freeze({ ...e });
    }
    const { bytesToNumberBE: JP, hexToBytes: XP } = nP;
    class QP extends Error {
      constructor(e = "") {
        super(e);
      }
    }
    const Vs = {
        Err: QP,
        _tlv: {
          encode: (t, e) => {
            const { Err: r } = Vs;
            if (t < 0 || t > 256) throw new r("tlv.encode: wrong tag");
            if (e.length & 1) throw new r("tlv.encode: unpadded data");
            const i = e.length / 2,
              s = Qa(i);
            if ((s.length / 2) & 128)
              throw new r("tlv.encode: long form length too big");
            const n = i > 127 ? Qa((s.length / 2) | 128) : "";
            return Qa(t) + n + s + e;
          },
          decode(t, e) {
            const { Err: r } = Vs;
            let i = 0;
            if (t < 0 || t > 256) throw new r("tlv.encode: wrong tag");
            if (e.length < 2 || e[i++] !== t)
              throw new r("tlv.decode: wrong tlv");
            const s = e[i++],
              n = !!(s & 128);
            let o = 0;
            if (!n) o = s;
            else {
              const c = s & 127;
              if (!c)
                throw new r(
                  "tlv.decode(long): indefinite length not supported"
                );
              if (c > 4)
                throw new r("tlv.decode(long): byte length is too big");
              const l = e.subarray(i, i + c);
              if (l.length !== c)
                throw new r("tlv.decode: length bytes not complete");
              if (l[0] === 0)
                throw new r("tlv.decode(long): zero leftmost byte");
              for (const u of l) o = (o << 8) | u;
              if (((i += c), o < 128))
                throw new r("tlv.decode(long): not minimal encoding");
            }
            const a = e.subarray(i, i + o);
            if (a.length !== o) throw new r("tlv.decode: wrong value length");
            return { v: a, l: e.subarray(i + o) };
          },
        },
        _int: {
          encode(t) {
            const { Err: e } = Vs;
            if (t < Zi)
              throw new e("integer: negative integers are not allowed");
            let r = Qa(t);
            if ((Number.parseInt(r[0], 16) & 8 && (r = "00" + r), r.length & 1))
              throw new e("unexpected DER parsing assertion: unpadded hex");
            return r;
          },
          decode(t) {
            const { Err: e } = Vs;
            if (t[0] & 128) throw new e("invalid signature integer: negative");
            if (t[0] === 0 && !(t[1] & 128))
              throw new e(
                "invalid signature integer: unnecessary leading zero"
              );
            return JP(t);
          },
        },
        toSig(t) {
          const { Err: e, _int: r, _tlv: i } = Vs,
            s = typeof t == "string" ? XP(t) : t;
          ws(s);
          const { v: n, l: o } = i.decode(48, s);
          if (o.length)
            throw new e("invalid signature: left bytes after parsing");
          const { v: a, l: c } = i.decode(2, n),
            { v: l, l: u } = i.decode(2, c);
          if (u.length)
            throw new e("invalid signature: left bytes after parsing");
          return { r: r.decode(a), s: r.decode(l) };
        },
        hexFromSig(t) {
          const { _tlv: e, _int: r } = Vs,
            i = e.encode(2, r.encode(t.r)),
            s = e.encode(2, r.encode(t.s)),
            n = i + s;
          return e.encode(48, n);
        },
      },
      Zi = BigInt(0),
      Qe = BigInt(1),
      Dn = BigInt(2),
      ep = BigInt(3),
      z2 = BigInt(4);
    function eO(t) {
      const e = YP(t),
        { Fp: r } = e,
        i = $2(e.n, e.nBitLength),
        s =
          e.toBytes ||
          ((w, f, m) => {
            const y = f.toAffine();
            return si(Uint8Array.from([4]), r.toBytes(y.x), r.toBytes(y.y));
          }),
        n =
          e.fromBytes ||
          ((w) => {
            const f = w.subarray(1),
              m = r.fromBytes(f.subarray(0, r.BYTES)),
              y = r.fromBytes(f.subarray(r.BYTES, 2 * r.BYTES));
            return { x: m, y };
          });
      function o(w) {
        const { a: f, b: m } = e,
          y = r.sqr(w),
          E = r.mul(y, w);
        return r.add(r.add(E, r.mul(w, f)), m);
      }
      if (!r.eql(r.sqr(e.Gy), o(e.Gx)))
        throw new Error("bad generator point: equation left != right");
      function a(w) {
        return tc(w, Qe, e.n);
      }
      function c(w) {
        const {
          allowedPrivateKeyLengths: f,
          nByteLength: m,
          wrapPrivateKey: y,
          n: E,
        } = e;
        if (f && typeof w != "bigint") {
          if (
            (ko(w) && (w = Xa(w)),
            typeof w != "string" || !f.includes(w.length))
          )
            throw new Error("invalid private key");
          w = w.padStart(m * 2, "0");
        }
        let C;
        try {
          C = typeof w == "bigint" ? w : ms(_r("private key", w, m));
        } catch {
          throw new Error(
            "invalid private key, expected hex or " +
              m +
              " bytes, got " +
              typeof w
          );
        }
        return y && (C = Vt(C, E)), Un("private key", C, Qe, E), C;
      }
      function l(w) {
        if (!(w instanceof d)) throw new Error("ProjectivePoint expected");
      }
      const u = Cg((w, f) => {
          const { px: m, py: y, pz: E } = w;
          if (r.eql(E, r.ONE)) return { x: m, y };
          const C = w.is0();
          f == null && (f = C ? r.ONE : r.inv(E));
          const O = r.mul(m, f),
            A = r.mul(y, f),
            P = r.mul(E, f);
          if (C) return { x: r.ZERO, y: r.ZERO };
          if (!r.eql(P, r.ONE)) throw new Error("invZ was invalid");
          return { x: O, y: A };
        }),
        h = Cg((w) => {
          if (w.is0()) {
            if (e.allowInfinityPoint && !r.is0(w.py)) return;
            throw new Error("bad point: ZERO");
          }
          const { x: f, y: m } = w.toAffine();
          if (!r.isValid(f) || !r.isValid(m))
            throw new Error("bad point: x or y not FE");
          const y = r.sqr(m),
            E = o(f);
          if (!r.eql(y, E))
            throw new Error("bad point: equation left != right");
          if (!w.isTorsionFree())
            throw new Error("bad point: not in prime-order subgroup");
          return !0;
        });
      class d {
        constructor(f, m, y) {
          if (
            ((this.px = f),
            (this.py = m),
            (this.pz = y),
            f == null || !r.isValid(f))
          )
            throw new Error("x required");
          if (m == null || !r.isValid(m)) throw new Error("y required");
          if (y == null || !r.isValid(y)) throw new Error("z required");
          Object.freeze(this);
        }
        static fromAffine(f) {
          const { x: m, y } = f || {};
          if (!f || !r.isValid(m) || !r.isValid(y))
            throw new Error("invalid affine point");
          if (f instanceof d) throw new Error("projective point not allowed");
          const E = (C) => r.eql(C, r.ZERO);
          return E(m) && E(y) ? d.ZERO : new d(m, y, r.ONE);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        static normalizeZ(f) {
          const m = r.invertBatch(f.map((y) => y.pz));
          return f.map((y, E) => y.toAffine(m[E])).map(d.fromAffine);
        }
        static fromHex(f) {
          const m = d.fromAffine(n(_r("pointHex", f)));
          return m.assertValidity(), m;
        }
        static fromPrivateKey(f) {
          return d.BASE.multiply(c(f));
        }
        static msm(f, m) {
          return ZP(d, i, f, m);
        }
        _setWindowSize(f) {
          p.setWindowSize(this, f);
        }
        assertValidity() {
          h(this);
        }
        hasEvenY() {
          const { y: f } = this.toAffine();
          if (r.isOdd) return !r.isOdd(f);
          throw new Error("Field doesn't support isOdd");
        }
        equals(f) {
          l(f);
          const { px: m, py: y, pz: E } = this,
            { px: C, py: O, pz: A } = f,
            P = r.eql(r.mul(m, A), r.mul(C, E)),
            N = r.eql(r.mul(y, A), r.mul(O, E));
          return P && N;
        }
        negate() {
          return new d(this.px, r.neg(this.py), this.pz);
        }
        double() {
          const { a: f, b: m } = e,
            y = r.mul(m, ep),
            { px: E, py: C, pz: O } = this;
          let A = r.ZERO,
            P = r.ZERO,
            N = r.ZERO,
            x = r.mul(E, E),
            $ = r.mul(C, C),
            k = r.mul(O, O),
            F = r.mul(E, C);
          return (
            (F = r.add(F, F)),
            (N = r.mul(E, O)),
            (N = r.add(N, N)),
            (A = r.mul(f, N)),
            (P = r.mul(y, k)),
            (P = r.add(A, P)),
            (A = r.sub($, P)),
            (P = r.add($, P)),
            (P = r.mul(A, P)),
            (A = r.mul(F, A)),
            (N = r.mul(y, N)),
            (k = r.mul(f, k)),
            (F = r.sub(x, k)),
            (F = r.mul(f, F)),
            (F = r.add(F, N)),
            (N = r.add(x, x)),
            (x = r.add(N, x)),
            (x = r.add(x, k)),
            (x = r.mul(x, F)),
            (P = r.add(P, x)),
            (k = r.mul(C, O)),
            (k = r.add(k, k)),
            (x = r.mul(k, F)),
            (A = r.sub(A, x)),
            (N = r.mul(k, $)),
            (N = r.add(N, N)),
            (N = r.add(N, N)),
            new d(A, P, N)
          );
        }
        add(f) {
          l(f);
          const { px: m, py: y, pz: E } = this,
            { px: C, py: O, pz: A } = f;
          let P = r.ZERO,
            N = r.ZERO,
            x = r.ZERO;
          const $ = e.a,
            k = r.mul(e.b, ep);
          let F = r.mul(m, C),
            j = r.mul(y, O),
            I = r.mul(E, A),
            b = r.add(m, y),
            v = r.add(C, O);
          (b = r.mul(b, v)),
            (v = r.add(F, j)),
            (b = r.sub(b, v)),
            (v = r.add(m, E));
          let S = r.add(C, A);
          return (
            (v = r.mul(v, S)),
            (S = r.add(F, I)),
            (v = r.sub(v, S)),
            (S = r.add(y, E)),
            (P = r.add(O, A)),
            (S = r.mul(S, P)),
            (P = r.add(j, I)),
            (S = r.sub(S, P)),
            (x = r.mul($, v)),
            (P = r.mul(k, I)),
            (x = r.add(P, x)),
            (P = r.sub(j, x)),
            (x = r.add(j, x)),
            (N = r.mul(P, x)),
            (j = r.add(F, F)),
            (j = r.add(j, F)),
            (I = r.mul($, I)),
            (v = r.mul(k, v)),
            (j = r.add(j, I)),
            (I = r.sub(F, I)),
            (I = r.mul($, I)),
            (v = r.add(v, I)),
            (F = r.mul(j, v)),
            (N = r.add(N, F)),
            (F = r.mul(S, v)),
            (P = r.mul(b, P)),
            (P = r.sub(P, F)),
            (F = r.mul(b, j)),
            (x = r.mul(S, x)),
            (x = r.add(x, F)),
            new d(P, N, x)
          );
        }
        subtract(f) {
          return this.add(f.negate());
        }
        is0() {
          return this.equals(d.ZERO);
        }
        wNAF(f) {
          return p.wNAFCached(this, f, d.normalizeZ);
        }
        multiplyUnsafe(f) {
          const { endo: m, n: y } = e;
          Un("scalar", f, Zi, y);
          const E = d.ZERO;
          if (f === Zi) return E;
          if (this.is0() || f === Qe) return this;
          if (!m || p.hasPrecomputes(this))
            return p.wNAFCachedUnsafe(this, f, d.normalizeZ);
          let { k1neg: C, k1: O, k2neg: A, k2: P } = m.splitScalar(f),
            N = E,
            x = E,
            $ = this;
          for (; O > Zi || P > Zi; )
            O & Qe && (N = N.add($)),
              P & Qe && (x = x.add($)),
              ($ = $.double()),
              (O >>= Qe),
              (P >>= Qe);
          return (
            C && (N = N.negate()),
            A && (x = x.negate()),
            (x = new d(r.mul(x.px, m.beta), x.py, x.pz)),
            N.add(x)
          );
        }
        multiply(f) {
          const { endo: m, n: y } = e;
          Un("scalar", f, Qe, y);
          let E, C;
          if (m) {
            const { k1neg: O, k1: A, k2neg: P, k2: N } = m.splitScalar(f);
            let { p: x, f: $ } = this.wNAF(A),
              { p: k, f: F } = this.wNAF(N);
            (x = p.constTimeNegate(O, x)),
              (k = p.constTimeNegate(P, k)),
              (k = new d(r.mul(k.px, m.beta), k.py, k.pz)),
              (E = x.add(k)),
              (C = $.add(F));
          } else {
            const { p: O, f: A } = this.wNAF(f);
            (E = O), (C = A);
          }
          return d.normalizeZ([E, C])[0];
        }
        multiplyAndAddUnsafe(f, m, y) {
          const E = d.BASE,
            C = (A, P) =>
              P === Zi || P === Qe || !A.equals(E)
                ? A.multiplyUnsafe(P)
                : A.multiply(P),
            O = C(this, m).add(C(f, y));
          return O.is0() ? void 0 : O;
        }
        toAffine(f) {
          return u(this, f);
        }
        isTorsionFree() {
          const { h: f, isTorsionFree: m } = e;
          if (f === Qe) return !0;
          if (m) return m(d, this);
          throw new Error(
            "isTorsionFree() has not been declared for the elliptic curve"
          );
        }
        clearCofactor() {
          const { h: f, clearCofactor: m } = e;
          return f === Qe ? this : m ? m(d, this) : this.multiplyUnsafe(e.h);
        }
        toRawBytes(f = !0) {
          return Ja("isCompressed", f), this.assertValidity(), s(d, this, f);
        }
        toHex(f = !0) {
          return Ja("isCompressed", f), Xa(this.toRawBytes(f));
        }
      }
      (d.BASE = new d(e.Gx, e.Gy, r.ONE)),
        (d.ZERO = new d(r.ZERO, r.ONE, r.ZERO));
      const g = e.nBitLength,
        p = GP(d, e.endo ? Math.ceil(g / 2) : g);
      return {
        CURVE: e,
        ProjectivePoint: d,
        normPrivateKeyToScalar: c,
        weierstrassEquation: o,
        isWithinCurveOrder: a,
      };
    }
    function tO(t) {
      const e = j2(t);
      return (
        rc(
          e,
          { hash: "hash", hmac: "function", randomBytes: "function" },
          { bits2int: "function", bits2int_modN: "function", lowS: "boolean" }
        ),
        Object.freeze({ lowS: !0, ...e })
      );
    }
    function rO(t) {
      const e = tO(t),
        { Fp: r, n: i } = e,
        s = r.BYTES + 1,
        n = 2 * r.BYTES + 1;
      function o(I) {
        return Vt(I, i);
      }
      function a(I) {
        return Og(I, i);
      }
      const {
          ProjectivePoint: c,
          normPrivateKeyToScalar: l,
          weierstrassEquation: u,
          isWithinCurveOrder: h,
        } = eO({
          ...e,
          toBytes(I, b, v) {
            const S = b.toAffine(),
              T = r.toBytes(S.x),
              _ = si;
            return (
              Ja("isCompressed", v),
              v
                ? _(Uint8Array.from([b.hasEvenY() ? 2 : 3]), T)
                : _(Uint8Array.from([4]), T, r.toBytes(S.y))
            );
          },
          fromBytes(I) {
            const b = I.length,
              v = I[0],
              S = I.subarray(1);
            if (b === s && (v === 2 || v === 3)) {
              const T = ms(S);
              if (!tc(T, Qe, r.ORDER)) throw new Error("Point is not on curve");
              const _ = u(T);
              let R;
              try {
                R = r.sqrt(_);
              } catch (D) {
                const H = D instanceof Error ? ": " + D.message : "";
                throw new Error("Point is not on curve" + H);
              }
              const U = (R & Qe) === Qe;
              return ((v & 1) === 1) !== U && (R = r.neg(R)), { x: T, y: R };
            } else if (b === n && v === 4) {
              const T = r.fromBytes(S.subarray(0, r.BYTES)),
                _ = r.fromBytes(S.subarray(r.BYTES, 2 * r.BYTES));
              return { x: T, y: _ };
            } else {
              const T = s,
                _ = n;
              throw new Error(
                "invalid Point, expected length of " +
                  T +
                  ", or uncompressed " +
                  _ +
                  ", got " +
                  b
              );
            }
          },
        }),
        d = (I) => Xa(Ln(I, e.nByteLength));
      function g(I) {
        const b = i >> Qe;
        return I > b;
      }
      function p(I) {
        return g(I) ? o(-I) : I;
      }
      const w = (I, b, v) => ms(I.slice(b, v));
      class f {
        constructor(b, v, S) {
          (this.r = b),
            (this.s = v),
            (this.recovery = S),
            this.assertValidity();
        }
        static fromCompact(b) {
          const v = e.nByteLength;
          return (
            (b = _r("compactSignature", b, v * 2)),
            new f(w(b, 0, v), w(b, v, 2 * v))
          );
        }
        static fromDER(b) {
          const { r: v, s: S } = Vs.toSig(_r("DER", b));
          return new f(v, S);
        }
        assertValidity() {
          Un("r", this.r, Qe, i), Un("s", this.s, Qe, i);
        }
        addRecoveryBit(b) {
          return new f(this.r, this.s, b);
        }
        recoverPublicKey(b) {
          const { r: v, s: S, recovery: T } = this,
            _ = A(_r("msgHash", b));
          if (T == null || ![0, 1, 2, 3].includes(T))
            throw new Error("recovery id invalid");
          const R = T === 2 || T === 3 ? v + e.n : v;
          if (R >= r.ORDER) throw new Error("recovery id 2 or 3 invalid");
          const U = (T & 1) === 0 ? "02" : "03",
            D = c.fromHex(U + d(R)),
            H = a(R),
            q = o(-_ * H),
            V = o(S * H),
            Y = c.BASE.multiplyAndAddUnsafe(D, q, V);
          if (!Y) throw new Error("point at infinify");
          return Y.assertValidity(), Y;
        }
        hasHighS() {
          return g(this.s);
        }
        normalizeS() {
          return this.hasHighS()
            ? new f(this.r, o(-this.s), this.recovery)
            : this;
        }
        toDERRawBytes() {
          return ec(this.toDERHex());
        }
        toDERHex() {
          return Vs.hexFromSig({ r: this.r, s: this.s });
        }
        toCompactRawBytes() {
          return ec(this.toCompactHex());
        }
        toCompactHex() {
          return d(this.r) + d(this.s);
        }
      }
      const m = {
        isValidPrivateKey(I) {
          try {
            return l(I), !0;
          } catch {
            return !1;
          }
        },
        normPrivateKeyToScalar: l,
        randomPrivateKey: () => {
          const I = B2(e.n);
          return VP(e.randomBytes(I), e.n);
        },
        precompute(I = 8, b = c.BASE) {
          return b._setWindowSize(I), b.multiply(BigInt(3)), b;
        },
      };
      function y(I, b = !0) {
        return c.fromPrivateKey(I).toRawBytes(b);
      }
      function E(I) {
        const b = ko(I),
          v = typeof I == "string",
          S = (b || v) && I.length;
        return b
          ? S === s || S === n
          : v
          ? S === 2 * s || S === 2 * n
          : I instanceof c;
      }
      function C(I, b, v = !0) {
        if (E(I)) throw new Error("first arg must be private key");
        if (!E(b)) throw new Error("second arg must be public key");
        return c.fromHex(b).multiply(l(I)).toRawBytes(v);
      }
      const O =
          e.bits2int ||
          function (I) {
            if (I.length > 8192) throw new Error("input is too large");
            const b = ms(I),
              v = I.length * 8 - e.nBitLength;
            return v > 0 ? b >> BigInt(v) : b;
          },
        A =
          e.bits2int_modN ||
          function (I) {
            return o(O(I));
          },
        P = vg(e.nBitLength);
      function N(I) {
        return Un("num < 2^" + e.nBitLength, I, Zi, P), Ln(I, e.nByteLength);
      }
      function x(I, b, v = $) {
        if (["recovered", "canonical"].some((re) => re in v))
          throw new Error("sign() legacy options not supported");
        const { hash: S, randomBytes: T } = e;
        let { lowS: _, prehash: R, extraEntropy: U } = v;
        _ == null && (_ = !0),
          (I = _r("msgHash", I)),
          M2(v),
          R && (I = _r("prehashed msgHash", S(I)));
        const D = A(I),
          H = l(b),
          q = [N(H), N(D)];
        if (U != null && U !== !1) {
          const re = U === !0 ? T(r.BYTES) : U;
          q.push(_r("extraEntropy", re));
        }
        const V = si(...q),
          Y = D;
        function ae(re) {
          const te = O(re);
          if (!h(te)) return;
          const ve = a(te),
            Ee = c.BASE.multiply(te).toAffine(),
            Ce = o(Ee.x);
          if (Ce === Zi) return;
          const Ie = o(ve * o(Y + Ce * H));
          if (Ie === Zi) return;
          let mt = (Ee.x === Ce ? 0 : 2) | Number(Ee.y & Qe),
            Ir = Ie;
          return _ && g(Ie) && ((Ir = p(Ie)), (mt ^= 1)), new f(Ce, Ir, mt);
        }
        return { seed: V, k2sig: ae };
      }
      const $ = { lowS: e.lowS, prehash: !1 },
        k = { lowS: e.lowS, prehash: !1 };
      function F(I, b, v = $) {
        const { seed: S, k2sig: T } = x(I, b, v),
          _ = e;
        return b2(_.hash.outputLen, _.nByteLength, _.hmac)(S, T);
      }
      c.BASE._setWindowSize(8);
      function j(I, b, v, S = k) {
        const T = I;
        (b = _r("msgHash", b)), (v = _r("publicKey", v));
        const { lowS: _, prehash: R, format: U } = S;
        if ((M2(S), "strict" in S))
          throw new Error("options.strict was renamed to lowS");
        if (U !== void 0 && U !== "compact" && U !== "der")
          throw new Error("format must be compact or der");
        const D = typeof T == "string" || ko(T),
          H =
            !D &&
            !U &&
            typeof T == "object" &&
            T !== null &&
            typeof T.r == "bigint" &&
            typeof T.s == "bigint";
        if (!D && !H)
          throw new Error(
            "invalid signature, expected Uint8Array, hex string or Signature instance"
          );
        let q, V;
        try {
          if ((H && (q = new f(T.r, T.s)), D)) {
            try {
              U !== "compact" && (q = f.fromDER(T));
            } catch (Ie) {
              if (!(Ie instanceof Vs.Err)) throw Ie;
            }
            !q && U !== "der" && (q = f.fromCompact(T));
          }
          V = c.fromHex(v);
        } catch {
          return !1;
        }
        if (!q || (_ && q.hasHighS())) return !1;
        R && (b = e.hash(b));
        const { r: Y, s: ae } = q,
          re = A(b),
          te = a(ae),
          ve = o(re * te),
          Ee = o(Y * te),
          Ce = c.BASE.multiplyAndAddUnsafe(V, ve, Ee)?.toAffine();
        return Ce ? o(Ce.x) === Y : !1;
      }
      return {
        CURVE: e,
        getPublicKey: y,
        getSharedSecret: C,
        sign: F,
        verify: j,
        ProjectivePoint: c,
        Signature: f,
        utils: m,
      };
    }
    function iO(t, e) {
      const r = t.ORDER;
      let i = Zi;
      for (let p = r - Qe; p % Dn === Zi; p /= Dn) i += Qe;
      const s = i,
        n = Dn << (s - Qe - Qe),
        o = n * Dn,
        a = (r - Qe) / o,
        c = (a - Qe) / Dn,
        l = o - Qe,
        u = n,
        h = t.pow(e, a),
        d = t.pow(e, (a + Qe) / Dn);
      let g = (p, w) => {
        let f = h,
          m = t.pow(w, l),
          y = t.sqr(m);
        y = t.mul(y, w);
        let E = t.mul(p, y);
        (E = t.pow(E, c)),
          (E = t.mul(E, m)),
          (m = t.mul(E, w)),
          (y = t.mul(E, p));
        let C = t.mul(y, m);
        E = t.pow(C, u);
        let O = t.eql(E, t.ONE);
        (m = t.mul(y, d)),
          (E = t.mul(C, f)),
          (y = t.cmov(m, y, O)),
          (C = t.cmov(E, C, O));
        for (let A = s; A > Qe; A--) {
          let P = A - Dn;
          P = Dn << (P - Qe);
          let N = t.pow(C, P);
          const x = t.eql(N, t.ONE);
          (m = t.mul(y, f)),
            (f = t.mul(f, f)),
            (N = t.mul(C, f)),
            (y = t.cmov(m, y, x)),
            (C = t.cmov(N, C, x));
        }
        return { isValid: O, value: y };
      };
      if (t.ORDER % z2 === ep) {
        const p = (t.ORDER - ep) / z2,
          w = t.sqrt(t.neg(e));
        g = (f, m) => {
          let y = t.sqr(m);
          const E = t.mul(f, m);
          y = t.mul(y, E);
          let C = t.pow(y, p);
          C = t.mul(C, E);
          const O = t.mul(C, w),
            A = t.mul(t.sqr(C), m),
            P = t.eql(A, f);
          let N = t.cmov(O, C, P);
          return { isValid: P, value: N };
        };
      }
      return g;
    }
    function sO(t, e) {
      if ((k2(t), !t.isValid(e.A) || !t.isValid(e.B) || !t.isValid(e.Z)))
        throw new Error("mapToCurveSimpleSWU: invalid opts");
      const r = iO(t, e.Z);
      if (!t.isOdd) throw new Error("Fp.isOdd is not implemented!");
      return (i) => {
        let s, n, o, a, c, l, u, h;
        (s = t.sqr(i)),
          (s = t.mul(s, e.Z)),
          (n = t.sqr(s)),
          (n = t.add(n, s)),
          (o = t.add(n, t.ONE)),
          (o = t.mul(o, e.B)),
          (a = t.cmov(e.Z, t.neg(n), !t.eql(n, t.ZERO))),
          (a = t.mul(a, e.A)),
          (n = t.sqr(o)),
          (l = t.sqr(a)),
          (c = t.mul(l, e.A)),
          (n = t.add(n, c)),
          (n = t.mul(n, o)),
          (l = t.mul(l, a)),
          (c = t.mul(l, e.B)),
          (n = t.add(n, c)),
          (u = t.mul(s, o));
        const { isValid: d, value: g } = r(n, l);
        (h = t.mul(s, i)),
          (h = t.mul(h, g)),
          (u = t.cmov(u, o, d)),
          (h = t.cmov(h, g, d));
        const p = t.isOdd(i) === t.isOdd(h);
        return (h = t.cmov(t.neg(h), h, p)), (u = t.div(u, a)), { x: u, y: h };
      };
    }
    function nO(t) {
      return {
        hash: t,
        hmac: (e, ...r) => O2(t, e, PS(...r)),
        randomBytes: o2,
      };
    }
    function oO(t, e) {
      const r = (i) => rO({ ...t, ...nO(i) });
      return { ...r(e), create: r };
    }
    const aO = ms;
    function jn(t, e) {
      if ((ou(t), ou(e), t < 0 || t >= 1 << (8 * e)))
        throw new Error("invalid I2OSP input: " + t);
      const r = Array.from({ length: e }).fill(0);
      for (let i = e - 1; i >= 0; i--) (r[i] = t & 255), (t >>>= 8);
      return new Uint8Array(r);
    }
    function cO(t, e) {
      const r = new Uint8Array(t.length);
      for (let i = 0; i < t.length; i++) r[i] = t[i] ^ e[i];
      return r;
    }
    function ou(t) {
      if (!Number.isSafeInteger(t)) throw new Error("number expected");
    }
    function lO(t, e, r, i) {
      ws(t),
        ws(e),
        ou(r),
        e.length > 255 && (e = i(si(Jd("H2C-OVERSIZE-DST-"), e)));
      const { outputLen: s, blockLen: n } = i,
        o = Math.ceil(r / s);
      if (r > 65535 || o > 255)
        throw new Error("expand_message_xmd: invalid lenInBytes");
      const a = si(e, jn(e.length, 1)),
        c = jn(0, n),
        l = jn(r, 2),
        u = new Array(o),
        h = i(si(c, t, l, jn(0, 1), a));
      u[0] = i(si(h, jn(1, 1), a));
      for (let d = 1; d <= o; d++) {
        const g = [cO(h, u[d - 1]), jn(d + 1, 1), a];
        u[d] = i(si(...g));
      }
      return si(...u).slice(0, r);
    }
    function uO(t, e, r, i, s) {
      if ((ws(t), ws(e), ou(r), e.length > 255)) {
        const n = Math.ceil((2 * i) / 8);
        e = s
          .create({ dkLen: n })
          .update(Jd("H2C-OVERSIZE-DST-"))
          .update(e)
          .digest();
      }
      if (r > 65535 || e.length > 255)
        throw new Error("expand_message_xof: invalid lenInBytes");
      return s
        .create({ dkLen: r })
        .update(t)
        .update(jn(r, 2))
        .update(e)
        .update(jn(e.length, 1))
        .digest();
    }
    function q2(t, e, r) {
      rc(r, {
        DST: "stringOrUint8Array",
        p: "bigint",
        m: "isSafeInteger",
        k: "isSafeInteger",
        hash: "hash",
      });
      const { p: i, k: s, m: n, hash: o, expand: a, DST: c } = r;
      ws(t), ou(e);
      const l = typeof c == "string" ? Jd(c) : c,
        u = i.toString(2).length,
        h = Math.ceil((u + s) / 8),
        d = e * n * h;
      let g;
      if (a === "xmd") g = lO(t, l, d, o);
      else if (a === "xof") g = uO(t, l, d, s, o);
      else if (a === "_internal_pass") g = t;
      else throw new Error('expand must be "xmd" or "xof"');
      const p = new Array(e);
      for (let w = 0; w < e; w++) {
        const f = new Array(n);
        for (let m = 0; m < n; m++) {
          const y = h * (m + w * n),
            E = g.subarray(y, y + h);
          f[m] = Vt(aO(E), i);
        }
        p[w] = f;
      }
      return p;
    }
    function hO(t, e) {
      const r = e.map((i) => Array.from(i).reverse());
      return (i, s) => {
        const [n, o, a, c] = r.map((l) =>
          l.reduce((u, h) => t.add(t.mul(u, i), h))
        );
        return (i = t.div(n, o)), (s = t.mul(s, t.div(a, c))), { x: i, y: s };
      };
    }
    function dO(t, e, r) {
      if (typeof e != "function")
        throw new Error("mapToCurve() must be defined");
      return {
        hashToCurve(i, s) {
          const n = q2(i, 2, { ...r, DST: r.DST, ...s }),
            o = t.fromAffine(e(n[0])),
            a = t.fromAffine(e(n[1])),
            c = o.add(a).clearCofactor();
          return c.assertValidity(), c;
        },
        encodeToCurve(i, s) {
          const n = q2(i, 1, { ...r, DST: r.encodeDST, ...s }),
            o = t.fromAffine(e(n[0])).clearCofactor();
          return o.assertValidity(), o;
        },
        mapToCurve(i) {
          if (!Array.isArray(i))
            throw new Error("mapToCurve: expected array of bigints");
          for (const n of i)
            if (typeof n != "bigint")
              throw new Error("mapToCurve: expected array of bigints");
          const s = t.fromAffine(e(i)).clearCofactor();
          return s.assertValidity(), s;
        },
      };
    }
    const au = BigInt(
        "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"
      ),
      tp = BigInt(
        "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
      ),
      cu = BigInt(1),
      rp = BigInt(2),
      H2 = (t, e) => (t + e / rp) / e;
    function V2(t) {
      const e = au,
        r = BigInt(3),
        i = BigInt(6),
        s = BigInt(11),
        n = BigInt(22),
        o = BigInt(23),
        a = BigInt(44),
        c = BigInt(88),
        l = (t * t * t) % e,
        u = (l * l * t) % e,
        h = (Ni(u, r, e) * u) % e,
        d = (Ni(h, r, e) * u) % e,
        g = (Ni(d, rp, e) * l) % e,
        p = (Ni(g, s, e) * g) % e,
        w = (Ni(p, n, e) * p) % e,
        f = (Ni(w, a, e) * w) % e,
        m = (Ni(f, c, e) * f) % e,
        y = (Ni(m, a, e) * w) % e,
        E = (Ni(y, r, e) * u) % e,
        C = (Ni(E, o, e) * p) % e,
        O = (Ni(C, i, e) * l) % e,
        A = Ni(O, rp, e);
      if (!Mn.eql(Mn.sqr(A), t)) throw new Error("Cannot find square root");
      return A;
    }
    const Mn = $2(au, void 0, void 0, { sqrt: V2 }),
      lu = oO(
        {
          a: BigInt(0),
          b: BigInt(7),
          Fp: Mn,
          n: tp,
          Gx: BigInt(
            "55066263022277343669578718895168534326250603453777594175500187360389116729240"
          ),
          Gy: BigInt(
            "32670510020758816978083085130507043184471273380659243275938904335757337482424"
          ),
          h: BigInt(1),
          lowS: !0,
          endo: {
            beta: BigInt(
              "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"
            ),
            splitScalar: (t) => {
              const e = tp,
                r = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                i = -cu * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                s = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
                n = r,
                o = BigInt("0x100000000000000000000000000000000"),
                a = H2(n * t, e),
                c = H2(-i * t, e);
              let l = Vt(t - a * r - c * s, e),
                u = Vt(-a * i - c * n, e);
              const h = l > o,
                d = u > o;
              if ((h && (l = e - l), d && (u = e - u), l > o || u > o))
                throw new Error("splitScalar: Endomorphism failed, k=" + t);
              return { k1neg: h, k1: l, k2neg: d, k2: u };
            },
          },
        },
        nu
      ),
      W2 = BigInt(0),
      K2 = {};
    function ip(t, ...e) {
      let r = K2[t];
      if (r === void 0) {
        const i = nu(Uint8Array.from(t, (s) => s.charCodeAt(0)));
        (r = si(i, i)), (K2[t] = r);
      }
      return nu(si(r, ...e));
    }
    const $g = (t) => t.toRawBytes(!0).slice(1),
      Fg = (t) => Ln(t, 32),
      Bg = (t) => Vt(t, au),
      uu = (t) => Vt(t, tp),
      Lg = lu.ProjectivePoint,
      pO = (t, e, r) => Lg.BASE.multiplyAndAddUnsafe(t, e, r);
    function Ug(t) {
      let e = lu.utils.normPrivateKeyToScalar(t),
        r = Lg.fromPrivateKey(e);
      return { scalar: r.hasEvenY() ? e : uu(-e), bytes: $g(r) };
    }
    function G2(t) {
      Un("x", t, cu, au);
      const e = Bg(t * t),
        r = Bg(e * t + BigInt(7));
      let i = V2(r);
      i % rp !== W2 && (i = Bg(-i));
      const s = new Lg(t, i, cu);
      return s.assertValidity(), s;
    }
    const ic = ms;
    function Z2(...t) {
      return uu(ic(ip("BIP0340/challenge", ...t)));
    }
    function fO(t) {
      return Ug(t).bytes;
    }
    function gO(t, e, r = o2(32)) {
      const i = _r("message", t),
        { bytes: s, scalar: n } = Ug(e),
        o = _r("auxRand", r, 32),
        a = Fg(n ^ ic(ip("BIP0340/aux", o))),
        c = ip("BIP0340/nonce", a, s, i),
        l = uu(ic(c));
      if (l === W2) throw new Error("sign failed: k is zero");
      const { bytes: u, scalar: h } = Ug(l),
        d = Z2(u, s, i),
        g = new Uint8Array(64);
      if ((g.set(u, 0), g.set(Fg(uu(h + d * n)), 32), !Y2(g, i, s)))
        throw new Error("sign: Invalid signature produced");
      return g;
    }
    function Y2(t, e, r) {
      const i = _r("signature", t, 64),
        s = _r("message", e),
        n = _r("publicKey", r, 32);
      try {
        const o = G2(ic(n)),
          a = ic(i.subarray(0, 32));
        if (!tc(a, cu, au)) return !1;
        const c = ic(i.subarray(32, 64));
        if (!tc(c, cu, tp)) return !1;
        const l = Z2(Fg(a), $g(o), s),
          u = pO(o, c, uu(-l));
        return !(!u || !u.hasEvenY() || u.toAffine().x !== a);
      } catch {
        return !1;
      }
    }
    const wO = {
        getPublicKey: fO,
        sign: gO,
        verify: Y2,
        utils: {
          randomPrivateKey: lu.utils.randomPrivateKey,
          lift_x: G2,
          pointToBytes: $g,
          numberToBytesBE: Ln,
          bytesToNumberBE: ms,
          taggedHash: ip,
          mod: Vt,
        },
      },
      mO = hO(
        Mn,
        [
          [
            "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
            "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
            "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
            "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c",
          ],
          [
            "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
            "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
            "0x0000000000000000000000000000000000000000000000000000000000000001",
          ],
          [
            "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
            "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
            "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
            "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84",
          ],
          [
            "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
            "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
            "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
            "0x0000000000000000000000000000000000000000000000000000000000000001",
          ],
        ].map((t) => t.map((e) => BigInt(e)))
      ),
      yO = sO(Mn, {
        A: BigInt(
          "0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"
        ),
        B: BigInt("1771"),
        Z: Mn.create(BigInt("-11")),
      }),
      J2 = dO(
        lu.ProjectivePoint,
        (t) => {
          const { x: e, y: r } = yO(Mn.create(t[0]));
          return mO(e, r);
        },
        {
          DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
          encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
          p: Mn.ORDER,
          m: 1,
          k: 128,
          expand: "xmd",
          hash: nu,
        }
      );
    var X2 = Object.freeze({
      __proto__: null,
      secp256k1: lu,
      schnorr: wO,
      hashToCurve: J2.hashToCurve,
      encodeToCurve: J2.encodeToCurve,
    });
    function bO(t) {
      if (t.length >= 255) throw new TypeError("Alphabet too long");
      const e = new Uint8Array(256);
      for (let l = 0; l < e.length; l++) e[l] = 255;
      for (let l = 0; l < t.length; l++) {
        const u = t.charAt(l),
          h = u.charCodeAt(0);
        if (e[h] !== 255) throw new TypeError(u + " is ambiguous");
        e[h] = l;
      }
      const r = t.length,
        i = t.charAt(0),
        s = Math.log(r) / Math.log(256),
        n = Math.log(256) / Math.log(r);
      function o(l) {
        if (
          (l instanceof Uint8Array ||
            (ArrayBuffer.isView(l)
              ? (l = new Uint8Array(l.buffer, l.byteOffset, l.byteLength))
              : Array.isArray(l) && (l = Uint8Array.from(l))),
          !(l instanceof Uint8Array))
        )
          throw new TypeError("Expected Uint8Array");
        if (l.length === 0) return "";
        let u = 0,
          h = 0,
          d = 0;
        const g = l.length;
        for (; d !== g && l[d] === 0; ) d++, u++;
        const p = ((g - d) * n + 1) >>> 0,
          w = new Uint8Array(p);
        for (; d !== g; ) {
          let y = l[d],
            E = 0;
          for (let C = p - 1; (y !== 0 || E < h) && C !== -1; C--, E++)
            (y += (256 * w[C]) >>> 0),
              (w[C] = y % r >>> 0),
              (y = (y / r) >>> 0);
          if (y !== 0) throw new Error("Non-zero carry");
          (h = E), d++;
        }
        let f = p - h;
        for (; f !== p && w[f] === 0; ) f++;
        let m = i.repeat(u);
        for (; f < p; ++f) m += t.charAt(w[f]);
        return m;
      }
      function a(l) {
        if (typeof l != "string") throw new TypeError("Expected String");
        if (l.length === 0) return new Uint8Array();
        let u = 0,
          h = 0,
          d = 0;
        for (; l[u] === i; ) h++, u++;
        const g = ((l.length - u) * s + 1) >>> 0,
          p = new Uint8Array(g);
        for (; u < l.length; ) {
          const y = l.charCodeAt(u);
          if (y > 255) return;
          let E = e[y];
          if (E === 255) return;
          let C = 0;
          for (let O = g - 1; (E !== 0 || C < d) && O !== -1; O--, C++)
            (E += (r * p[O]) >>> 0),
              (p[O] = E % 256 >>> 0),
              (E = (E / 256) >>> 0);
          if (E !== 0) throw new Error("Non-zero carry");
          (d = C), u++;
        }
        let w = g - d;
        for (; w !== g && p[w] === 0; ) w++;
        const f = new Uint8Array(h + (g - w));
        let m = h;
        for (; w !== g; ) f[m++] = p[w++];
        return f;
      }
      function c(l) {
        const u = a(l);
        if (u) return u;
        throw new Error("Non-base" + r + " character");
      }
      return { encode: o, decodeUnsafe: a, decode: c };
    }
    var vO = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
      Dg = bO(vO);
    const EO = (t) =>
        JSON.stringify(t, (e, r) =>
          typeof r == "bigint" ? r.toString() + "n" : r
        ),
      CO = (t) => {
        const e =
            /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g,
          r = t.replace(e, '$1"$2n"$3');
        return JSON.parse(r, (i, s) =>
          typeof s == "string" && s.match(/^\d+n$/)
            ? BigInt(s.substring(0, s.length - 1))
            : s
        );
      };
    function Ws(t) {
      if (typeof t != "string")
        throw new Error(`Cannot safe json parse value of type ${typeof t}`);
      try {
        return CO(t);
      } catch {
        return t;
      }
    }
    function ys(t) {
      return typeof t == "string" ? t : EO(t) || "";
    }
    function xO(t) {
      return (
        t instanceof Uint8Array ||
        (ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array")
      );
    }
    function Q2(t, ...e) {
      if (!xO(t)) throw new Error("Uint8Array expected");
      if (e.length > 0 && !e.includes(t.length))
        throw new Error(
          "Uint8Array expected of length " + e + ", got length=" + t.length
        );
    }
    function e3(t, e = !0) {
      if (t.destroyed) throw new Error("Hash instance has been destroyed");
      if (e && t.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function IO(t, e) {
      Q2(t);
      const r = e.outputLen;
      if (t.length < r)
        throw new Error(
          "digestInto() expects output buffer of length at least " + r
        );
    }
    const sc =
      typeof globalThis == "object" && "crypto" in globalThis
        ? globalThis.crypto
        : void 0;
    /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const jg =
      (t) => new DataView(t.buffer, t.byteOffset, t.byteLength);
    function _O(t) {
      if (typeof t != "string")
        throw new Error("utf8ToBytes expected string, got " + typeof t);
      return new Uint8Array(new TextEncoder().encode(t));
    }
    function t3(t) {
      return typeof t == "string" && (t = _O(t)), Q2(t), t;
    }
    class AO {
      clone() {
        return this._cloneInto();
      }
    }
    function SO(t) {
      const e = (i) => t().update(t3(i)).digest(),
        r = t();
      return (
        (e.outputLen = r.outputLen),
        (e.blockLen = r.blockLen),
        (e.create = () => t()),
        e
      );
    }
    function r3(t = 32) {
      if (sc && typeof sc.getRandomValues == "function")
        return sc.getRandomValues(new Uint8Array(t));
      if (sc && typeof sc.randomBytes == "function") return sc.randomBytes(t);
      throw new Error("crypto.getRandomValues must be defined");
    }
    function PO(t, e, r, i) {
      if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, r, i);
      const s = BigInt(32),
        n = BigInt(4294967295),
        o = Number((r >> s) & n),
        a = Number(r & n),
        c = i ? 4 : 0,
        l = i ? 0 : 4;
      t.setUint32(e + c, o, i), t.setUint32(e + l, a, i);
    }
    class OO extends AO {
      constructor(e, r, i, s) {
        super(),
          (this.blockLen = e),
          (this.outputLen = r),
          (this.padOffset = i),
          (this.isLE = s),
          (this.finished = !1),
          (this.length = 0),
          (this.pos = 0),
          (this.destroyed = !1),
          (this.buffer = new Uint8Array(e)),
          (this.view = jg(this.buffer));
      }
      update(e) {
        e3(this);
        const { view: r, buffer: i, blockLen: s } = this;
        e = t3(e);
        const n = e.length;
        for (let o = 0; o < n; ) {
          const a = Math.min(s - this.pos, n - o);
          if (a === s) {
            const c = jg(e);
            for (; s <= n - o; o += s) this.process(c, o);
            continue;
          }
          i.set(e.subarray(o, o + a), this.pos),
            (this.pos += a),
            (o += a),
            this.pos === s && (this.process(r, 0), (this.pos = 0));
        }
        return (this.length += e.length), this.roundClean(), this;
      }
      digestInto(e) {
        e3(this), IO(e, this), (this.finished = !0);
        const { buffer: r, view: i, blockLen: s, isLE: n } = this;
        let { pos: o } = this;
        (r[o++] = 128),
          this.buffer.subarray(o).fill(0),
          this.padOffset > s - o && (this.process(i, 0), (o = 0));
        for (let h = o; h < s; h++) r[h] = 0;
        PO(i, s - 8, BigInt(this.length * 8), n), this.process(i, 0);
        const a = jg(e),
          c = this.outputLen;
        if (c % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const l = c / 4,
          u = this.get();
        if (l > u.length) throw new Error("_sha2: outputLen bigger than state");
        for (let h = 0; h < l; h++) a.setUint32(4 * h, u[h], n);
      }
      digest() {
        const { buffer: e, outputLen: r } = this;
        this.digestInto(e);
        const i = e.slice(0, r);
        return this.destroy(), i;
      }
      _cloneInto(e) {
        e || (e = new this.constructor()), e.set(...this.get());
        const {
          blockLen: r,
          buffer: i,
          length: s,
          finished: n,
          destroyed: o,
          pos: a,
        } = this;
        return (
          (e.length = s),
          (e.pos = a),
          (e.finished = n),
          (e.destroyed = o),
          s % r && e.buffer.set(i),
          e
        );
      }
    }
    const sp = BigInt(2 ** 32 - 1),
      Mg = BigInt(32);
    function i3(t, e = !1) {
      return e
        ? { h: Number(t & sp), l: Number((t >> Mg) & sp) }
        : { h: Number((t >> Mg) & sp) | 0, l: Number(t & sp) | 0 };
    }
    function NO(t, e = !1) {
      let r = new Uint32Array(t.length),
        i = new Uint32Array(t.length);
      for (let s = 0; s < t.length; s++) {
        const { h: n, l: o } = i3(t[s], e);
        [r[s], i[s]] = [n, o];
      }
      return [r, i];
    }
    const TO = (t, e) => (BigInt(t >>> 0) << Mg) | BigInt(e >>> 0),
      kO = (t, e, r) => t >>> r,
      RO = (t, e, r) => (t << (32 - r)) | (e >>> r),
      $O = (t, e, r) => (t >>> r) | (e << (32 - r)),
      FO = (t, e, r) => (t << (32 - r)) | (e >>> r),
      BO = (t, e, r) => (t << (64 - r)) | (e >>> (r - 32)),
      LO = (t, e, r) => (t >>> (r - 32)) | (e << (64 - r)),
      UO = (t, e) => e,
      DO = (t, e) => t,
      jO = (t, e, r) => (t << r) | (e >>> (32 - r)),
      MO = (t, e, r) => (e << r) | (t >>> (32 - r)),
      zO = (t, e, r) => (e << (r - 32)) | (t >>> (64 - r)),
      qO = (t, e, r) => (t << (r - 32)) | (e >>> (64 - r));
    function HO(t, e, r, i) {
      const s = (e >>> 0) + (i >>> 0);
      return { h: (t + r + ((s / 2 ** 32) | 0)) | 0, l: s | 0 };
    }
    const VO = (t, e, r) => (t >>> 0) + (e >>> 0) + (r >>> 0),
      WO = (t, e, r, i) => (e + r + i + ((t / 2 ** 32) | 0)) | 0,
      KO = (t, e, r, i) => (t >>> 0) + (e >>> 0) + (r >>> 0) + (i >>> 0),
      GO = (t, e, r, i, s) => (e + r + i + s + ((t / 2 ** 32) | 0)) | 0,
      ZO = (t, e, r, i, s) =>
        (t >>> 0) + (e >>> 0) + (r >>> 0) + (i >>> 0) + (s >>> 0),
      YO = (t, e, r, i, s, n) => (e + r + i + s + n + ((t / 2 ** 32) | 0)) | 0,
      _e = {
        fromBig: i3,
        split: NO,
        toBig: TO,
        shrSH: kO,
        shrSL: RO,
        rotrSH: $O,
        rotrSL: FO,
        rotrBH: BO,
        rotrBL: LO,
        rotr32H: UO,
        rotr32L: DO,
        rotlSH: jO,
        rotlSL: MO,
        rotlBH: zO,
        rotlBL: qO,
        add: HO,
        add3L: VO,
        add3H: WO,
        add4L: KO,
        add4H: GO,
        add5H: YO,
        add5L: ZO,
      },
      [JO, XO] = _e.split(
        [
          "0x428a2f98d728ae22",
          "0x7137449123ef65cd",
          "0xb5c0fbcfec4d3b2f",
          "0xe9b5dba58189dbbc",
          "0x3956c25bf348b538",
          "0x59f111f1b605d019",
          "0x923f82a4af194f9b",
          "0xab1c5ed5da6d8118",
          "0xd807aa98a3030242",
          "0x12835b0145706fbe",
          "0x243185be4ee4b28c",
          "0x550c7dc3d5ffb4e2",
          "0x72be5d74f27b896f",
          "0x80deb1fe3b1696b1",
          "0x9bdc06a725c71235",
          "0xc19bf174cf692694",
          "0xe49b69c19ef14ad2",
          "0xefbe4786384f25e3",
          "0x0fc19dc68b8cd5b5",
          "0x240ca1cc77ac9c65",
          "0x2de92c6f592b0275",
          "0x4a7484aa6ea6e483",
          "0x5cb0a9dcbd41fbd4",
          "0x76f988da831153b5",
          "0x983e5152ee66dfab",
          "0xa831c66d2db43210",
          "0xb00327c898fb213f",
          "0xbf597fc7beef0ee4",
          "0xc6e00bf33da88fc2",
          "0xd5a79147930aa725",
          "0x06ca6351e003826f",
          "0x142929670a0e6e70",
          "0x27b70a8546d22ffc",
          "0x2e1b21385c26c926",
          "0x4d2c6dfc5ac42aed",
          "0x53380d139d95b3df",
          "0x650a73548baf63de",
          "0x766a0abb3c77b2a8",
          "0x81c2c92e47edaee6",
          "0x92722c851482353b",
          "0xa2bfe8a14cf10364",
          "0xa81a664bbc423001",
          "0xc24b8b70d0f89791",
          "0xc76c51a30654be30",
          "0xd192e819d6ef5218",
          "0xd69906245565a910",
          "0xf40e35855771202a",
          "0x106aa07032bbd1b8",
          "0x19a4c116b8d2d0c8",
          "0x1e376c085141ab53",
          "0x2748774cdf8eeb99",
          "0x34b0bcb5e19b48a8",
          "0x391c0cb3c5c95a63",
          "0x4ed8aa4ae3418acb",
          "0x5b9cca4f7763e373",
          "0x682e6ff3d6b2b8a3",
          "0x748f82ee5defb2fc",
          "0x78a5636f43172f60",
          "0x84c87814a1f0ab72",
          "0x8cc702081a6439ec",
          "0x90befffa23631e28",
          "0xa4506cebde82bde9",
          "0xbef9a3f7b2c67915",
          "0xc67178f2e372532b",
          "0xca273eceea26619c",
          "0xd186b8c721c0c207",
          "0xeada7dd6cde0eb1e",
          "0xf57d4f7fee6ed178",
          "0x06f067aa72176fba",
          "0x0a637dc5a2c898a6",
          "0x113f9804bef90dae",
          "0x1b710b35131c471b",
          "0x28db77f523047d84",
          "0x32caab7b40c72493",
          "0x3c9ebe0a15c9bebc",
          "0x431d67c49c100d4c",
          "0x4cc5d4becb3e42b6",
          "0x597f299cfc657e2a",
          "0x5fcb6fab3ad6faec",
          "0x6c44198c4a475817",
        ].map((t) => BigInt(t))
      ),
      zn = new Uint32Array(80),
      qn = new Uint32Array(80);
    class QO extends OO {
      constructor() {
        super(128, 64, 16, !1),
          (this.Ah = 1779033703),
          (this.Al = -205731576),
          (this.Bh = -1150833019),
          (this.Bl = -2067093701),
          (this.Ch = 1013904242),
          (this.Cl = -23791573),
          (this.Dh = -1521486534),
          (this.Dl = 1595750129),
          (this.Eh = 1359893119),
          (this.El = -1377402159),
          (this.Fh = -1694144372),
          (this.Fl = 725511199),
          (this.Gh = 528734635),
          (this.Gl = -79577749),
          (this.Hh = 1541459225),
          (this.Hl = 327033209);
      }
      get() {
        const {
          Ah: e,
          Al: r,
          Bh: i,
          Bl: s,
          Ch: n,
          Cl: o,
          Dh: a,
          Dl: c,
          Eh: l,
          El: u,
          Fh: h,
          Fl: d,
          Gh: g,
          Gl: p,
          Hh: w,
          Hl: f,
        } = this;
        return [e, r, i, s, n, o, a, c, l, u, h, d, g, p, w, f];
      }
      set(e, r, i, s, n, o, a, c, l, u, h, d, g, p, w, f) {
        (this.Ah = e | 0),
          (this.Al = r | 0),
          (this.Bh = i | 0),
          (this.Bl = s | 0),
          (this.Ch = n | 0),
          (this.Cl = o | 0),
          (this.Dh = a | 0),
          (this.Dl = c | 0),
          (this.Eh = l | 0),
          (this.El = u | 0),
          (this.Fh = h | 0),
          (this.Fl = d | 0),
          (this.Gh = g | 0),
          (this.Gl = p | 0),
          (this.Hh = w | 0),
          (this.Hl = f | 0);
      }
      process(e, r) {
        for (let E = 0; E < 16; E++, r += 4)
          (zn[E] = e.getUint32(r)), (qn[E] = e.getUint32((r += 4)));
        for (let E = 16; E < 80; E++) {
          const C = zn[E - 15] | 0,
            O = qn[E - 15] | 0,
            A = _e.rotrSH(C, O, 1) ^ _e.rotrSH(C, O, 8) ^ _e.shrSH(C, O, 7),
            P = _e.rotrSL(C, O, 1) ^ _e.rotrSL(C, O, 8) ^ _e.shrSL(C, O, 7),
            N = zn[E - 2] | 0,
            x = qn[E - 2] | 0,
            $ = _e.rotrSH(N, x, 19) ^ _e.rotrBH(N, x, 61) ^ _e.shrSH(N, x, 6),
            k = _e.rotrSL(N, x, 19) ^ _e.rotrBL(N, x, 61) ^ _e.shrSL(N, x, 6),
            F = _e.add4L(P, k, qn[E - 7], qn[E - 16]),
            j = _e.add4H(F, A, $, zn[E - 7], zn[E - 16]);
          (zn[E] = j | 0), (qn[E] = F | 0);
        }
        let {
          Ah: i,
          Al: s,
          Bh: n,
          Bl: o,
          Ch: a,
          Cl: c,
          Dh: l,
          Dl: u,
          Eh: h,
          El: d,
          Fh: g,
          Fl: p,
          Gh: w,
          Gl: f,
          Hh: m,
          Hl: y,
        } = this;
        for (let E = 0; E < 80; E++) {
          const C =
              _e.rotrSH(h, d, 14) ^ _e.rotrSH(h, d, 18) ^ _e.rotrBH(h, d, 41),
            O = _e.rotrSL(h, d, 14) ^ _e.rotrSL(h, d, 18) ^ _e.rotrBL(h, d, 41),
            A = (h & g) ^ (~h & w),
            P = (d & p) ^ (~d & f),
            N = _e.add5L(y, O, P, XO[E], qn[E]),
            x = _e.add5H(N, m, C, A, JO[E], zn[E]),
            $ = N | 0,
            k = _e.rotrSH(i, s, 28) ^ _e.rotrBH(i, s, 34) ^ _e.rotrBH(i, s, 39),
            F = _e.rotrSL(i, s, 28) ^ _e.rotrBL(i, s, 34) ^ _e.rotrBL(i, s, 39),
            j = (i & n) ^ (i & a) ^ (n & a),
            I = (s & o) ^ (s & c) ^ (o & c);
          (m = w | 0),
            (y = f | 0),
            (w = g | 0),
            (f = p | 0),
            (g = h | 0),
            (p = d | 0),
            ({ h, l: d } = _e.add(l | 0, u | 0, x | 0, $ | 0)),
            (l = a | 0),
            (u = c | 0),
            (a = n | 0),
            (c = o | 0),
            (n = i | 0),
            (o = s | 0);
          const b = _e.add3L($, F, I);
          (i = _e.add3H(b, x, k, j)), (s = b | 0);
        }
        ({ h: i, l: s } = _e.add(this.Ah | 0, this.Al | 0, i | 0, s | 0)),
          ({ h: n, l: o } = _e.add(this.Bh | 0, this.Bl | 0, n | 0, o | 0)),
          ({ h: a, l: c } = _e.add(this.Ch | 0, this.Cl | 0, a | 0, c | 0)),
          ({ h: l, l: u } = _e.add(this.Dh | 0, this.Dl | 0, l | 0, u | 0)),
          ({ h, l: d } = _e.add(this.Eh | 0, this.El | 0, h | 0, d | 0)),
          ({ h: g, l: p } = _e.add(this.Fh | 0, this.Fl | 0, g | 0, p | 0)),
          ({ h: w, l: f } = _e.add(this.Gh | 0, this.Gl | 0, w | 0, f | 0)),
          ({ h: m, l: y } = _e.add(this.Hh | 0, this.Hl | 0, m | 0, y | 0)),
          this.set(i, s, n, o, a, c, l, u, h, d, g, p, w, f, m, y);
      }
      roundClean() {
        zn.fill(0), qn.fill(0);
      }
      destroy() {
        this.buffer.fill(0),
          this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    }
    const eN = SO(() => new QO());
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const zg =
        BigInt(0),
      s3 = BigInt(1),
      tN = BigInt(2);
    function qg(t) {
      return (
        t instanceof Uint8Array ||
        (ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array")
      );
    }
    function Hg(t) {
      if (!qg(t)) throw new Error("Uint8Array expected");
    }
    function Vg(t, e) {
      if (typeof e != "boolean")
        throw new Error(t + " boolean expected, got " + e);
    }
    const rN = Array.from({ length: 256 }, (t, e) =>
      e.toString(16).padStart(2, "0")
    );
    function Wg(t) {
      Hg(t);
      let e = "";
      for (let r = 0; r < t.length; r++) e += rN[t[r]];
      return e;
    }
    function n3(t) {
      if (typeof t != "string")
        throw new Error("hex string expected, got " + typeof t);
      return t === "" ? zg : BigInt("0x" + t);
    }
    const Ks = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function o3(t) {
      if (t >= Ks._0 && t <= Ks._9) return t - Ks._0;
      if (t >= Ks.A && t <= Ks.F) return t - (Ks.A - 10);
      if (t >= Ks.a && t <= Ks.f) return t - (Ks.a - 10);
    }
    function a3(t) {
      if (typeof t != "string")
        throw new Error("hex string expected, got " + typeof t);
      const e = t.length,
        r = e / 2;
      if (e % 2)
        throw new Error("hex string expected, got unpadded hex of length " + e);
      const i = new Uint8Array(r);
      for (let s = 0, n = 0; s < r; s++, n += 2) {
        const o = o3(t.charCodeAt(n)),
          a = o3(t.charCodeAt(n + 1));
        if (o === void 0 || a === void 0) {
          const c = t[n] + t[n + 1];
          throw new Error(
            'hex string expected, got non-hex character "' +
              c +
              '" at index ' +
              n
          );
        }
        i[s] = o * 16 + a;
      }
      return i;
    }
    function iN(t) {
      return n3(Wg(t));
    }
    function np(t) {
      return Hg(t), n3(Wg(Uint8Array.from(t).reverse()));
    }
    function c3(t, e) {
      return a3(t.toString(16).padStart(e * 2, "0"));
    }
    function Kg(t, e) {
      return c3(t, e).reverse();
    }
    function Gs(t, e, r) {
      let i;
      if (typeof e == "string")
        try {
          i = a3(e);
        } catch (n) {
          throw new Error(t + " must be hex string or Uint8Array, cause: " + n);
        }
      else if (qg(e)) i = Uint8Array.from(e);
      else throw new Error(t + " must be hex string or Uint8Array");
      const s = i.length;
      if (typeof r == "number" && s !== r)
        throw new Error(t + " of length " + r + " expected, got " + s);
      return i;
    }
    function l3(...t) {
      let e = 0;
      for (let i = 0; i < t.length; i++) {
        const s = t[i];
        Hg(s), (e += s.length);
      }
      const r = new Uint8Array(e);
      for (let i = 0, s = 0; i < t.length; i++) {
        const n = t[i];
        r.set(n, s), (s += n.length);
      }
      return r;
    }
    const Gg = (t) => typeof t == "bigint" && zg <= t;
    function sN(t, e, r) {
      return Gg(t) && Gg(e) && Gg(r) && e <= t && t < r;
    }
    function hu(t, e, r, i) {
      if (!sN(e, r, i))
        throw new Error(
          "expected valid " + t + ": " + r + " <= n < " + i + ", got " + e
        );
    }
    function nN(t) {
      let e;
      for (e = 0; t > zg; t >>= s3, e += 1);
      return e;
    }
    const oN = (t) => (tN << BigInt(t - 1)) - s3,
      aN = {
        bigint: (t) => typeof t == "bigint",
        function: (t) => typeof t == "function",
        boolean: (t) => typeof t == "boolean",
        string: (t) => typeof t == "string",
        stringOrUint8Array: (t) => typeof t == "string" || qg(t),
        isSafeInteger: (t) => Number.isSafeInteger(t),
        array: (t) => Array.isArray(t),
        field: (t, e) => e.Fp.isValid(t),
        hash: (t) =>
          typeof t == "function" && Number.isSafeInteger(t.outputLen),
      };
    function Zg(t, e, r = {}) {
      const i = (s, n, o) => {
        const a = aN[n];
        if (typeof a != "function")
          throw new Error("invalid validator function");
        const c = t[s];
        if (!(o && c === void 0) && !a(c, t))
          throw new Error(
            "param " + String(s) + " is invalid. Expected " + n + ", got " + c
          );
      };
      for (const [s, n] of Object.entries(e)) i(s, n, !1);
      for (const [s, n] of Object.entries(r)) i(s, n, !0);
      return t;
    }
    function u3(t) {
      const e = new WeakMap();
      return (r, ...i) => {
        const s = e.get(r);
        if (s !== void 0) return s;
        const n = t(r, ...i);
        return e.set(r, n), n;
      };
    }
    const Wt = BigInt(0),
      _t = BigInt(1),
      $o = BigInt(2),
      cN = BigInt(3),
      Yg = BigInt(4),
      h3 = BigInt(5),
      d3 = BigInt(8);
    function $t(t, e) {
      const r = t % e;
      return r >= Wt ? r : e + r;
    }
    function lN(t, e, r) {
      if (e < Wt) throw new Error("invalid exponent, negatives unsupported");
      if (r <= Wt) throw new Error("invalid modulus");
      if (r === _t) return Wt;
      let i = _t;
      for (; e > Wt; )
        e & _t && (i = (i * t) % r), (t = (t * t) % r), (e >>= _t);
      return i;
    }
    function bs(t, e, r) {
      let i = t;
      for (; e-- > Wt; ) (i *= i), (i %= r);
      return i;
    }
    function p3(t, e) {
      if (t === Wt) throw new Error("invert: expected non-zero number");
      if (e <= Wt)
        throw new Error("invert: expected positive modulus, got " + e);
      let r = $t(t, e),
        i = e,
        s = Wt,
        n = _t;
      for (; r !== Wt; ) {
        const o = i / r,
          a = i % r,
          c = s - n * o;
        (i = r), (r = a), (s = n), (n = c);
      }
      if (i !== _t) throw new Error("invert: does not exist");
      return $t(s, e);
    }
    function uN(t) {
      const e = (t - _t) / $o;
      let r, i, s;
      for (r = t - _t, i = 0; r % $o === Wt; r /= $o, i++);
      for (s = $o; s < t && lN(s, e, t) !== t - _t; s++)
        if (s > 1e3)
          throw new Error("Cannot find square root: likely non-prime P");
      if (i === 1) {
        const o = (t + _t) / Yg;
        return function (a, c) {
          const l = a.pow(c, o);
          if (!a.eql(a.sqr(l), c)) throw new Error("Cannot find square root");
          return l;
        };
      }
      const n = (r + _t) / $o;
      return function (o, a) {
        if (o.pow(a, e) === o.neg(o.ONE))
          throw new Error("Cannot find square root");
        let c = i,
          l = o.pow(o.mul(o.ONE, s), r),
          u = o.pow(a, n),
          h = o.pow(a, r);
        for (; !o.eql(h, o.ONE); ) {
          if (o.eql(h, o.ZERO)) return o.ZERO;
          let d = 1;
          for (let p = o.sqr(h); d < c && !o.eql(p, o.ONE); d++) p = o.sqr(p);
          const g = o.pow(l, _t << BigInt(c - d - 1));
          (l = o.sqr(g)), (u = o.mul(u, g)), (h = o.mul(h, l)), (c = d);
        }
        return u;
      };
    }
    function hN(t) {
      if (t % Yg === cN) {
        const e = (t + _t) / Yg;
        return function (r, i) {
          const s = r.pow(i, e);
          if (!r.eql(r.sqr(s), i)) throw new Error("Cannot find square root");
          return s;
        };
      }
      if (t % d3 === h3) {
        const e = (t - h3) / d3;
        return function (r, i) {
          const s = r.mul(i, $o),
            n = r.pow(s, e),
            o = r.mul(i, n),
            a = r.mul(r.mul(o, $o), n),
            c = r.mul(o, r.sub(a, r.ONE));
          if (!r.eql(r.sqr(c), i)) throw new Error("Cannot find square root");
          return c;
        };
      }
      return uN(t);
    }
    const dN = (t, e) => ($t(t, e) & _t) === _t,
      pN = [
        "create",
        "isValid",
        "is0",
        "neg",
        "inv",
        "sqrt",
        "sqr",
        "eql",
        "add",
        "sub",
        "mul",
        "pow",
        "div",
        "addN",
        "subN",
        "mulN",
        "sqrN",
      ];
    function fN(t) {
      const e = {
          ORDER: "bigint",
          MASK: "bigint",
          BYTES: "isSafeInteger",
          BITS: "isSafeInteger",
        },
        r = pN.reduce((i, s) => ((i[s] = "function"), i), e);
      return Zg(t, r);
    }
    function gN(t, e, r) {
      if (r < Wt) throw new Error("invalid exponent, negatives unsupported");
      if (r === Wt) return t.ONE;
      if (r === _t) return e;
      let i = t.ONE,
        s = e;
      for (; r > Wt; ) r & _t && (i = t.mul(i, s)), (s = t.sqr(s)), (r >>= _t);
      return i;
    }
    function wN(t, e) {
      const r = new Array(e.length),
        i = e.reduce(
          (n, o, a) => (t.is0(o) ? n : ((r[a] = n), t.mul(n, o))),
          t.ONE
        ),
        s = t.inv(i);
      return (
        e.reduceRight(
          (n, o, a) => (t.is0(o) ? n : ((r[a] = t.mul(n, r[a])), t.mul(n, o))),
          s
        ),
        r
      );
    }
    function f3(t, e) {
      const r = e !== void 0 ? e : t.toString(2).length,
        i = Math.ceil(r / 8);
      return { nBitLength: r, nByteLength: i };
    }
    function g3(t, e, r = !1, i = {}) {
      if (t <= Wt)
        throw new Error("invalid field: expected ORDER > 0, got " + t);
      const { nBitLength: s, nByteLength: n } = f3(t, e);
      if (n > 2048)
        throw new Error("invalid field: expected ORDER of <= 2048 bytes");
      let o;
      const a = Object.freeze({
        ORDER: t,
        isLE: r,
        BITS: s,
        BYTES: n,
        MASK: oN(s),
        ZERO: Wt,
        ONE: _t,
        create: (c) => $t(c, t),
        isValid: (c) => {
          if (typeof c != "bigint")
            throw new Error(
              "invalid field element: expected bigint, got " + typeof c
            );
          return Wt <= c && c < t;
        },
        is0: (c) => c === Wt,
        isOdd: (c) => (c & _t) === _t,
        neg: (c) => $t(-c, t),
        eql: (c, l) => c === l,
        sqr: (c) => $t(c * c, t),
        add: (c, l) => $t(c + l, t),
        sub: (c, l) => $t(c - l, t),
        mul: (c, l) => $t(c * l, t),
        pow: (c, l) => gN(a, c, l),
        div: (c, l) => $t(c * p3(l, t), t),
        sqrN: (c) => c * c,
        addN: (c, l) => c + l,
        subN: (c, l) => c - l,
        mulN: (c, l) => c * l,
        inv: (c) => p3(c, t),
        sqrt: i.sqrt || ((c) => (o || (o = hN(t)), o(a, c))),
        invertBatch: (c) => wN(a, c),
        cmov: (c, l, u) => (u ? l : c),
        toBytes: (c) => (r ? Kg(c, n) : c3(c, n)),
        fromBytes: (c) => {
          if (c.length !== n)
            throw new Error(
              "Field.fromBytes: expected " + n + " bytes, got " + c.length
            );
          return r ? np(c) : iN(c);
        },
      });
      return Object.freeze(a);
    }
    const w3 = BigInt(0),
      op = BigInt(1);
    function Jg(t, e) {
      const r = e.negate();
      return t ? r : e;
    }
    function m3(t, e) {
      if (!Number.isSafeInteger(t) || t <= 0 || t > e)
        throw new Error(
          "invalid window size, expected [1.." + e + "], got W=" + t
        );
    }
    function Xg(t, e) {
      m3(t, e);
      const r = Math.ceil(e / t) + 1,
        i = 2 ** (t - 1);
      return { windows: r, windowSize: i };
    }
    function mN(t, e) {
      if (!Array.isArray(t)) throw new Error("array expected");
      t.forEach((r, i) => {
        if (!(r instanceof e)) throw new Error("invalid point at index " + i);
      });
    }
    function yN(t, e) {
      if (!Array.isArray(t)) throw new Error("array of scalars expected");
      t.forEach((r, i) => {
        if (!e.isValid(r)) throw new Error("invalid scalar at index " + i);
      });
    }
    const Qg = new WeakMap(),
      y3 = new WeakMap();
    function e1(t) {
      return y3.get(t) || 1;
    }
    function bN(t, e) {
      return {
        constTimeNegate: Jg,
        hasPrecomputes(r) {
          return e1(r) !== 1;
        },
        unsafeLadder(r, i, s = t.ZERO) {
          let n = r;
          for (; i > w3; )
            i & op && (s = s.add(n)), (n = n.double()), (i >>= op);
          return s;
        },
        precomputeWindow(r, i) {
          const { windows: s, windowSize: n } = Xg(i, e),
            o = [];
          let a = r,
            c = a;
          for (let l = 0; l < s; l++) {
            (c = a), o.push(c);
            for (let u = 1; u < n; u++) (c = c.add(a)), o.push(c);
            a = c.double();
          }
          return o;
        },
        wNAF(r, i, s) {
          const { windows: n, windowSize: o } = Xg(r, e);
          let a = t.ZERO,
            c = t.BASE;
          const l = BigInt(2 ** r - 1),
            u = 2 ** r,
            h = BigInt(r);
          for (let d = 0; d < n; d++) {
            const g = d * o;
            let p = Number(s & l);
            (s >>= h), p > o && ((p -= u), (s += op));
            const w = g,
              f = g + Math.abs(p) - 1,
              m = d % 2 !== 0,
              y = p < 0;
            p === 0 ? (c = c.add(Jg(m, i[w]))) : (a = a.add(Jg(y, i[f])));
          }
          return { p: a, f: c };
        },
        wNAFUnsafe(r, i, s, n = t.ZERO) {
          const { windows: o, windowSize: a } = Xg(r, e),
            c = BigInt(2 ** r - 1),
            l = 2 ** r,
            u = BigInt(r);
          for (let h = 0; h < o; h++) {
            const d = h * a;
            if (s === w3) break;
            let g = Number(s & c);
            if (((s >>= u), g > a && ((g -= l), (s += op)), g === 0)) continue;
            let p = i[d + Math.abs(g) - 1];
            g < 0 && (p = p.negate()), (n = n.add(p));
          }
          return n;
        },
        getPrecomputes(r, i, s) {
          let n = Qg.get(i);
          return (
            n ||
              ((n = this.precomputeWindow(i, r)), r !== 1 && Qg.set(i, s(n))),
            n
          );
        },
        wNAFCached(r, i, s) {
          const n = e1(r);
          return this.wNAF(n, this.getPrecomputes(n, r, s), i);
        },
        wNAFCachedUnsafe(r, i, s, n) {
          const o = e1(r);
          return o === 1
            ? this.unsafeLadder(r, i, n)
            : this.wNAFUnsafe(o, this.getPrecomputes(o, r, s), i, n);
        },
        setWindowSize(r, i) {
          m3(i, e), y3.set(r, i), Qg.delete(r);
        },
      };
    }
    function vN(t, e, r, i) {
      if ((mN(r, t), yN(i, e), r.length !== i.length))
        throw new Error("arrays of points and scalars must have equal length");
      const s = t.ZERO,
        n = nN(BigInt(r.length)),
        o = n > 12 ? n - 3 : n > 4 ? n - 2 : n ? 2 : 1,
        a = (1 << o) - 1,
        c = new Array(a + 1).fill(s),
        l = Math.floor((e.BITS - 1) / o) * o;
      let u = s;
      for (let h = l; h >= 0; h -= o) {
        c.fill(s);
        for (let g = 0; g < i.length; g++) {
          const p = i[g],
            w = Number((p >> BigInt(h)) & BigInt(a));
          c[w] = c[w].add(r[g]);
        }
        let d = s;
        for (let g = c.length - 1, p = s; g > 0; g--)
          (p = p.add(c[g])), (d = d.add(p));
        if (((u = u.add(d)), h !== 0))
          for (let g = 0; g < o; g++) u = u.double();
      }
      return u;
    }
    function EN(t) {
      return (
        fN(t.Fp),
        Zg(
          t,
          { n: "bigint", h: "bigint", Gx: "field", Gy: "field" },
          { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }
        ),
        Object.freeze({ ...f3(t.n, t.nBitLength), ...t, p: t.Fp.ORDER })
      );
    }
    const Yi = BigInt(0),
      qr = BigInt(1),
      ap = BigInt(2),
      CN = BigInt(8),
      xN = { zip215: !0 };
    function IN(t) {
      const e = EN(t);
      return (
        Zg(
          t,
          {
            hash: "function",
            a: "bigint",
            d: "bigint",
            randomBytes: "function",
          },
          {
            adjustScalarBytes: "function",
            domain: "function",
            uvRatio: "function",
            mapToCurve: "function",
          }
        ),
        Object.freeze({ ...e })
      );
    }
    function _N(t) {
      const e = IN(t),
        {
          Fp: r,
          n: i,
          prehash: s,
          hash: n,
          randomBytes: o,
          nByteLength: a,
          h: c,
        } = e,
        l = ap << (BigInt(a * 8) - qr),
        u = r.create,
        h = g3(e.n, e.nBitLength),
        d =
          e.uvRatio ||
          ((b, v) => {
            try {
              return { isValid: !0, value: r.sqrt(b * r.inv(v)) };
            } catch {
              return { isValid: !1, value: Yi };
            }
          }),
        g = e.adjustScalarBytes || ((b) => b),
        p =
          e.domain ||
          ((b, v, S) => {
            if ((Vg("phflag", S), v.length || S))
              throw new Error("Contexts/pre-hash are not supported");
            return b;
          });
      function w(b, v) {
        hu("coordinate " + b, v, Yi, l);
      }
      function f(b) {
        if (!(b instanceof E)) throw new Error("ExtendedPoint expected");
      }
      const m = u3((b, v) => {
          const { ex: S, ey: T, ez: _ } = b,
            R = b.is0();
          v == null && (v = R ? CN : r.inv(_));
          const U = u(S * v),
            D = u(T * v),
            H = u(_ * v);
          if (R) return { x: Yi, y: qr };
          if (H !== qr) throw new Error("invZ was invalid");
          return { x: U, y: D };
        }),
        y = u3((b) => {
          const { a: v, d: S } = e;
          if (b.is0()) throw new Error("bad point: ZERO");
          const { ex: T, ey: _, ez: R, et: U } = b,
            D = u(T * T),
            H = u(_ * _),
            q = u(R * R),
            V = u(q * q),
            Y = u(D * v),
            ae = u(q * u(Y + H)),
            re = u(V + u(S * u(D * H)));
          if (ae !== re)
            throw new Error("bad point: equation left != right (1)");
          const te = u(T * _),
            ve = u(R * U);
          if (te !== ve)
            throw new Error("bad point: equation left != right (2)");
          return !0;
        });
      class E {
        constructor(v, S, T, _) {
          (this.ex = v),
            (this.ey = S),
            (this.ez = T),
            (this.et = _),
            w("x", v),
            w("y", S),
            w("z", T),
            w("t", _),
            Object.freeze(this);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        static fromAffine(v) {
          if (v instanceof E) throw new Error("extended point not allowed");
          const { x: S, y: T } = v || {};
          return w("x", S), w("y", T), new E(S, T, qr, u(S * T));
        }
        static normalizeZ(v) {
          const S = r.invertBatch(v.map((T) => T.ez));
          return v.map((T, _) => T.toAffine(S[_])).map(E.fromAffine);
        }
        static msm(v, S) {
          return vN(E, h, v, S);
        }
        _setWindowSize(v) {
          A.setWindowSize(this, v);
        }
        assertValidity() {
          y(this);
        }
        equals(v) {
          f(v);
          const { ex: S, ey: T, ez: _ } = this,
            { ex: R, ey: U, ez: D } = v,
            H = u(S * D),
            q = u(R * _),
            V = u(T * D),
            Y = u(U * _);
          return H === q && V === Y;
        }
        is0() {
          return this.equals(E.ZERO);
        }
        negate() {
          return new E(u(-this.ex), this.ey, this.ez, u(-this.et));
        }
        double() {
          const { a: v } = e,
            { ex: S, ey: T, ez: _ } = this,
            R = u(S * S),
            U = u(T * T),
            D = u(ap * u(_ * _)),
            H = u(v * R),
            q = S + T,
            V = u(u(q * q) - R - U),
            Y = H + U,
            ae = Y - D,
            re = H - U,
            te = u(V * ae),
            ve = u(Y * re),
            Ee = u(V * re),
            Ce = u(ae * Y);
          return new E(te, ve, Ce, Ee);
        }
        add(v) {
          f(v);
          const { a: S, d: T } = e,
            { ex: _, ey: R, ez: U, et: D } = this,
            { ex: H, ey: q, ez: V, et: Y } = v;
          if (S === BigInt(-1)) {
            const K_ = u((R - _) * (q + H)),
              G_ = u((R + _) * (q - H)),
              pv = u(G_ - K_);
            if (pv === Yi) return this.double();
            const Z_ = u(U * ap * Y),
              Y_ = u(D * ap * V),
              J_ = Y_ + Z_,
              X_ = G_ + K_,
              Q_ = Y_ - Z_,
              vfe = u(J_ * pv),
              Efe = u(X_ * Q_),
              Cfe = u(J_ * Q_),
              xfe = u(pv * X_);
            return new E(vfe, Efe, xfe, Cfe);
          }
          const ae = u(_ * H),
            re = u(R * q),
            te = u(D * T * Y),
            ve = u(U * V),
            Ee = u((_ + R) * (H + q) - ae - re),
            Ce = ve - te,
            Ie = ve + te,
            mt = u(re - S * ae),
            Ir = u(Ee * Ce),
            mfe = u(Ie * mt),
            yfe = u(Ee * mt),
            bfe = u(Ce * Ie);
          return new E(Ir, mfe, bfe, yfe);
        }
        subtract(v) {
          return this.add(v.negate());
        }
        wNAF(v) {
          return A.wNAFCached(this, v, E.normalizeZ);
        }
        multiply(v) {
          const S = v;
          hu("scalar", S, qr, i);
          const { p: T, f: _ } = this.wNAF(S);
          return E.normalizeZ([T, _])[0];
        }
        multiplyUnsafe(v, S = E.ZERO) {
          const T = v;
          return (
            hu("scalar", T, Yi, i),
            T === Yi
              ? O
              : this.is0() || T === qr
              ? this
              : A.wNAFCachedUnsafe(this, T, E.normalizeZ, S)
          );
        }
        isSmallOrder() {
          return this.multiplyUnsafe(c).is0();
        }
        isTorsionFree() {
          return A.unsafeLadder(this, i).is0();
        }
        toAffine(v) {
          return m(this, v);
        }
        clearCofactor() {
          const { h: v } = e;
          return v === qr ? this : this.multiplyUnsafe(v);
        }
        static fromHex(v, S = !1) {
          const { d: T, a: _ } = e,
            R = r.BYTES;
          (v = Gs("pointHex", v, R)), Vg("zip215", S);
          const U = v.slice(),
            D = v[R - 1];
          U[R - 1] = D & -129;
          const H = np(U),
            q = S ? l : r.ORDER;
          hu("pointHex.y", H, Yi, q);
          const V = u(H * H),
            Y = u(V - qr),
            ae = u(T * V - _);
          let { isValid: re, value: te } = d(Y, ae);
          if (!re) throw new Error("Point.fromHex: invalid y coordinate");
          const ve = (te & qr) === qr,
            Ee = (D & 128) !== 0;
          if (!S && te === Yi && Ee)
            throw new Error("Point.fromHex: x=0 and x_0=1");
          return Ee !== ve && (te = u(-te)), E.fromAffine({ x: te, y: H });
        }
        static fromPrivateKey(v) {
          return x(v).point;
        }
        toRawBytes() {
          const { x: v, y: S } = this.toAffine(),
            T = Kg(S, r.BYTES);
          return (T[T.length - 1] |= v & qr ? 128 : 0), T;
        }
        toHex() {
          return Wg(this.toRawBytes());
        }
      }
      (E.BASE = new E(e.Gx, e.Gy, qr, u(e.Gx * e.Gy))),
        (E.ZERO = new E(Yi, qr, qr, Yi));
      const { BASE: C, ZERO: O } = E,
        A = bN(E, a * 8);
      function P(b) {
        return $t(b, i);
      }
      function N(b) {
        return P(np(b));
      }
      function x(b) {
        const v = r.BYTES;
        b = Gs("private key", b, v);
        const S = Gs("hashed private key", n(b), 2 * v),
          T = g(S.slice(0, v)),
          _ = S.slice(v, 2 * v),
          R = N(T),
          U = C.multiply(R),
          D = U.toRawBytes();
        return { head: T, prefix: _, scalar: R, point: U, pointBytes: D };
      }
      function $(b) {
        return x(b).pointBytes;
      }
      function k(b = new Uint8Array(), ...v) {
        const S = l3(...v);
        return N(n(p(S, Gs("context", b), !!s)));
      }
      function F(b, v, S = {}) {
        (b = Gs("message", b)), s && (b = s(b));
        const { prefix: T, scalar: _, pointBytes: R } = x(v),
          U = k(S.context, T, b),
          D = C.multiply(U).toRawBytes(),
          H = k(S.context, D, R, b),
          q = P(U + H * _);
        hu("signature.s", q, Yi, i);
        const V = l3(D, Kg(q, r.BYTES));
        return Gs("result", V, r.BYTES * 2);
      }
      const j = xN;
      function I(b, v, S, T = j) {
        const { context: _, zip215: R } = T,
          U = r.BYTES;
        (b = Gs("signature", b, 2 * U)),
          (v = Gs("message", v)),
          (S = Gs("publicKey", S, U)),
          R !== void 0 && Vg("zip215", R),
          s && (v = s(v));
        const D = np(b.slice(U, 2 * U));
        let H, q, V;
        try {
          (H = E.fromHex(S, R)),
            (q = E.fromHex(b.slice(0, U), R)),
            (V = C.multiplyUnsafe(D));
        } catch {
          return !1;
        }
        if (!R && H.isSmallOrder()) return !1;
        const Y = k(_, q.toRawBytes(), H.toRawBytes(), v);
        return q
          .add(H.multiplyUnsafe(Y))
          .subtract(V)
          .clearCofactor()
          .equals(E.ZERO);
      }
      return (
        C._setWindowSize(8),
        {
          CURVE: e,
          getPublicKey: $,
          sign: F,
          verify: I,
          ExtendedPoint: E,
          utils: {
            getExtendedPublicKey: x,
            randomPrivateKey: () => o(r.BYTES),
            precompute(b = 8, v = E.BASE) {
              return v._setWindowSize(b), v.multiply(BigInt(3)), v;
            },
          },
        }
      );
    }
    BigInt(0), BigInt(1);
    const t1 = BigInt(
        "57896044618658097711785492504343953926634992332820282019728792003956564819949"
      ),
      b3 = BigInt(
        "19681161376707505956807079304988542015446066515923890162744021073123829784752"
      );
    BigInt(0);
    const AN = BigInt(1),
      v3 = BigInt(2);
    BigInt(3);
    const SN = BigInt(5),
      PN = BigInt(8);
    function ON(t) {
      const e = BigInt(10),
        r = BigInt(20),
        i = BigInt(40),
        s = BigInt(80),
        n = t1,
        o = (((t * t) % n) * t) % n,
        a = (bs(o, v3, n) * o) % n,
        c = (bs(a, AN, n) * t) % n,
        l = (bs(c, SN, n) * c) % n,
        u = (bs(l, e, n) * l) % n,
        h = (bs(u, r, n) * u) % n,
        d = (bs(h, i, n) * h) % n,
        g = (bs(d, s, n) * d) % n,
        p = (bs(g, s, n) * d) % n,
        w = (bs(p, e, n) * l) % n;
      return { pow_p_5_8: (bs(w, v3, n) * t) % n, b2: o };
    }
    function NN(t) {
      return (t[0] &= 248), (t[31] &= 127), (t[31] |= 64), t;
    }
    function TN(t, e) {
      const r = t1,
        i = $t(e * e * e, r),
        s = $t(i * i * e, r),
        n = ON(t * s).pow_p_5_8;
      let o = $t(t * i * n, r);
      const a = $t(e * o * o, r),
        c = o,
        l = $t(o * b3, r),
        u = a === t,
        h = a === $t(-t, r),
        d = a === $t(-t * b3, r);
      return (
        u && (o = c),
        (h || d) && (o = l),
        dN(o, r) && (o = $t(-o, r)),
        { isValid: u || h, value: o }
      );
    }
    const kN = g3(t1, void 0, !0),
      RN = {
        a: BigInt(-1),
        d: BigInt(
          "37095705934669439343138083508754565189542113879843219016388785533085940283555"
        ),
        Fp: kN,
        n: BigInt(
          "7237005577332262213973186563042994240857116359379907606001950938285454250989"
        ),
        h: PN,
        Gx: BigInt(
          "15112221349535400772501151409588531511454012693041857206046113283949847762202"
        ),
        Gy: BigInt(
          "46316835694926478169428394003475163141307993866256225615783033603165251855960"
        ),
        hash: eN,
        randomBytes: r3,
        adjustScalarBytes: NN,
        uvRatio: TN,
      },
      E3 = _N(RN),
      $N = "EdDSA",
      FN = "JWT",
      cp = ".",
      lp = "base64url",
      C3 = "utf8",
      x3 = "utf8",
      BN = ":",
      LN = "did",
      UN = "key",
      I3 = "base58btc",
      DN = "z",
      jN = "K36",
      MN = 32;
    function r1(t) {
      return globalThis.Buffer != null
        ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength)
        : t;
    }
    function _3(t = 0) {
      return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null
        ? r1(globalThis.Buffer.allocUnsafe(t))
        : new Uint8Array(t);
    }
    function A3(t, e) {
      e || (e = t.reduce((s, n) => s + n.length, 0));
      const r = _3(e);
      let i = 0;
      for (const s of t) r.set(s, i), (i += s.length);
      return r1(r);
    }
    function zN(t, e) {
      if (t.length >= 255) throw new TypeError("Alphabet too long");
      for (var r = new Uint8Array(256), i = 0; i < r.length; i++) r[i] = 255;
      for (var s = 0; s < t.length; s++) {
        var n = t.charAt(s),
          o = n.charCodeAt(0);
        if (r[o] !== 255) throw new TypeError(n + " is ambiguous");
        r[o] = s;
      }
      var a = t.length,
        c = t.charAt(0),
        l = Math.log(a) / Math.log(256),
        u = Math.log(256) / Math.log(a);
      function h(p) {
        if (
          (p instanceof Uint8Array ||
            (ArrayBuffer.isView(p)
              ? (p = new Uint8Array(p.buffer, p.byteOffset, p.byteLength))
              : Array.isArray(p) && (p = Uint8Array.from(p))),
          !(p instanceof Uint8Array))
        )
          throw new TypeError("Expected Uint8Array");
        if (p.length === 0) return "";
        for (var w = 0, f = 0, m = 0, y = p.length; m !== y && p[m] === 0; )
          m++, w++;
        for (
          var E = ((y - m) * u + 1) >>> 0, C = new Uint8Array(E);
          m !== y;

        ) {
          for (
            var O = p[m], A = 0, P = E - 1;
            (O !== 0 || A < f) && P !== -1;
            P--, A++
          )
            (O += (256 * C[P]) >>> 0),
              (C[P] = O % a >>> 0),
              (O = (O / a) >>> 0);
          if (O !== 0) throw new Error("Non-zero carry");
          (f = A), m++;
        }
        for (var N = E - f; N !== E && C[N] === 0; ) N++;
        for (var x = c.repeat(w); N < E; ++N) x += t.charAt(C[N]);
        return x;
      }
      function d(p) {
        if (typeof p != "string") throw new TypeError("Expected String");
        if (p.length === 0) return new Uint8Array();
        var w = 0;
        if (p[w] !== " ") {
          for (var f = 0, m = 0; p[w] === c; ) f++, w++;
          for (
            var y = ((p.length - w) * l + 1) >>> 0, E = new Uint8Array(y);
            p[w];

          ) {
            var C = r[p.charCodeAt(w)];
            if (C === 255) return;
            for (var O = 0, A = y - 1; (C !== 0 || O < m) && A !== -1; A--, O++)
              (C += (a * E[A]) >>> 0),
                (E[A] = C % 256 >>> 0),
                (C = (C / 256) >>> 0);
            if (C !== 0) throw new Error("Non-zero carry");
            (m = O), w++;
          }
          if (p[w] !== " ") {
            for (var P = y - m; P !== y && E[P] === 0; ) P++;
            for (var N = new Uint8Array(f + (y - P)), x = f; P !== y; )
              N[x++] = E[P++];
            return N;
          }
        }
      }
      function g(p) {
        var w = d(p);
        if (w) return w;
        throw new Error(`Non-${e} character`);
      }
      return { encode: h, decodeUnsafe: d, decode: g };
    }
    var qN = zN,
      HN = qN;
    const S3 = (t) => {
        if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
          return t;
        if (t instanceof ArrayBuffer) return new Uint8Array(t);
        if (ArrayBuffer.isView(t))
          return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
        throw new Error("Unknown type, must be binary type");
      },
      VN = (t) => new TextEncoder().encode(t),
      WN = (t) => new TextDecoder().decode(t);
    class KN {
      constructor(e, r, i) {
        (this.name = e), (this.prefix = r), (this.baseEncode = i);
      }
      encode(e) {
        if (e instanceof Uint8Array)
          return `${this.prefix}${this.baseEncode(e)}`;
        throw Error("Unknown type, must be binary type");
      }
    }
    class GN {
      constructor(e, r, i) {
        if (((this.name = e), (this.prefix = r), r.codePointAt(0) === void 0))
          throw new Error("Invalid prefix character");
        (this.prefixCodePoint = r.codePointAt(0)), (this.baseDecode = i);
      }
      decode(e) {
        if (typeof e == "string") {
          if (e.codePointAt(0) !== this.prefixCodePoint)
            throw Error(
              `Unable to decode multibase string ${JSON.stringify(e)}, ${
                this.name
              } decoder only supports inputs prefixed with ${this.prefix}`
            );
          return this.baseDecode(e.slice(this.prefix.length));
        } else throw Error("Can only multibase decode strings");
      }
      or(e) {
        return P3(this, e);
      }
    }
    class ZN {
      constructor(e) {
        this.decoders = e;
      }
      or(e) {
        return P3(this, e);
      }
      decode(e) {
        const r = e[0],
          i = this.decoders[r];
        if (i) return i.decode(e);
        throw RangeError(
          `Unable to decode multibase string ${JSON.stringify(
            e
          )}, only inputs prefixed with ${Object.keys(
            this.decoders
          )} are supported`
        );
      }
    }
    const P3 = (t, e) =>
      new ZN({
        ...(t.decoders || { [t.prefix]: t }),
        ...(e.decoders || { [e.prefix]: e }),
      });
    class YN {
      constructor(e, r, i, s) {
        (this.name = e),
          (this.prefix = r),
          (this.baseEncode = i),
          (this.baseDecode = s),
          (this.encoder = new KN(e, r, i)),
          (this.decoder = new GN(e, r, s));
      }
      encode(e) {
        return this.encoder.encode(e);
      }
      decode(e) {
        return this.decoder.decode(e);
      }
    }
    const up = ({ name: t, prefix: e, encode: r, decode: i }) =>
        new YN(t, e, r, i),
      du = ({ prefix: t, name: e, alphabet: r }) => {
        const { encode: i, decode: s } = HN(r, e);
        return up({ prefix: t, name: e, encode: i, decode: (n) => S3(s(n)) });
      },
      JN = (t, e, r, i) => {
        const s = {};
        for (let u = 0; u < e.length; ++u) s[e[u]] = u;
        let n = t.length;
        for (; t[n - 1] === "="; ) --n;
        const o = new Uint8Array(((n * r) / 8) | 0);
        let a = 0,
          c = 0,
          l = 0;
        for (let u = 0; u < n; ++u) {
          const h = s[t[u]];
          if (h === void 0) throw new SyntaxError(`Non-${i} character`);
          (c = (c << r) | h),
            (a += r),
            a >= 8 && ((a -= 8), (o[l++] = 255 & (c >> a)));
        }
        if (a >= r || 255 & (c << (8 - a)))
          throw new SyntaxError("Unexpected end of data");
        return o;
      },
      XN = (t, e, r) => {
        const i = e[e.length - 1] === "=",
          s = (1 << r) - 1;
        let n = "",
          o = 0,
          a = 0;
        for (let c = 0; c < t.length; ++c)
          for (a = (a << 8) | t[c], o += 8; o > r; )
            (o -= r), (n += e[s & (a >> o)]);
        if ((o && (n += e[s & (a << (r - o))]), i))
          for (; (n.length * r) & 7; ) n += "=";
        return n;
      },
      cr = ({ name: t, prefix: e, bitsPerChar: r, alphabet: i }) =>
        up({
          prefix: e,
          name: t,
          encode(s) {
            return XN(s, i, r);
          },
          decode(s) {
            return JN(s, i, r, t);
          },
        }),
      QN = up({
        prefix: "\0",
        name: "identity",
        encode: (t) => WN(t),
        decode: (t) => VN(t),
      });
    var eT = Object.freeze({ __proto__: null, identity: QN });
    const tT = cr({
      prefix: "0",
      name: "base2",
      alphabet: "01",
      bitsPerChar: 1,
    });
    var rT = Object.freeze({ __proto__: null, base2: tT });
    const iT = cr({
      prefix: "7",
      name: "base8",
      alphabet: "01234567",
      bitsPerChar: 3,
    });
    var sT = Object.freeze({ __proto__: null, base8: iT });
    const nT = du({ prefix: "9", name: "base10", alphabet: "0123456789" });
    var oT = Object.freeze({ __proto__: null, base10: nT });
    const aT = cr({
        prefix: "f",
        name: "base16",
        alphabet: "0123456789abcdef",
        bitsPerChar: 4,
      }),
      cT = cr({
        prefix: "F",
        name: "base16upper",
        alphabet: "0123456789ABCDEF",
        bitsPerChar: 4,
      });
    var lT = Object.freeze({ __proto__: null, base16: aT, base16upper: cT });
    const uT = cr({
        prefix: "b",
        name: "base32",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567",
        bitsPerChar: 5,
      }),
      hT = cr({
        prefix: "B",
        name: "base32upper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
        bitsPerChar: 5,
      }),
      dT = cr({
        prefix: "c",
        name: "base32pad",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
        bitsPerChar: 5,
      }),
      pT = cr({
        prefix: "C",
        name: "base32padupper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
        bitsPerChar: 5,
      }),
      fT = cr({
        prefix: "v",
        name: "base32hex",
        alphabet: "0123456789abcdefghijklmnopqrstuv",
        bitsPerChar: 5,
      }),
      gT = cr({
        prefix: "V",
        name: "base32hexupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
        bitsPerChar: 5,
      }),
      wT = cr({
        prefix: "t",
        name: "base32hexpad",
        alphabet: "0123456789abcdefghijklmnopqrstuv=",
        bitsPerChar: 5,
      }),
      mT = cr({
        prefix: "T",
        name: "base32hexpadupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
        bitsPerChar: 5,
      }),
      yT = cr({
        prefix: "h",
        name: "base32z",
        alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
        bitsPerChar: 5,
      });
    var bT = Object.freeze({
      __proto__: null,
      base32: uT,
      base32upper: hT,
      base32pad: dT,
      base32padupper: pT,
      base32hex: fT,
      base32hexupper: gT,
      base32hexpad: wT,
      base32hexpadupper: mT,
      base32z: yT,
    });
    const vT = du({
        prefix: "k",
        name: "base36",
        alphabet: "0123456789abcdefghijklmnopqrstuvwxyz",
      }),
      ET = du({
        prefix: "K",
        name: "base36upper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
      });
    var CT = Object.freeze({ __proto__: null, base36: vT, base36upper: ET });
    const xT = du({
        name: "base58btc",
        prefix: "z",
        alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
      }),
      IT = du({
        name: "base58flickr",
        prefix: "Z",
        alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
      });
    var _T = Object.freeze({
      __proto__: null,
      base58btc: xT,
      base58flickr: IT,
    });
    const AT = cr({
        prefix: "m",
        name: "base64",
        alphabet:
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        bitsPerChar: 6,
      }),
      ST = cr({
        prefix: "M",
        name: "base64pad",
        alphabet:
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        bitsPerChar: 6,
      }),
      PT = cr({
        prefix: "u",
        name: "base64url",
        alphabet:
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
        bitsPerChar: 6,
      }),
      OT = cr({
        prefix: "U",
        name: "base64urlpad",
        alphabet:
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
        bitsPerChar: 6,
      });
    var NT = Object.freeze({
      __proto__: null,
      base64: AT,
      base64pad: ST,
      base64url: PT,
      base64urlpad: OT,
    });
    const O3 = Array.from(
        "\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"
      ),
      TT = O3.reduce((t, e, r) => ((t[r] = e), t), []),
      kT = O3.reduce((t, e, r) => ((t[e.codePointAt(0)] = r), t), []);
    function RT(t) {
      return t.reduce((e, r) => ((e += TT[r]), e), "");
    }
    function $T(t) {
      const e = [];
      for (const r of t) {
        const i = kT[r.codePointAt(0)];
        if (i === void 0) throw new Error(`Non-base256emoji character: ${r}`);
        e.push(i);
      }
      return new Uint8Array(e);
    }
    const FT = up({
      prefix: "\u{1F680}",
      name: "base256emoji",
      encode: RT,
      decode: $T,
    });
    var BT = Object.freeze({ __proto__: null, base256emoji: FT }),
      LT = T3,
      N3 = 128,
      UT = 127,
      DT = ~UT,
      jT = Math.pow(2, 31);
    function T3(t, e, r) {
      (e = e || []), (r = r || 0);
      for (var i = r; t >= jT; ) (e[r++] = (t & 255) | N3), (t /= 128);
      for (; t & DT; ) (e[r++] = (t & 255) | N3), (t >>>= 7);
      return (e[r] = t | 0), (T3.bytes = r - i + 1), e;
    }
    var MT = i1,
      zT = 128,
      k3 = 127;
    function i1(t, i) {
      var r = 0,
        i = i || 0,
        s = 0,
        n = i,
        o,
        a = t.length;
      do {
        if (n >= a)
          throw ((i1.bytes = 0), new RangeError("Could not decode varint"));
        (o = t[n++]),
          (r += s < 28 ? (o & k3) << s : (o & k3) * Math.pow(2, s)),
          (s += 7);
      } while (o >= zT);
      return (i1.bytes = n - i), r;
    }
    var qT = Math.pow(2, 7),
      HT = Math.pow(2, 14),
      VT = Math.pow(2, 21),
      WT = Math.pow(2, 28),
      KT = Math.pow(2, 35),
      GT = Math.pow(2, 42),
      ZT = Math.pow(2, 49),
      YT = Math.pow(2, 56),
      JT = Math.pow(2, 63),
      XT = function (t) {
        return t < qT
          ? 1
          : t < HT
          ? 2
          : t < VT
          ? 3
          : t < WT
          ? 4
          : t < KT
          ? 5
          : t < GT
          ? 6
          : t < ZT
          ? 7
          : t < YT
          ? 8
          : t < JT
          ? 9
          : 10;
      },
      QT = { encode: LT, decode: MT, encodingLength: XT },
      R3 = QT;
    const $3 = (t, e, r = 0) => (R3.encode(t, e, r), e),
      F3 = (t) => R3.encodingLength(t),
      s1 = (t, e) => {
        const r = e.byteLength,
          i = F3(t),
          s = i + F3(r),
          n = new Uint8Array(s + r);
        return $3(t, n, 0), $3(r, n, i), n.set(e, s), new ek(t, r, e, n);
      };
    class ek {
      constructor(e, r, i, s) {
        (this.code = e), (this.size = r), (this.digest = i), (this.bytes = s);
      }
    }
    const B3 = ({ name: t, code: e, encode: r }) => new tk(t, e, r);
    class tk {
      constructor(e, r, i) {
        (this.name = e), (this.code = r), (this.encode = i);
      }
      digest(e) {
        if (e instanceof Uint8Array) {
          const r = this.encode(e);
          return r instanceof Uint8Array
            ? s1(this.code, r)
            : r.then((i) => s1(this.code, i));
        } else throw Error("Unknown type, must be binary type");
      }
    }
    const L3 = (t) => async (e) =>
        new Uint8Array(await crypto.subtle.digest(t, e)),
      rk = B3({ name: "sha2-256", code: 18, encode: L3("SHA-256") }),
      ik = B3({ name: "sha2-512", code: 19, encode: L3("SHA-512") });
    var sk = Object.freeze({ __proto__: null, sha256: rk, sha512: ik });
    const U3 = 0,
      nk = "identity",
      D3 = S3;
    var ok = Object.freeze({
      __proto__: null,
      identity: {
        code: U3,
        name: nk,
        encode: D3,
        digest: (t) => s1(U3, D3(t)),
      },
    });
    new TextEncoder(), new TextDecoder();
    const j3 = {
      ...eT,
      ...rT,
      ...sT,
      ...oT,
      ...lT,
      ...bT,
      ...CT,
      ..._T,
      ...NT,
      ...BT,
    };
    ({ ...sk, ...ok });
    function M3(t, e, r, i) {
      return {
        name: t,
        prefix: e,
        encoder: { name: t, prefix: e, encode: r },
        decoder: { decode: i },
      };
    }
    const z3 = M3(
        "utf8",
        "u",
        (t) => "u" + new TextDecoder("utf8").decode(t),
        (t) => new TextEncoder().encode(t.substring(1))
      ),
      n1 = M3(
        "ascii",
        "a",
        (t) => {
          let e = "a";
          for (let r = 0; r < t.length; r++) e += String.fromCharCode(t[r]);
          return e;
        },
        (t) => {
          t = t.substring(1);
          const e = _3(t.length);
          for (let r = 0; r < t.length; r++) e[r] = t.charCodeAt(r);
          return e;
        }
      ),
      q3 = {
        utf8: z3,
        "utf-8": z3,
        hex: j3.base16,
        latin1: n1,
        ascii: n1,
        binary: n1,
        ...j3,
      };
    function hp(t, e = "utf8") {
      const r = q3[e];
      if (!r) throw new Error(`Unsupported encoding "${e}"`);
      return (e === "utf8" || e === "utf-8") &&
        globalThis.Buffer != null &&
        globalThis.Buffer.from != null
        ? globalThis.Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString(
            "utf8"
          )
        : r.encoder.encode(t).substring(1);
    }
    function nc(t, e = "utf8") {
      const r = q3[e];
      if (!r) throw new Error(`Unsupported encoding "${e}"`);
      return (e === "utf8" || e === "utf-8") &&
        globalThis.Buffer != null &&
        globalThis.Buffer.from != null
        ? r1(globalThis.Buffer.from(t, "utf-8"))
        : r.decoder.decode(`${r.prefix}${t}`);
    }
    function H3(t) {
      return Ws(hp(nc(t, lp), C3));
    }
    function dp(t) {
      return hp(nc(ys(t), C3), lp);
    }
    function o1(t) {
      const e = nc(jN, I3),
        r = DN + hp(A3([e, t]), I3);
      return [LN, UN, r].join(BN);
    }
    function ak(t) {
      return hp(t, lp);
    }
    function ck(t) {
      return nc(t, lp);
    }
    function lk(t) {
      return nc([dp(t.header), dp(t.payload)].join(cp), x3);
    }
    function uk(t) {
      return [dp(t.header), dp(t.payload), ak(t.signature)].join(cp);
    }
    function oc(t) {
      const e = t.split(cp),
        r = H3(e[0]),
        i = H3(e[1]),
        s = ck(e[2]),
        n = nc(e.slice(0, 2).join(cp), x3);
      return { header: r, payload: i, signature: s, data: n };
    }
    function pp(t = r3(MN)) {
      const e = E3.getPublicKey(t);
      return { secretKey: A3([t, e]), publicKey: e };
    }
    async function V3(t, e, r, i, s = z.fromMiliseconds(Date.now())) {
      const n = { alg: $N, typ: FN },
        o = o1(i.publicKey),
        a = s + r,
        c = { iss: o, sub: t, aud: e, iat: s, exp: a },
        l = lk({ header: n, payload: c }),
        u = E3.sign(l, i.secretKey.slice(0, 32));
      return uk({ header: n, payload: c, signature: u });
    }
    function W3(t = 0) {
      return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null
        ? globalThis.Buffer.allocUnsafe(t)
        : new Uint8Array(t);
    }
    function vs(t, e) {
      e || (e = t.reduce((s, n) => s + n.length, 0));
      const r = W3(e);
      let i = 0;
      for (const s of t) r.set(s, i), (i += s.length);
      return r;
    }
    function hk(t, e) {
      if (t.length >= 255) throw new TypeError("Alphabet too long");
      for (var r = new Uint8Array(256), i = 0; i < r.length; i++) r[i] = 255;
      for (var s = 0; s < t.length; s++) {
        var n = t.charAt(s),
          o = n.charCodeAt(0);
        if (r[o] !== 255) throw new TypeError(n + " is ambiguous");
        r[o] = s;
      }
      var a = t.length,
        c = t.charAt(0),
        l = Math.log(a) / Math.log(256),
        u = Math.log(256) / Math.log(a);
      function h(p) {
        if (
          (p instanceof Uint8Array ||
            (ArrayBuffer.isView(p)
              ? (p = new Uint8Array(p.buffer, p.byteOffset, p.byteLength))
              : Array.isArray(p) && (p = Uint8Array.from(p))),
          !(p instanceof Uint8Array))
        )
          throw new TypeError("Expected Uint8Array");
        if (p.length === 0) return "";
        for (var w = 0, f = 0, m = 0, y = p.length; m !== y && p[m] === 0; )
          m++, w++;
        for (
          var E = ((y - m) * u + 1) >>> 0, C = new Uint8Array(E);
          m !== y;

        ) {
          for (
            var O = p[m], A = 0, P = E - 1;
            (O !== 0 || A < f) && P !== -1;
            P--, A++
          )
            (O += (256 * C[P]) >>> 0),
              (C[P] = O % a >>> 0),
              (O = (O / a) >>> 0);
          if (O !== 0) throw new Error("Non-zero carry");
          (f = A), m++;
        }
        for (var N = E - f; N !== E && C[N] === 0; ) N++;
        for (var x = c.repeat(w); N < E; ++N) x += t.charAt(C[N]);
        return x;
      }
      function d(p) {
        if (typeof p != "string") throw new TypeError("Expected String");
        if (p.length === 0) return new Uint8Array();
        var w = 0;
        if (p[w] !== " ") {
          for (var f = 0, m = 0; p[w] === c; ) f++, w++;
          for (
            var y = ((p.length - w) * l + 1) >>> 0, E = new Uint8Array(y);
            p[w];

          ) {
            var C = r[p.charCodeAt(w)];
            if (C === 255) return;
            for (var O = 0, A = y - 1; (C !== 0 || O < m) && A !== -1; A--, O++)
              (C += (a * E[A]) >>> 0),
                (E[A] = C % 256 >>> 0),
                (C = (C / 256) >>> 0);
            if (C !== 0) throw new Error("Non-zero carry");
            (m = O), w++;
          }
          if (p[w] !== " ") {
            for (var P = y - m; P !== y && E[P] === 0; ) P++;
            for (var N = new Uint8Array(f + (y - P)), x = f; P !== y; )
              N[x++] = E[P++];
            return N;
          }
        }
      }
      function g(p) {
        var w = d(p);
        if (w) return w;
        throw new Error(`Non-${e} character`);
      }
      return { encode: h, decodeUnsafe: d, decode: g };
    }
    var dk = hk,
      pk = dk;
    const K3 = (t) => {
        if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
          return t;
        if (t instanceof ArrayBuffer) return new Uint8Array(t);
        if (ArrayBuffer.isView(t))
          return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
        throw new Error("Unknown type, must be binary type");
      },
      fk = (t) => new TextEncoder().encode(t),
      gk = (t) => new TextDecoder().decode(t);
    class wk {
      constructor(e, r, i) {
        (this.name = e), (this.prefix = r), (this.baseEncode = i);
      }
      encode(e) {
        if (e instanceof Uint8Array)
          return `${this.prefix}${this.baseEncode(e)}`;
        throw Error("Unknown type, must be binary type");
      }
    }
    class mk {
      constructor(e, r, i) {
        if (((this.name = e), (this.prefix = r), r.codePointAt(0) === void 0))
          throw new Error("Invalid prefix character");
        (this.prefixCodePoint = r.codePointAt(0)), (this.baseDecode = i);
      }
      decode(e) {
        if (typeof e == "string") {
          if (e.codePointAt(0) !== this.prefixCodePoint)
            throw Error(
              `Unable to decode multibase string ${JSON.stringify(e)}, ${
                this.name
              } decoder only supports inputs prefixed with ${this.prefix}`
            );
          return this.baseDecode(e.slice(this.prefix.length));
        } else throw Error("Can only multibase decode strings");
      }
      or(e) {
        return G3(this, e);
      }
    }
    class yk {
      constructor(e) {
        this.decoders = e;
      }
      or(e) {
        return G3(this, e);
      }
      decode(e) {
        const r = e[0],
          i = this.decoders[r];
        if (i) return i.decode(e);
        throw RangeError(
          `Unable to decode multibase string ${JSON.stringify(
            e
          )}, only inputs prefixed with ${Object.keys(
            this.decoders
          )} are supported`
        );
      }
    }
    const G3 = (t, e) =>
      new yk({
        ...(t.decoders || { [t.prefix]: t }),
        ...(e.decoders || { [e.prefix]: e }),
      });
    class bk {
      constructor(e, r, i, s) {
        (this.name = e),
          (this.prefix = r),
          (this.baseEncode = i),
          (this.baseDecode = s),
          (this.encoder = new wk(e, r, i)),
          (this.decoder = new mk(e, r, s));
      }
      encode(e) {
        return this.encoder.encode(e);
      }
      decode(e) {
        return this.decoder.decode(e);
      }
    }
    const fp = ({ name: t, prefix: e, encode: r, decode: i }) =>
        new bk(t, e, r, i),
      pu = ({ prefix: t, name: e, alphabet: r }) => {
        const { encode: i, decode: s } = pk(r, e);
        return fp({ prefix: t, name: e, encode: i, decode: (n) => K3(s(n)) });
      },
      vk = (t, e, r, i) => {
        const s = {};
        for (let u = 0; u < e.length; ++u) s[e[u]] = u;
        let n = t.length;
        for (; t[n - 1] === "="; ) --n;
        const o = new Uint8Array(((n * r) / 8) | 0);
        let a = 0,
          c = 0,
          l = 0;
        for (let u = 0; u < n; ++u) {
          const h = s[t[u]];
          if (h === void 0) throw new SyntaxError(`Non-${i} character`);
          (c = (c << r) | h),
            (a += r),
            a >= 8 && ((a -= 8), (o[l++] = 255 & (c >> a)));
        }
        if (a >= r || 255 & (c << (8 - a)))
          throw new SyntaxError("Unexpected end of data");
        return o;
      },
      Ek = (t, e, r) => {
        const i = e[e.length - 1] === "=",
          s = (1 << r) - 1;
        let n = "",
          o = 0,
          a = 0;
        for (let c = 0; c < t.length; ++c)
          for (a = (a << 8) | t[c], o += 8; o > r; )
            (o -= r), (n += e[s & (a >> o)]);
        if ((o && (n += e[s & (a << (r - o))]), i))
          for (; (n.length * r) & 7; ) n += "=";
        return n;
      },
      lr = ({ name: t, prefix: e, bitsPerChar: r, alphabet: i }) =>
        fp({
          prefix: e,
          name: t,
          encode(s) {
            return Ek(s, i, r);
          },
          decode(s) {
            return vk(s, i, r, t);
          },
        }),
      Ck = fp({
        prefix: "\0",
        name: "identity",
        encode: (t) => gk(t),
        decode: (t) => fk(t),
      });
    var xk = Object.freeze({ __proto__: null, identity: Ck });
    const Ik = lr({
      prefix: "0",
      name: "base2",
      alphabet: "01",
      bitsPerChar: 1,
    });
    var _k = Object.freeze({ __proto__: null, base2: Ik });
    const Ak = lr({
      prefix: "7",
      name: "base8",
      alphabet: "01234567",
      bitsPerChar: 3,
    });
    var Sk = Object.freeze({ __proto__: null, base8: Ak });
    const Pk = pu({ prefix: "9", name: "base10", alphabet: "0123456789" });
    var Ok = Object.freeze({ __proto__: null, base10: Pk });
    const Nk = lr({
        prefix: "f",
        name: "base16",
        alphabet: "0123456789abcdef",
        bitsPerChar: 4,
      }),
      Tk = lr({
        prefix: "F",
        name: "base16upper",
        alphabet: "0123456789ABCDEF",
        bitsPerChar: 4,
      });
    var kk = Object.freeze({ __proto__: null, base16: Nk, base16upper: Tk });
    const Rk = lr({
        prefix: "b",
        name: "base32",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567",
        bitsPerChar: 5,
      }),
      $k = lr({
        prefix: "B",
        name: "base32upper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
        bitsPerChar: 5,
      }),
      Fk = lr({
        prefix: "c",
        name: "base32pad",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
        bitsPerChar: 5,
      }),
      Bk = lr({
        prefix: "C",
        name: "base32padupper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
        bitsPerChar: 5,
      }),
      Lk = lr({
        prefix: "v",
        name: "base32hex",
        alphabet: "0123456789abcdefghijklmnopqrstuv",
        bitsPerChar: 5,
      }),
      Uk = lr({
        prefix: "V",
        name: "base32hexupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
        bitsPerChar: 5,
      }),
      Dk = lr({
        prefix: "t",
        name: "base32hexpad",
        alphabet: "0123456789abcdefghijklmnopqrstuv=",
        bitsPerChar: 5,
      }),
      jk = lr({
        prefix: "T",
        name: "base32hexpadupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
        bitsPerChar: 5,
      }),
      Mk = lr({
        prefix: "h",
        name: "base32z",
        alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
        bitsPerChar: 5,
      });
    var zk = Object.freeze({
      __proto__: null,
      base32: Rk,
      base32upper: $k,
      base32pad: Fk,
      base32padupper: Bk,
      base32hex: Lk,
      base32hexupper: Uk,
      base32hexpad: Dk,
      base32hexpadupper: jk,
      base32z: Mk,
    });
    const qk = pu({
        prefix: "k",
        name: "base36",
        alphabet: "0123456789abcdefghijklmnopqrstuvwxyz",
      }),
      Hk = pu({
        prefix: "K",
        name: "base36upper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
      });
    var Vk = Object.freeze({ __proto__: null, base36: qk, base36upper: Hk });
    const Wk = pu({
        name: "base58btc",
        prefix: "z",
        alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
      }),
      Kk = pu({
        name: "base58flickr",
        prefix: "Z",
        alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
      });
    var Gk = Object.freeze({
      __proto__: null,
      base58btc: Wk,
      base58flickr: Kk,
    });
    const Zk = lr({
        prefix: "m",
        name: "base64",
        alphabet:
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        bitsPerChar: 6,
      }),
      Yk = lr({
        prefix: "M",
        name: "base64pad",
        alphabet:
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        bitsPerChar: 6,
      }),
      Jk = lr({
        prefix: "u",
        name: "base64url",
        alphabet:
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
        bitsPerChar: 6,
      }),
      Xk = lr({
        prefix: "U",
        name: "base64urlpad",
        alphabet:
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
        bitsPerChar: 6,
      });
    var Qk = Object.freeze({
      __proto__: null,
      base64: Zk,
      base64pad: Yk,
      base64url: Jk,
      base64urlpad: Xk,
    });
    const Z3 = Array.from(
        "\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"
      ),
      eR = Z3.reduce((t, e, r) => ((t[r] = e), t), []),
      tR = Z3.reduce((t, e, r) => ((t[e.codePointAt(0)] = r), t), []);
    function rR(t) {
      return t.reduce((e, r) => ((e += eR[r]), e), "");
    }
    function iR(t) {
      const e = [];
      for (const r of t) {
        const i = tR[r.codePointAt(0)];
        if (i === void 0) throw new Error(`Non-base256emoji character: ${r}`);
        e.push(i);
      }
      return new Uint8Array(e);
    }
    const sR = fp({
      prefix: "\u{1F680}",
      name: "base256emoji",
      encode: rR,
      decode: iR,
    });
    var nR = Object.freeze({ __proto__: null, base256emoji: sR }),
      oR = J3,
      Y3 = 128,
      aR = 127,
      cR = ~aR,
      lR = Math.pow(2, 31);
    function J3(t, e, r) {
      (e = e || []), (r = r || 0);
      for (var i = r; t >= lR; ) (e[r++] = (t & 255) | Y3), (t /= 128);
      for (; t & cR; ) (e[r++] = (t & 255) | Y3), (t >>>= 7);
      return (e[r] = t | 0), (J3.bytes = r - i + 1), e;
    }
    var uR = a1,
      hR = 128,
      X3 = 127;
    function a1(t, i) {
      var r = 0,
        i = i || 0,
        s = 0,
        n = i,
        o,
        a = t.length;
      do {
        if (n >= a)
          throw ((a1.bytes = 0), new RangeError("Could not decode varint"));
        (o = t[n++]),
          (r += s < 28 ? (o & X3) << s : (o & X3) * Math.pow(2, s)),
          (s += 7);
      } while (o >= hR);
      return (a1.bytes = n - i), r;
    }
    var dR = Math.pow(2, 7),
      pR = Math.pow(2, 14),
      fR = Math.pow(2, 21),
      gR = Math.pow(2, 28),
      wR = Math.pow(2, 35),
      mR = Math.pow(2, 42),
      yR = Math.pow(2, 49),
      bR = Math.pow(2, 56),
      vR = Math.pow(2, 63),
      ER = function (t) {
        return t < dR
          ? 1
          : t < pR
          ? 2
          : t < fR
          ? 3
          : t < gR
          ? 4
          : t < wR
          ? 5
          : t < mR
          ? 6
          : t < yR
          ? 7
          : t < bR
          ? 8
          : t < vR
          ? 9
          : 10;
      },
      CR = { encode: oR, decode: uR, encodingLength: ER },
      Q3 = CR;
    const e5 = (t, e, r = 0) => (Q3.encode(t, e, r), e),
      t5 = (t) => Q3.encodingLength(t),
      c1 = (t, e) => {
        const r = e.byteLength,
          i = t5(t),
          s = i + t5(r),
          n = new Uint8Array(s + r);
        return e5(t, n, 0), e5(r, n, i), n.set(e, s), new xR(t, r, e, n);
      };
    class xR {
      constructor(e, r, i, s) {
        (this.code = e), (this.size = r), (this.digest = i), (this.bytes = s);
      }
    }
    const r5 = ({ name: t, code: e, encode: r }) => new IR(t, e, r);
    class IR {
      constructor(e, r, i) {
        (this.name = e), (this.code = r), (this.encode = i);
      }
      digest(e) {
        if (e instanceof Uint8Array) {
          const r = this.encode(e);
          return r instanceof Uint8Array
            ? c1(this.code, r)
            : r.then((i) => c1(this.code, i));
        } else throw Error("Unknown type, must be binary type");
      }
    }
    const i5 = (t) => async (e) =>
        new Uint8Array(await crypto.subtle.digest(t, e)),
      _R = r5({ name: "sha2-256", code: 18, encode: i5("SHA-256") }),
      AR = r5({ name: "sha2-512", code: 19, encode: i5("SHA-512") });
    var SR = Object.freeze({ __proto__: null, sha256: _R, sha512: AR });
    const s5 = 0,
      PR = "identity",
      n5 = K3;
    var OR = Object.freeze({
      __proto__: null,
      identity: {
        code: s5,
        name: PR,
        encode: n5,
        digest: (t) => c1(s5, n5(t)),
      },
    });
    new TextEncoder(), new TextDecoder();
    const o5 = {
      ...xk,
      ..._k,
      ...Sk,
      ...Ok,
      ...kk,
      ...zk,
      ...Vk,
      ...Gk,
      ...Qk,
      ...nR,
    };
    ({ ...SR, ...OR });
    function a5(t, e, r, i) {
      return {
        name: t,
        prefix: e,
        encoder: { name: t, prefix: e, encode: r },
        decoder: { decode: i },
      };
    }
    const c5 = a5(
        "utf8",
        "u",
        (t) => "u" + new TextDecoder("utf8").decode(t),
        (t) => new TextEncoder().encode(t.substring(1))
      ),
      l1 = a5(
        "ascii",
        "a",
        (t) => {
          let e = "a";
          for (let r = 0; r < t.length; r++) e += String.fromCharCode(t[r]);
          return e;
        },
        (t) => {
          t = t.substring(1);
          const e = W3(t.length);
          for (let r = 0; r < t.length; r++) e[r] = t.charCodeAt(r);
          return e;
        }
      ),
      l5 = {
        utf8: c5,
        "utf-8": c5,
        hex: o5.base16,
        latin1: l1,
        ascii: l1,
        binary: l1,
        ...o5,
      };
    function yt(t, e = "utf8") {
      const r = l5[e];
      if (!r) throw new Error(`Unsupported encoding "${e}"`);
      return (e === "utf8" || e === "utf-8") &&
        globalThis.Buffer != null &&
        globalThis.Buffer.from != null
        ? globalThis.Buffer.from(t, "utf8")
        : r.decoder.decode(`${r.prefix}${t}`);
    }
    function et(t, e = "utf8") {
      const r = l5[e];
      if (!r) throw new Error(`Unsupported encoding "${e}"`);
      return (e === "utf8" || e === "utf-8") &&
        globalThis.Buffer != null &&
        globalThis.Buffer.from != null
        ? globalThis.Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString(
            "utf8"
          )
        : r.encoder.encode(t).substring(1);
    }
    const u5 = {
      waku: {
        publish: "waku_publish",
        batchPublish: "waku_batchPublish",
        subscribe: "waku_subscribe",
        batchSubscribe: "waku_batchSubscribe",
        subscription: "waku_subscription",
        unsubscribe: "waku_unsubscribe",
        batchUnsubscribe: "waku_batchUnsubscribe",
        batchFetchMessages: "waku_batchFetchMessages",
      },
      irn: {
        publish: "irn_publish",
        batchPublish: "irn_batchPublish",
        subscribe: "irn_subscribe",
        batchSubscribe: "irn_batchSubscribe",
        subscription: "irn_subscription",
        unsubscribe: "irn_unsubscribe",
        batchUnsubscribe: "irn_batchUnsubscribe",
        batchFetchMessages: "irn_batchFetchMessages",
      },
      iridium: {
        publish: "iridium_publish",
        batchPublish: "iridium_batchPublish",
        subscribe: "iridium_subscribe",
        batchSubscribe: "iridium_batchSubscribe",
        subscription: "iridium_subscription",
        unsubscribe: "iridium_unsubscribe",
        batchUnsubscribe: "iridium_batchUnsubscribe",
        batchFetchMessages: "iridium_batchFetchMessages",
      },
    };
    var NR = Object.defineProperty,
      TR = Object.defineProperties,
      kR = Object.getOwnPropertyDescriptors,
      h5 = Object.getOwnPropertySymbols,
      RR = Object.prototype.hasOwnProperty,
      $R = Object.prototype.propertyIsEnumerable,
      d5 = (t, e, r) =>
        e in t
          ? NR(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Zs = (t, e) => {
        for (var r in e || (e = {})) RR.call(e, r) && d5(t, r, e[r]);
        if (h5) for (var r of h5(e)) $R.call(e, r) && d5(t, r, e[r]);
        return t;
      },
      u1 = (t, e) => TR(t, kR(e));
    const FR = ":";
    function ac(t) {
      const [e, r] = t.split(FR);
      return { namespace: e, reference: r };
    }
    function p5(t, e = []) {
      const r = [];
      return (
        Object.keys(t).forEach((i) => {
          if (e.length && !e.includes(i)) return;
          const s = t[i];
          r.push(...s.accounts);
        }),
        r
      );
    }
    function f5(t, e) {
      return t.includes(":") ? [t] : e.chains || [];
    }
    var BR = Object.defineProperty,
      LR = Object.defineProperties,
      UR = Object.getOwnPropertyDescriptors,
      g5 = Object.getOwnPropertySymbols,
      DR = Object.prototype.hasOwnProperty,
      jR = Object.prototype.propertyIsEnumerable,
      w5 = (t, e, r) =>
        e in t
          ? BR(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      m5 = (t, e) => {
        for (var r in e || (e = {})) DR.call(e, r) && w5(t, r, e[r]);
        if (g5) for (var r of g5(e)) jR.call(e, r) && w5(t, r, e[r]);
        return t;
      },
      MR = (t, e) => LR(t, UR(e));
    const zR = "ReactNative",
      ni = {
        reactNative: "react-native",
        node: "node",
        browser: "browser",
        unknown: "unknown",
      },
      qR = "js";
    function gp() {
      return (
        typeof ut < "u" &&
        typeof ut.versions < "u" &&
        typeof ut.versions.node < "u"
      );
    }
    function Hn() {
      return !Gi() && !!tu() && navigator.product === zR;
    }
    function HR() {
      return (
        Hn() &&
        typeof globalThis < "u" &&
        typeof globalThis?.Platform < "u" &&
        globalThis?.Platform.OS === "android"
      );
    }
    function VR() {
      return (
        Hn() &&
        typeof globalThis < "u" &&
        typeof globalThis?.Platform < "u" &&
        globalThis?.Platform.OS === "ios"
      );
    }
    function cc() {
      return !gp() && !!tu() && !!Gi();
    }
    function fu() {
      return Hn()
        ? ni.reactNative
        : gp()
        ? ni.node
        : cc()
        ? ni.browser
        : ni.unknown;
    }
    function y5() {
      var t;
      try {
        return Hn() &&
          typeof globalThis < "u" &&
          typeof globalThis?.Application < "u"
          ? (t = globalThis.Application) == null
            ? void 0
            : t.applicationId
          : void 0;
      } catch {
        return;
      }
    }
    function WR(t, e) {
      const r = new URLSearchParams(t);
      for (const i of Object.keys(e).sort())
        if (e.hasOwnProperty(i)) {
          const s = e[i];
          s !== void 0 && r.set(i, s);
        }
      return r.toString();
    }
    function KR(t) {
      var e, r;
      const i = b5();
      try {
        return (
          t != null &&
            t.url &&
            i.url &&
            new URL(t.url).host !== new URL(i.url).host &&
            (console.warn(
              `The configured WalletConnect 'metadata.url':${t.url} differs from the actual page url:${i.url}. This is probably unintended and can lead to issues.`
            ),
            (t.url = i.url)),
          (e = t?.icons) != null &&
            e.length &&
            t.icons.length > 0 &&
            (t.icons = t.icons.filter((s) => s !== "")),
          MR(m5(m5({}, i), t), {
            url: t?.url || i.url,
            name: t?.name || i.name,
            description: t?.description || i.description,
            icons:
              (r = t?.icons) != null && r.length && t.icons.length > 0
                ? t.icons
                : i.icons,
          })
        );
      } catch (s) {
        return console.warn("Error populating app metadata", s), t || i;
      }
    }
    function b5() {
      return cg() || { name: "", description: "", url: "", icons: [""] };
    }
    function GR() {
      if (
        fu() === ni.reactNative &&
        typeof globalThis < "u" &&
        typeof globalThis?.Platform < "u"
      ) {
        const { OS: r, Version: i } = globalThis.Platform;
        return [r, i].join("-");
      }
      const t = Pv();
      if (t === null) return "unknown";
      const e = t.os ? t.os.replace(" ", "").toLowerCase() : "unknown";
      return t.type === "browser"
        ? [e, t.name, t.version].join("-")
        : [e, t.version].join("-");
    }
    function ZR() {
      var t;
      const e = fu();
      return e === ni.browser
        ? [e, ((t = og()) == null ? void 0 : t.host) || "unknown"].join(":")
        : e;
    }
    function v5(t, e, r) {
      const i = GR(),
        s = ZR();
      return [[t, e].join("-"), [qR, r].join("-"), i, s].join("/");
    }
    function YR({
      protocol: t,
      version: e,
      relayUrl: r,
      sdkVersion: i,
      auth: s,
      projectId: n,
      useOnCloseEvent: o,
      bundleId: a,
      packageName: c,
    }) {
      const l = r.split("?"),
        u = v5(t, e, i),
        h = {
          auth: s,
          ua: u,
          projectId: n,
          useOnCloseEvent: o || void 0,
          packageName: c || void 0,
          bundleId: a || void 0,
        },
        d = WR(l[1] || "", h);
      return l[0] + "?" + d;
    }
    function Fo(t, e) {
      return t.filter((r) => e.includes(r)).length === t.length;
    }
    function h1(t) {
      return Object.fromEntries(t.entries());
    }
    function d1(t) {
      return new Map(Object.entries(t));
    }
    function Bo(t = z.FIVE_MINUTES, e) {
      const r = z.toMiliseconds(t || z.FIVE_MINUTES);
      let i, s, n, o;
      return {
        resolve: (a) => {
          n && i && (clearTimeout(n), i(a), (o = Promise.resolve(a)));
        },
        reject: (a) => {
          n && s && (clearTimeout(n), s(a));
        },
        done: () =>
          new Promise((a, c) => {
            if (o) return a(o);
            (n = setTimeout(() => {
              const l = new Error(e);
              (o = Promise.reject(l)), c(l);
            }, r)),
              (i = a),
              (s = c);
          }),
      };
    }
    function Vn(t, e, r) {
      return new Promise(async (i, s) => {
        const n = setTimeout(() => s(new Error(r)), e);
        try {
          const o = await t;
          i(o);
        } catch (o) {
          s(o);
        }
        clearTimeout(n);
      });
    }
    function E5(t, e) {
      if (typeof e == "string" && e.startsWith(`${t}:`)) return e;
      if (t.toLowerCase() === "topic") {
        if (typeof e != "string")
          throw new Error(
            'Value must be "string" for expirer target type: topic'
          );
        return `topic:${e}`;
      } else if (t.toLowerCase() === "id") {
        if (typeof e != "number")
          throw new Error('Value must be "number" for expirer target type: id');
        return `id:${e}`;
      }
      throw new Error(`Unknown expirer target type: ${t}`);
    }
    function JR(t) {
      return E5("topic", t);
    }
    function XR(t) {
      return E5("id", t);
    }
    function C5(t) {
      const [e, r] = t.split(":"),
        i = { id: void 0, topic: void 0 };
      if (e === "topic" && typeof r == "string") i.topic = r;
      else if (e === "id" && Number.isInteger(Number(r))) i.id = Number(r);
      else
        throw new Error(
          `Invalid target, expected id:number or topic:string, got ${e}:${r}`
        );
      return i;
    }
    function Ft(t, e) {
      return z.fromMiliseconds((e || Date.now()) + z.toMiliseconds(t));
    }
    function Wn(t) {
      return Date.now() >= z.toMiliseconds(t);
    }
    function He(t, e) {
      return `${t}${e ? `:${e}` : ""}`;
    }
    function wp(t = [], e = []) {
      return [...new Set([...t, ...e])];
    }
    async function QR({ id: t, topic: e, wcDeepLink: r }) {
      var i;
      try {
        if (!r) return;
        const s = typeof r == "string" ? JSON.parse(r) : r,
          n = s?.href;
        if (typeof n != "string") return;
        const o = e$(n, t, e),
          a = fu();
        if (a === ni.browser) {
          if (!((i = Gi()) != null && i.hasFocus())) {
            console.warn("Document does not have focus, skipping deeplink.");
            return;
          }
          t$(o);
        } else a === ni.reactNative && typeof globalThis?.Linking < "u" && (await globalThis.Linking.openURL(o));
      } catch (s) {
        console.error(s);
      }
    }
    function e$(t, e, r) {
      const i = `requestId=${e}&sessionTopic=${r}`;
      t.endsWith("/") && (t = t.slice(0, -1));
      let s = `${t}`;
      if (t.startsWith("https://t.me")) {
        const n = t.includes("?") ? "&startapp=" : "?startapp=";
        s = `${s}${n}${n$(i, !0)}`;
      } else s = `${s}/wc?${i}`;
      return s;
    }
    function t$(t) {
      let e = "_self";
      s$()
        ? (e = "_top")
        : (i$() || t.startsWith("https://") || t.startsWith("http://")) &&
          (e = "_blank"),
        window.open(t, e, "noreferrer noopener");
    }
    async function r$(t, e) {
      let r = "";
      try {
        if (cc() && ((r = localStorage.getItem(e)), r)) return r;
        r = await t.getItem(e);
      } catch (i) {
        console.error(i);
      }
      return r;
    }
    function x5(t, e) {
      if (!t.includes(e)) return null;
      const r = t.split(/([&,?,=])/),
        i = r.indexOf(e);
      return r[i + 2];
    }
    function I5() {
      return typeof crypto < "u" && crypto != null && crypto.randomUUID
        ? crypto.randomUUID()
        : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (t) => {
            const e = (Math.random() * 16) | 0;
            return (t === "x" ? e : (e & 3) | 8).toString(16);
          });
    }
    function p1() {
      return typeof ut < "u" && {}.IS_VITEST === "true";
    }
    function i$() {
      return (
        typeof window < "u" &&
        (!!window.TelegramWebviewProxy ||
          !!window.Telegram ||
          !!window.TelegramWebviewProxyProto)
      );
    }
    function s$() {
      try {
        return window.self !== window.top;
      } catch {
        return !1;
      }
    }
    function n$(t, e = !1) {
      const r = Fe.from(t).toString("base64");
      return e ? r.replace(/[=]/g, "") : r;
    }
    function _5(t) {
      return Fe.from(t, "base64").toString("utf-8");
    }
    function o$(t) {
      return new Promise((e) => setTimeout(e, t));
    }
    function gu(t) {
      if (!Number.isSafeInteger(t) || t < 0)
        throw new Error("positive integer expected, got " + t);
    }
    function a$(t) {
      return (
        t instanceof Uint8Array ||
        (ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array")
      );
    }
    function wu(t, ...e) {
      if (!a$(t)) throw new Error("Uint8Array expected");
      if (e.length > 0 && !e.includes(t.length))
        throw new Error(
          "Uint8Array expected of length " + e + ", got length=" + t.length
        );
    }
    function f1(t) {
      if (typeof t != "function" || typeof t.create != "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      gu(t.outputLen), gu(t.blockLen);
    }
    function lc(t, e = !0) {
      if (t.destroyed) throw new Error("Hash instance has been destroyed");
      if (e && t.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function A5(t, e) {
      wu(t);
      const r = e.outputLen;
      if (t.length < r)
        throw new Error(
          "digestInto() expects output buffer of length at least " + r
        );
    }
    const mp = BigInt(2 ** 32 - 1),
      S5 = BigInt(32);
    function c$(t, e = !1) {
      return e
        ? { h: Number(t & mp), l: Number((t >> S5) & mp) }
        : { h: Number((t >> S5) & mp) | 0, l: Number(t & mp) | 0 };
    }
    function l$(t, e = !1) {
      let r = new Uint32Array(t.length),
        i = new Uint32Array(t.length);
      for (let s = 0; s < t.length; s++) {
        const { h: n, l: o } = c$(t[s], e);
        [r[s], i[s]] = [n, o];
      }
      return [r, i];
    }
    const u$ = (t, e, r) => (t << r) | (e >>> (32 - r)),
      h$ = (t, e, r) => (e << r) | (t >>> (32 - r)),
      d$ = (t, e, r) => (e << (r - 32)) | (t >>> (64 - r)),
      p$ = (t, e, r) => (t << (r - 32)) | (e >>> (64 - r)),
      uc =
        typeof globalThis == "object" && "crypto" in globalThis
          ? globalThis.crypto
          : void 0;
    function f$(t) {
      return new Uint32Array(
        t.buffer,
        t.byteOffset,
        Math.floor(t.byteLength / 4)
      );
    }
    function g1(t) {
      return new DataView(t.buffer, t.byteOffset, t.byteLength);
    }
    function Es(t, e) {
      return (t << (32 - e)) | (t >>> e);
    }
    const P5 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    function g$(t) {
      return (
        ((t << 24) & 4278190080) |
        ((t << 8) & 16711680) |
        ((t >>> 8) & 65280) |
        ((t >>> 24) & 255)
      );
    }
    function O5(t) {
      for (let e = 0; e < t.length; e++) t[e] = g$(t[e]);
    }
    function w$(t) {
      if (typeof t != "string")
        throw new Error("utf8ToBytes expected string, got " + typeof t);
      return new Uint8Array(new TextEncoder().encode(t));
    }
    function hc(t) {
      return typeof t == "string" && (t = w$(t)), wu(t), t;
    }
    function m$(...t) {
      let e = 0;
      for (let i = 0; i < t.length; i++) {
        const s = t[i];
        wu(s), (e += s.length);
      }
      const r = new Uint8Array(e);
      for (let i = 0, s = 0; i < t.length; i++) {
        const n = t[i];
        r.set(n, s), (s += n.length);
      }
      return r;
    }
    class w1 {
      clone() {
        return this._cloneInto();
      }
    }
    function N5(t) {
      const e = (i) => t().update(hc(i)).digest(),
        r = t();
      return (
        (e.outputLen = r.outputLen),
        (e.blockLen = r.blockLen),
        (e.create = () => t()),
        e
      );
    }
    function dc(t = 32) {
      if (uc && typeof uc.getRandomValues == "function")
        return uc.getRandomValues(new Uint8Array(t));
      if (uc && typeof uc.randomBytes == "function") return uc.randomBytes(t);
      throw new Error("crypto.getRandomValues must be defined");
    }
    const T5 = [],
      k5 = [],
      R5 = [],
      y$ = BigInt(0),
      mu = BigInt(1),
      b$ = BigInt(2),
      v$ = BigInt(7),
      E$ = BigInt(256),
      C$ = BigInt(113);
    for (let t = 0, e = mu, r = 1, i = 0; t < 24; t++) {
      ([r, i] = [i, (2 * r + 3 * i) % 5]),
        T5.push(2 * (5 * i + r)),
        k5.push((((t + 1) * (t + 2)) / 2) % 64);
      let s = y$;
      for (let n = 0; n < 7; n++)
        (e = ((e << mu) ^ ((e >> v$) * C$)) % E$),
          e & b$ && (s ^= mu << ((mu << BigInt(n)) - mu));
      R5.push(s);
    }
    const [x$, I$] = l$(R5, !0),
      $5 = (t, e, r) => (r > 32 ? d$(t, e, r) : u$(t, e, r)),
      F5 = (t, e, r) => (r > 32 ? p$(t, e, r) : h$(t, e, r));
    function _$(t, e = 24) {
      const r = new Uint32Array(10);
      for (let i = 24 - e; i < 24; i++) {
        for (let o = 0; o < 10; o++)
          r[o] = t[o] ^ t[o + 10] ^ t[o + 20] ^ t[o + 30] ^ t[o + 40];
        for (let o = 0; o < 10; o += 2) {
          const a = (o + 8) % 10,
            c = (o + 2) % 10,
            l = r[c],
            u = r[c + 1],
            h = $5(l, u, 1) ^ r[a],
            d = F5(l, u, 1) ^ r[a + 1];
          for (let g = 0; g < 50; g += 10) (t[o + g] ^= h), (t[o + g + 1] ^= d);
        }
        let s = t[2],
          n = t[3];
        for (let o = 0; o < 24; o++) {
          const a = k5[o],
            c = $5(s, n, a),
            l = F5(s, n, a),
            u = T5[o];
          (s = t[u]), (n = t[u + 1]), (t[u] = c), (t[u + 1] = l);
        }
        for (let o = 0; o < 50; o += 10) {
          for (let a = 0; a < 10; a++) r[a] = t[o + a];
          for (let a = 0; a < 10; a++)
            t[o + a] ^= ~r[(a + 2) % 10] & r[(a + 4) % 10];
        }
        (t[0] ^= x$[i]), (t[1] ^= I$[i]);
      }
      r.fill(0);
    }
    class m1 extends w1 {
      constructor(e, r, i, s = !1, n = 24) {
        if (
          (super(),
          (this.blockLen = e),
          (this.suffix = r),
          (this.outputLen = i),
          (this.enableXOF = s),
          (this.rounds = n),
          (this.pos = 0),
          (this.posOut = 0),
          (this.finished = !1),
          (this.destroyed = !1),
          gu(i),
          0 >= this.blockLen || this.blockLen >= 200)
        )
          throw new Error("Sha3 supports only keccak-f1600 function");
        (this.state = new Uint8Array(200)), (this.state32 = f$(this.state));
      }
      keccak() {
        P5 || O5(this.state32),
          _$(this.state32, this.rounds),
          P5 || O5(this.state32),
          (this.posOut = 0),
          (this.pos = 0);
      }
      update(e) {
        lc(this);
        const { blockLen: r, state: i } = this;
        e = hc(e);
        const s = e.length;
        for (let n = 0; n < s; ) {
          const o = Math.min(r - this.pos, s - n);
          for (let a = 0; a < o; a++) i[this.pos++] ^= e[n++];
          this.pos === r && this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished) return;
        this.finished = !0;
        const { state: e, suffix: r, pos: i, blockLen: s } = this;
        (e[i] ^= r),
          (r & 128) !== 0 && i === s - 1 && this.keccak(),
          (e[s - 1] ^= 128),
          this.keccak();
      }
      writeInto(e) {
        lc(this, !1), wu(e), this.finish();
        const r = this.state,
          { blockLen: i } = this;
        for (let s = 0, n = e.length; s < n; ) {
          this.posOut >= i && this.keccak();
          const o = Math.min(i - this.posOut, n - s);
          e.set(r.subarray(this.posOut, this.posOut + o), s),
            (this.posOut += o),
            (s += o);
        }
        return e;
      }
      xofInto(e) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(e);
      }
      xof(e) {
        return gu(e), this.xofInto(new Uint8Array(e));
      }
      digestInto(e) {
        if ((A5(e, this), this.finished))
          throw new Error("digest() was already called");
        return this.writeInto(e), this.destroy(), e;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        (this.destroyed = !0), this.state.fill(0);
      }
      _cloneInto(e) {
        const {
          blockLen: r,
          suffix: i,
          outputLen: s,
          rounds: n,
          enableXOF: o,
        } = this;
        return (
          e || (e = new m1(r, i, s, o, n)),
          e.state32.set(this.state32),
          (e.pos = this.pos),
          (e.posOut = this.posOut),
          (e.finished = this.finished),
          (e.rounds = n),
          (e.suffix = i),
          (e.outputLen = s),
          (e.enableXOF = o),
          (e.destroyed = this.destroyed),
          e
        );
      }
    }
    const A$ = (t, e, r) => N5(() => new m1(e, t, r)),
      S$ = A$(1, 136, 256 / 8),
      P$ = "https://rpc.walletconnect.org/v1";
    function B5(t) {
      const e = `Ethereum Signed Message:
${t.length}`,
        r = new TextEncoder().encode(e + t);
      return "0x" + Fe.from(S$(r)).toString("hex");
    }
    async function O$(t, e, r, i, s, n) {
      switch (r.t) {
        case "eip191":
          return await N$(t, e, r.s);
        case "eip1271":
          return await T$(t, e, r.s, i, s, n);
        default:
          throw new Error(
            `verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${r.t}`
          );
      }
    }
    async function N$(t, e, r) {
      return (
        (await jS({ hash: B5(e), signature: r })).toLowerCase() ===
        t.toLowerCase()
      );
    }
    async function T$(t, e, r, i, s, n) {
      const o = ac(i);
      if (!o.namespace || !o.reference)
        throw new Error(
          `isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${i}`
        );
      try {
        const a = "0x1626ba7e",
          c =
            "0000000000000000000000000000000000000000000000000000000000000040",
          l =
            "0000000000000000000000000000000000000000000000000000000000000041",
          u = r.substring(2),
          h = B5(e).substring(2),
          d = a + h + c + l + u,
          g = await fetch(`${n || P$}/?chainId=${i}&projectId=${s}`, {
            method: "POST",
            body: JSON.stringify({
              id: k$(),
              jsonrpc: "2.0",
              method: "eth_call",
              params: [{ to: t, data: d }, "latest"],
            }),
          }),
          { result: p } = await g.json();
        return p ? p.slice(0, a.length).toLowerCase() === a.toLowerCase() : !1;
      } catch (a) {
        return console.error("isValidEip1271Signature: ", a), !1;
      }
    }
    function k$() {
      return Date.now() + Math.floor(Math.random() * 1e3);
    }
    function R$(t) {
      const e = atob(t),
        r = new Uint8Array(e.length);
      for (let o = 0; o < e.length; o++) r[o] = e.charCodeAt(o);
      const i = r[0];
      if (i === 0) throw new Error("No signatures found");
      const s = 1 + i * 64;
      if (r.length < s)
        throw new Error(
          "Transaction data too short for claimed signature count"
        );
      if (r.length < 100) throw new Error("Transaction too short");
      const n = Fe.from(t, "base64").slice(1, 65);
      return Dg.encode(n);
    }
    var $$ = Object.defineProperty,
      F$ = Object.defineProperties,
      B$ = Object.getOwnPropertyDescriptors,
      L5 = Object.getOwnPropertySymbols,
      L$ = Object.prototype.hasOwnProperty,
      U$ = Object.prototype.propertyIsEnumerable,
      U5 = (t, e, r) =>
        e in t
          ? $$(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      D$ = (t, e) => {
        for (var r in e || (e = {})) L$.call(e, r) && U5(t, r, e[r]);
        if (L5) for (var r of L5(e)) U$.call(e, r) && U5(t, r, e[r]);
        return t;
      },
      j$ = (t, e) => F$(t, B$(e));
    const M$ = "did:pkh:",
      y1 = (t) => t?.split(":"),
      z$ = (t) => {
        const e = t && y1(t);
        if (e) return t.includes(M$) ? e[3] : e[1];
      },
      b1 = (t) => {
        const e = t && y1(t);
        if (e) return e[2] + ":" + e[3];
      },
      yp = (t) => {
        const e = t && y1(t);
        if (e) return e.pop();
      };
    async function D5(t) {
      const { cacao: e, projectId: r } = t,
        { s: i, p: s } = e,
        n = j5(s, s.iss),
        o = yp(s.iss);
      return await O$(o, n, i, b1(s.iss), r);
    }
    const j5 = (t, e) => {
      const r = `${t.domain} wants you to sign in with your Ethereum account:`,
        i = yp(e);
      if (!t.aud && !t.uri)
        throw new Error(
          "Either `aud` or `uri` is required to construct the message"
        );
      let s = t.statement || void 0;
      const n = `URI: ${t.aud || t.uri}`,
        o = `Version: ${t.version}`,
        a = `Chain ID: ${z$(e)}`,
        c = `Nonce: ${t.nonce}`,
        l = `Issued At: ${t.iat}`,
        u = t.exp ? `Expiration Time: ${t.exp}` : void 0,
        h = t.nbf ? `Not Before: ${t.nbf}` : void 0,
        d = t.requestId ? `Request ID: ${t.requestId}` : void 0,
        g = t.resources
          ? `Resources:${t.resources
              .map(
                (w) => `
- ${w}`
              )
              .join("")}`
          : void 0,
        p = bp(t.resources);
      if (p) {
        const w = yu(p);
        s = J$(s, w);
      }
      return [r, i, "", s, "", n, o, a, c, l, u, h, d, g].filter(
        (w) => w != null
      ).join(`
`);
    };
    function q$(t) {
      return Fe.from(JSON.stringify(t)).toString("base64");
    }
    function H$(t) {
      return JSON.parse(Fe.from(t, "base64").toString("utf-8"));
    }
    function Lo(t) {
      if (!t) throw new Error("No recap provided, value is undefined");
      if (!t.att) throw new Error("No `att` property found");
      const e = Object.keys(t.att);
      if (!(e != null && e.length))
        throw new Error("No resources found in `att` property");
      e.forEach((r) => {
        const i = t.att[r];
        if (Array.isArray(i))
          throw new Error(`Resource must be an object: ${r}`);
        if (typeof i != "object")
          throw new Error(`Resource must be an object: ${r}`);
        if (!Object.keys(i).length)
          throw new Error(`Resource object is empty: ${r}`);
        Object.keys(i).forEach((s) => {
          const n = i[s];
          if (!Array.isArray(n))
            throw new Error(
              `Ability limits ${s} must be an array of objects, found: ${n}`
            );
          if (!n.length)
            throw new Error(
              `Value of ${s} is empty array, must be an array with objects`
            );
          n.forEach((o) => {
            if (typeof o != "object")
              throw new Error(
                `Ability limits (${s}) must be an array of objects, found: ${o}`
              );
          });
        });
      });
    }
    function V$(t, e, r, i = {}) {
      return (
        r?.sort((s, n) => s.localeCompare(n)), { att: { [t]: W$(e, r, i) } }
      );
    }
    function W$(t, e, r = {}) {
      e = e?.sort((s, n) => s.localeCompare(n));
      const i = e.map((s) => ({ [`${t}/${s}`]: [r] }));
      return Object.assign({}, ...i);
    }
    function M5(t) {
      return Lo(t), `urn:recap:${q$(t).replace(/=/g, "")}`;
    }
    function yu(t) {
      const e = H$(t.replace("urn:recap:", ""));
      return Lo(e), e;
    }
    function K$(t, e, r) {
      const i = V$(t, e, r);
      return M5(i);
    }
    function G$(t) {
      return t && t.includes("urn:recap:");
    }
    function Z$(t, e) {
      const r = yu(t),
        i = yu(e),
        s = Y$(r, i);
      return M5(s);
    }
    function Y$(t, e) {
      Lo(t), Lo(e);
      const r = Object.keys(t.att)
          .concat(Object.keys(e.att))
          .sort((s, n) => s.localeCompare(n)),
        i = { att: {} };
      return (
        r.forEach((s) => {
          var n, o;
          Object.keys(((n = t.att) == null ? void 0 : n[s]) || {})
            .concat(Object.keys(((o = e.att) == null ? void 0 : o[s]) || {}))
            .sort((a, c) => a.localeCompare(c))
            .forEach((a) => {
              var c, l;
              i.att[s] = j$(D$({}, i.att[s]), {
                [a]:
                  ((c = t.att[s]) == null ? void 0 : c[a]) ||
                  ((l = e.att[s]) == null ? void 0 : l[a]),
              });
            });
        }),
        i
      );
    }
    function J$(t = "", e) {
      Lo(e);
      const r =
        "I further authorize the stated URI to perform the following actions on my behalf: ";
      if (t.includes(r)) return t;
      const i = [];
      let s = 0;
      Object.keys(e.att).forEach((a) => {
        const c = Object.keys(e.att[a]).map((h) => ({
          ability: h.split("/")[0],
          action: h.split("/")[1],
        }));
        c.sort((h, d) => h.action.localeCompare(d.action));
        const l = {};
        c.forEach((h) => {
          l[h.ability] || (l[h.ability] = []), l[h.ability].push(h.action);
        });
        const u = Object.keys(l).map(
          (h) => (s++, `(${s}) '${h}': '${l[h].join("', '")}' for '${a}'.`)
        );
        i.push(u.join(", ").replace(".,", "."));
      });
      const n = i.join(" "),
        o = `${r}${n}`;
      return `${t ? t + " " : ""}${o}`;
    }
    function z5(t) {
      var e;
      const r = yu(t);
      Lo(r);
      const i = (e = r.att) == null ? void 0 : e.eip155;
      return i ? Object.keys(i).map((s) => s.split("/")[1]) : [];
    }
    function q5(t) {
      const e = yu(t);
      Lo(e);
      const r = [];
      return (
        Object.values(e.att).forEach((i) => {
          Object.values(i).forEach((s) => {
            var n;
            (n = s?.[0]) != null && n.chains && r.push(s[0].chains);
          });
        }),
        [...new Set(r.flat())]
      );
    }
    function bp(t) {
      if (!t) return;
      const e = t?.[t.length - 1];
      return G$(e) ? e : void 0;
    }
    function v1(t) {
      if (!Number.isSafeInteger(t) || t < 0)
        throw new Error("positive integer expected, got " + t);
    }
    function H5(t) {
      return (
        t instanceof Uint8Array ||
        (ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array")
      );
    }
    function oi(t, ...e) {
      if (!H5(t)) throw new Error("Uint8Array expected");
      if (e.length > 0 && !e.includes(t.length))
        throw new Error(
          "Uint8Array expected of length " + e + ", got length=" + t.length
        );
    }
    function V5(t, e = !0) {
      if (t.destroyed) throw new Error("Hash instance has been destroyed");
      if (e && t.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function X$(t, e) {
      oi(t);
      const r = e.outputLen;
      if (t.length < r)
        throw new Error(
          "digestInto() expects output buffer of length at least " + r
        );
    }
    function W5(t) {
      if (typeof t != "boolean") throw new Error(`boolean expected, not ${t}`);
    }
    const Kn = (t) =>
        new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4)),
      Q$ = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength);
    if (new Uint8Array(new Uint32Array([287454020]).buffer)[0] !== 68)
      throw new Error("Non little-endian hardware is not supported");
    function eF(t) {
      if (typeof t != "string") throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(t));
    }
    function E1(t) {
      if (typeof t == "string") t = eF(t);
      else if (H5(t)) t = C1(t);
      else throw new Error("Uint8Array expected, got " + typeof t);
      return t;
    }
    function tF(t, e) {
      if (e == null || typeof e != "object")
        throw new Error("options must be defined");
      return Object.assign(t, e);
    }
    function rF(t, e) {
      if (t.length !== e.length) return !1;
      let r = 0;
      for (let i = 0; i < t.length; i++) r |= t[i] ^ e[i];
      return r === 0;
    }
    const iF = (t, e) => {
      function r(i, ...s) {
        if ((oi(i), t.nonceLength !== void 0)) {
          const l = s[0];
          if (!l) throw new Error("nonce / iv required");
          t.varSizeNonce ? oi(l) : oi(l, t.nonceLength);
        }
        const n = t.tagLength;
        n && s[1] !== void 0 && oi(s[1]);
        const o = e(i, ...s),
          a = (l, u) => {
            if (u !== void 0) {
              if (l !== 2) throw new Error("cipher output not supported");
              oi(u);
            }
          };
        let c = !1;
        return {
          encrypt(l, u) {
            if (c)
              throw new Error("cannot encrypt() twice with same key + nonce");
            return (c = !0), oi(l), a(o.encrypt.length, u), o.encrypt(l, u);
          },
          decrypt(l, u) {
            if ((oi(l), n && l.length < n))
              throw new Error(
                "invalid ciphertext length: smaller than tagLength=" + n
              );
            return a(o.decrypt.length, u), o.decrypt(l, u);
          },
        };
      }
      return Object.assign(r, t), r;
    };
    function K5(t, e, r = !0) {
      if (e === void 0) return new Uint8Array(t);
      if (e.length !== t)
        throw new Error(
          "invalid output length, expected " + t + ", got: " + e.length
        );
      if (r && !sF(e)) throw new Error("invalid output, must be aligned");
      return e;
    }
    function G5(t, e, r, i) {
      if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, r, i);
      const s = BigInt(32),
        n = BigInt(4294967295),
        o = Number((r >> s) & n),
        a = Number(r & n),
        c = i ? 4 : 0,
        l = i ? 0 : 4;
      t.setUint32(e + c, o, i), t.setUint32(e + l, a, i);
    }
    function sF(t) {
      return t.byteOffset % 4 === 0;
    }
    function C1(t) {
      return Uint8Array.from(t);
    }
    function pc(...t) {
      for (let e = 0; e < t.length; e++) t[e].fill(0);
    }
    const Z5 = (t) => Uint8Array.from(t.split("").map((e) => e.charCodeAt(0))),
      nF = Z5("expand 16-byte k"),
      oF = Z5("expand 32-byte k"),
      aF = Kn(nF),
      cF = Kn(oF);
    function Be(t, e) {
      return (t << e) | (t >>> (32 - e));
    }
    function x1(t) {
      return t.byteOffset % 4 === 0;
    }
    const vp = 64,
      lF = 16,
      Y5 = 2 ** 32 - 1,
      J5 = new Uint32Array();
    function uF(t, e, r, i, s, n, o, a) {
      const c = s.length,
        l = new Uint8Array(vp),
        u = Kn(l),
        h = x1(s) && x1(n),
        d = h ? Kn(s) : J5,
        g = h ? Kn(n) : J5;
      for (let p = 0; p < c; o++) {
        if ((t(e, r, i, u, o, a), o >= Y5))
          throw new Error("arx: counter overflow");
        const w = Math.min(vp, c - p);
        if (h && w === vp) {
          const f = p / 4;
          if (p % 4 !== 0) throw new Error("arx: invalid block position");
          for (let m = 0, y; m < lF; m++) (y = f + m), (g[y] = d[y] ^ u[m]);
          p += vp;
          continue;
        }
        for (let f = 0, m; f < w; f++) (m = p + f), (n[m] = s[m] ^ l[f]);
        p += w;
      }
    }
    function hF(t, e) {
      const {
        allowShortKeys: r,
        extendNonceFn: i,
        counterLength: s,
        counterRight: n,
        rounds: o,
      } = tF(
        { allowShortKeys: !1, counterLength: 8, counterRight: !1, rounds: 20 },
        e
      );
      if (typeof t != "function") throw new Error("core must be a function");
      return (
        v1(s),
        v1(o),
        W5(n),
        W5(r),
        (a, c, l, u, h = 0) => {
          oi(a), oi(c), oi(l);
          const d = l.length;
          if (
            (u === void 0 && (u = new Uint8Array(d)),
            oi(u),
            v1(h),
            h < 0 || h >= Y5)
          )
            throw new Error("arx: counter overflow");
          if (u.length < d)
            throw new Error(
              `arx: output (${u.length}) is shorter than data (${d})`
            );
          const g = [];
          let p = a.length,
            w,
            f;
          if (p === 32) g.push((w = C1(a))), (f = cF);
          else if (p === 16 && r)
            (w = new Uint8Array(32)),
              w.set(a),
              w.set(a, 16),
              (f = aF),
              g.push(w);
          else throw new Error(`arx: invalid 32-byte key, got length=${p}`);
          x1(c) || g.push((c = C1(c)));
          const m = Kn(w);
          if (i) {
            if (c.length !== 24)
              throw new Error("arx: extended nonce must be 24 bytes");
            i(f, m, Kn(c.subarray(0, 16)), m), (c = c.subarray(16));
          }
          const y = 16 - s;
          if (y !== c.length)
            throw new Error(`arx: nonce must be ${y} or 16 bytes`);
          if (y !== 12) {
            const C = new Uint8Array(12);
            C.set(c, n ? 0 : 12 - c.length), (c = C), g.push(c);
          }
          const E = Kn(c);
          return uF(t, f, m, E, l, u, h, o), pc(...g), u;
        }
      );
    }
    const ur = (t, e) => (t[e++] & 255) | ((t[e++] & 255) << 8);
    class dF {
      constructor(e) {
        (this.blockLen = 16),
          (this.outputLen = 16),
          (this.buffer = new Uint8Array(16)),
          (this.r = new Uint16Array(10)),
          (this.h = new Uint16Array(10)),
          (this.pad = new Uint16Array(8)),
          (this.pos = 0),
          (this.finished = !1),
          (e = E1(e)),
          oi(e, 32);
        const r = ur(e, 0),
          i = ur(e, 2),
          s = ur(e, 4),
          n = ur(e, 6),
          o = ur(e, 8),
          a = ur(e, 10),
          c = ur(e, 12),
          l = ur(e, 14);
        (this.r[0] = r & 8191),
          (this.r[1] = ((r >>> 13) | (i << 3)) & 8191),
          (this.r[2] = ((i >>> 10) | (s << 6)) & 7939),
          (this.r[3] = ((s >>> 7) | (n << 9)) & 8191),
          (this.r[4] = ((n >>> 4) | (o << 12)) & 255),
          (this.r[5] = (o >>> 1) & 8190),
          (this.r[6] = ((o >>> 14) | (a << 2)) & 8191),
          (this.r[7] = ((a >>> 11) | (c << 5)) & 8065),
          (this.r[8] = ((c >>> 8) | (l << 8)) & 8191),
          (this.r[9] = (l >>> 5) & 127);
        for (let u = 0; u < 8; u++) this.pad[u] = ur(e, 16 + 2 * u);
      }
      process(e, r, i = !1) {
        const s = i ? 0 : 2048,
          { h: n, r: o } = this,
          a = o[0],
          c = o[1],
          l = o[2],
          u = o[3],
          h = o[4],
          d = o[5],
          g = o[6],
          p = o[7],
          w = o[8],
          f = o[9],
          m = ur(e, r + 0),
          y = ur(e, r + 2),
          E = ur(e, r + 4),
          C = ur(e, r + 6),
          O = ur(e, r + 8),
          A = ur(e, r + 10),
          P = ur(e, r + 12),
          N = ur(e, r + 14);
        let x = n[0] + (m & 8191),
          $ = n[1] + (((m >>> 13) | (y << 3)) & 8191),
          k = n[2] + (((y >>> 10) | (E << 6)) & 8191),
          F = n[3] + (((E >>> 7) | (C << 9)) & 8191),
          j = n[4] + (((C >>> 4) | (O << 12)) & 8191),
          I = n[5] + ((O >>> 1) & 8191),
          b = n[6] + (((O >>> 14) | (A << 2)) & 8191),
          v = n[7] + (((A >>> 11) | (P << 5)) & 8191),
          S = n[8] + (((P >>> 8) | (N << 8)) & 8191),
          T = n[9] + ((N >>> 5) | s),
          _ = 0,
          R = _ + x * a + $ * (5 * f) + k * (5 * w) + F * (5 * p) + j * (5 * g);
        (_ = R >>> 13),
          (R &= 8191),
          (R +=
            I * (5 * d) +
            b * (5 * h) +
            v * (5 * u) +
            S * (5 * l) +
            T * (5 * c)),
          (_ += R >>> 13),
          (R &= 8191);
        let U = _ + x * c + $ * a + k * (5 * f) + F * (5 * w) + j * (5 * p);
        (_ = U >>> 13),
          (U &= 8191),
          (U +=
            I * (5 * g) +
            b * (5 * d) +
            v * (5 * h) +
            S * (5 * u) +
            T * (5 * l)),
          (_ += U >>> 13),
          (U &= 8191);
        let D = _ + x * l + $ * c + k * a + F * (5 * f) + j * (5 * w);
        (_ = D >>> 13),
          (D &= 8191),
          (D +=
            I * (5 * p) +
            b * (5 * g) +
            v * (5 * d) +
            S * (5 * h) +
            T * (5 * u)),
          (_ += D >>> 13),
          (D &= 8191);
        let H = _ + x * u + $ * l + k * c + F * a + j * (5 * f);
        (_ = H >>> 13),
          (H &= 8191),
          (H +=
            I * (5 * w) +
            b * (5 * p) +
            v * (5 * g) +
            S * (5 * d) +
            T * (5 * h)),
          (_ += H >>> 13),
          (H &= 8191);
        let q = _ + x * h + $ * u + k * l + F * c + j * a;
        (_ = q >>> 13),
          (q &= 8191),
          (q +=
            I * (5 * f) +
            b * (5 * w) +
            v * (5 * p) +
            S * (5 * g) +
            T * (5 * d)),
          (_ += q >>> 13),
          (q &= 8191);
        let V = _ + x * d + $ * h + k * u + F * l + j * c;
        (_ = V >>> 13),
          (V &= 8191),
          (V += I * a + b * (5 * f) + v * (5 * w) + S * (5 * p) + T * (5 * g)),
          (_ += V >>> 13),
          (V &= 8191);
        let Y = _ + x * g + $ * d + k * h + F * u + j * l;
        (_ = Y >>> 13),
          (Y &= 8191),
          (Y += I * c + b * a + v * (5 * f) + S * (5 * w) + T * (5 * p)),
          (_ += Y >>> 13),
          (Y &= 8191);
        let ae = _ + x * p + $ * g + k * d + F * h + j * u;
        (_ = ae >>> 13),
          (ae &= 8191),
          (ae += I * l + b * c + v * a + S * (5 * f) + T * (5 * w)),
          (_ += ae >>> 13),
          (ae &= 8191);
        let re = _ + x * w + $ * p + k * g + F * d + j * h;
        (_ = re >>> 13),
          (re &= 8191),
          (re += I * u + b * l + v * c + S * a + T * (5 * f)),
          (_ += re >>> 13),
          (re &= 8191);
        let te = _ + x * f + $ * w + k * p + F * g + j * d;
        (_ = te >>> 13),
          (te &= 8191),
          (te += I * h + b * u + v * l + S * c + T * a),
          (_ += te >>> 13),
          (te &= 8191),
          (_ = ((_ << 2) + _) | 0),
          (_ = (_ + R) | 0),
          (R = _ & 8191),
          (_ = _ >>> 13),
          (U += _),
          (n[0] = R),
          (n[1] = U),
          (n[2] = D),
          (n[3] = H),
          (n[4] = q),
          (n[5] = V),
          (n[6] = Y),
          (n[7] = ae),
          (n[8] = re),
          (n[9] = te);
      }
      finalize() {
        const { h: e, pad: r } = this,
          i = new Uint16Array(10);
        let s = e[1] >>> 13;
        e[1] &= 8191;
        for (let a = 2; a < 10; a++)
          (e[a] += s), (s = e[a] >>> 13), (e[a] &= 8191);
        (e[0] += s * 5),
          (s = e[0] >>> 13),
          (e[0] &= 8191),
          (e[1] += s),
          (s = e[1] >>> 13),
          (e[1] &= 8191),
          (e[2] += s),
          (i[0] = e[0] + 5),
          (s = i[0] >>> 13),
          (i[0] &= 8191);
        for (let a = 1; a < 10; a++)
          (i[a] = e[a] + s), (s = i[a] >>> 13), (i[a] &= 8191);
        i[9] -= 8192;
        let n = (s ^ 1) - 1;
        for (let a = 0; a < 10; a++) i[a] &= n;
        n = ~n;
        for (let a = 0; a < 10; a++) e[a] = (e[a] & n) | i[a];
        (e[0] = (e[0] | (e[1] << 13)) & 65535),
          (e[1] = ((e[1] >>> 3) | (e[2] << 10)) & 65535),
          (e[2] = ((e[2] >>> 6) | (e[3] << 7)) & 65535),
          (e[3] = ((e[3] >>> 9) | (e[4] << 4)) & 65535),
          (e[4] = ((e[4] >>> 12) | (e[5] << 1) | (e[6] << 14)) & 65535),
          (e[5] = ((e[6] >>> 2) | (e[7] << 11)) & 65535),
          (e[6] = ((e[7] >>> 5) | (e[8] << 8)) & 65535),
          (e[7] = ((e[8] >>> 8) | (e[9] << 5)) & 65535);
        let o = e[0] + r[0];
        e[0] = o & 65535;
        for (let a = 1; a < 8; a++)
          (o = (((e[a] + r[a]) | 0) + (o >>> 16)) | 0), (e[a] = o & 65535);
        pc(i);
      }
      update(e) {
        V5(this);
        const { buffer: r, blockLen: i } = this;
        e = E1(e);
        const s = e.length;
        for (let n = 0; n < s; ) {
          const o = Math.min(i - this.pos, s - n);
          if (o === i) {
            for (; i <= s - n; n += i) this.process(e, n);
            continue;
          }
          r.set(e.subarray(n, n + o), this.pos),
            (this.pos += o),
            (n += o),
            this.pos === i && (this.process(r, 0, !1), (this.pos = 0));
        }
        return this;
      }
      destroy() {
        pc(this.h, this.r, this.buffer, this.pad);
      }
      digestInto(e) {
        V5(this), X$(e, this), (this.finished = !0);
        const { buffer: r, h: i } = this;
        let { pos: s } = this;
        if (s) {
          for (r[s++] = 1; s < 16; s++) r[s] = 0;
          this.process(r, 0, !0);
        }
        this.finalize();
        let n = 0;
        for (let o = 0; o < 8; o++)
          (e[n++] = i[o] >>> 0), (e[n++] = i[o] >>> 8);
        return e;
      }
      digest() {
        const { buffer: e, outputLen: r } = this;
        this.digestInto(e);
        const i = e.slice(0, r);
        return this.destroy(), i;
      }
    }
    function pF(t) {
      const e = (i, s) => t(s).update(E1(i)).digest(),
        r = t(new Uint8Array(32));
      return (
        (e.outputLen = r.outputLen),
        (e.blockLen = r.blockLen),
        (e.create = (i) => t(i)),
        e
      );
    }
    const fF = pF((t) => new dF(t));
    function gF(t, e, r, i, s, n = 20) {
      let o = t[0],
        a = t[1],
        c = t[2],
        l = t[3],
        u = e[0],
        h = e[1],
        d = e[2],
        g = e[3],
        p = e[4],
        w = e[5],
        f = e[6],
        m = e[7],
        y = s,
        E = r[0],
        C = r[1],
        O = r[2],
        A = o,
        P = a,
        N = c,
        x = l,
        $ = u,
        k = h,
        F = d,
        j = g,
        I = p,
        b = w,
        v = f,
        S = m,
        T = y,
        _ = E,
        R = C,
        U = O;
      for (let H = 0; H < n; H += 2)
        (A = (A + $) | 0),
          (T = Be(T ^ A, 16)),
          (I = (I + T) | 0),
          ($ = Be($ ^ I, 12)),
          (A = (A + $) | 0),
          (T = Be(T ^ A, 8)),
          (I = (I + T) | 0),
          ($ = Be($ ^ I, 7)),
          (P = (P + k) | 0),
          (_ = Be(_ ^ P, 16)),
          (b = (b + _) | 0),
          (k = Be(k ^ b, 12)),
          (P = (P + k) | 0),
          (_ = Be(_ ^ P, 8)),
          (b = (b + _) | 0),
          (k = Be(k ^ b, 7)),
          (N = (N + F) | 0),
          (R = Be(R ^ N, 16)),
          (v = (v + R) | 0),
          (F = Be(F ^ v, 12)),
          (N = (N + F) | 0),
          (R = Be(R ^ N, 8)),
          (v = (v + R) | 0),
          (F = Be(F ^ v, 7)),
          (x = (x + j) | 0),
          (U = Be(U ^ x, 16)),
          (S = (S + U) | 0),
          (j = Be(j ^ S, 12)),
          (x = (x + j) | 0),
          (U = Be(U ^ x, 8)),
          (S = (S + U) | 0),
          (j = Be(j ^ S, 7)),
          (A = (A + k) | 0),
          (U = Be(U ^ A, 16)),
          (v = (v + U) | 0),
          (k = Be(k ^ v, 12)),
          (A = (A + k) | 0),
          (U = Be(U ^ A, 8)),
          (v = (v + U) | 0),
          (k = Be(k ^ v, 7)),
          (P = (P + F) | 0),
          (T = Be(T ^ P, 16)),
          (S = (S + T) | 0),
          (F = Be(F ^ S, 12)),
          (P = (P + F) | 0),
          (T = Be(T ^ P, 8)),
          (S = (S + T) | 0),
          (F = Be(F ^ S, 7)),
          (N = (N + j) | 0),
          (_ = Be(_ ^ N, 16)),
          (I = (I + _) | 0),
          (j = Be(j ^ I, 12)),
          (N = (N + j) | 0),
          (_ = Be(_ ^ N, 8)),
          (I = (I + _) | 0),
          (j = Be(j ^ I, 7)),
          (x = (x + $) | 0),
          (R = Be(R ^ x, 16)),
          (b = (b + R) | 0),
          ($ = Be($ ^ b, 12)),
          (x = (x + $) | 0),
          (R = Be(R ^ x, 8)),
          (b = (b + R) | 0),
          ($ = Be($ ^ b, 7));
      let D = 0;
      (i[D++] = (o + A) | 0),
        (i[D++] = (a + P) | 0),
        (i[D++] = (c + N) | 0),
        (i[D++] = (l + x) | 0),
        (i[D++] = (u + $) | 0),
        (i[D++] = (h + k) | 0),
        (i[D++] = (d + F) | 0),
        (i[D++] = (g + j) | 0),
        (i[D++] = (p + I) | 0),
        (i[D++] = (w + b) | 0),
        (i[D++] = (f + v) | 0),
        (i[D++] = (m + S) | 0),
        (i[D++] = (y + T) | 0),
        (i[D++] = (E + _) | 0),
        (i[D++] = (C + R) | 0),
        (i[D++] = (O + U) | 0);
    }
    const wF = hF(gF, {
        counterRight: !1,
        counterLength: 4,
        allowShortKeys: !1,
      }),
      mF = new Uint8Array(16),
      X5 = (t, e) => {
        t.update(e);
        const r = e.length % 16;
        r && t.update(mF.subarray(r));
      },
      yF = new Uint8Array(32);
    function Q5(t, e, r, i, s) {
      const n = t(e, r, yF),
        o = fF.create(n);
      s && X5(o, s), X5(o, i);
      const a = new Uint8Array(16),
        c = Q$(a);
      G5(c, 0, BigInt(s ? s.length : 0), !0),
        G5(c, 8, BigInt(i.length), !0),
        o.update(a);
      const l = o.digest();
      return pc(n, a), l;
    }
    const bF = (t) => (e, r, i) => ({
        encrypt(s, n) {
          const o = s.length;
          (n = K5(o + 16, n, !1)), n.set(s);
          const a = n.subarray(0, -16);
          t(e, r, a, a, 1);
          const c = Q5(t, e, r, a, i);
          return n.set(c, o), pc(c), n;
        },
        decrypt(s, n) {
          n = K5(s.length - 16, n, !1);
          const o = s.subarray(0, -16),
            a = s.subarray(-16),
            c = Q5(t, e, r, o, i);
          if (!rF(a, c)) throw new Error("invalid tag");
          return n.set(s.subarray(0, -16)), t(e, r, n, n, 1), pc(c), n;
        },
      }),
      e4 = iF({ blockSize: 64, nonceLength: 12, tagLength: 16 }, bF(wF));
    class t4 extends w1 {
      constructor(e, r) {
        super(), (this.finished = !1), (this.destroyed = !1), f1(e);
        const i = hc(r);
        if (((this.iHash = e.create()), typeof this.iHash.update != "function"))
          throw new Error(
            "Expected instance of class which extends utils.Hash"
          );
        (this.blockLen = this.iHash.blockLen),
          (this.outputLen = this.iHash.outputLen);
        const s = this.blockLen,
          n = new Uint8Array(s);
        n.set(i.length > s ? e.create().update(i).digest() : i);
        for (let o = 0; o < n.length; o++) n[o] ^= 54;
        this.iHash.update(n), (this.oHash = e.create());
        for (let o = 0; o < n.length; o++) n[o] ^= 106;
        this.oHash.update(n), n.fill(0);
      }
      update(e) {
        return lc(this), this.iHash.update(e), this;
      }
      digestInto(e) {
        lc(this),
          wu(e, this.outputLen),
          (this.finished = !0),
          this.iHash.digestInto(e),
          this.oHash.update(e),
          this.oHash.digestInto(e),
          this.destroy();
      }
      digest() {
        const e = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(e), e;
      }
      _cloneInto(e) {
        e || (e = Object.create(Object.getPrototypeOf(this), {}));
        const {
          oHash: r,
          iHash: i,
          finished: s,
          destroyed: n,
          blockLen: o,
          outputLen: a,
        } = this;
        return (
          (e = e),
          (e.finished = s),
          (e.destroyed = n),
          (e.blockLen = o),
          (e.outputLen = a),
          (e.oHash = r._cloneInto(e.oHash)),
          (e.iHash = i._cloneInto(e.iHash)),
          e
        );
      }
      destroy() {
        (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
      }
    }
    const Ep = (t, e, r) => new t4(t, e).update(r).digest();
    Ep.create = (t, e) => new t4(t, e);
    function vF(t, e, r) {
      return (
        f1(t),
        r === void 0 && (r = new Uint8Array(t.outputLen)),
        Ep(t, hc(r), hc(e))
      );
    }
    const I1 = new Uint8Array([0]),
      r4 = new Uint8Array();
    function EF(t, e, r, i = 32) {
      if ((f1(t), gu(i), i > 255 * t.outputLen))
        throw new Error("Length should be <= 255*HashLen");
      const s = Math.ceil(i / t.outputLen);
      r === void 0 && (r = r4);
      const n = new Uint8Array(s * t.outputLen),
        o = Ep.create(t, e),
        a = o._cloneInto(),
        c = new Uint8Array(o.outputLen);
      for (let l = 0; l < s; l++)
        (I1[0] = l + 1),
          a
            .update(l === 0 ? r4 : c)
            .update(r)
            .update(I1)
            .digestInto(c),
          n.set(c, t.outputLen * l),
          o._cloneInto(a);
      return o.destroy(), a.destroy(), c.fill(0), I1.fill(0), n.slice(0, i);
    }
    const CF = (t, e, r, i, s) => EF(t, vF(t, e, r), i, s);
    function xF(t, e, r, i) {
      if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, r, i);
      const s = BigInt(32),
        n = BigInt(4294967295),
        o = Number((r >> s) & n),
        a = Number(r & n),
        c = i ? 4 : 0,
        l = i ? 0 : 4;
      t.setUint32(e + c, o, i), t.setUint32(e + l, a, i);
    }
    function IF(t, e, r) {
      return (t & e) ^ (~t & r);
    }
    function _F(t, e, r) {
      return (t & e) ^ (t & r) ^ (e & r);
    }
    class AF extends w1 {
      constructor(e, r, i, s) {
        super(),
          (this.blockLen = e),
          (this.outputLen = r),
          (this.padOffset = i),
          (this.isLE = s),
          (this.finished = !1),
          (this.length = 0),
          (this.pos = 0),
          (this.destroyed = !1),
          (this.buffer = new Uint8Array(e)),
          (this.view = g1(this.buffer));
      }
      update(e) {
        lc(this);
        const { view: r, buffer: i, blockLen: s } = this;
        e = hc(e);
        const n = e.length;
        for (let o = 0; o < n; ) {
          const a = Math.min(s - this.pos, n - o);
          if (a === s) {
            const c = g1(e);
            for (; s <= n - o; o += s) this.process(c, o);
            continue;
          }
          i.set(e.subarray(o, o + a), this.pos),
            (this.pos += a),
            (o += a),
            this.pos === s && (this.process(r, 0), (this.pos = 0));
        }
        return (this.length += e.length), this.roundClean(), this;
      }
      digestInto(e) {
        lc(this), A5(e, this), (this.finished = !0);
        const { buffer: r, view: i, blockLen: s, isLE: n } = this;
        let { pos: o } = this;
        (r[o++] = 128),
          this.buffer.subarray(o).fill(0),
          this.padOffset > s - o && (this.process(i, 0), (o = 0));
        for (let h = o; h < s; h++) r[h] = 0;
        xF(i, s - 8, BigInt(this.length * 8), n), this.process(i, 0);
        const a = g1(e),
          c = this.outputLen;
        if (c % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const l = c / 4,
          u = this.get();
        if (l > u.length) throw new Error("_sha2: outputLen bigger than state");
        for (let h = 0; h < l; h++) a.setUint32(4 * h, u[h], n);
      }
      digest() {
        const { buffer: e, outputLen: r } = this;
        this.digestInto(e);
        const i = e.slice(0, r);
        return this.destroy(), i;
      }
      _cloneInto(e) {
        e || (e = new this.constructor()), e.set(...this.get());
        const {
          blockLen: r,
          buffer: i,
          length: s,
          finished: n,
          destroyed: o,
          pos: a,
        } = this;
        return (
          (e.length = s),
          (e.pos = a),
          (e.finished = n),
          (e.destroyed = o),
          s % r && e.buffer.set(i),
          e
        );
      }
    }
    const SF = new Uint32Array([
        1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
        2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
        1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
        264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
        2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
        113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
        1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
        3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
        430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
        1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
        2428436474, 2756734187, 3204031479, 3329325298,
      ]),
      Gn = new Uint32Array([
        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924,
        528734635, 1541459225,
      ]),
      Zn = new Uint32Array(64);
    class PF extends AF {
      constructor() {
        super(64, 32, 8, !1),
          (this.A = Gn[0] | 0),
          (this.B = Gn[1] | 0),
          (this.C = Gn[2] | 0),
          (this.D = Gn[3] | 0),
          (this.E = Gn[4] | 0),
          (this.F = Gn[5] | 0),
          (this.G = Gn[6] | 0),
          (this.H = Gn[7] | 0);
      }
      get() {
        const { A: e, B: r, C: i, D: s, E: n, F: o, G: a, H: c } = this;
        return [e, r, i, s, n, o, a, c];
      }
      set(e, r, i, s, n, o, a, c) {
        (this.A = e | 0),
          (this.B = r | 0),
          (this.C = i | 0),
          (this.D = s | 0),
          (this.E = n | 0),
          (this.F = o | 0),
          (this.G = a | 0),
          (this.H = c | 0);
      }
      process(e, r) {
        for (let h = 0; h < 16; h++, r += 4) Zn[h] = e.getUint32(r, !1);
        for (let h = 16; h < 64; h++) {
          const d = Zn[h - 15],
            g = Zn[h - 2],
            p = Es(d, 7) ^ Es(d, 18) ^ (d >>> 3),
            w = Es(g, 17) ^ Es(g, 19) ^ (g >>> 10);
          Zn[h] = (w + Zn[h - 7] + p + Zn[h - 16]) | 0;
        }
        let { A: i, B: s, C: n, D: o, E: a, F: c, G: l, H: u } = this;
        for (let h = 0; h < 64; h++) {
          const d = Es(a, 6) ^ Es(a, 11) ^ Es(a, 25),
            g = (u + d + IF(a, c, l) + SF[h] + Zn[h]) | 0,
            p = ((Es(i, 2) ^ Es(i, 13) ^ Es(i, 22)) + _F(i, s, n)) | 0;
          (u = l),
            (l = c),
            (c = a),
            (a = (o + g) | 0),
            (o = n),
            (n = s),
            (s = i),
            (i = (g + p) | 0);
        }
        (i = (i + this.A) | 0),
          (s = (s + this.B) | 0),
          (n = (n + this.C) | 0),
          (o = (o + this.D) | 0),
          (a = (a + this.E) | 0),
          (c = (c + this.F) | 0),
          (l = (l + this.G) | 0),
          (u = (u + this.H) | 0),
          this.set(i, s, n, o, a, c, l, u);
      }
      roundClean() {
        Zn.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
      }
    }
    const bu = N5(() => new PF());
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Cp =
        BigInt(0),
      xp = BigInt(1),
      OF = BigInt(2);
    function Uo(t) {
      return (
        t instanceof Uint8Array ||
        (ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array")
      );
    }
    function vu(t) {
      if (!Uo(t)) throw new Error("Uint8Array expected");
    }
    function fc(t, e) {
      if (typeof e != "boolean")
        throw new Error(t + " boolean expected, got " + e);
    }
    const NF = Array.from({ length: 256 }, (t, e) =>
      e.toString(16).padStart(2, "0")
    );
    function gc(t) {
      vu(t);
      let e = "";
      for (let r = 0; r < t.length; r++) e += NF[t[r]];
      return e;
    }
    function wc(t) {
      const e = t.toString(16);
      return e.length & 1 ? "0" + e : e;
    }
    function _1(t) {
      if (typeof t != "string")
        throw new Error("hex string expected, got " + typeof t);
      return t === "" ? Cp : BigInt("0x" + t);
    }
    const Ys = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function i4(t) {
      if (t >= Ys._0 && t <= Ys._9) return t - Ys._0;
      if (t >= Ys.A && t <= Ys.F) return t - (Ys.A - 10);
      if (t >= Ys.a && t <= Ys.f) return t - (Ys.a - 10);
    }
    function mc(t) {
      if (typeof t != "string")
        throw new Error("hex string expected, got " + typeof t);
      const e = t.length,
        r = e / 2;
      if (e % 2)
        throw new Error("hex string expected, got unpadded hex of length " + e);
      const i = new Uint8Array(r);
      for (let s = 0, n = 0; s < r; s++, n += 2) {
        const o = i4(t.charCodeAt(n)),
          a = i4(t.charCodeAt(n + 1));
        if (o === void 0 || a === void 0) {
          const c = t[n] + t[n + 1];
          throw new Error(
            'hex string expected, got non-hex character "' +
              c +
              '" at index ' +
              n
          );
        }
        i[s] = o * 16 + a;
      }
      return i;
    }
    function Do(t) {
      return _1(gc(t));
    }
    function Eu(t) {
      return vu(t), _1(gc(Uint8Array.from(t).reverse()));
    }
    function yc(t, e) {
      return mc(t.toString(16).padStart(e * 2, "0"));
    }
    function Ip(t, e) {
      return yc(t, e).reverse();
    }
    function TF(t) {
      return mc(wc(t));
    }
    function ai(t, e, r) {
      let i;
      if (typeof e == "string")
        try {
          i = mc(e);
        } catch (n) {
          throw new Error(t + " must be hex string or Uint8Array, cause: " + n);
        }
      else if (Uo(e)) i = Uint8Array.from(e);
      else throw new Error(t + " must be hex string or Uint8Array");
      const s = i.length;
      if (typeof r == "number" && s !== r)
        throw new Error(t + " of length " + r + " expected, got " + s);
      return i;
    }
    function Cu(...t) {
      let e = 0;
      for (let i = 0; i < t.length; i++) {
        const s = t[i];
        vu(s), (e += s.length);
      }
      const r = new Uint8Array(e);
      for (let i = 0, s = 0; i < t.length; i++) {
        const n = t[i];
        r.set(n, s), (s += n.length);
      }
      return r;
    }
    function kF(t, e) {
      if (t.length !== e.length) return !1;
      let r = 0;
      for (let i = 0; i < t.length; i++) r |= t[i] ^ e[i];
      return r === 0;
    }
    function RF(t) {
      if (typeof t != "string") throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(t));
    }
    const A1 = (t) => typeof t == "bigint" && Cp <= t;
    function _p(t, e, r) {
      return A1(t) && A1(e) && A1(r) && e <= t && t < r;
    }
    function Js(t, e, r, i) {
      if (!_p(e, r, i))
        throw new Error(
          "expected valid " + t + ": " + r + " <= n < " + i + ", got " + e
        );
    }
    function s4(t) {
      let e;
      for (e = 0; t > Cp; t >>= xp, e += 1);
      return e;
    }
    function $F(t, e) {
      return (t >> BigInt(e)) & xp;
    }
    function FF(t, e, r) {
      return t | ((r ? xp : Cp) << BigInt(e));
    }
    const S1 = (t) => (OF << BigInt(t - 1)) - xp,
      P1 = (t) => new Uint8Array(t),
      n4 = (t) => Uint8Array.from(t);
    function o4(t, e, r) {
      if (typeof t != "number" || t < 2)
        throw new Error("hashLen must be a number");
      if (typeof e != "number" || e < 2)
        throw new Error("qByteLen must be a number");
      if (typeof r != "function") throw new Error("hmacFn must be a function");
      let i = P1(t),
        s = P1(t),
        n = 0;
      const o = () => {
          i.fill(1), s.fill(0), (n = 0);
        },
        a = (...u) => r(s, i, ...u),
        c = (u = P1()) => {
          (s = a(n4([0]), u)),
            (i = a()),
            u.length !== 0 && ((s = a(n4([1]), u)), (i = a()));
        },
        l = () => {
          if (n++ >= 1e3) throw new Error("drbg: tried 1000 values");
          let u = 0;
          const h = [];
          for (; u < e; ) {
            i = a();
            const d = i.slice();
            h.push(d), (u += i.length);
          }
          return Cu(...h);
        };
      return (u, h) => {
        o(), c(u);
        let d;
        for (; !(d = h(l())); ) c();
        return o(), d;
      };
    }
    const BF = {
      bigint: (t) => typeof t == "bigint",
      function: (t) => typeof t == "function",
      boolean: (t) => typeof t == "boolean",
      string: (t) => typeof t == "string",
      stringOrUint8Array: (t) => typeof t == "string" || Uo(t),
      isSafeInteger: (t) => Number.isSafeInteger(t),
      array: (t) => Array.isArray(t),
      field: (t, e) => e.Fp.isValid(t),
      hash: (t) => typeof t == "function" && Number.isSafeInteger(t.outputLen),
    };
    function bc(t, e, r = {}) {
      const i = (s, n, o) => {
        const a = BF[n];
        if (typeof a != "function")
          throw new Error("invalid validator function");
        const c = t[s];
        if (!(o && c === void 0) && !a(c, t))
          throw new Error(
            "param " + String(s) + " is invalid. Expected " + n + ", got " + c
          );
      };
      for (const [s, n] of Object.entries(e)) i(s, n, !1);
      for (const [s, n] of Object.entries(r)) i(s, n, !0);
      return t;
    }
    const LF = () => {
      throw new Error("not implemented");
    };
    function O1(t) {
      const e = new WeakMap();
      return (r, ...i) => {
        const s = e.get(r);
        if (s !== void 0) return s;
        const n = t(r, ...i);
        return e.set(r, n), n;
      };
    }
    var UF = Object.freeze({
      __proto__: null,
      isBytes: Uo,
      abytes: vu,
      abool: fc,
      bytesToHex: gc,
      numberToHexUnpadded: wc,
      hexToNumber: _1,
      hexToBytes: mc,
      bytesToNumberBE: Do,
      bytesToNumberLE: Eu,
      numberToBytesBE: yc,
      numberToBytesLE: Ip,
      numberToVarBytesBE: TF,
      ensureBytes: ai,
      concatBytes: Cu,
      equalBytes: kF,
      utf8ToBytes: RF,
      inRange: _p,
      aInRange: Js,
      bitLen: s4,
      bitGet: $F,
      bitSet: FF,
      bitMask: S1,
      createHmacDrbg: o4,
      validateObject: bc,
      notImplemented: LF,
      memoized: O1,
    });
    const Kt = BigInt(0),
      At = BigInt(1),
      jo = BigInt(2),
      DF = BigInt(3),
      N1 = BigInt(4),
      a4 = BigInt(5),
      c4 = BigInt(8);
    function Hr(t, e) {
      const r = t % e;
      return r >= Kt ? r : e + r;
    }
    function l4(t, e, r) {
      if (e < Kt) throw new Error("invalid exponent, negatives unsupported");
      if (r <= Kt) throw new Error("invalid modulus");
      if (r === At) return Kt;
      let i = At;
      for (; e > Kt; )
        e & At && (i = (i * t) % r), (t = (t * t) % r), (e >>= At);
      return i;
    }
    function Ji(t, e, r) {
      let i = t;
      for (; e-- > Kt; ) (i *= i), (i %= r);
      return i;
    }
    function T1(t, e) {
      if (t === Kt) throw new Error("invert: expected non-zero number");
      if (e <= Kt)
        throw new Error("invert: expected positive modulus, got " + e);
      let r = Hr(t, e),
        i = e,
        s = Kt,
        n = At;
      for (; r !== Kt; ) {
        const o = i / r,
          a = i % r,
          c = s - n * o;
        (i = r), (r = a), (s = n), (n = c);
      }
      if (i !== At) throw new Error("invert: does not exist");
      return Hr(s, e);
    }
    function jF(t) {
      const e = (t - At) / jo;
      let r, i, s;
      for (r = t - At, i = 0; r % jo === Kt; r /= jo, i++);
      for (s = jo; s < t && l4(s, e, t) !== t - At; s++)
        if (s > 1e3)
          throw new Error("Cannot find square root: likely non-prime P");
      if (i === 1) {
        const o = (t + At) / N1;
        return function (a, c) {
          const l = a.pow(c, o);
          if (!a.eql(a.sqr(l), c)) throw new Error("Cannot find square root");
          return l;
        };
      }
      const n = (r + At) / jo;
      return function (o, a) {
        if (o.pow(a, e) === o.neg(o.ONE))
          throw new Error("Cannot find square root");
        let c = i,
          l = o.pow(o.mul(o.ONE, s), r),
          u = o.pow(a, n),
          h = o.pow(a, r);
        for (; !o.eql(h, o.ONE); ) {
          if (o.eql(h, o.ZERO)) return o.ZERO;
          let d = 1;
          for (let p = o.sqr(h); d < c && !o.eql(p, o.ONE); d++) p = o.sqr(p);
          const g = o.pow(l, At << BigInt(c - d - 1));
          (l = o.sqr(g)), (u = o.mul(u, g)), (h = o.mul(h, l)), (c = d);
        }
        return u;
      };
    }
    function MF(t) {
      if (t % N1 === DF) {
        const e = (t + At) / N1;
        return function (r, i) {
          const s = r.pow(i, e);
          if (!r.eql(r.sqr(s), i)) throw new Error("Cannot find square root");
          return s;
        };
      }
      if (t % c4 === a4) {
        const e = (t - a4) / c4;
        return function (r, i) {
          const s = r.mul(i, jo),
            n = r.pow(s, e),
            o = r.mul(i, n),
            a = r.mul(r.mul(o, jo), n),
            c = r.mul(o, r.sub(a, r.ONE));
          if (!r.eql(r.sqr(c), i)) throw new Error("Cannot find square root");
          return c;
        };
      }
      return jF(t);
    }
    const zF = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN",
    ];
    function qF(t) {
      const e = {
          ORDER: "bigint",
          MASK: "bigint",
          BYTES: "isSafeInteger",
          BITS: "isSafeInteger",
        },
        r = zF.reduce((i, s) => ((i[s] = "function"), i), e);
      return bc(t, r);
    }
    function HF(t, e, r) {
      if (r < Kt) throw new Error("invalid exponent, negatives unsupported");
      if (r === Kt) return t.ONE;
      if (r === At) return e;
      let i = t.ONE,
        s = e;
      for (; r > Kt; ) r & At && (i = t.mul(i, s)), (s = t.sqr(s)), (r >>= At);
      return i;
    }
    function VF(t, e) {
      const r = new Array(e.length),
        i = e.reduce(
          (n, o, a) => (t.is0(o) ? n : ((r[a] = n), t.mul(n, o))),
          t.ONE
        ),
        s = t.inv(i);
      return (
        e.reduceRight(
          (n, o, a) => (t.is0(o) ? n : ((r[a] = t.mul(n, r[a])), t.mul(n, o))),
          s
        ),
        r
      );
    }
    function u4(t, e) {
      const r = e !== void 0 ? e : t.toString(2).length,
        i = Math.ceil(r / 8);
      return { nBitLength: r, nByteLength: i };
    }
    function h4(t, e, r = !1, i = {}) {
      if (t <= Kt)
        throw new Error("invalid field: expected ORDER > 0, got " + t);
      const { nBitLength: s, nByteLength: n } = u4(t, e);
      if (n > 2048)
        throw new Error("invalid field: expected ORDER of <= 2048 bytes");
      let o;
      const a = Object.freeze({
        ORDER: t,
        isLE: r,
        BITS: s,
        BYTES: n,
        MASK: S1(s),
        ZERO: Kt,
        ONE: At,
        create: (c) => Hr(c, t),
        isValid: (c) => {
          if (typeof c != "bigint")
            throw new Error(
              "invalid field element: expected bigint, got " + typeof c
            );
          return Kt <= c && c < t;
        },
        is0: (c) => c === Kt,
        isOdd: (c) => (c & At) === At,
        neg: (c) => Hr(-c, t),
        eql: (c, l) => c === l,
        sqr: (c) => Hr(c * c, t),
        add: (c, l) => Hr(c + l, t),
        sub: (c, l) => Hr(c - l, t),
        mul: (c, l) => Hr(c * l, t),
        pow: (c, l) => HF(a, c, l),
        div: (c, l) => Hr(c * T1(l, t), t),
        sqrN: (c) => c * c,
        addN: (c, l) => c + l,
        subN: (c, l) => c - l,
        mulN: (c, l) => c * l,
        inv: (c) => T1(c, t),
        sqrt: i.sqrt || ((c) => (o || (o = MF(t)), o(a, c))),
        invertBatch: (c) => VF(a, c),
        cmov: (c, l, u) => (u ? l : c),
        toBytes: (c) => (r ? Ip(c, n) : yc(c, n)),
        fromBytes: (c) => {
          if (c.length !== n)
            throw new Error(
              "Field.fromBytes: expected " + n + " bytes, got " + c.length
            );
          return r ? Eu(c) : Do(c);
        },
      });
      return Object.freeze(a);
    }
    function d4(t) {
      if (typeof t != "bigint") throw new Error("field order must be bigint");
      const e = t.toString(2).length;
      return Math.ceil(e / 8);
    }
    function p4(t) {
      const e = d4(t);
      return e + Math.ceil(e / 2);
    }
    function WF(t, e, r = !1) {
      const i = t.length,
        s = d4(e),
        n = p4(e);
      if (i < 16 || i < n || i > 1024)
        throw new Error("expected " + n + "-1024 bytes of input, got " + i);
      const o = r ? Eu(t) : Do(t),
        a = Hr(o, e - At) + At;
      return r ? Ip(a, s) : yc(a, s);
    }
    const f4 = BigInt(0),
      Ap = BigInt(1);
    function k1(t, e) {
      const r = e.negate();
      return t ? r : e;
    }
    function g4(t, e) {
      if (!Number.isSafeInteger(t) || t <= 0 || t > e)
        throw new Error(
          "invalid window size, expected [1.." + e + "], got W=" + t
        );
    }
    function R1(t, e) {
      g4(t, e);
      const r = Math.ceil(e / t) + 1,
        i = 2 ** (t - 1);
      return { windows: r, windowSize: i };
    }
    function KF(t, e) {
      if (!Array.isArray(t)) throw new Error("array expected");
      t.forEach((r, i) => {
        if (!(r instanceof e)) throw new Error("invalid point at index " + i);
      });
    }
    function GF(t, e) {
      if (!Array.isArray(t)) throw new Error("array of scalars expected");
      t.forEach((r, i) => {
        if (!e.isValid(r)) throw new Error("invalid scalar at index " + i);
      });
    }
    const $1 = new WeakMap(),
      w4 = new WeakMap();
    function F1(t) {
      return w4.get(t) || 1;
    }
    function ZF(t, e) {
      return {
        constTimeNegate: k1,
        hasPrecomputes(r) {
          return F1(r) !== 1;
        },
        unsafeLadder(r, i, s = t.ZERO) {
          let n = r;
          for (; i > f4; )
            i & Ap && (s = s.add(n)), (n = n.double()), (i >>= Ap);
          return s;
        },
        precomputeWindow(r, i) {
          const { windows: s, windowSize: n } = R1(i, e),
            o = [];
          let a = r,
            c = a;
          for (let l = 0; l < s; l++) {
            (c = a), o.push(c);
            for (let u = 1; u < n; u++) (c = c.add(a)), o.push(c);
            a = c.double();
          }
          return o;
        },
        wNAF(r, i, s) {
          const { windows: n, windowSize: o } = R1(r, e);
          let a = t.ZERO,
            c = t.BASE;
          const l = BigInt(2 ** r - 1),
            u = 2 ** r,
            h = BigInt(r);
          for (let d = 0; d < n; d++) {
            const g = d * o;
            let p = Number(s & l);
            (s >>= h), p > o && ((p -= u), (s += Ap));
            const w = g,
              f = g + Math.abs(p) - 1,
              m = d % 2 !== 0,
              y = p < 0;
            p === 0 ? (c = c.add(k1(m, i[w]))) : (a = a.add(k1(y, i[f])));
          }
          return { p: a, f: c };
        },
        wNAFUnsafe(r, i, s, n = t.ZERO) {
          const { windows: o, windowSize: a } = R1(r, e),
            c = BigInt(2 ** r - 1),
            l = 2 ** r,
            u = BigInt(r);
          for (let h = 0; h < o; h++) {
            const d = h * a;
            if (s === f4) break;
            let g = Number(s & c);
            if (((s >>= u), g > a && ((g -= l), (s += Ap)), g === 0)) continue;
            let p = i[d + Math.abs(g) - 1];
            g < 0 && (p = p.negate()), (n = n.add(p));
          }
          return n;
        },
        getPrecomputes(r, i, s) {
          let n = $1.get(i);
          return (
            n ||
              ((n = this.precomputeWindow(i, r)), r !== 1 && $1.set(i, s(n))),
            n
          );
        },
        wNAFCached(r, i, s) {
          const n = F1(r);
          return this.wNAF(n, this.getPrecomputes(n, r, s), i);
        },
        wNAFCachedUnsafe(r, i, s, n) {
          const o = F1(r);
          return o === 1
            ? this.unsafeLadder(r, i, n)
            : this.wNAFUnsafe(o, this.getPrecomputes(o, r, s), i, n);
        },
        setWindowSize(r, i) {
          g4(i, e), w4.set(r, i), $1.delete(r);
        },
      };
    }
    function YF(t, e, r, i) {
      if ((KF(r, t), GF(i, e), r.length !== i.length))
        throw new Error("arrays of points and scalars must have equal length");
      const s = t.ZERO,
        n = s4(BigInt(r.length)),
        o = n > 12 ? n - 3 : n > 4 ? n - 2 : n ? 2 : 1,
        a = (1 << o) - 1,
        c = new Array(a + 1).fill(s),
        l = Math.floor((e.BITS - 1) / o) * o;
      let u = s;
      for (let h = l; h >= 0; h -= o) {
        c.fill(s);
        for (let g = 0; g < i.length; g++) {
          const p = i[g],
            w = Number((p >> BigInt(h)) & BigInt(a));
          c[w] = c[w].add(r[g]);
        }
        let d = s;
        for (let g = c.length - 1, p = s; g > 0; g--)
          (p = p.add(c[g])), (d = d.add(p));
        if (((u = u.add(d)), h !== 0))
          for (let g = 0; g < o; g++) u = u.double();
      }
      return u;
    }
    function m4(t) {
      return (
        qF(t.Fp),
        bc(
          t,
          { n: "bigint", h: "bigint", Gx: "field", Gy: "field" },
          { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }
        ),
        Object.freeze(
          u1(Zs(Zs({}, u4(t.n, t.nBitLength)), t), { p: t.Fp.ORDER })
        )
      );
    }
    BigInt(0), BigInt(1), BigInt(2), BigInt(8);
    const vc = BigInt(0),
      B1 = BigInt(1);
    function JF(t) {
      return (
        bc(
          t,
          { a: "bigint" },
          {
            montgomeryBits: "isSafeInteger",
            nByteLength: "isSafeInteger",
            adjustScalarBytes: "function",
            domain: "function",
            powPminus2: "function",
            Gu: "bigint",
          }
        ),
        Object.freeze(Zs({}, t))
      );
    }
    function XF(t) {
      const e = JF(t),
        { P: r } = e,
        i = (y) => Hr(y, r),
        s = e.montgomeryBits,
        n = Math.ceil(s / 8),
        o = e.nByteLength,
        a = e.adjustScalarBytes || ((y) => y),
        c = e.powPminus2 || ((y) => l4(y, r - BigInt(2), r));
      function l(y, E, C) {
        const O = i(y * (E - C));
        return (E = i(E - O)), (C = i(C + O)), [E, C];
      }
      const u = (e.a - BigInt(2)) / BigInt(4);
      function h(y, E) {
        Js("u", y, vc, r), Js("scalar", E, vc, r);
        const C = E,
          O = y;
        let A = B1,
          P = vc,
          N = y,
          x = B1,
          $ = vc,
          k;
        for (let j = BigInt(s - 1); j >= vc; j--) {
          const I = (C >> j) & B1;
          ($ ^= I),
            (k = l($, A, N)),
            (A = k[0]),
            (N = k[1]),
            (k = l($, P, x)),
            (P = k[0]),
            (x = k[1]),
            ($ = I);
          const b = A + P,
            v = i(b * b),
            S = A - P,
            T = i(S * S),
            _ = v - T,
            R = N + x,
            U = N - x,
            D = i(U * b),
            H = i(R * S),
            q = D + H,
            V = D - H;
          (N = i(q * q)),
            (x = i(O * i(V * V))),
            (A = i(v * T)),
            (P = i(_ * (v + i(u * _))));
        }
        (k = l($, A, N)),
          (A = k[0]),
          (N = k[1]),
          (k = l($, P, x)),
          (P = k[0]),
          (x = k[1]);
        const F = c(P);
        return i(A * F);
      }
      function d(y) {
        return Ip(i(y), n);
      }
      function g(y) {
        const E = ai("u coordinate", y, n);
        return o === 32 && (E[31] &= 127), Eu(E);
      }
      function p(y) {
        const E = ai("scalar", y),
          C = E.length;
        if (C !== n && C !== o) {
          let O = "" + n + " or " + o;
          throw new Error("invalid scalar, expected " + O + " bytes, got " + C);
        }
        return Eu(a(E));
      }
      function w(y, E) {
        const C = g(E),
          O = p(y),
          A = h(C, O);
        if (A === vc) throw new Error("invalid private or public key received");
        return d(A);
      }
      const f = d(e.Gu);
      function m(y) {
        return w(y, f);
      }
      return {
        scalarMult: w,
        scalarMultBase: m,
        getSharedSecret: (y, E) => w(y, E),
        getPublicKey: (y) => m(y),
        utils: { randomPrivateKey: () => e.randomBytes(e.nByteLength) },
        GuBytes: f,
      };
    }
    const L1 = BigInt(
      "57896044618658097711785492504343953926634992332820282019728792003956564819949"
    );
    BigInt(0);
    const QF = BigInt(1),
      y4 = BigInt(2),
      eB = BigInt(3),
      tB = BigInt(5);
    BigInt(8);
    function rB(t) {
      const e = BigInt(10),
        r = BigInt(20),
        i = BigInt(40),
        s = BigInt(80),
        n = L1,
        o = (((t * t) % n) * t) % n,
        a = (Ji(o, y4, n) * o) % n,
        c = (Ji(a, QF, n) * t) % n,
        l = (Ji(c, tB, n) * c) % n,
        u = (Ji(l, e, n) * l) % n,
        h = (Ji(u, r, n) * u) % n,
        d = (Ji(h, i, n) * h) % n,
        g = (Ji(d, s, n) * d) % n,
        p = (Ji(g, s, n) * d) % n,
        w = (Ji(p, e, n) * l) % n;
      return { pow_p_5_8: (Ji(w, y4, n) * t) % n, b2: o };
    }
    function iB(t) {
      return (t[0] &= 248), (t[31] &= 127), (t[31] |= 64), t;
    }
    const U1 = XF({
      P: L1,
      a: BigInt(486662),
      montgomeryBits: 255,
      nByteLength: 32,
      Gu: BigInt(9),
      powPminus2: (t) => {
        const e = L1,
          { pow_p_5_8: r, b2: i } = rB(t);
        return Hr(Ji(r, eB, e) * i, e);
      },
      adjustScalarBytes: iB,
      randomBytes: dc,
    });
    function b4(t) {
      t.lowS !== void 0 && fc("lowS", t.lowS),
        t.prehash !== void 0 && fc("prehash", t.prehash);
    }
    function sB(t) {
      const e = m4(t);
      bc(
        e,
        { a: "field", b: "field" },
        {
          allowedPrivateKeyLengths: "array",
          wrapPrivateKey: "boolean",
          isTorsionFree: "function",
          clearCofactor: "function",
          allowInfinityPoint: "boolean",
          fromBytes: "function",
          toBytes: "function",
        }
      );
      const { endo: r, Fp: i, a: s } = e;
      if (r) {
        if (!i.eql(s, i.ZERO))
          throw new Error(
            "invalid endomorphism, can only be defined for Koblitz curves that have a=0"
          );
        if (
          typeof r != "object" ||
          typeof r.beta != "bigint" ||
          typeof r.splitScalar != "function"
        )
          throw new Error(
            "invalid endomorphism, expected beta: bigint and splitScalar: function"
          );
      }
      return Object.freeze(Zs({}, e));
    }
    const { bytesToNumberBE: nB, hexToBytes: oB } = UF;
    class aB extends Error {
      constructor(e = "") {
        super(e);
      }
    }
    const Xs = {
        Err: aB,
        _tlv: {
          encode: (t, e) => {
            const { Err: r } = Xs;
            if (t < 0 || t > 256) throw new r("tlv.encode: wrong tag");
            if (e.length & 1) throw new r("tlv.encode: unpadded data");
            const i = e.length / 2,
              s = wc(i);
            if ((s.length / 2) & 128)
              throw new r("tlv.encode: long form length too big");
            const n = i > 127 ? wc((s.length / 2) | 128) : "";
            return wc(t) + n + s + e;
          },
          decode(t, e) {
            const { Err: r } = Xs;
            let i = 0;
            if (t < 0 || t > 256) throw new r("tlv.encode: wrong tag");
            if (e.length < 2 || e[i++] !== t)
              throw new r("tlv.decode: wrong tlv");
            const s = e[i++],
              n = !!(s & 128);
            let o = 0;
            if (!n) o = s;
            else {
              const c = s & 127;
              if (!c)
                throw new r(
                  "tlv.decode(long): indefinite length not supported"
                );
              if (c > 4)
                throw new r("tlv.decode(long): byte length is too big");
              const l = e.subarray(i, i + c);
              if (l.length !== c)
                throw new r("tlv.decode: length bytes not complete");
              if (l[0] === 0)
                throw new r("tlv.decode(long): zero leftmost byte");
              for (const u of l) o = (o << 8) | u;
              if (((i += c), o < 128))
                throw new r("tlv.decode(long): not minimal encoding");
            }
            const a = e.subarray(i, i + o);
            if (a.length !== o) throw new r("tlv.decode: wrong value length");
            return { v: a, l: e.subarray(i + o) };
          },
        },
        _int: {
          encode(t) {
            const { Err: e } = Xs;
            if (t < Qs)
              throw new e("integer: negative integers are not allowed");
            let r = wc(t);
            if ((Number.parseInt(r[0], 16) & 8 && (r = "00" + r), r.length & 1))
              throw new e("unexpected DER parsing assertion: unpadded hex");
            return r;
          },
          decode(t) {
            const { Err: e } = Xs;
            if (t[0] & 128) throw new e("invalid signature integer: negative");
            if (t[0] === 0 && !(t[1] & 128))
              throw new e(
                "invalid signature integer: unnecessary leading zero"
              );
            return nB(t);
          },
        },
        toSig(t) {
          const { Err: e, _int: r, _tlv: i } = Xs,
            s = typeof t == "string" ? oB(t) : t;
          vu(s);
          const { v: n, l: o } = i.decode(48, s);
          if (o.length)
            throw new e("invalid signature: left bytes after parsing");
          const { v: a, l: c } = i.decode(2, n),
            { v: l, l: u } = i.decode(2, c);
          if (u.length)
            throw new e("invalid signature: left bytes after parsing");
          return { r: r.decode(a), s: r.decode(l) };
        },
        hexFromSig(t) {
          const { _tlv: e, _int: r } = Xs,
            i = e.encode(2, r.encode(t.r)),
            s = e.encode(2, r.encode(t.s)),
            n = i + s;
          return e.encode(48, n);
        },
      },
      Qs = BigInt(0),
      Gt = BigInt(1);
    BigInt(2);
    const v4 = BigInt(3);
    BigInt(4);
    function cB(t) {
      const e = sB(t),
        { Fp: r } = e,
        i = h4(e.n, e.nBitLength),
        s =
          e.toBytes ||
          ((w, f, m) => {
            const y = f.toAffine();
            return Cu(Uint8Array.from([4]), r.toBytes(y.x), r.toBytes(y.y));
          }),
        n =
          e.fromBytes ||
          ((w) => {
            const f = w.subarray(1),
              m = r.fromBytes(f.subarray(0, r.BYTES)),
              y = r.fromBytes(f.subarray(r.BYTES, 2 * r.BYTES));
            return { x: m, y };
          });
      function o(w) {
        const { a: f, b: m } = e,
          y = r.sqr(w),
          E = r.mul(y, w);
        return r.add(r.add(E, r.mul(w, f)), m);
      }
      if (!r.eql(r.sqr(e.Gy), o(e.Gx)))
        throw new Error("bad generator point: equation left != right");
      function a(w) {
        return _p(w, Gt, e.n);
      }
      function c(w) {
        const {
          allowedPrivateKeyLengths: f,
          nByteLength: m,
          wrapPrivateKey: y,
          n: E,
        } = e;
        if (f && typeof w != "bigint") {
          if (
            (Uo(w) && (w = gc(w)),
            typeof w != "string" || !f.includes(w.length))
          )
            throw new Error("invalid private key");
          w = w.padStart(m * 2, "0");
        }
        let C;
        try {
          C = typeof w == "bigint" ? w : Do(ai("private key", w, m));
        } catch {
          throw new Error(
            "invalid private key, expected hex or " +
              m +
              " bytes, got " +
              typeof w
          );
        }
        return y && (C = Hr(C, E)), Js("private key", C, Gt, E), C;
      }
      function l(w) {
        if (!(w instanceof d)) throw new Error("ProjectivePoint expected");
      }
      const u = O1((w, f) => {
          const { px: m, py: y, pz: E } = w;
          if (r.eql(E, r.ONE)) return { x: m, y };
          const C = w.is0();
          f == null && (f = C ? r.ONE : r.inv(E));
          const O = r.mul(m, f),
            A = r.mul(y, f),
            P = r.mul(E, f);
          if (C) return { x: r.ZERO, y: r.ZERO };
          if (!r.eql(P, r.ONE)) throw new Error("invZ was invalid");
          return { x: O, y: A };
        }),
        h = O1((w) => {
          if (w.is0()) {
            if (e.allowInfinityPoint && !r.is0(w.py)) return;
            throw new Error("bad point: ZERO");
          }
          const { x: f, y: m } = w.toAffine();
          if (!r.isValid(f) || !r.isValid(m))
            throw new Error("bad point: x or y not FE");
          const y = r.sqr(m),
            E = o(f);
          if (!r.eql(y, E))
            throw new Error("bad point: equation left != right");
          if (!w.isTorsionFree())
            throw new Error("bad point: not in prime-order subgroup");
          return !0;
        });
      class d {
        constructor(f, m, y) {
          if (
            ((this.px = f),
            (this.py = m),
            (this.pz = y),
            f == null || !r.isValid(f))
          )
            throw new Error("x required");
          if (m == null || !r.isValid(m)) throw new Error("y required");
          if (y == null || !r.isValid(y)) throw new Error("z required");
          Object.freeze(this);
        }
        static fromAffine(f) {
          const { x: m, y } = f || {};
          if (!f || !r.isValid(m) || !r.isValid(y))
            throw new Error("invalid affine point");
          if (f instanceof d) throw new Error("projective point not allowed");
          const E = (C) => r.eql(C, r.ZERO);
          return E(m) && E(y) ? d.ZERO : new d(m, y, r.ONE);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        static normalizeZ(f) {
          const m = r.invertBatch(f.map((y) => y.pz));
          return f.map((y, E) => y.toAffine(m[E])).map(d.fromAffine);
        }
        static fromHex(f) {
          const m = d.fromAffine(n(ai("pointHex", f)));
          return m.assertValidity(), m;
        }
        static fromPrivateKey(f) {
          return d.BASE.multiply(c(f));
        }
        static msm(f, m) {
          return YF(d, i, f, m);
        }
        _setWindowSize(f) {
          p.setWindowSize(this, f);
        }
        assertValidity() {
          h(this);
        }
        hasEvenY() {
          const { y: f } = this.toAffine();
          if (r.isOdd) return !r.isOdd(f);
          throw new Error("Field doesn't support isOdd");
        }
        equals(f) {
          l(f);
          const { px: m, py: y, pz: E } = this,
            { px: C, py: O, pz: A } = f,
            P = r.eql(r.mul(m, A), r.mul(C, E)),
            N = r.eql(r.mul(y, A), r.mul(O, E));
          return P && N;
        }
        negate() {
          return new d(this.px, r.neg(this.py), this.pz);
        }
        double() {
          const { a: f, b: m } = e,
            y = r.mul(m, v4),
            { px: E, py: C, pz: O } = this;
          let A = r.ZERO,
            P = r.ZERO,
            N = r.ZERO,
            x = r.mul(E, E),
            $ = r.mul(C, C),
            k = r.mul(O, O),
            F = r.mul(E, C);
          return (
            (F = r.add(F, F)),
            (N = r.mul(E, O)),
            (N = r.add(N, N)),
            (A = r.mul(f, N)),
            (P = r.mul(y, k)),
            (P = r.add(A, P)),
            (A = r.sub($, P)),
            (P = r.add($, P)),
            (P = r.mul(A, P)),
            (A = r.mul(F, A)),
            (N = r.mul(y, N)),
            (k = r.mul(f, k)),
            (F = r.sub(x, k)),
            (F = r.mul(f, F)),
            (F = r.add(F, N)),
            (N = r.add(x, x)),
            (x = r.add(N, x)),
            (x = r.add(x, k)),
            (x = r.mul(x, F)),
            (P = r.add(P, x)),
            (k = r.mul(C, O)),
            (k = r.add(k, k)),
            (x = r.mul(k, F)),
            (A = r.sub(A, x)),
            (N = r.mul(k, $)),
            (N = r.add(N, N)),
            (N = r.add(N, N)),
            new d(A, P, N)
          );
        }
        add(f) {
          l(f);
          const { px: m, py: y, pz: E } = this,
            { px: C, py: O, pz: A } = f;
          let P = r.ZERO,
            N = r.ZERO,
            x = r.ZERO;
          const $ = e.a,
            k = r.mul(e.b, v4);
          let F = r.mul(m, C),
            j = r.mul(y, O),
            I = r.mul(E, A),
            b = r.add(m, y),
            v = r.add(C, O);
          (b = r.mul(b, v)),
            (v = r.add(F, j)),
            (b = r.sub(b, v)),
            (v = r.add(m, E));
          let S = r.add(C, A);
          return (
            (v = r.mul(v, S)),
            (S = r.add(F, I)),
            (v = r.sub(v, S)),
            (S = r.add(y, E)),
            (P = r.add(O, A)),
            (S = r.mul(S, P)),
            (P = r.add(j, I)),
            (S = r.sub(S, P)),
            (x = r.mul($, v)),
            (P = r.mul(k, I)),
            (x = r.add(P, x)),
            (P = r.sub(j, x)),
            (x = r.add(j, x)),
            (N = r.mul(P, x)),
            (j = r.add(F, F)),
            (j = r.add(j, F)),
            (I = r.mul($, I)),
            (v = r.mul(k, v)),
            (j = r.add(j, I)),
            (I = r.sub(F, I)),
            (I = r.mul($, I)),
            (v = r.add(v, I)),
            (F = r.mul(j, v)),
            (N = r.add(N, F)),
            (F = r.mul(S, v)),
            (P = r.mul(b, P)),
            (P = r.sub(P, F)),
            (F = r.mul(b, j)),
            (x = r.mul(S, x)),
            (x = r.add(x, F)),
            new d(P, N, x)
          );
        }
        subtract(f) {
          return this.add(f.negate());
        }
        is0() {
          return this.equals(d.ZERO);
        }
        wNAF(f) {
          return p.wNAFCached(this, f, d.normalizeZ);
        }
        multiplyUnsafe(f) {
          const { endo: m, n: y } = e;
          Js("scalar", f, Qs, y);
          const E = d.ZERO;
          if (f === Qs) return E;
          if (this.is0() || f === Gt) return this;
          if (!m || p.hasPrecomputes(this))
            return p.wNAFCachedUnsafe(this, f, d.normalizeZ);
          let { k1neg: C, k1: O, k2neg: A, k2: P } = m.splitScalar(f),
            N = E,
            x = E,
            $ = this;
          for (; O > Qs || P > Qs; )
            O & Gt && (N = N.add($)),
              P & Gt && (x = x.add($)),
              ($ = $.double()),
              (O >>= Gt),
              (P >>= Gt);
          return (
            C && (N = N.negate()),
            A && (x = x.negate()),
            (x = new d(r.mul(x.px, m.beta), x.py, x.pz)),
            N.add(x)
          );
        }
        multiply(f) {
          const { endo: m, n: y } = e;
          Js("scalar", f, Gt, y);
          let E, C;
          if (m) {
            const { k1neg: O, k1: A, k2neg: P, k2: N } = m.splitScalar(f);
            let { p: x, f: $ } = this.wNAF(A),
              { p: k, f: F } = this.wNAF(N);
            (x = p.constTimeNegate(O, x)),
              (k = p.constTimeNegate(P, k)),
              (k = new d(r.mul(k.px, m.beta), k.py, k.pz)),
              (E = x.add(k)),
              (C = $.add(F));
          } else {
            const { p: O, f: A } = this.wNAF(f);
            (E = O), (C = A);
          }
          return d.normalizeZ([E, C])[0];
        }
        multiplyAndAddUnsafe(f, m, y) {
          const E = d.BASE,
            C = (A, P) =>
              P === Qs || P === Gt || !A.equals(E)
                ? A.multiplyUnsafe(P)
                : A.multiply(P),
            O = C(this, m).add(C(f, y));
          return O.is0() ? void 0 : O;
        }
        toAffine(f) {
          return u(this, f);
        }
        isTorsionFree() {
          const { h: f, isTorsionFree: m } = e;
          if (f === Gt) return !0;
          if (m) return m(d, this);
          throw new Error(
            "isTorsionFree() has not been declared for the elliptic curve"
          );
        }
        clearCofactor() {
          const { h: f, clearCofactor: m } = e;
          return f === Gt ? this : m ? m(d, this) : this.multiplyUnsafe(e.h);
        }
        toRawBytes(f = !0) {
          return fc("isCompressed", f), this.assertValidity(), s(d, this, f);
        }
        toHex(f = !0) {
          return fc("isCompressed", f), gc(this.toRawBytes(f));
        }
      }
      (d.BASE = new d(e.Gx, e.Gy, r.ONE)),
        (d.ZERO = new d(r.ZERO, r.ONE, r.ZERO));
      const g = e.nBitLength,
        p = ZF(d, e.endo ? Math.ceil(g / 2) : g);
      return {
        CURVE: e,
        ProjectivePoint: d,
        normPrivateKeyToScalar: c,
        weierstrassEquation: o,
        isWithinCurveOrder: a,
      };
    }
    function lB(t) {
      const e = m4(t);
      return (
        bc(
          e,
          { hash: "hash", hmac: "function", randomBytes: "function" },
          { bits2int: "function", bits2int_modN: "function", lowS: "boolean" }
        ),
        Object.freeze(Zs({ lowS: !0 }, e))
      );
    }
    function uB(t) {
      const e = lB(t),
        { Fp: r, n: i } = e,
        s = r.BYTES + 1,
        n = 2 * r.BYTES + 1;
      function o(I) {
        return Hr(I, i);
      }
      function a(I) {
        return T1(I, i);
      }
      const {
          ProjectivePoint: c,
          normPrivateKeyToScalar: l,
          weierstrassEquation: u,
          isWithinCurveOrder: h,
        } = cB(
          u1(Zs({}, e), {
            toBytes(I, b, v) {
              const S = b.toAffine(),
                T = r.toBytes(S.x),
                _ = Cu;
              return (
                fc("isCompressed", v),
                v
                  ? _(Uint8Array.from([b.hasEvenY() ? 2 : 3]), T)
                  : _(Uint8Array.from([4]), T, r.toBytes(S.y))
              );
            },
            fromBytes(I) {
              const b = I.length,
                v = I[0],
                S = I.subarray(1);
              if (b === s && (v === 2 || v === 3)) {
                const T = Do(S);
                if (!_p(T, Gt, r.ORDER))
                  throw new Error("Point is not on curve");
                const _ = u(T);
                let R;
                try {
                  R = r.sqrt(_);
                } catch (D) {
                  const H = D instanceof Error ? ": " + D.message : "";
                  throw new Error("Point is not on curve" + H);
                }
                const U = (R & Gt) === Gt;
                return ((v & 1) === 1) !== U && (R = r.neg(R)), { x: T, y: R };
              } else if (b === n && v === 4) {
                const T = r.fromBytes(S.subarray(0, r.BYTES)),
                  _ = r.fromBytes(S.subarray(r.BYTES, 2 * r.BYTES));
                return { x: T, y: _ };
              } else {
                const T = s,
                  _ = n;
                throw new Error(
                  "invalid Point, expected length of " +
                    T +
                    ", or uncompressed " +
                    _ +
                    ", got " +
                    b
                );
              }
            },
          })
        ),
        d = (I) => gc(yc(I, e.nByteLength));
      function g(I) {
        const b = i >> Gt;
        return I > b;
      }
      function p(I) {
        return g(I) ? o(-I) : I;
      }
      const w = (I, b, v) => Do(I.slice(b, v));
      class f {
        constructor(b, v, S) {
          (this.r = b),
            (this.s = v),
            (this.recovery = S),
            this.assertValidity();
        }
        static fromCompact(b) {
          const v = e.nByteLength;
          return (
            (b = ai("compactSignature", b, v * 2)),
            new f(w(b, 0, v), w(b, v, 2 * v))
          );
        }
        static fromDER(b) {
          const { r: v, s: S } = Xs.toSig(ai("DER", b));
          return new f(v, S);
        }
        assertValidity() {
          Js("r", this.r, Gt, i), Js("s", this.s, Gt, i);
        }
        addRecoveryBit(b) {
          return new f(this.r, this.s, b);
        }
        recoverPublicKey(b) {
          const { r: v, s: S, recovery: T } = this,
            _ = A(ai("msgHash", b));
          if (T == null || ![0, 1, 2, 3].includes(T))
            throw new Error("recovery id invalid");
          const R = T === 2 || T === 3 ? v + e.n : v;
          if (R >= r.ORDER) throw new Error("recovery id 2 or 3 invalid");
          const U = (T & 1) === 0 ? "02" : "03",
            D = c.fromHex(U + d(R)),
            H = a(R),
            q = o(-_ * H),
            V = o(S * H),
            Y = c.BASE.multiplyAndAddUnsafe(D, q, V);
          if (!Y) throw new Error("point at infinify");
          return Y.assertValidity(), Y;
        }
        hasHighS() {
          return g(this.s);
        }
        normalizeS() {
          return this.hasHighS()
            ? new f(this.r, o(-this.s), this.recovery)
            : this;
        }
        toDERRawBytes() {
          return mc(this.toDERHex());
        }
        toDERHex() {
          return Xs.hexFromSig({ r: this.r, s: this.s });
        }
        toCompactRawBytes() {
          return mc(this.toCompactHex());
        }
        toCompactHex() {
          return d(this.r) + d(this.s);
        }
      }
      const m = {
        isValidPrivateKey(I) {
          try {
            return l(I), !0;
          } catch {
            return !1;
          }
        },
        normPrivateKeyToScalar: l,
        randomPrivateKey: () => {
          const I = p4(e.n);
          return WF(e.randomBytes(I), e.n);
        },
        precompute(I = 8, b = c.BASE) {
          return b._setWindowSize(I), b.multiply(BigInt(3)), b;
        },
      };
      function y(I, b = !0) {
        return c.fromPrivateKey(I).toRawBytes(b);
      }
      function E(I) {
        const b = Uo(I),
          v = typeof I == "string",
          S = (b || v) && I.length;
        return b
          ? S === s || S === n
          : v
          ? S === 2 * s || S === 2 * n
          : I instanceof c;
      }
      function C(I, b, v = !0) {
        if (E(I)) throw new Error("first arg must be private key");
        if (!E(b)) throw new Error("second arg must be public key");
        return c.fromHex(b).multiply(l(I)).toRawBytes(v);
      }
      const O =
          e.bits2int ||
          function (I) {
            if (I.length > 8192) throw new Error("input is too large");
            const b = Do(I),
              v = I.length * 8 - e.nBitLength;
            return v > 0 ? b >> BigInt(v) : b;
          },
        A =
          e.bits2int_modN ||
          function (I) {
            return o(O(I));
          },
        P = S1(e.nBitLength);
      function N(I) {
        return Js("num < 2^" + e.nBitLength, I, Qs, P), yc(I, e.nByteLength);
      }
      function x(I, b, v = $) {
        if (["recovered", "canonical"].some((re) => re in v))
          throw new Error("sign() legacy options not supported");
        const { hash: S, randomBytes: T } = e;
        let { lowS: _, prehash: R, extraEntropy: U } = v;
        _ == null && (_ = !0),
          (I = ai("msgHash", I)),
          b4(v),
          R && (I = ai("prehashed msgHash", S(I)));
        const D = A(I),
          H = l(b),
          q = [N(H), N(D)];
        if (U != null && U !== !1) {
          const re = U === !0 ? T(r.BYTES) : U;
          q.push(ai("extraEntropy", re));
        }
        const V = Cu(...q),
          Y = D;
        function ae(re) {
          const te = O(re);
          if (!h(te)) return;
          const ve = a(te),
            Ee = c.BASE.multiply(te).toAffine(),
            Ce = o(Ee.x);
          if (Ce === Qs) return;
          const Ie = o(ve * o(Y + Ce * H));
          if (Ie === Qs) return;
          let mt = (Ee.x === Ce ? 0 : 2) | Number(Ee.y & Gt),
            Ir = Ie;
          return _ && g(Ie) && ((Ir = p(Ie)), (mt ^= 1)), new f(Ce, Ir, mt);
        }
        return { seed: V, k2sig: ae };
      }
      const $ = { lowS: e.lowS, prehash: !1 },
        k = { lowS: e.lowS, prehash: !1 };
      function F(I, b, v = $) {
        const { seed: S, k2sig: T } = x(I, b, v),
          _ = e;
        return o4(_.hash.outputLen, _.nByteLength, _.hmac)(S, T);
      }
      c.BASE._setWindowSize(8);
      function j(I, b, v, S = k) {
        var T;
        const _ = I;
        (b = ai("msgHash", b)), (v = ai("publicKey", v));
        const { lowS: R, prehash: U, format: D } = S;
        if ((b4(S), "strict" in S))
          throw new Error("options.strict was renamed to lowS");
        if (D !== void 0 && D !== "compact" && D !== "der")
          throw new Error("format must be compact or der");
        const H = typeof _ == "string" || Uo(_),
          q =
            !H &&
            !D &&
            typeof _ == "object" &&
            _ !== null &&
            typeof _.r == "bigint" &&
            typeof _.s == "bigint";
        if (!H && !q)
          throw new Error(
            "invalid signature, expected Uint8Array, hex string or Signature instance"
          );
        let V, Y;
        try {
          if ((q && (V = new f(_.r, _.s)), H)) {
            try {
              D !== "compact" && (V = f.fromDER(_));
            } catch (mt) {
              if (!(mt instanceof Xs.Err)) throw mt;
            }
            !V && D !== "der" && (V = f.fromCompact(_));
          }
          Y = c.fromHex(v);
        } catch {
          return !1;
        }
        if (!V || (R && V.hasHighS())) return !1;
        U && (b = e.hash(b));
        const { r: ae, s: re } = V,
          te = A(b),
          ve = a(re),
          Ee = o(te * ve),
          Ce = o(ae * ve),
          Ie =
            (T = c.BASE.multiplyAndAddUnsafe(Y, Ee, Ce)) == null
              ? void 0
              : T.toAffine();
        return Ie ? o(Ie.x) === ae : !1;
      }
      return {
        CURVE: e,
        getPublicKey: y,
        getSharedSecret: C,
        sign: F,
        verify: j,
        ProjectivePoint: c,
        Signature: f,
        utils: m,
      };
    }
    function hB(t) {
      return {
        hash: t,
        hmac: (e, ...r) => Ep(t, e, m$(...r)),
        randomBytes: dc,
      };
    }
    function dB(t, e) {
      const r = (i) => uB(Zs(Zs({}, t), hB(i)));
      return u1(Zs({}, r(e)), { create: r });
    }
    const E4 = h4(
        BigInt(
          "0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"
        )
      ),
      pB = E4.create(BigInt("-3")),
      fB = BigInt(
        "0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"
      ),
      gB = dB(
        {
          a: pB,
          b: fB,
          Fp: E4,
          n: BigInt(
            "0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"
          ),
          Gx: BigInt(
            "0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"
          ),
          Gy: BigInt(
            "0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"
          ),
          h: BigInt(1),
          lowS: !1,
        },
        bu
      ),
      C4 = "base10",
      Tr = "base16",
      Xi = "base64pad",
      Yn = "base64url",
      xu = "utf8",
      x4 = 0,
      en = 1,
      Iu = 2,
      wB = 0,
      I4 = 1,
      _u = 12,
      D1 = 32;
    function mB() {
      const t = U1.utils.randomPrivateKey(),
        e = U1.getPublicKey(t);
      return { privateKey: et(t, Tr), publicKey: et(e, Tr) };
    }
    function j1() {
      const t = dc(D1);
      return et(t, Tr);
    }
    function yB(t, e) {
      const r = U1.getSharedSecret(yt(t, Tr), yt(e, Tr)),
        i = CF(bu, r, void 0, void 0, D1);
      return et(i, Tr);
    }
    function Sp(t) {
      const e = bu(yt(t, Tr));
      return et(e, Tr);
    }
    function Cs(t) {
      const e = bu(yt(t, xu));
      return et(e, Tr);
    }
    function _4(t) {
      return yt(`${t}`, C4);
    }
    function Mo(t) {
      return Number(et(t, C4));
    }
    function A4(t) {
      return t.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
    }
    function S4(t) {
      const e = t.replace(/-/g, "+").replace(/_/g, "/"),
        r = (4 - (e.length % 4)) % 4;
      return e + "=".repeat(r);
    }
    function bB(t) {
      const e = _4(typeof t.type < "u" ? t.type : x4);
      if (Mo(e) === en && typeof t.senderPublicKey > "u")
        throw new Error("Missing sender public key for type 1 envelope");
      const r =
          typeof t.senderPublicKey < "u" ? yt(t.senderPublicKey, Tr) : void 0,
        i = typeof t.iv < "u" ? yt(t.iv, Tr) : dc(_u),
        s = yt(t.symKey, Tr),
        n = e4(s, i).encrypt(yt(t.message, xu)),
        o = P4({ type: e, sealed: n, iv: i, senderPublicKey: r });
      return t.encoding === Yn ? A4(o) : o;
    }
    function vB(t) {
      const e = yt(t.symKey, Tr),
        { sealed: r, iv: i } = Au({ encoded: t.encoded, encoding: t.encoding }),
        s = e4(e, i).decrypt(r);
      if (s === null) throw new Error("Failed to decrypt");
      return et(s, xu);
    }
    function EB(t, e) {
      const r = _4(Iu),
        i = dc(_u),
        s = yt(t, xu),
        n = P4({ type: r, sealed: s, iv: i });
      return e === Yn ? A4(n) : n;
    }
    function CB(t, e) {
      const { sealed: r } = Au({ encoded: t, encoding: e });
      return et(r, xu);
    }
    function P4(t) {
      if (Mo(t.type) === Iu) return et(vs([t.type, t.sealed]), Xi);
      if (Mo(t.type) === en) {
        if (typeof t.senderPublicKey > "u")
          throw new Error("Missing sender public key for type 1 envelope");
        return et(vs([t.type, t.senderPublicKey, t.iv, t.sealed]), Xi);
      }
      return et(vs([t.type, t.iv, t.sealed]), Xi);
    }
    function Au(t) {
      const e = (t.encoding || Xi) === Yn ? S4(t.encoded) : t.encoded,
        r = yt(e, Xi),
        i = r.slice(wB, I4),
        s = I4;
      if (Mo(i) === en) {
        const c = s + D1,
          l = c + _u,
          u = r.slice(s, c),
          h = r.slice(c, l),
          d = r.slice(l);
        return { type: i, sealed: d, iv: h, senderPublicKey: u };
      }
      if (Mo(i) === Iu) {
        const c = r.slice(s),
          l = dc(_u);
        return { type: i, sealed: c, iv: l };
      }
      const n = s + _u,
        o = r.slice(s, n),
        a = r.slice(n);
      return { type: i, sealed: a, iv: o };
    }
    function xB(t, e) {
      const r = Au({ encoded: t, encoding: e?.encoding });
      return O4({
        type: Mo(r.type),
        senderPublicKey:
          typeof r.senderPublicKey < "u" ? et(r.senderPublicKey, Tr) : void 0,
        receiverPublicKey: e?.receiverPublicKey,
      });
    }
    function O4(t) {
      const e = t?.type || x4;
      if (e === en) {
        if (typeof t?.senderPublicKey > "u")
          throw new Error("missing sender public key");
        if (typeof t?.receiverPublicKey > "u")
          throw new Error("missing receiver public key");
      }
      return {
        type: e,
        senderPublicKey: t?.senderPublicKey,
        receiverPublicKey: t?.receiverPublicKey,
      };
    }
    function N4(t) {
      return (
        t.type === en &&
        typeof t.senderPublicKey == "string" &&
        typeof t.receiverPublicKey == "string"
      );
    }
    function T4(t) {
      return t.type === Iu;
    }
    function IB(t) {
      const e = Fe.from(t.x, "base64"),
        r = Fe.from(t.y, "base64");
      return vs([new Uint8Array([4]), e, r]);
    }
    function _B(t, e) {
      const [r, i, s] = t.split("."),
        n = Fe.from(S4(s), "base64");
      if (n.length !== 64) throw new Error("Invalid signature length");
      const o = n.slice(0, 32),
        a = n.slice(32, 64),
        c = `${r}.${i}`,
        l = bu(c),
        u = IB(e);
      if (!gB.verify(vs([o, a]), l, u)) throw new Error("Invalid signature");
      return oc(t).payload;
    }
    const AB = "irn";
    function Pp(t) {
      return t?.relay || { protocol: AB };
    }
    function Su(t) {
      const e = u5[t];
      if (typeof e > "u") throw new Error(`Relay Protocol not supported: ${t}`);
      return e;
    }
    function SB(t, e = "-") {
      const r = {},
        i = "relay" + e;
      return (
        Object.keys(t).forEach((s) => {
          if (s.startsWith(i)) {
            const n = s.replace(i, ""),
              o = t[s];
            r[n] = o;
          }
        }),
        r
      );
    }
    function k4(t) {
      if (!t.includes("wc:")) {
        const l = _5(t);
        l != null && l.includes("wc:") && (t = l);
      }
      (t = t.includes("wc://") ? t.replace("wc://", "") : t),
        (t = t.includes("wc:") ? t.replace("wc:", "") : t);
      const e = t.indexOf(":"),
        r = t.indexOf("?") !== -1 ? t.indexOf("?") : void 0,
        i = t.substring(0, e),
        s = t.substring(e + 1, r).split("@"),
        n = typeof r < "u" ? t.substring(r) : "",
        o = new URLSearchParams(n),
        a = {};
      o.forEach((l, u) => {
        a[u] = l;
      });
      const c = typeof a.methods == "string" ? a.methods.split(",") : void 0;
      return {
        protocol: i,
        topic: PB(s[0]),
        version: parseInt(s[1], 10),
        symKey: a.symKey,
        relay: SB(a),
        methods: c,
        expiryTimestamp: a.expiryTimestamp
          ? parseInt(a.expiryTimestamp, 10)
          : void 0,
      };
    }
    function PB(t) {
      return t.startsWith("//") ? t.substring(2) : t;
    }
    function OB(t, e = "-") {
      const r = "relay",
        i = {};
      return (
        Object.keys(t).forEach((s) => {
          const n = s,
            o = r + e + n;
          t[n] && (i[o] = t[n]);
        }),
        i
      );
    }
    function R4(t) {
      const e = new URLSearchParams(),
        r = OB(t.relay);
      Object.keys(r)
        .sort()
        .forEach((s) => {
          e.set(s, r[s]);
        }),
        e.set("symKey", t.symKey),
        t.expiryTimestamp &&
          e.set("expiryTimestamp", t.expiryTimestamp.toString()),
        t.methods && e.set("methods", t.methods.join(","));
      const i = e.toString();
      return `${t.protocol}:${t.topic}@${t.version}?${i}`;
    }
    function Op(t, e, r) {
      return `${t}?wc_ev=${r}&topic=${e}`;
    }
    function Ec(t) {
      const e = [];
      return (
        t.forEach((r) => {
          const [i, s] = r.split(":");
          e.push(`${i}:${s}`);
        }),
        e
      );
    }
    function NB(t) {
      const e = [];
      return (
        Object.values(t).forEach((r) => {
          e.push(...Ec(r.accounts));
        }),
        e
      );
    }
    function TB(t, e) {
      const r = [];
      return (
        Object.values(t).forEach((i) => {
          Ec(i.accounts).includes(e) && r.push(...i.methods);
        }),
        r
      );
    }
    function kB(t, e) {
      const r = [];
      return (
        Object.values(t).forEach((i) => {
          Ec(i.accounts).includes(e) && r.push(...i.events);
        }),
        r
      );
    }
    function M1(t) {
      return t.includes(":");
    }
    function Pu(t) {
      return M1(t) ? t.split(":")[0] : t;
    }
    function RB(t) {
      const e = {};
      return (
        t?.forEach((r) => {
          var i;
          const [s, n] = r.split(":");
          e[s] ||
            (e[s] = { accounts: [], chains: [], events: [], methods: [] }),
            e[s].accounts.push(r),
            (i = e[s].chains) == null || i.push(`${s}:${n}`);
        }),
        e
      );
    }
    function $4(t, e) {
      e = e.map((i) => i.replace("did:pkh:", ""));
      const r = RB(e);
      for (const [i, s] of Object.entries(r))
        s.methods ? (s.methods = wp(s.methods, t)) : (s.methods = t),
          (s.events = ["chainChanged", "accountsChanged"]);
      return r;
    }
    const $B = {
        INVALID_METHOD: { message: "Invalid method.", code: 1001 },
        INVALID_EVENT: { message: "Invalid event.", code: 1002 },
        INVALID_UPDATE_REQUEST: {
          message: "Invalid update request.",
          code: 1003,
        },
        INVALID_EXTEND_REQUEST: {
          message: "Invalid extend request.",
          code: 1004,
        },
        INVALID_SESSION_SETTLE_REQUEST: {
          message: "Invalid session settle request.",
          code: 1005,
        },
        UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 },
        UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 },
        UNAUTHORIZED_UPDATE_REQUEST: {
          message: "Unauthorized update request.",
          code: 3003,
        },
        UNAUTHORIZED_EXTEND_REQUEST: {
          message: "Unauthorized extend request.",
          code: 3004,
        },
        USER_REJECTED: { message: "User rejected.", code: 5e3 },
        USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 },
        USER_REJECTED_METHODS: {
          message: "User rejected methods.",
          code: 5002,
        },
        USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 },
        UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 },
        UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 },
        UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 },
        UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 },
        UNSUPPORTED_NAMESPACE_KEY: {
          message: "Unsupported namespace key.",
          code: 5104,
        },
        USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 },
        SESSION_SETTLEMENT_FAILED: {
          message: "Session settlement failed.",
          code: 7e3,
        },
        WC_METHOD_UNSUPPORTED: {
          message: "Unsupported wc_ method.",
          code: 10001,
        },
      },
      FB = {
        NOT_INITIALIZED: { message: "Not initialized.", code: 1 },
        NO_MATCHING_KEY: { message: "No matching key.", code: 2 },
        RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 },
        RESUBSCRIBED: { message: "Resubscribed.", code: 4 },
        MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 },
        EXPIRED: { message: "Expired.", code: 6 },
        UNKNOWN_TYPE: { message: "Unknown type.", code: 7 },
        MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 },
        NON_CONFORMING_NAMESPACES: {
          message: "Non conforming namespaces.",
          code: 9,
        },
      };
    function J(t, e) {
      const { message: r, code: i } = FB[t];
      return { message: e ? `${r} ${e}` : r, code: i };
    }
    function Ge(t, e) {
      const { message: r, code: i } = $B[t];
      return { message: e ? `${r} ${e}` : r, code: i };
    }
    function Qi(t, e) {
      return Array.isArray(t)
        ? typeof e < "u" && t.length
          ? t.every(e)
          : !0
        : !1;
    }
    function Ou(t) {
      return (
        Object.getPrototypeOf(t) === Object.prototype && Object.keys(t).length
      );
    }
    function hr(t) {
      return typeof t > "u";
    }
    function Nt(t, e) {
      return e && hr(t) ? !0 : typeof t == "string" && !!t.trim().length;
    }
    function z1(t, e) {
      return e && hr(t) ? !0 : typeof t == "number" && !isNaN(t);
    }
    function BB(t, e) {
      const { requiredNamespaces: r } = e,
        i = Object.keys(t.namespaces),
        s = Object.keys(r);
      let n = !0;
      return Fo(s, i)
        ? (i.forEach((o) => {
            const { accounts: a, methods: c, events: l } = t.namespaces[o],
              u = Ec(a),
              h = r[o];
            (!Fo(f5(o, h), u) || !Fo(h.methods, c) || !Fo(h.events, l)) &&
              (n = !1);
          }),
          n)
        : !1;
    }
    function Np(t) {
      return Nt(t, !1) && t.includes(":") ? t.split(":").length === 2 : !1;
    }
    function LB(t) {
      if (Nt(t, !1) && t.includes(":")) {
        const e = t.split(":");
        if (e.length === 3) {
          const r = e[0] + ":" + e[1];
          return !!e[2] && Np(r);
        }
      }
      return !1;
    }
    function UB(t) {
      function e(r) {
        try {
          return typeof new URL(r) < "u";
        } catch {
          return !1;
        }
      }
      try {
        if (Nt(t, !1)) {
          if (e(t)) return !0;
          const r = _5(t);
          return e(r);
        }
      } catch {}
      return !1;
    }
    function DB(t) {
      var e;
      return (e = t?.proposer) == null ? void 0 : e.publicKey;
    }
    function jB(t) {
      return t?.topic;
    }
    function MB(t, e) {
      let r = null;
      return (
        Nt(t?.publicKey, !1) ||
          (r = J(
            "MISSING_OR_INVALID",
            `${e} controller public key should be a string`
          )),
        r
      );
    }
    function F4(t) {
      let e = !0;
      return Qi(t) ? t.length && (e = t.every((r) => Nt(r, !1))) : (e = !1), e;
    }
    function zB(t, e, r) {
      let i = null;
      return (
        Qi(e) && e.length
          ? e.forEach((s) => {
              i ||
                Np(s) ||
                (i = Ge(
                  "UNSUPPORTED_CHAINS",
                  `${r}, chain ${s} should be a string and conform to "namespace:chainId" format`
                ));
            })
          : Np(t) ||
            (i = Ge(
              "UNSUPPORTED_CHAINS",
              `${r}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`
            )),
        i
      );
    }
    function qB(t, e, r) {
      let i = null;
      return (
        Object.entries(t).forEach(([s, n]) => {
          if (i) return;
          const o = zB(s, f5(s, n), `${e} ${r}`);
          o && (i = o);
        }),
        i
      );
    }
    function HB(t, e) {
      let r = null;
      return (
        Qi(t)
          ? t.forEach((i) => {
              r ||
                LB(i) ||
                (r = Ge(
                  "UNSUPPORTED_ACCOUNTS",
                  `${e}, account ${i} should be a string and conform to "namespace:chainId:address" format`
                ));
            })
          : (r = Ge(
              "UNSUPPORTED_ACCOUNTS",
              `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`
            )),
        r
      );
    }
    function VB(t, e) {
      let r = null;
      return (
        Object.values(t).forEach((i) => {
          if (r) return;
          const s = HB(i?.accounts, `${e} namespace`);
          s && (r = s);
        }),
        r
      );
    }
    function WB(t, e) {
      let r = null;
      return (
        F4(t?.methods)
          ? F4(t?.events) ||
            (r = Ge(
              "UNSUPPORTED_EVENTS",
              `${e}, events should be an array of strings or empty array for no events`
            ))
          : (r = Ge(
              "UNSUPPORTED_METHODS",
              `${e}, methods should be an array of strings or empty array for no methods`
            )),
        r
      );
    }
    function B4(t, e) {
      let r = null;
      return (
        Object.values(t).forEach((i) => {
          if (r) return;
          const s = WB(i, `${e}, namespace`);
          s && (r = s);
        }),
        r
      );
    }
    function KB(t, e, r) {
      let i = null;
      if (t && Ou(t)) {
        const s = B4(t, e);
        s && (i = s);
        const n = qB(t, e, r);
        n && (i = n);
      } else i = J("MISSING_OR_INVALID", `${e}, ${r} should be an object with data`);
      return i;
    }
    function q1(t, e) {
      let r = null;
      if (t && Ou(t)) {
        const i = B4(t, e);
        i && (r = i);
        const s = VB(t, e);
        s && (r = s);
      } else r = J("MISSING_OR_INVALID", `${e}, namespaces should be an object with data`);
      return r;
    }
    function L4(t) {
      return Nt(t.protocol, !0);
    }
    function GB(t, e) {
      let r = !1;
      return (
        e && !t
          ? (r = !0)
          : t &&
            Qi(t) &&
            t.length &&
            t.forEach((i) => {
              r = L4(i);
            }),
        r
      );
    }
    function ZB(t) {
      return typeof t == "number";
    }
    function Vr(t) {
      return typeof t < "u" && typeof t !== null;
    }
    function YB(t) {
      return !(
        !t ||
        typeof t != "object" ||
        !t.code ||
        !z1(t.code, !1) ||
        !t.message ||
        !Nt(t.message, !1)
      );
    }
    function JB(t) {
      return !(hr(t) || !Nt(t.method, !1));
    }
    function XB(t) {
      return !(
        hr(t) ||
        (hr(t.result) && hr(t.error)) ||
        !z1(t.id, !1) ||
        !Nt(t.jsonrpc, !1)
      );
    }
    function QB(t) {
      return !(hr(t) || !Nt(t.name, !1));
    }
    function U4(t, e) {
      return !(!Np(e) || !NB(t).includes(e));
    }
    function eL(t, e, r) {
      return Nt(r, !1) ? TB(t, e).includes(r) : !1;
    }
    function tL(t, e, r) {
      return Nt(r, !1) ? kB(t, e).includes(r) : !1;
    }
    function D4(t, e, r) {
      let i = null;
      const s = rL(t),
        n = iL(e),
        o = Object.keys(s),
        a = Object.keys(n),
        c = j4(Object.keys(t)),
        l = j4(Object.keys(e)),
        u = c.filter((h) => !l.includes(h));
      return (
        u.length &&
          (i = J(
            "NON_CONFORMING_NAMESPACES",
            `${r} namespaces keys don't satisfy requiredNamespaces.
      Required: ${u.toString()}
      Received: ${Object.keys(e).toString()}`
          )),
        Fo(o, a) ||
          (i = J(
            "NON_CONFORMING_NAMESPACES",
            `${r} namespaces chains don't satisfy required namespaces.
      Required: ${o.toString()}
      Approved: ${a.toString()}`
          )),
        Object.keys(e).forEach((h) => {
          if (!h.includes(":") || i) return;
          const d = Ec(e[h].accounts);
          d.includes(h) ||
            (i = J(
              "NON_CONFORMING_NAMESPACES",
              `${r} namespaces accounts don't satisfy namespace accounts for ${h}
        Required: ${h}
        Approved: ${d.toString()}`
            ));
        }),
        o.forEach((h) => {
          i ||
            (Fo(s[h].methods, n[h].methods)
              ? Fo(s[h].events, n[h].events) ||
                (i = J(
                  "NON_CONFORMING_NAMESPACES",
                  `${r} namespaces events don't satisfy namespace events for ${h}`
                ))
              : (i = J(
                  "NON_CONFORMING_NAMESPACES",
                  `${r} namespaces methods don't satisfy namespace methods for ${h}`
                )));
        }),
        i
      );
    }
    function rL(t) {
      const e = {};
      return (
        Object.keys(t).forEach((r) => {
          var i;
          r.includes(":")
            ? (e[r] = t[r])
            : (i = t[r].chains) == null ||
              i.forEach((s) => {
                e[s] = { methods: t[r].methods, events: t[r].events };
              });
        }),
        e
      );
    }
    function j4(t) {
      return [
        ...new Set(t.map((e) => (e.includes(":") ? e.split(":")[0] : e))),
      ];
    }
    function iL(t) {
      const e = {};
      return (
        Object.keys(t).forEach((r) => {
          r.includes(":")
            ? (e[r] = t[r])
            : Ec(t[r].accounts)?.forEach((s) => {
                e[s] = {
                  accounts: t[r].accounts.filter((n) => n.includes(`${s}:`)),
                  methods: t[r].methods,
                  events: t[r].events,
                };
              });
        }),
        e
      );
    }
    function sL(t, e) {
      return z1(t, !1) && t <= e.max && t >= e.min;
    }
    function M4() {
      const t = fu();
      return new Promise((e) => {
        switch (t) {
          case ni.browser:
            e(nL());
            break;
          case ni.reactNative:
            e(oL());
            break;
          case ni.node:
            e(aL());
            break;
          default:
            e(!0);
        }
      });
    }
    function nL() {
      return cc() && navigator?.onLine;
    }
    async function oL() {
      return Hn() &&
        typeof globalThis < "u" &&
        globalThis != null &&
        globalThis.NetInfo
        ? (await globalThis?.NetInfo.fetch())?.isConnected
        : !0;
    }
    function aL() {
      return !0;
    }
    function cL(t) {
      switch (fu()) {
        case ni.browser:
          lL(t);
          break;
        case ni.reactNative:
          uL(t);
          break;
      }
    }
    function lL(t) {
      !Hn() &&
        cc() &&
        (window.addEventListener("online", () => t(!0)),
        window.addEventListener("offline", () => t(!1)));
    }
    function uL(t) {
      Hn() &&
        typeof globalThis < "u" &&
        globalThis != null &&
        globalThis.NetInfo &&
        globalThis?.NetInfo.addEventListener((e) => t(e?.isConnected));
    }
    function hL() {
      var t;
      return cc() && Gi()
        ? ((t = Gi()) == null ? void 0 : t.visibilityState) === "visible"
        : !0;
    }
    const H1 = {};
    class Nu {
      static get(e) {
        return H1[e];
      }
      static set(e, r) {
        H1[e] = r;
      }
      static delete(e) {
        delete H1[e];
      }
    }
    class ci {}
    class dL extends ci {
      constructor(e) {
        super();
      }
    }
    const z4 = z.FIVE_SECONDS,
      Ti = { pulse: "heartbeat_pulse" };
    class Tp extends dL {
      constructor(e) {
        super(e),
          (this.events = new rt.exports.EventEmitter()),
          (this.interval = z4),
          (this.interval = e?.interval || z4);
      }
      static async init(e) {
        const r = new Tp(e);
        return await r.init(), r;
      }
      async init() {
        await this.initialize();
      }
      stop() {
        clearInterval(this.intervalRef);
      }
      on(e, r) {
        this.events.on(e, r);
      }
      once(e, r) {
        this.events.once(e, r);
      }
      off(e, r) {
        this.events.off(e, r);
      }
      removeListener(e, r) {
        this.events.removeListener(e, r);
      }
      async initialize() {
        this.intervalRef = setInterval(
          () => this.pulse(),
          z.toMiliseconds(this.interval)
        );
      }
      pulse() {
        this.events.emit(Ti.pulse);
      }
    }
    const pL =
        /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/,
      fL =
        /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/,
      gL = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
    function wL(t, e) {
      if (
        t === "__proto__" ||
        (t === "constructor" && e && typeof e == "object" && "prototype" in e)
      ) {
        mL(t);
        return;
      }
      return e;
    }
    function mL(t) {
      console.warn(
        `[destr] Dropping "${t}" key to prevent prototype pollution.`
      );
    }
    function kp(t, e = {}) {
      if (typeof t != "string") return t;
      if (t[0] === '"' && t[t.length - 1] === '"' && t.indexOf("\\") === -1)
        return t.slice(1, -1);
      const r = t.trim();
      if (r.length <= 9)
        switch (r.toLowerCase()) {
          case "true":
            return !0;
          case "false":
            return !1;
          case "undefined":
            return;
          case "null":
            return null;
          case "nan":
            return Number.NaN;
          case "infinity":
            return Number.POSITIVE_INFINITY;
          case "-infinity":
            return Number.NEGATIVE_INFINITY;
        }
      if (!gL.test(t)) {
        if (e.strict) throw new SyntaxError("[destr] Invalid JSON");
        return t;
      }
      try {
        if (pL.test(t) || fL.test(t)) {
          if (e.strict) throw new Error("[destr] Possible prototype pollution");
          return JSON.parse(t, wL);
        }
        return JSON.parse(t);
      } catch (i) {
        if (e.strict) throw i;
        return t;
      }
    }
    function yL(t) {
      return !t || typeof t.then != "function" ? Promise.resolve(t) : t;
    }
    function Zt(t, ...e) {
      try {
        return yL(t(...e));
      } catch (r) {
        return Promise.reject(r);
      }
    }
    function bL(t) {
      const e = typeof t;
      return t === null || (e !== "object" && e !== "function");
    }
    function vL(t) {
      const e = Object.getPrototypeOf(t);
      return !e || e.isPrototypeOf(Object);
    }
    function Rp(t) {
      if (bL(t)) return String(t);
      if (vL(t) || Array.isArray(t)) return JSON.stringify(t);
      if (typeof t.toJSON == "function") return Rp(t.toJSON());
      throw new Error("[unstorage] Cannot stringify value!");
    }
    const V1 = "base64:";
    function EL(t) {
      return typeof t == "string" ? t : V1 + IL(t);
    }
    function CL(t) {
      return typeof t != "string" || !t.startsWith(V1)
        ? t
        : xL(t.slice(V1.length));
    }
    function xL(t) {
      return globalThis.Buffer
        ? Fe.from(t, "base64")
        : Uint8Array.from(globalThis.atob(t), (e) => e.codePointAt(0));
    }
    function IL(t) {
      return globalThis.Buffer
        ? Fe.from(t).toString("base64")
        : globalThis.btoa(String.fromCodePoint(...t));
    }
    function Wr(t) {
      return (
        (t &&
          t
            .split("?")[0]
            ?.replace(/[/\\]/g, ":")
            .replace(/:+/g, ":")
            .replace(/^:|:$/g, "")) ||
        ""
      );
    }
    function _L(...t) {
      return Wr(t.join(":"));
    }
    function $p(t) {
      return (t = Wr(t)), t ? t + ":" : "";
    }
    function AL(t, e) {
      if (e === void 0) return !0;
      let r = 0,
        i = t.indexOf(":");
      for (; i > -1; ) r++, (i = t.indexOf(":", i + 1));
      return r <= e;
    }
    function SL(t, e) {
      return e
        ? t.startsWith(e) && t[t.length - 1] !== "$"
        : t[t.length - 1] !== "$";
    }
    const PL = "memory",
      OL = () => {
        const t = new Map();
        return {
          name: PL,
          getInstance: () => t,
          hasItem(e) {
            return t.has(e);
          },
          getItem(e) {
            return t.get(e) ?? null;
          },
          getItemRaw(e) {
            return t.get(e) ?? null;
          },
          setItem(e, r) {
            t.set(e, r);
          },
          setItemRaw(e, r) {
            t.set(e, r);
          },
          removeItem(e) {
            t.delete(e);
          },
          getKeys() {
            return [...t.keys()];
          },
          clear() {
            t.clear();
          },
          dispose() {
            t.clear();
          },
        };
      };
    function NL(t = {}) {
      const e = {
          mounts: { "": t.driver || OL() },
          mountpoints: [""],
          watching: !1,
          watchListeners: [],
          unwatch: {},
        },
        r = (l) => {
          for (const u of e.mountpoints)
            if (l.startsWith(u))
              return {
                base: u,
                relativeKey: l.slice(u.length),
                driver: e.mounts[u],
              };
          return { base: "", relativeKey: l, driver: e.mounts[""] };
        },
        i = (l, u) =>
          e.mountpoints
            .filter((h) => h.startsWith(l) || (u && l.startsWith(h)))
            .map((h) => ({
              relativeBase: l.length > h.length ? l.slice(h.length) : void 0,
              mountpoint: h,
              driver: e.mounts[h],
            })),
        s = (l, u) => {
          if (e.watching) {
            u = Wr(u);
            for (const h of e.watchListeners) h(l, u);
          }
        },
        n = async () => {
          if (!e.watching) {
            e.watching = !0;
            for (const l in e.mounts)
              e.unwatch[l] = await q4(e.mounts[l], s, l);
          }
        },
        o = async () => {
          if (e.watching) {
            for (const l in e.unwatch) await e.unwatch[l]();
            (e.unwatch = {}), (e.watching = !1);
          }
        },
        a = (l, u, h) => {
          const d = new Map(),
            g = (p) => {
              let w = d.get(p.base);
              return (
                w ||
                  ((w = { driver: p.driver, base: p.base, items: [] }),
                  d.set(p.base, w)),
                w
              );
            };
          for (const p of l) {
            const w = typeof p == "string",
              f = Wr(w ? p : p.key),
              m = w ? void 0 : p.value,
              y = w || !p.options ? u : { ...u, ...p.options },
              E = r(f);
            g(E).items.push({
              key: f,
              value: m,
              relativeKey: E.relativeKey,
              options: y,
            });
          }
          return Promise.all([...d.values()].map((p) => h(p))).then((p) =>
            p.flat()
          );
        },
        c = {
          hasItem(l, u = {}) {
            l = Wr(l);
            const { relativeKey: h, driver: d } = r(l);
            return Zt(d.hasItem, h, u);
          },
          getItem(l, u = {}) {
            l = Wr(l);
            const { relativeKey: h, driver: d } = r(l);
            return Zt(d.getItem, h, u).then((g) => kp(g));
          },
          getItems(l, u = {}) {
            return a(l, u, (h) =>
              h.driver.getItems
                ? Zt(
                    h.driver.getItems,
                    h.items.map((d) => ({
                      key: d.relativeKey,
                      options: d.options,
                    })),
                    u
                  ).then((d) =>
                    d.map((g) => ({
                      key: _L(h.base, g.key),
                      value: kp(g.value),
                    }))
                  )
                : Promise.all(
                    h.items.map((d) =>
                      Zt(h.driver.getItem, d.relativeKey, d.options).then(
                        (g) => ({ key: d.key, value: kp(g) })
                      )
                    )
                  )
            );
          },
          getItemRaw(l, u = {}) {
            l = Wr(l);
            const { relativeKey: h, driver: d } = r(l);
            return d.getItemRaw
              ? Zt(d.getItemRaw, h, u)
              : Zt(d.getItem, h, u).then((g) => CL(g));
          },
          async setItem(l, u, h = {}) {
            if (u === void 0) return c.removeItem(l);
            l = Wr(l);
            const { relativeKey: d, driver: g } = r(l);
            g.setItem &&
              (await Zt(g.setItem, d, Rp(u), h), g.watch || s("update", l));
          },
          async setItems(l, u) {
            await a(l, u, async (h) => {
              if (h.driver.setItems)
                return Zt(
                  h.driver.setItems,
                  h.items.map((d) => ({
                    key: d.relativeKey,
                    value: Rp(d.value),
                    options: d.options,
                  })),
                  u
                );
              h.driver.setItem &&
                (await Promise.all(
                  h.items.map((d) =>
                    Zt(h.driver.setItem, d.relativeKey, Rp(d.value), d.options)
                  )
                ));
            });
          },
          async setItemRaw(l, u, h = {}) {
            if (u === void 0) return c.removeItem(l, h);
            l = Wr(l);
            const { relativeKey: d, driver: g } = r(l);
            if (g.setItemRaw) await Zt(g.setItemRaw, d, u, h);
            else if (g.setItem) await Zt(g.setItem, d, EL(u), h);
            else return;
            g.watch || s("update", l);
          },
          async removeItem(l, u = {}) {
            typeof u == "boolean" && (u = { removeMeta: u }), (l = Wr(l));
            const { relativeKey: h, driver: d } = r(l);
            d.removeItem &&
              (await Zt(d.removeItem, h, u),
              (u.removeMeta || u.removeMata) &&
                (await Zt(d.removeItem, h + "$", u)),
              d.watch || s("remove", l));
          },
          async getMeta(l, u = {}) {
            typeof u == "boolean" && (u = { nativeOnly: u }), (l = Wr(l));
            const { relativeKey: h, driver: d } = r(l),
              g = Object.create(null);
            if (
              (d.getMeta && Object.assign(g, await Zt(d.getMeta, h, u)),
              !u.nativeOnly)
            ) {
              const p = await Zt(d.getItem, h + "$", u).then((w) => kp(w));
              p &&
                typeof p == "object" &&
                (typeof p.atime == "string" && (p.atime = new Date(p.atime)),
                typeof p.mtime == "string" && (p.mtime = new Date(p.mtime)),
                Object.assign(g, p));
            }
            return g;
          },
          setMeta(l, u, h = {}) {
            return this.setItem(l + "$", u, h);
          },
          removeMeta(l, u = {}) {
            return this.removeItem(l + "$", u);
          },
          async getKeys(l, u = {}) {
            l = $p(l);
            const h = i(l, !0);
            let d = [];
            const g = [];
            let p = !0;
            for (const f of h) {
              f.driver.flags?.maxDepth || (p = !1);
              const m = await Zt(f.driver.getKeys, f.relativeBase, u);
              for (const y of m) {
                const E = f.mountpoint + Wr(y);
                d.some((C) => E.startsWith(C)) || g.push(E);
              }
              d = [
                f.mountpoint,
                ...d.filter((y) => !y.startsWith(f.mountpoint)),
              ];
            }
            const w = u.maxDepth !== void 0 && !p;
            return g.filter((f) => (!w || AL(f, u.maxDepth)) && SL(f, l));
          },
          async clear(l, u = {}) {
            (l = $p(l)),
              await Promise.all(
                i(l, !1).map(async (h) => {
                  if (h.driver.clear)
                    return Zt(h.driver.clear, h.relativeBase, u);
                  if (h.driver.removeItem) {
                    const d = await h.driver.getKeys(h.relativeBase || "", u);
                    return Promise.all(d.map((g) => h.driver.removeItem(g, u)));
                  }
                })
              );
          },
          async dispose() {
            await Promise.all(Object.values(e.mounts).map((l) => H4(l)));
          },
          async watch(l) {
            return (
              await n(),
              e.watchListeners.push(l),
              async () => {
                (e.watchListeners = e.watchListeners.filter((u) => u !== l)),
                  e.watchListeners.length === 0 && (await o());
              }
            );
          },
          async unwatch() {
            (e.watchListeners = []), await o();
          },
          mount(l, u) {
            if (((l = $p(l)), l && e.mounts[l]))
              throw new Error(`already mounted at ${l}`);
            return (
              l &&
                (e.mountpoints.push(l),
                e.mountpoints.sort((h, d) => d.length - h.length)),
              (e.mounts[l] = u),
              e.watching &&
                Promise.resolve(q4(u, s, l))
                  .then((h) => {
                    e.unwatch[l] = h;
                  })
                  .catch(console.error),
              c
            );
          },
          async unmount(l, u = !0) {
            (l = $p(l)),
              !(!l || !e.mounts[l]) &&
                (e.watching &&
                  l in e.unwatch &&
                  (e.unwatch[l]?.(), delete e.unwatch[l]),
                u && (await H4(e.mounts[l])),
                (e.mountpoints = e.mountpoints.filter((h) => h !== l)),
                delete e.mounts[l]);
          },
          getMount(l = "") {
            l = Wr(l) + ":";
            const u = r(l);
            return { driver: u.driver, base: u.base };
          },
          getMounts(l = "", u = {}) {
            return (
              (l = Wr(l)),
              i(l, u.parents).map((h) => ({
                driver: h.driver,
                base: h.mountpoint,
              }))
            );
          },
          keys: (l, u = {}) => c.getKeys(l, u),
          get: (l, u = {}) => c.getItem(l, u),
          set: (l, u, h = {}) => c.setItem(l, u, h),
          has: (l, u = {}) => c.hasItem(l, u),
          del: (l, u = {}) => c.removeItem(l, u),
          remove: (l, u = {}) => c.removeItem(l, u),
        };
      return c;
    }
    function q4(t, e, r) {
      return t.watch ? t.watch((i, s) => e(i, r + s)) : () => {};
    }
    async function H4(t) {
      typeof t.dispose == "function" && (await Zt(t.dispose));
    }
    function zo(t) {
      return new Promise((e, r) => {
        (t.oncomplete = t.onsuccess = () => e(t.result)),
          (t.onabort = t.onerror = () => r(t.error));
      });
    }
    function V4(t, e) {
      const r = indexedDB.open(t);
      r.onupgradeneeded = () => r.result.createObjectStore(e);
      const i = zo(r);
      return (s, n) => i.then((o) => n(o.transaction(e, s).objectStore(e)));
    }
    let W1;
    function Tu() {
      return W1 || (W1 = V4("keyval-store", "keyval")), W1;
    }
    function W4(t, e = Tu()) {
      return e("readonly", (r) => zo(r.get(t)));
    }
    function TL(t, e, r = Tu()) {
      return r("readwrite", (i) => (i.put(e, t), zo(i.transaction)));
    }
    function kL(t, e = Tu()) {
      return e("readwrite", (r) => (r.delete(t), zo(r.transaction)));
    }
    function RL(t = Tu()) {
      return t("readwrite", (e) => (e.clear(), zo(e.transaction)));
    }
    function $L(t, e) {
      return (
        (t.openCursor().onsuccess = function () {
          this.result && (e(this.result), this.result.continue());
        }),
        zo(t.transaction)
      );
    }
    function FL(t = Tu()) {
      return t("readonly", (e) => {
        if (e.getAllKeys) return zo(e.getAllKeys());
        const r = [];
        return $L(e, (i) => r.push(i.key)).then(() => r);
      });
    }
    const BL = "idb-keyval";
    var LL = (t = {}) => {
      const e = t.base && t.base.length > 0 ? `${t.base}:` : "",
        r = (s) => e + s;
      let i;
      return (
        t.dbName && t.storeName && (i = V4(t.dbName, t.storeName)),
        {
          name: BL,
          options: t,
          async hasItem(s) {
            return !(typeof (await W4(r(s), i)) > "u");
          },
          async getItem(s) {
            return (await W4(r(s), i)) ?? null;
          },
          setItem(s, n) {
            return TL(r(s), n, i);
          },
          removeItem(s) {
            return kL(r(s), i);
          },
          getKeys() {
            return FL(i);
          },
          clear() {
            return RL(i);
          },
        }
      );
    };
    const UL = "WALLET_CONNECT_V2_INDEXED_DB",
      DL = "keyvaluestorage";
    class jL {
      constructor() {
        this.indexedDb = NL({ driver: LL({ dbName: UL, storeName: DL }) });
      }
      async getKeys() {
        return this.indexedDb.getKeys();
      }
      async getEntries() {
        return (
          await this.indexedDb.getItems(await this.indexedDb.getKeys())
        ).map((e) => [e.key, e.value]);
      }
      async getItem(e) {
        const r = await this.indexedDb.getItem(e);
        if (r !== null) return r;
      }
      async setItem(e, r) {
        await this.indexedDb.setItem(e, ys(r));
      }
      async removeItem(e) {
        await this.indexedDb.removeItem(e);
      }
    }
    var K1 =
        typeof globalThis < "u"
          ? globalThis
          : typeof window < "u"
          ? window
          : typeof globalThis < "u"
          ? globalThis
          : typeof self < "u"
          ? self
          : {},
      Fp = { exports: {} };
    (function () {
      let t;
      function e() {}
      (t = e),
        (t.prototype.getItem = function (r) {
          return this.hasOwnProperty(r) ? String(this[r]) : null;
        }),
        (t.prototype.setItem = function (r, i) {
          this[r] = String(i);
        }),
        (t.prototype.removeItem = function (r) {
          delete this[r];
        }),
        (t.prototype.clear = function () {
          const r = this;
          Object.keys(r).forEach(function (i) {
            (r[i] = void 0), delete r[i];
          });
        }),
        (t.prototype.key = function (r) {
          return (r = r || 0), Object.keys(this)[r];
        }),
        t.prototype.__defineGetter__("length", function () {
          return Object.keys(this).length;
        }),
        typeof K1 < "u" && K1.localStorage
          ? (Fp.exports = K1.localStorage)
          : typeof window < "u" && window.localStorage
          ? (Fp.exports = window.localStorage)
          : (Fp.exports = new e());
    })();
    function ML(t) {
      var e;
      return [t[0], Ws((e = t[1]) != null ? e : "")];
    }
    class zL {
      constructor() {
        this.localStorage = Fp.exports;
      }
      async getKeys() {
        return Object.keys(this.localStorage);
      }
      async getEntries() {
        return Object.entries(this.localStorage).map(ML);
      }
      async getItem(e) {
        const r = this.localStorage.getItem(e);
        if (r !== null) return Ws(r);
      }
      async setItem(e, r) {
        this.localStorage.setItem(e, ys(r));
      }
      async removeItem(e) {
        this.localStorage.removeItem(e);
      }
    }
    const qL = "wc_storage_version",
      K4 = 1,
      HL = async (t, e, r) => {
        const i = qL,
          s = await e.getItem(i);
        if (s && s >= K4) {
          r(e);
          return;
        }
        const n = await t.getKeys();
        if (!n.length) {
          r(e);
          return;
        }
        const o = [];
        for (; n.length; ) {
          const a = n.shift();
          if (!a) continue;
          const c = a.toLowerCase();
          if (
            c.includes("wc@") ||
            c.includes("walletconnect") ||
            c.includes("wc_") ||
            c.includes("wallet_connect")
          ) {
            const l = await t.getItem(a);
            await e.setItem(a, l), o.push(a);
          }
        }
        await e.setItem(i, K4), r(e), VL(t, o);
      },
      VL = async (t, e) => {
        e.length &&
          e.forEach(async (r) => {
            await t.removeItem(r);
          });
      };
    class G4 {
      constructor() {
        (this.initialized = !1),
          (this.setInitialized = (r) => {
            (this.storage = r), (this.initialized = !0);
          });
        const e = new zL();
        this.storage = e;
        try {
          const r = new jL();
          HL(e, r, this.setInitialized);
        } catch {
          this.initialized = !0;
        }
      }
      async getKeys() {
        return await this.initialize(), this.storage.getKeys();
      }
      async getEntries() {
        return await this.initialize(), this.storage.getEntries();
      }
      async getItem(e) {
        return await this.initialize(), this.storage.getItem(e);
      }
      async setItem(e, r) {
        return await this.initialize(), this.storage.setItem(e, r);
      }
      async removeItem(e) {
        return await this.initialize(), this.storage.removeItem(e);
      }
      async initialize() {
        this.initialized ||
          (await new Promise((e) => {
            const r = setInterval(() => {
              this.initialized && (clearInterval(r), e());
            }, 20);
          }));
      }
    }
    function WL(t) {
      try {
        return JSON.stringify(t);
      } catch {
        return '"[Circular]"';
      }
    }
    var KL = GL;
    function GL(t, e, r) {
      var i = (r && r.stringify) || WL,
        s = 1;
      if (typeof t == "object" && t !== null) {
        var n = e.length + s;
        if (n === 1) return t;
        var o = new Array(n);
        o[0] = i(t);
        for (var a = 1; a < n; a++) o[a] = i(e[a]);
        return o.join(" ");
      }
      if (typeof t != "string") return t;
      var c = e.length;
      if (c === 0) return t;
      for (
        var l = "", u = 1 - s, h = -1, d = (t && t.length) || 0, g = 0;
        g < d;

      ) {
        if (t.charCodeAt(g) === 37 && g + 1 < d) {
          switch (((h = h > -1 ? h : 0), t.charCodeAt(g + 1))) {
            case 100:
            case 102:
              if (u >= c || e[u] == null) break;
              h < g && (l += t.slice(h, g)),
                (l += Number(e[u])),
                (h = g + 2),
                g++;
              break;
            case 105:
              if (u >= c || e[u] == null) break;
              h < g && (l += t.slice(h, g)),
                (l += Math.floor(Number(e[u]))),
                (h = g + 2),
                g++;
              break;
            case 79:
            case 111:
            case 106:
              if (u >= c || e[u] === void 0) break;
              h < g && (l += t.slice(h, g));
              var p = typeof e[u];
              if (p === "string") {
                (l += "'" + e[u] + "'"), (h = g + 2), g++;
                break;
              }
              if (p === "function") {
                (l += e[u].name || "<anonymous>"), (h = g + 2), g++;
                break;
              }
              (l += i(e[u])), (h = g + 2), g++;
              break;
            case 115:
              if (u >= c) break;
              h < g && (l += t.slice(h, g)),
                (l += String(e[u])),
                (h = g + 2),
                g++;
              break;
            case 37:
              h < g && (l += t.slice(h, g)), (l += "%"), (h = g + 2), g++, u--;
              break;
          }
          ++u;
        }
        ++g;
      }
      return h === -1 ? t : (h < d && (l += t.slice(h)), l);
    }
    const Z4 = KL;
    var li = xs;
    const ku = sU().console || {},
      ZL = {
        mapHttpRequest: Lp,
        mapHttpResponse: Lp,
        wrapRequestSerializer: Z1,
        wrapResponseSerializer: Z1,
        wrapErrorSerializer: Z1,
        req: Lp,
        res: Lp,
        err: eU,
      };
    function YL(t, e) {
      return Array.isArray(t)
        ? t.filter(function (r) {
            return r !== "!stdSerializers.err";
          })
        : t === !0
        ? Object.keys(e)
        : !1;
    }
    function xs(t) {
      (t = t || {}), (t.browser = t.browser || {});
      const e = t.browser.transmit;
      if (e && typeof e.send != "function")
        throw Error("pino: transmit option must have a send function");
      const r = t.browser.write || ku;
      t.browser.write && (t.browser.asObject = !0);
      const i = t.serializers || {},
        s = YL(t.browser.serialize, i);
      let n = t.browser.serialize;
      Array.isArray(t.browser.serialize) &&
        t.browser.serialize.indexOf("!stdSerializers.err") > -1 &&
        (n = !1);
      const o = ["error", "fatal", "warn", "info", "debug", "trace"];
      typeof r == "function" &&
        (r.error = r.fatal = r.warn = r.info = r.debug = r.trace = r),
        t.enabled === !1 && (t.level = "silent");
      const a = t.level || "info",
        c = Object.create(r);
      c.log || (c.log = Ru),
        Object.defineProperty(c, "levelVal", { get: u }),
        Object.defineProperty(c, "level", { get: h, set: d });
      const l = {
        transmit: e,
        serialize: s,
        asObject: t.browser.asObject,
        levels: o,
        timestamp: tU(t),
      };
      (c.levels = xs.levels),
        (c.level = a),
        (c.setMaxListeners =
          c.getMaxListeners =
          c.emit =
          c.addListener =
          c.on =
          c.prependListener =
          c.once =
          c.prependOnceListener =
          c.removeListener =
          c.removeAllListeners =
          c.listeners =
          c.listenerCount =
          c.eventNames =
          c.write =
          c.flush =
            Ru),
        (c.serializers = i),
        (c._serialize = s),
        (c._stdErrSerialize = n),
        (c.child = g),
        e && (c._logEvent = G1());
      function u() {
        return this.level === "silent" ? 1 / 0 : this.levels.values[this.level];
      }
      function h() {
        return this._level;
      }
      function d(p) {
        if (p !== "silent" && !this.levels.values[p])
          throw Error("unknown level " + p);
        (this._level = p),
          Cc(l, c, "error", "log"),
          Cc(l, c, "fatal", "error"),
          Cc(l, c, "warn", "error"),
          Cc(l, c, "info", "log"),
          Cc(l, c, "debug", "log"),
          Cc(l, c, "trace", "log");
      }
      function g(p, w) {
        if (!p) throw new Error("missing bindings for child Pino");
        (w = w || {}), s && p.serializers && (w.serializers = p.serializers);
        const f = w.serializers;
        if (s && f) {
          var m = Object.assign({}, i, f),
            y = t.browser.serialize === !0 ? Object.keys(m) : s;
          delete p.serializers, Bp([p], y, m, this._stdErrSerialize);
        }
        function E(C) {
          (this._childLevel = (C._childLevel | 0) + 1),
            (this.error = xc(C, p, "error")),
            (this.fatal = xc(C, p, "fatal")),
            (this.warn = xc(C, p, "warn")),
            (this.info = xc(C, p, "info")),
            (this.debug = xc(C, p, "debug")),
            (this.trace = xc(C, p, "trace")),
            m && ((this.serializers = m), (this._serialize = y)),
            e && (this._logEvent = G1([].concat(C._logEvent.bindings, p)));
        }
        return (E.prototype = this), new E(this);
      }
      return c;
    }
    (xs.levels = {
      values: {
        fatal: 60,
        error: 50,
        warn: 40,
        info: 30,
        debug: 20,
        trace: 10,
      },
      labels: {
        10: "trace",
        20: "debug",
        30: "info",
        40: "warn",
        50: "error",
        60: "fatal",
      },
    }),
      (xs.stdSerializers = ZL),
      (xs.stdTimeFunctions = Object.assign(
        {},
        { nullTime: Y4, epochTime: J4, unixTime: rU, isoTime: iU }
      ));
    function Cc(t, e, r, i) {
      const s = Object.getPrototypeOf(e);
      (e[r] =
        e.levelVal > e.levels.values[r]
          ? Ru
          : s[r]
          ? s[r]
          : ku[r] || ku[i] || Ru),
        JL(t, e, r);
    }
    function JL(t, e, r) {
      (!t.transmit && e[r] === Ru) ||
        (e[r] = (function (i) {
          return function () {
            const s = t.timestamp(),
              n = new Array(arguments.length),
              o =
                Object.getPrototypeOf && Object.getPrototypeOf(this) === ku
                  ? ku
                  : this;
            for (var a = 0; a < n.length; a++) n[a] = arguments[a];
            if (
              (t.serialize &&
                !t.asObject &&
                Bp(n, this._serialize, this.serializers, this._stdErrSerialize),
              t.asObject ? i.call(o, XL(this, r, n, s)) : i.apply(o, n),
              t.transmit)
            ) {
              const c = t.transmit.level || e.level,
                l = xs.levels.values[c],
                u = xs.levels.values[r];
              if (u < l) return;
              QL(
                this,
                {
                  ts: s,
                  methodLevel: r,
                  methodValue: u,
                  transmitLevel: c,
                  transmitValue: xs.levels.values[t.transmit.level || e.level],
                  send: t.transmit.send,
                  val: e.levelVal,
                },
                n
              );
            }
          };
        })(e[r]));
    }
    function XL(t, e, r, i) {
      t._serialize && Bp(r, t._serialize, t.serializers, t._stdErrSerialize);
      const s = r.slice();
      let n = s[0];
      const o = {};
      i && (o.time = i), (o.level = xs.levels.values[e]);
      let a = (t._childLevel | 0) + 1;
      if ((a < 1 && (a = 1), n !== null && typeof n == "object")) {
        for (; a-- && typeof s[0] == "object"; ) Object.assign(o, s.shift());
        n = s.length ? Z4(s.shift(), s) : void 0;
      } else typeof n == "string" && (n = Z4(s.shift(), s));
      return n !== void 0 && (o.msg = n), o;
    }
    function Bp(t, e, r, i) {
      for (const s in t)
        if (i && t[s] instanceof Error) t[s] = xs.stdSerializers.err(t[s]);
        else if (typeof t[s] == "object" && !Array.isArray(t[s]))
          for (const n in t[s])
            e && e.indexOf(n) > -1 && n in r && (t[s][n] = r[n](t[s][n]));
    }
    function xc(t, e, r) {
      return function () {
        const i = new Array(1 + arguments.length);
        i[0] = e;
        for (var s = 1; s < i.length; s++) i[s] = arguments[s - 1];
        return t[r].apply(this, i);
      };
    }
    function QL(t, e, r) {
      const i = e.send,
        s = e.ts,
        n = e.methodLevel,
        o = e.methodValue,
        a = e.val,
        c = t._logEvent.bindings;
      Bp(
        r,
        t._serialize || Object.keys(t.serializers),
        t.serializers,
        t._stdErrSerialize === void 0 ? !0 : t._stdErrSerialize
      ),
        (t._logEvent.ts = s),
        (t._logEvent.messages = r.filter(function (l) {
          return c.indexOf(l) === -1;
        })),
        (t._logEvent.level.label = n),
        (t._logEvent.level.value = o),
        i(n, t._logEvent, a),
        (t._logEvent = G1(c));
    }
    function G1(t) {
      return {
        ts: 0,
        messages: [],
        bindings: t || [],
        level: { label: "", value: 0 },
      };
    }
    function eU(t) {
      const e = { type: t.constructor.name, msg: t.message, stack: t.stack };
      for (const r in t) e[r] === void 0 && (e[r] = t[r]);
      return e;
    }
    function tU(t) {
      return typeof t.timestamp == "function"
        ? t.timestamp
        : t.timestamp === !1
        ? Y4
        : J4;
    }
    function Lp() {
      return {};
    }
    function Z1(t) {
      return t;
    }
    function Ru() {}
    function Y4() {
      return !1;
    }
    function J4() {
      return Date.now();
    }
    function rU() {
      return Math.round(Date.now() / 1e3);
    }
    function iU() {
      return new Date(Date.now()).toISOString();
    }
    function sU() {
      function t(e) {
        return typeof e < "u" && e;
      }
      try {
        return (
          typeof globalThis < "u" ||
            Object.defineProperty(Object.prototype, "globalThis", {
              get: function () {
                return (
                  delete Object.prototype.globalThis, (this.globalThis = this)
                );
              },
              configurable: !0,
            }),
          globalThis
        );
      } catch {
        return t(self) || t(window) || t(this) || {};
      }
    }
    const nU = { level: "info" },
      $u = "custom_context",
      Y1 = 1e3 * 1024;
    class oU {
      constructor(e) {
        (this.nodeValue = e),
          (this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length),
          (this.next = null);
      }
      get value() {
        return this.nodeValue;
      }
      get size() {
        return this.sizeInBytes;
      }
    }
    class X4 {
      constructor(e) {
        (this.head = null),
          (this.tail = null),
          (this.lengthInNodes = 0),
          (this.maxSizeInBytes = e),
          (this.sizeInBytes = 0);
      }
      append(e) {
        const r = new oU(e);
        if (r.size > this.maxSizeInBytes)
          throw new Error(
            `[LinkedList] Value too big to insert into list: ${e} with size ${r.size}`
          );
        for (; this.size + r.size > this.maxSizeInBytes; ) this.shift();
        this.head
          ? (this.tail && (this.tail.next = r), (this.tail = r))
          : ((this.head = r), (this.tail = r)),
          this.lengthInNodes++,
          (this.sizeInBytes += r.size);
      }
      shift() {
        if (!this.head) return;
        const e = this.head;
        (this.head = this.head.next),
          this.head || (this.tail = null),
          this.lengthInNodes--,
          (this.sizeInBytes -= e.size);
      }
      toArray() {
        const e = [];
        let r = this.head;
        for (; r !== null; ) e.push(r.value), (r = r.next);
        return e;
      }
      get length() {
        return this.lengthInNodes;
      }
      get size() {
        return this.sizeInBytes;
      }
      toOrderedArray() {
        return Array.from(this);
      }
      [Symbol.iterator]() {
        let e = this.head;
        return {
          next: () => {
            if (!e) return { done: !0, value: null };
            const r = e.value;
            return (e = e.next), { done: !1, value: r };
          },
        };
      }
    }
    class Q4 {
      constructor(e, r = Y1) {
        (this.level = e ?? "error"),
          (this.levelValue = li.levels.values[this.level]),
          (this.MAX_LOG_SIZE_IN_BYTES = r),
          (this.logs = new X4(this.MAX_LOG_SIZE_IN_BYTES));
      }
      forwardToConsole(e, r) {
        r === li.levels.values.error
          ? console.error(e)
          : r === li.levels.values.warn
          ? console.warn(e)
          : r === li.levels.values.debug
          ? console.debug(e)
          : r === li.levels.values.trace
          ? console.trace(e)
          : console.log(e);
      }
      appendToLogs(e) {
        this.logs.append(ys({ timestamp: new Date().toISOString(), log: e }));
        const r = typeof e == "string" ? JSON.parse(e).level : e.level;
        r >= this.levelValue && this.forwardToConsole(e, r);
      }
      getLogs() {
        return this.logs;
      }
      clearLogs() {
        this.logs = new X4(this.MAX_LOG_SIZE_IN_BYTES);
      }
      getLogArray() {
        return Array.from(this.logs);
      }
      logsToBlob(e) {
        const r = this.getLogArray();
        return (
          r.push(ys({ extraMetadata: e })),
          new Blob(r, { type: "application/json" })
        );
      }
    }
    class aU {
      constructor(e, r = Y1) {
        this.baseChunkLogger = new Q4(e, r);
      }
      write(e) {
        this.baseChunkLogger.appendToLogs(e);
      }
      getLogs() {
        return this.baseChunkLogger.getLogs();
      }
      clearLogs() {
        this.baseChunkLogger.clearLogs();
      }
      getLogArray() {
        return this.baseChunkLogger.getLogArray();
      }
      logsToBlob(e) {
        return this.baseChunkLogger.logsToBlob(e);
      }
      downloadLogsBlobInBrowser(e) {
        const r = URL.createObjectURL(this.logsToBlob(e)),
          i = document.createElement("a");
        (i.href = r),
          (i.download = `walletconnect-logs-${new Date().toISOString()}.txt`),
          document.body.appendChild(i),
          i.click(),
          document.body.removeChild(i),
          URL.revokeObjectURL(r);
      }
    }
    class cU {
      constructor(e, r = Y1) {
        this.baseChunkLogger = new Q4(e, r);
      }
      write(e) {
        this.baseChunkLogger.appendToLogs(e);
      }
      getLogs() {
        return this.baseChunkLogger.getLogs();
      }
      clearLogs() {
        this.baseChunkLogger.clearLogs();
      }
      getLogArray() {
        return this.baseChunkLogger.getLogArray();
      }
      logsToBlob(e) {
        return this.baseChunkLogger.logsToBlob(e);
      }
    }
    var lU = Object.defineProperty,
      uU = Object.defineProperties,
      hU = Object.getOwnPropertyDescriptors,
      e6 = Object.getOwnPropertySymbols,
      dU = Object.prototype.hasOwnProperty,
      pU = Object.prototype.propertyIsEnumerable,
      t6 = (t, e, r) =>
        e in t
          ? lU(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Up = (t, e) => {
        for (var r in e || (e = {})) dU.call(e, r) && t6(t, r, e[r]);
        if (e6) for (var r of e6(e)) pU.call(e, r) && t6(t, r, e[r]);
        return t;
      },
      Dp = (t, e) => uU(t, hU(e));
    function tn(t) {
      return Dp(Up({}, t), { level: t?.level || nU.level });
    }
    function fU(t, e = $u) {
      return t[e] || "";
    }
    function gU(t, e, r = $u) {
      return (t[r] = e), t;
    }
    function it(t, e = $u) {
      let r = "";
      return (
        typeof t.bindings > "u"
          ? (r = fU(t, e))
          : (r = t.bindings().context || ""),
        r
      );
    }
    function wU(t, e, r = $u) {
      const i = it(t, r);
      return i.trim() ? `${i}/${e}` : e;
    }
    function Ve(t, e, r = $u) {
      const i = wU(t, e, r),
        s = t.child({ context: i });
      return gU(s, i, r);
    }
    function mU(t) {
      var e, r;
      const i = new aU(
        (e = t.opts) == null ? void 0 : e.level,
        t.maxSizeInBytes
      );
      return {
        logger: li(
          Dp(Up({}, t.opts), {
            level: "trace",
            browser: Dp(Up({}, (r = t.opts) == null ? void 0 : r.browser), {
              write: (s) => i.write(s),
            }),
          })
        ),
        chunkLoggerController: i,
      };
    }
    function yU(t) {
      var e;
      const r = new cU(
        (e = t.opts) == null ? void 0 : e.level,
        t.maxSizeInBytes
      );
      return {
        logger: li(Dp(Up({}, t.opts), { level: "trace" })),
        chunkLoggerController: r,
      };
    }
    function J1(t) {
      return typeof t.loggerOverride < "u" &&
        typeof t.loggerOverride != "string"
        ? { logger: t.loggerOverride, chunkLoggerController: null }
        : typeof window < "u"
        ? mU(t)
        : yU(t);
    }
    var bU = Object.defineProperty,
      vU = (t, e, r) =>
        e in t
          ? bU(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      r6 = (t, e, r) => vU(t, typeof e != "symbol" ? e + "" : e, r);
    class EU extends ci {
      constructor(e) {
        super(),
          (this.opts = e),
          r6(this, "protocol", "wc"),
          r6(this, "version", 2);
      }
    }
    var CU = Object.defineProperty,
      xU = (t, e, r) =>
        e in t
          ? CU(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      IU = (t, e, r) => xU(t, typeof e != "symbol" ? e + "" : e, r);
    class _U extends ci {
      constructor(e, r) {
        super(),
          (this.core = e),
          (this.logger = r),
          IU(this, "records", new Map());
      }
    }
    class AU {
      constructor(e, r) {
        (this.logger = e), (this.core = r);
      }
    }
    class SU extends ci {
      constructor(e, r) {
        super(), (this.relayer = e), (this.logger = r);
      }
    }
    class PU extends ci {
      constructor(e) {
        super();
      }
    }
    class OU {
      constructor(e, r, i, s) {
        (this.core = e), (this.logger = r), (this.name = i);
      }
    }
    class NU extends ci {
      constructor(e, r) {
        super(), (this.relayer = e), (this.logger = r);
      }
    }
    class TU extends ci {
      constructor(e, r) {
        super(), (this.core = e), (this.logger = r);
      }
    }
    class kU {
      constructor(e, r, i) {
        (this.core = e), (this.logger = r), (this.store = i);
      }
    }
    class RU {
      constructor(e, r) {
        (this.projectId = e), (this.logger = r);
      }
    }
    class $U {
      constructor(e, r, i) {
        (this.core = e), (this.logger = r), (this.telemetryEnabled = i);
      }
    }
    var FU = Object.defineProperty,
      BU = (t, e, r) =>
        e in t
          ? FU(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      i6 = (t, e, r) => BU(t, typeof e != "symbol" ? e + "" : e, r);
    class LU {
      constructor(e) {
        (this.opts = e), i6(this, "protocol", "wc"), i6(this, "version", 2);
      }
    }
    class UU {
      constructor(e) {
        this.client = e;
      }
    }
    const DU = "PARSE_ERROR",
      jU = "INVALID_REQUEST",
      MU = "METHOD_NOT_FOUND",
      zU = "INVALID_PARAMS",
      s6 = "INTERNAL_ERROR",
      X1 = "SERVER_ERROR",
      qU = [-32700, -32600, -32601, -32602, -32603],
      Fu = {
        [DU]: { code: -32700, message: "Parse error" },
        [jU]: { code: -32600, message: "Invalid Request" },
        [MU]: { code: -32601, message: "Method not found" },
        [zU]: { code: -32602, message: "Invalid params" },
        [s6]: { code: -32603, message: "Internal error" },
        [X1]: { code: -32e3, message: "Server error" },
      },
      n6 = X1;
    function HU(t) {
      return qU.includes(t);
    }
    function o6(t) {
      return Object.keys(Fu).includes(t) ? Fu[t] : Fu[n6];
    }
    function VU(t) {
      return Object.values(Fu).find((r) => r.code === t) || Fu[n6];
    }
    function a6(t, e, r) {
      return t.message.includes("getaddrinfo ENOTFOUND") ||
        t.message.includes("connect ECONNREFUSED")
        ? new Error(`Unavailable ${r} RPC url at ${e}`)
        : t;
    }
    var c6 = {};
    /*! *****************************************************************************
		Copyright (c) Microsoft Corporation.

		Permission to use, copy, modify, and/or distribute this software for any
		purpose with or without fee is hereby granted.

		THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
		REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
		AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
		INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
		LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
		OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
		PERFORMANCE OF THIS SOFTWARE.
		***************************************************************************** */ var Q1 =
      function (t, e) {
        return (
          (Q1 =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (r, i) {
                r.__proto__ = i;
              }) ||
            function (r, i) {
              for (var s in i) i.hasOwnProperty(s) && (r[s] = i[s]);
            }),
          Q1(t, e)
        );
      };
    function WU(t, e) {
      Q1(t, e);
      function r() {
        this.constructor = t;
      }
      t.prototype =
        e === null ? Object.create(e) : ((r.prototype = e.prototype), new r());
    }
    var ew = function () {
      return (
        (ew =
          Object.assign ||
          function (t) {
            for (var e, r = 1, i = arguments.length; r < i; r++) {
              e = arguments[r];
              for (var s in e)
                Object.prototype.hasOwnProperty.call(e, s) && (t[s] = e[s]);
            }
            return t;
          }),
        ew.apply(this, arguments)
      );
    };
    function KU(t, e) {
      var r = {};
      for (var i in t)
        Object.prototype.hasOwnProperty.call(t, i) &&
          e.indexOf(i) < 0 &&
          (r[i] = t[i]);
      if (t != null && typeof Object.getOwnPropertySymbols == "function")
        for (var s = 0, i = Object.getOwnPropertySymbols(t); s < i.length; s++)
          e.indexOf(i[s]) < 0 &&
            Object.prototype.propertyIsEnumerable.call(t, i[s]) &&
            (r[i[s]] = t[i[s]]);
      return r;
    }
    function GU(t, e, r, i) {
      var s = arguments.length,
        n =
          s < 3
            ? e
            : i === null
            ? (i = Object.getOwnPropertyDescriptor(e, r))
            : i,
        o;
      if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        n = Reflect.decorate(t, e, r, i);
      else
        for (var a = t.length - 1; a >= 0; a--)
          (o = t[a]) &&
            (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
      return s > 3 && n && Object.defineProperty(e, r, n), n;
    }
    function ZU(t, e) {
      return function (r, i) {
        e(r, i, t);
      };
    }
    function YU(t, e) {
      if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
        return Reflect.metadata(t, e);
    }
    function JU(t, e, r, i) {
      function s(n) {
        return n instanceof r
          ? n
          : new r(function (o) {
              o(n);
            });
      }
      return new (r || (r = Promise))(function (n, o) {
        function a(u) {
          try {
            l(i.next(u));
          } catch (h) {
            o(h);
          }
        }
        function c(u) {
          try {
            l(i.throw(u));
          } catch (h) {
            o(h);
          }
        }
        function l(u) {
          u.done ? n(u.value) : s(u.value).then(a, c);
        }
        l((i = i.apply(t, e || [])).next());
      });
    }
    function XU(t, e) {
      var r = {
          label: 0,
          sent: function () {
            if (n[0] & 1) throw n[1];
            return n[1];
          },
          trys: [],
          ops: [],
        },
        i,
        s,
        n,
        o;
      return (
        (o = { next: a(0), throw: a(1), return: a(2) }),
        typeof Symbol == "function" &&
          (o[Symbol.iterator] = function () {
            return this;
          }),
        o
      );
      function a(l) {
        return function (u) {
          return c([l, u]);
        };
      }
      function c(l) {
        if (i) throw new TypeError("Generator is already executing.");
        for (; r; )
          try {
            if (
              ((i = 1),
              s &&
                (n =
                  l[0] & 2
                    ? s.return
                    : l[0]
                    ? s.throw || ((n = s.return) && n.call(s), 0)
                    : s.next) &&
                !(n = n.call(s, l[1])).done)
            )
              return n;
            switch (((s = 0), n && (l = [l[0] & 2, n.value]), l[0])) {
              case 0:
              case 1:
                n = l;
                break;
              case 4:
                return r.label++, { value: l[1], done: !1 };
              case 5:
                r.label++, (s = l[1]), (l = [0]);
                continue;
              case 7:
                (l = r.ops.pop()), r.trys.pop();
                continue;
              default:
                if (
                  ((n = r.trys),
                  !(n = n.length > 0 && n[n.length - 1]) &&
                    (l[0] === 6 || l[0] === 2))
                ) {
                  r = 0;
                  continue;
                }
                if (l[0] === 3 && (!n || (l[1] > n[0] && l[1] < n[3]))) {
                  r.label = l[1];
                  break;
                }
                if (l[0] === 6 && r.label < n[1]) {
                  (r.label = n[1]), (n = l);
                  break;
                }
                if (n && r.label < n[2]) {
                  (r.label = n[2]), r.ops.push(l);
                  break;
                }
                n[2] && r.ops.pop(), r.trys.pop();
                continue;
            }
            l = e.call(t, r);
          } catch (u) {
            (l = [6, u]), (s = 0);
          } finally {
            i = n = 0;
          }
        if (l[0] & 5) throw l[1];
        return { value: l[0] ? l[1] : void 0, done: !0 };
      }
    }
    function QU(t, e, r, i) {
      i === void 0 && (i = r), (t[i] = e[r]);
    }
    function eD(t, e) {
      for (var r in t) r !== "default" && !e.hasOwnProperty(r) && (e[r] = t[r]);
    }
    function tw(t) {
      var e = typeof Symbol == "function" && Symbol.iterator,
        r = e && t[e],
        i = 0;
      if (r) return r.call(t);
      if (t && typeof t.length == "number")
        return {
          next: function () {
            return (
              t && i >= t.length && (t = void 0),
              { value: t && t[i++], done: !t }
            );
          },
        };
      throw new TypeError(
        e ? "Object is not iterable." : "Symbol.iterator is not defined."
      );
    }
    function l6(t, e) {
      var r = typeof Symbol == "function" && t[Symbol.iterator];
      if (!r) return t;
      var i = r.call(t),
        s,
        n = [],
        o;
      try {
        for (; (e === void 0 || e-- > 0) && !(s = i.next()).done; )
          n.push(s.value);
      } catch (a) {
        o = { error: a };
      } finally {
        try {
          s && !s.done && (r = i.return) && r.call(i);
        } finally {
          if (o) throw o.error;
        }
      }
      return n;
    }
    function tD() {
      for (var t = [], e = 0; e < arguments.length; e++)
        t = t.concat(l6(arguments[e]));
      return t;
    }
    function rD() {
      for (var t = 0, e = 0, r = arguments.length; e < r; e++)
        t += arguments[e].length;
      for (var i = Array(t), s = 0, e = 0; e < r; e++)
        for (var n = arguments[e], o = 0, a = n.length; o < a; o++, s++)
          i[s] = n[o];
      return i;
    }
    function Bu(t) {
      return this instanceof Bu ? ((this.v = t), this) : new Bu(t);
    }
    function iD(t, e, r) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var i = r.apply(t, e || []),
        s,
        n = [];
      return (
        (s = {}),
        o("next"),
        o("throw"),
        o("return"),
        (s[Symbol.asyncIterator] = function () {
          return this;
        }),
        s
      );
      function o(d) {
        i[d] &&
          (s[d] = function (g) {
            return new Promise(function (p, w) {
              n.push([d, g, p, w]) > 1 || a(d, g);
            });
          });
      }
      function a(d, g) {
        try {
          c(i[d](g));
        } catch (p) {
          h(n[0][3], p);
        }
      }
      function c(d) {
        d.value instanceof Bu
          ? Promise.resolve(d.value.v).then(l, u)
          : h(n[0][2], d);
      }
      function l(d) {
        a("next", d);
      }
      function u(d) {
        a("throw", d);
      }
      function h(d, g) {
        d(g), n.shift(), n.length && a(n[0][0], n[0][1]);
      }
    }
    function sD(t) {
      var e, r;
      return (
        (e = {}),
        i("next"),
        i("throw", function (s) {
          throw s;
        }),
        i("return"),
        (e[Symbol.iterator] = function () {
          return this;
        }),
        e
      );
      function i(s, n) {
        e[s] = t[s]
          ? function (o) {
              return (r = !r)
                ? { value: Bu(t[s](o)), done: s === "return" }
                : n
                ? n(o)
                : o;
            }
          : n;
      }
    }
    function nD(t) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var e = t[Symbol.asyncIterator],
        r;
      return e
        ? e.call(t)
        : ((t = typeof tw == "function" ? tw(t) : t[Symbol.iterator]()),
          (r = {}),
          i("next"),
          i("throw"),
          i("return"),
          (r[Symbol.asyncIterator] = function () {
            return this;
          }),
          r);
      function i(n) {
        r[n] =
          t[n] &&
          function (o) {
            return new Promise(function (a, c) {
              (o = t[n](o)), s(a, c, o.done, o.value);
            });
          };
      }
      function s(n, o, a, c) {
        Promise.resolve(c).then(function (l) {
          n({ value: l, done: a });
        }, o);
      }
    }
    function oD(t, e) {
      return (
        Object.defineProperty
          ? Object.defineProperty(t, "raw", { value: e })
          : (t.raw = e),
        t
      );
    }
    function aD(t) {
      if (t && t.__esModule) return t;
      var e = {};
      if (t != null)
        for (var r in t) Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      return (e.default = t), e;
    }
    function cD(t) {
      return t && t.__esModule ? t : { default: t };
    }
    function lD(t, e) {
      if (!e.has(t))
        throw new TypeError("attempted to get private field on non-instance");
      return e.get(t);
    }
    function uD(t, e, r) {
      if (!e.has(t))
        throw new TypeError("attempted to set private field on non-instance");
      return e.set(t, r), r;
    }
    var hD = Object.freeze({
        __proto__: null,
        __extends: WU,
        get __assign() {
          return ew;
        },
        __rest: KU,
        __decorate: GU,
        __param: ZU,
        __metadata: YU,
        __awaiter: JU,
        __generator: XU,
        __createBinding: QU,
        __exportStar: eD,
        __values: tw,
        __read: l6,
        __spread: tD,
        __spreadArrays: rD,
        __await: Bu,
        __asyncGenerator: iD,
        __asyncDelegator: sD,
        __asyncValues: nD,
        __makeTemplateObject: oD,
        __importStar: aD,
        __importDefault: cD,
        __classPrivateFieldGet: lD,
        __classPrivateFieldSet: uD,
      }),
      dD = za(hD),
      rn = {},
      u6;
    function pD() {
      if (u6) return rn;
      (u6 = 1),
        Object.defineProperty(rn, "__esModule", { value: !0 }),
        (rn.isBrowserCryptoAvailable =
          rn.getSubtleCrypto =
          rn.getBrowerCrypto =
            void 0);
      function t() {
        return qt?.crypto || qt?.msCrypto || {};
      }
      rn.getBrowerCrypto = t;
      function e() {
        const i = t();
        return i.subtle || i.webkitSubtle;
      }
      rn.getSubtleCrypto = e;
      function r() {
        return !!t() && !!e();
      }
      return (rn.isBrowserCryptoAvailable = r), rn;
    }
    var sn = {},
      h6;
    function fD() {
      if (h6) return sn;
      (h6 = 1),
        Object.defineProperty(sn, "__esModule", { value: !0 }),
        (sn.isBrowser = sn.isNode = sn.isReactNative = void 0);
      function t() {
        return (
          typeof document > "u" &&
          typeof navigator < "u" &&
          navigator.product === "ReactNative"
        );
      }
      sn.isReactNative = t;
      function e() {
        return (
          typeof ut < "u" &&
          typeof ut.versions < "u" &&
          typeof ut.versions.node < "u"
        );
      }
      sn.isNode = e;
      function r() {
        return !t() && !e();
      }
      return (sn.isBrowser = r), sn;
    }
    (function (t) {
      Object.defineProperty(t, "__esModule", { value: !0 });
      const e = dD;
      e.__exportStar(pD(), t), e.__exportStar(fD(), t);
    })(c6);
    function Yt(t = 3) {
      const e = Date.now() * Math.pow(10, t),
        r = Math.floor(Math.random() * Math.pow(10, t));
      return e + r;
    }
    function ui(t = 6) {
      return BigInt(Yt(t));
    }
    function kr(t, e, r) {
      return { id: r || Yt(), jsonrpc: "2.0", method: t, params: e };
    }
    function Jn(t, e) {
      return { id: t, jsonrpc: "2.0", result: e };
    }
    function Ic(t, e, r) {
      return { id: t, jsonrpc: "2.0", error: gD(e, r) };
    }
    function gD(t, e) {
      return typeof t > "u"
        ? o6(s6)
        : (typeof t == "string" &&
            (t = Object.assign(Object.assign({}, o6(X1)), { message: t })),
          typeof e < "u" && (t.data = e),
          HU(t.code) && (t = VU(t.code)),
          t);
    }
    class wD {}
    class mD extends wD {
      constructor() {
        super();
      }
    }
    class yD extends mD {
      constructor(e) {
        super();
      }
    }
    const bD = "^https?:",
      vD = "^wss?:";
    function ED(t) {
      const e = t.match(new RegExp(/^\w+:/, "gi"));
      if (!(!e || !e.length)) return e[0];
    }
    function d6(t, e) {
      const r = ED(t);
      return typeof r > "u" ? !1 : new RegExp(e).test(r);
    }
    function p6(t) {
      return d6(t, bD);
    }
    function f6(t) {
      return d6(t, vD);
    }
    function CD(t) {
      return new RegExp("wss?://localhost(:d{2,5})?").test(t);
    }
    function g6(t) {
      return (
        typeof t == "object" &&
        "id" in t &&
        "jsonrpc" in t &&
        t.jsonrpc === "2.0"
      );
    }
    function _c(t) {
      return g6(t) && "method" in t;
    }
    function qo(t) {
      return g6(t) && (Bt(t) || Ct(t));
    }
    function Bt(t) {
      return "result" in t;
    }
    function Ct(t) {
      return "error" in t;
    }
    class bt extends yD {
      constructor(e) {
        super(e),
          (this.events = new rt.exports.EventEmitter()),
          (this.hasRegisteredEventListeners = !1),
          (this.connection = this.setConnection(e)),
          this.connection.connected && this.registerEventListeners();
      }
      async connect(e = this.connection) {
        await this.open(e);
      }
      async disconnect() {
        await this.close();
      }
      on(e, r) {
        this.events.on(e, r);
      }
      once(e, r) {
        this.events.once(e, r);
      }
      off(e, r) {
        this.events.off(e, r);
      }
      removeListener(e, r) {
        this.events.removeListener(e, r);
      }
      async request(e, r) {
        return this.requestStrict(
          kr(e.method, e.params || [], e.id || ui().toString()),
          r
        );
      }
      async requestStrict(e, r) {
        return new Promise(async (i, s) => {
          if (!this.connection.connected)
            try {
              await this.open();
            } catch (n) {
              s(n);
            }
          this.events.on(`${e.id}`, (n) => {
            Ct(n) ? s(n.error) : i(n.result);
          });
          try {
            await this.connection.send(e, r);
          } catch (n) {
            s(n);
          }
        });
      }
      setConnection(e = this.connection) {
        return e;
      }
      onPayload(e) {
        this.events.emit("payload", e),
          qo(e)
            ? this.events.emit(`${e.id}`, e)
            : this.events.emit("message", { type: e.method, data: e.params });
      }
      onClose(e) {
        e &&
          e.code === 3e3 &&
          this.events.emit(
            "error",
            new Error(
              `WebSocket connection closed abnormally with code: ${e.code} ${
                e.reason ? `(${e.reason})` : ""
              }`
            )
          ),
          this.events.emit("disconnect");
      }
      async open(e = this.connection) {
        (this.connection === e && this.connection.connected) ||
          (this.connection.connected && this.close(),
          typeof e == "string" &&
            (await this.connection.open(e), (e = this.connection)),
          (this.connection = this.setConnection(e)),
          await this.connection.open(),
          this.registerEventListeners(),
          this.events.emit("connect"));
      }
      async close() {
        await this.connection.close();
      }
      registerEventListeners() {
        this.hasRegisteredEventListeners ||
          (this.connection.on("payload", (e) => this.onPayload(e)),
          this.connection.on("close", (e) => this.onClose(e)),
          this.connection.on("error", (e) => this.events.emit("error", e)),
          this.connection.on("register_error", (e) => this.onClose()),
          (this.hasRegisteredEventListeners = !0));
      }
    }
    const xD = () =>
        typeof WebSocket < "u"
          ? WebSocket
          : typeof globalThis < "u" && typeof globalThis.WebSocket < "u"
          ? globalThis.WebSocket
          : typeof window < "u" && typeof window.WebSocket < "u"
          ? window.WebSocket
          : typeof self < "u" && typeof self.WebSocket < "u"
          ? self.WebSocket
          : Sfe(),
      ID = () =>
        typeof WebSocket < "u" ||
        (typeof globalThis < "u" && typeof globalThis.WebSocket < "u") ||
        (typeof window < "u" && typeof window.WebSocket < "u") ||
        (typeof self < "u" && typeof self.WebSocket < "u"),
      w6 = (t) => t.split("?")[0],
      m6 = 10,
      _D = xD();
    class y6 {
      constructor(e) {
        if (
          ((this.url = e),
          (this.events = new rt.exports.EventEmitter()),
          (this.registering = !1),
          !f6(e))
        )
          throw new Error(
            `Provided URL is not compatible with WebSocket connection: ${e}`
          );
        this.url = e;
      }
      get connected() {
        return typeof this.socket < "u";
      }
      get connecting() {
        return this.registering;
      }
      on(e, r) {
        this.events.on(e, r);
      }
      once(e, r) {
        this.events.once(e, r);
      }
      off(e, r) {
        this.events.off(e, r);
      }
      removeListener(e, r) {
        this.events.removeListener(e, r);
      }
      async open(e = this.url) {
        await this.register(e);
      }
      async close() {
        return new Promise((e, r) => {
          if (typeof this.socket > "u") {
            r(new Error("Connection already closed"));
            return;
          }
          (this.socket.onclose = (i) => {
            this.onClose(i), e();
          }),
            this.socket.close();
        });
      }
      async send(e) {
        typeof this.socket > "u" && (this.socket = await this.register());
        try {
          this.socket.send(ys(e));
        } catch (r) {
          this.onError(e.id, r);
        }
      }
      register(e = this.url) {
        if (!f6(e))
          throw new Error(
            `Provided URL is not compatible with WebSocket connection: ${e}`
          );
        if (this.registering) {
          const r = this.events.getMaxListeners();
          return (
            (this.events.listenerCount("register_error") >= r ||
              this.events.listenerCount("open") >= r) &&
              this.events.setMaxListeners(r + 1),
            new Promise((i, s) => {
              this.events.once("register_error", (n) => {
                this.resetMaxListeners(), s(n);
              }),
                this.events.once("open", () => {
                  if ((this.resetMaxListeners(), typeof this.socket > "u"))
                    return s(
                      new Error("WebSocket connection is missing or invalid")
                    );
                  i(this.socket);
                });
            })
          );
        }
        return (
          (this.url = e),
          (this.registering = !0),
          new Promise((r, i) => {
            const s = c6.isReactNative()
                ? void 0
                : { rejectUnauthorized: !CD(e) },
              n = new _D(e, [], s);
            ID()
              ? (n.onerror = (o) => {
                  const a = o;
                  i(this.emitError(a.error));
                })
              : n.on("error", (o) => {
                  i(this.emitError(o));
                }),
              (n.onopen = () => {
                this.onOpen(n), r(n);
              });
          })
        );
      }
      onOpen(e) {
        (e.onmessage = (r) => this.onPayload(r)),
          (e.onclose = (r) => this.onClose(r)),
          (this.socket = e),
          (this.registering = !1),
          this.events.emit("open");
      }
      onClose(e) {
        (this.socket = void 0),
          (this.registering = !1),
          this.events.emit("close", e);
      }
      onPayload(e) {
        if (typeof e.data > "u") return;
        const r = typeof e.data == "string" ? Ws(e.data) : e.data;
        this.events.emit("payload", r);
      }
      onError(e, r) {
        const i = this.parseError(r),
          s = i.message || i.toString(),
          n = Ic(e, s);
        this.events.emit("payload", n);
      }
      parseError(e, r = this.url) {
        return a6(e, w6(r), "WS");
      }
      resetMaxListeners() {
        this.events.getMaxListeners() > m6 && this.events.setMaxListeners(m6);
      }
      emitError(e) {
        const r = this.parseError(
          new Error(
            e?.message ||
              `WebSocket connection failed for host: ${w6(this.url)}`
          )
        );
        return this.events.emit("register_error", r), r;
      }
    }
    var AD = Object.defineProperty,
      b6 = Object.getOwnPropertySymbols,
      SD = Object.prototype.hasOwnProperty,
      PD = Object.prototype.propertyIsEnumerable,
      v6 = (t, e, r) =>
        e in t
          ? AD(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Rr = (t, e) => {
        for (var r in e || (e = {})) SD.call(e, r) && v6(t, r, e[r]);
        if (b6) for (var r of b6(e)) PD.call(e, r) && v6(t, r, e[r]);
        return t;
      };
    const E6 = "wc",
      C6 = 2,
      jp = "core",
      Is = `${E6}@2:${jp}:`,
      OD = { name: jp, logger: "error" },
      ND = { database: ":memory:" },
      TD = "crypto",
      x6 = "client_ed25519_seed",
      kD = z.ONE_DAY,
      RD = "keychain",
      $D = "0.3",
      FD = "messages",
      BD = "0.3",
      I6 = z.SIX_HOURS,
      LD = "publisher",
      _6 = "irn",
      UD = "error",
      A6 = "wss://relay.walletconnect.org",
      DD = "relayer",
      Jt = {
        message: "relayer_message",
        message_ack: "relayer_message_ack",
        connect: "relayer_connect",
        disconnect: "relayer_disconnect",
        error: "relayer_error",
        connection_stalled: "relayer_connection_stalled",
        transport_closed: "relayer_transport_closed",
        publish: "relayer_publish",
      },
      jD = "_subscription",
      ki = {
        payload: "payload",
        connect: "connect",
        disconnect: "disconnect",
        error: "error",
      },
      MD = 0.1,
      rw = "2.20.3",
      gt = { link_mode: "link_mode", relay: "relay" },
      Mp = { inbound: "inbound", outbound: "outbound" },
      zD = "0.3",
      qD = "WALLETCONNECT_CLIENT_ID",
      S6 = "WALLETCONNECT_LINK_MODE_APPS",
      hi = {
        created: "subscription_created",
        deleted: "subscription_deleted",
        expired: "subscription_expired",
        disabled: "subscription_disabled",
        sync: "subscription_sync",
        resubscribed: "subscription_resubscribed",
      },
      HD = "subscription",
      VD = "0.3",
      WD = "pairing",
      KD = "0.3",
      Lu = {
        wc_pairingDelete: {
          req: { ttl: z.ONE_DAY, prompt: !1, tag: 1e3 },
          res: { ttl: z.ONE_DAY, prompt: !1, tag: 1001 },
        },
        wc_pairingPing: {
          req: { ttl: z.THIRTY_SECONDS, prompt: !1, tag: 1002 },
          res: { ttl: z.THIRTY_SECONDS, prompt: !1, tag: 1003 },
        },
        unregistered_method: {
          req: { ttl: z.ONE_DAY, prompt: !1, tag: 0 },
          res: { ttl: z.ONE_DAY, prompt: !1, tag: 0 },
        },
      },
      Ho = {
        create: "pairing_create",
        expire: "pairing_expire",
        delete: "pairing_delete",
        ping: "pairing_ping",
      },
      es = {
        created: "history_created",
        updated: "history_updated",
        deleted: "history_deleted",
        sync: "history_sync",
      },
      GD = "history",
      ZD = "0.3",
      YD = "expirer",
      Ri = {
        created: "expirer_created",
        deleted: "expirer_deleted",
        expired: "expirer_expired",
        sync: "expirer_sync",
      },
      JD = "0.3",
      XD = "verify-api",
      QD = "https://verify.walletconnect.com",
      P6 = "https://verify.walletconnect.org",
      Uu = P6,
      ej = `${Uu}/v3`,
      tj = [QD, P6],
      rj = "echo",
      ij = "https://echo.walletconnect.com",
      _s = {
        pairing_started: "pairing_started",
        pairing_uri_validation_success: "pairing_uri_validation_success",
        pairing_uri_not_expired: "pairing_uri_not_expired",
        store_new_pairing: "store_new_pairing",
        subscribing_pairing_topic: "subscribing_pairing_topic",
        subscribe_pairing_topic_success: "subscribe_pairing_topic_success",
        existing_pairing: "existing_pairing",
        pairing_not_expired: "pairing_not_expired",
        emit_inactive_pairing: "emit_inactive_pairing",
        emit_session_proposal: "emit_session_proposal",
        subscribing_to_pairing_topic: "subscribing_to_pairing_topic",
      },
      nn = {
        no_wss_connection: "no_wss_connection",
        no_internet_connection: "no_internet_connection",
        malformed_pairing_uri: "malformed_pairing_uri",
        active_pairing_already_exists: "active_pairing_already_exists",
        subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure",
        pairing_expired: "pairing_expired",
        proposal_expired: "proposal_expired",
        proposal_listener_not_found: "proposal_listener_not_found",
      },
      ts = {
        session_approve_started: "session_approve_started",
        proposal_not_expired: "proposal_not_expired",
        session_namespaces_validation_success:
          "session_namespaces_validation_success",
        create_session_topic: "create_session_topic",
        subscribing_session_topic: "subscribing_session_topic",
        subscribe_session_topic_success: "subscribe_session_topic_success",
        publishing_session_approve: "publishing_session_approve",
        session_approve_publish_success: "session_approve_publish_success",
        store_session: "store_session",
        publishing_session_settle: "publishing_session_settle",
        session_settle_publish_success: "session_settle_publish_success",
      },
      Vo = {
        no_internet_connection: "no_internet_connection",
        no_wss_connection: "no_wss_connection",
        proposal_expired: "proposal_expired",
        subscribe_session_topic_failure: "subscribe_session_topic_failure",
        session_approve_publish_failure: "session_approve_publish_failure",
        session_settle_publish_failure: "session_settle_publish_failure",
        session_approve_namespace_validation_failure:
          "session_approve_namespace_validation_failure",
        proposal_not_found: "proposal_not_found",
      },
      Wo = {
        authenticated_session_approve_started:
          "authenticated_session_approve_started",
        authenticated_session_not_expired: "authenticated_session_not_expired",
        chains_caip2_compliant: "chains_caip2_compliant",
        chains_evm_compliant: "chains_evm_compliant",
        create_authenticated_session_topic:
          "create_authenticated_session_topic",
        cacaos_verified: "cacaos_verified",
        store_authenticated_session: "store_authenticated_session",
        subscribing_authenticated_session_topic:
          "subscribing_authenticated_session_topic",
        subscribe_authenticated_session_topic_success:
          "subscribe_authenticated_session_topic_success",
        publishing_authenticated_session_approve:
          "publishing_authenticated_session_approve",
        authenticated_session_approve_publish_success:
          "authenticated_session_approve_publish_success",
      },
      Du = {
        no_internet_connection: "no_internet_connection",
        no_wss_connection: "no_wss_connection",
        missing_session_authenticate_request:
          "missing_session_authenticate_request",
        session_authenticate_request_expired:
          "session_authenticate_request_expired",
        chains_caip2_compliant_failure: "chains_caip2_compliant_failure",
        chains_evm_compliant_failure: "chains_evm_compliant_failure",
        invalid_cacao: "invalid_cacao",
        subscribe_authenticated_session_topic_failure:
          "subscribe_authenticated_session_topic_failure",
        authenticated_session_approve_publish_failure:
          "authenticated_session_approve_publish_failure",
        authenticated_session_pending_request_not_found:
          "authenticated_session_pending_request_not_found",
      },
      sj = 0.1,
      nj = "event-client",
      oj = 86400,
      aj = "https://pulse.walletconnect.org/batch";
    function cj(t, e) {
      if (t.length >= 255) throw new TypeError("Alphabet too long");
      for (var r = new Uint8Array(256), i = 0; i < r.length; i++) r[i] = 255;
      for (var s = 0; s < t.length; s++) {
        var n = t.charAt(s),
          o = n.charCodeAt(0);
        if (r[o] !== 255) throw new TypeError(n + " is ambiguous");
        r[o] = s;
      }
      var a = t.length,
        c = t.charAt(0),
        l = Math.log(a) / Math.log(256),
        u = Math.log(256) / Math.log(a);
      function h(p) {
        if (
          (p instanceof Uint8Array ||
            (ArrayBuffer.isView(p)
              ? (p = new Uint8Array(p.buffer, p.byteOffset, p.byteLength))
              : Array.isArray(p) && (p = Uint8Array.from(p))),
          !(p instanceof Uint8Array))
        )
          throw new TypeError("Expected Uint8Array");
        if (p.length === 0) return "";
        for (var w = 0, f = 0, m = 0, y = p.length; m !== y && p[m] === 0; )
          m++, w++;
        for (
          var E = ((y - m) * u + 1) >>> 0, C = new Uint8Array(E);
          m !== y;

        ) {
          for (
            var O = p[m], A = 0, P = E - 1;
            (O !== 0 || A < f) && P !== -1;
            P--, A++
          )
            (O += (256 * C[P]) >>> 0),
              (C[P] = O % a >>> 0),
              (O = (O / a) >>> 0);
          if (O !== 0) throw new Error("Non-zero carry");
          (f = A), m++;
        }
        for (var N = E - f; N !== E && C[N] === 0; ) N++;
        for (var x = c.repeat(w); N < E; ++N) x += t.charAt(C[N]);
        return x;
      }
      function d(p) {
        if (typeof p != "string") throw new TypeError("Expected String");
        if (p.length === 0) return new Uint8Array();
        var w = 0;
        if (p[w] !== " ") {
          for (var f = 0, m = 0; p[w] === c; ) f++, w++;
          for (
            var y = ((p.length - w) * l + 1) >>> 0, E = new Uint8Array(y);
            p[w];

          ) {
            var C = r[p.charCodeAt(w)];
            if (C === 255) return;
            for (var O = 0, A = y - 1; (C !== 0 || O < m) && A !== -1; A--, O++)
              (C += (a * E[A]) >>> 0),
                (E[A] = C % 256 >>> 0),
                (C = (C / 256) >>> 0);
            if (C !== 0) throw new Error("Non-zero carry");
            (m = O), w++;
          }
          if (p[w] !== " ") {
            for (var P = y - m; P !== y && E[P] === 0; ) P++;
            for (var N = new Uint8Array(f + (y - P)), x = f; P !== y; )
              N[x++] = E[P++];
            return N;
          }
        }
      }
      function g(p) {
        var w = d(p);
        if (w) return w;
        throw new Error(`Non-${e} character`);
      }
      return { encode: h, decodeUnsafe: d, decode: g };
    }
    var lj = cj,
      uj = lj;
    const O6 = (t) => {
        if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
          return t;
        if (t instanceof ArrayBuffer) return new Uint8Array(t);
        if (ArrayBuffer.isView(t))
          return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
        throw new Error("Unknown type, must be binary type");
      },
      hj = (t) => new TextEncoder().encode(t),
      dj = (t) => new TextDecoder().decode(t);
    class pj {
      constructor(e, r, i) {
        (this.name = e), (this.prefix = r), (this.baseEncode = i);
      }
      encode(e) {
        if (e instanceof Uint8Array)
          return `${this.prefix}${this.baseEncode(e)}`;
        throw Error("Unknown type, must be binary type");
      }
    }
    class fj {
      constructor(e, r, i) {
        if (((this.name = e), (this.prefix = r), r.codePointAt(0) === void 0))
          throw new Error("Invalid prefix character");
        (this.prefixCodePoint = r.codePointAt(0)), (this.baseDecode = i);
      }
      decode(e) {
        if (typeof e == "string") {
          if (e.codePointAt(0) !== this.prefixCodePoint)
            throw Error(
              `Unable to decode multibase string ${JSON.stringify(e)}, ${
                this.name
              } decoder only supports inputs prefixed with ${this.prefix}`
            );
          return this.baseDecode(e.slice(this.prefix.length));
        } else throw Error("Can only multibase decode strings");
      }
      or(e) {
        return N6(this, e);
      }
    }
    class gj {
      constructor(e) {
        this.decoders = e;
      }
      or(e) {
        return N6(this, e);
      }
      decode(e) {
        const r = e[0],
          i = this.decoders[r];
        if (i) return i.decode(e);
        throw RangeError(
          `Unable to decode multibase string ${JSON.stringify(
            e
          )}, only inputs prefixed with ${Object.keys(
            this.decoders
          )} are supported`
        );
      }
    }
    const N6 = (t, e) =>
      new gj(
        Rr(
          Rr({}, t.decoders || { [t.prefix]: t }),
          e.decoders || { [e.prefix]: e }
        )
      );
    class wj {
      constructor(e, r, i, s) {
        (this.name = e),
          (this.prefix = r),
          (this.baseEncode = i),
          (this.baseDecode = s),
          (this.encoder = new pj(e, r, i)),
          (this.decoder = new fj(e, r, s));
      }
      encode(e) {
        return this.encoder.encode(e);
      }
      decode(e) {
        return this.decoder.decode(e);
      }
    }
    const zp = ({ name: t, prefix: e, encode: r, decode: i }) =>
        new wj(t, e, r, i),
      ju = ({ prefix: t, name: e, alphabet: r }) => {
        const { encode: i, decode: s } = uj(r, e);
        return zp({ prefix: t, name: e, encode: i, decode: (n) => O6(s(n)) });
      },
      mj = (t, e, r, i) => {
        const s = {};
        for (let u = 0; u < e.length; ++u) s[e[u]] = u;
        let n = t.length;
        for (; t[n - 1] === "="; ) --n;
        const o = new Uint8Array(((n * r) / 8) | 0);
        let a = 0,
          c = 0,
          l = 0;
        for (let u = 0; u < n; ++u) {
          const h = s[t[u]];
          if (h === void 0) throw new SyntaxError(`Non-${i} character`);
          (c = (c << r) | h),
            (a += r),
            a >= 8 && ((a -= 8), (o[l++] = 255 & (c >> a)));
        }
        if (a >= r || 255 & (c << (8 - a)))
          throw new SyntaxError("Unexpected end of data");
        return o;
      },
      yj = (t, e, r) => {
        const i = e[e.length - 1] === "=",
          s = (1 << r) - 1;
        let n = "",
          o = 0,
          a = 0;
        for (let c = 0; c < t.length; ++c)
          for (a = (a << 8) | t[c], o += 8; o > r; )
            (o -= r), (n += e[s & (a >> o)]);
        if ((o && (n += e[s & (a << (r - o))]), i))
          for (; (n.length * r) & 7; ) n += "=";
        return n;
      },
      dr = ({ name: t, prefix: e, bitsPerChar: r, alphabet: i }) =>
        zp({
          prefix: e,
          name: t,
          encode(s) {
            return yj(s, i, r);
          },
          decode(s) {
            return mj(s, i, r, t);
          },
        }),
      bj = zp({
        prefix: "\0",
        name: "identity",
        encode: (t) => dj(t),
        decode: (t) => hj(t),
      });
    var vj = Object.freeze({ __proto__: null, identity: bj });
    const Ej = dr({
      prefix: "0",
      name: "base2",
      alphabet: "01",
      bitsPerChar: 1,
    });
    var Cj = Object.freeze({ __proto__: null, base2: Ej });
    const xj = dr({
      prefix: "7",
      name: "base8",
      alphabet: "01234567",
      bitsPerChar: 3,
    });
    var Ij = Object.freeze({ __proto__: null, base8: xj });
    const _j = ju({ prefix: "9", name: "base10", alphabet: "0123456789" });
    var Aj = Object.freeze({ __proto__: null, base10: _j });
    const Sj = dr({
        prefix: "f",
        name: "base16",
        alphabet: "0123456789abcdef",
        bitsPerChar: 4,
      }),
      Pj = dr({
        prefix: "F",
        name: "base16upper",
        alphabet: "0123456789ABCDEF",
        bitsPerChar: 4,
      });
    var Oj = Object.freeze({ __proto__: null, base16: Sj, base16upper: Pj });
    const Nj = dr({
        prefix: "b",
        name: "base32",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567",
        bitsPerChar: 5,
      }),
      Tj = dr({
        prefix: "B",
        name: "base32upper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
        bitsPerChar: 5,
      }),
      kj = dr({
        prefix: "c",
        name: "base32pad",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
        bitsPerChar: 5,
      }),
      Rj = dr({
        prefix: "C",
        name: "base32padupper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
        bitsPerChar: 5,
      }),
      $j = dr({
        prefix: "v",
        name: "base32hex",
        alphabet: "0123456789abcdefghijklmnopqrstuv",
        bitsPerChar: 5,
      }),
      Fj = dr({
        prefix: "V",
        name: "base32hexupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
        bitsPerChar: 5,
      }),
      Bj = dr({
        prefix: "t",
        name: "base32hexpad",
        alphabet: "0123456789abcdefghijklmnopqrstuv=",
        bitsPerChar: 5,
      }),
      Lj = dr({
        prefix: "T",
        name: "base32hexpadupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
        bitsPerChar: 5,
      }),
      Uj = dr({
        prefix: "h",
        name: "base32z",
        alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
        bitsPerChar: 5,
      });
    var Dj = Object.freeze({
      __proto__: null,
      base32: Nj,
      base32upper: Tj,
      base32pad: kj,
      base32padupper: Rj,
      base32hex: $j,
      base32hexupper: Fj,
      base32hexpad: Bj,
      base32hexpadupper: Lj,
      base32z: Uj,
    });
    const jj = ju({
        prefix: "k",
        name: "base36",
        alphabet: "0123456789abcdefghijklmnopqrstuvwxyz",
      }),
      Mj = ju({
        prefix: "K",
        name: "base36upper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
      });
    var zj = Object.freeze({ __proto__: null, base36: jj, base36upper: Mj });
    const qj = ju({
        name: "base58btc",
        prefix: "z",
        alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
      }),
      Hj = ju({
        name: "base58flickr",
        prefix: "Z",
        alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
      });
    var Vj = Object.freeze({
      __proto__: null,
      base58btc: qj,
      base58flickr: Hj,
    });
    const Wj = dr({
        prefix: "m",
        name: "base64",
        alphabet:
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        bitsPerChar: 6,
      }),
      Kj = dr({
        prefix: "M",
        name: "base64pad",
        alphabet:
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        bitsPerChar: 6,
      }),
      Gj = dr({
        prefix: "u",
        name: "base64url",
        alphabet:
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
        bitsPerChar: 6,
      }),
      Zj = dr({
        prefix: "U",
        name: "base64urlpad",
        alphabet:
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
        bitsPerChar: 6,
      });
    var Yj = Object.freeze({
      __proto__: null,
      base64: Wj,
      base64pad: Kj,
      base64url: Gj,
      base64urlpad: Zj,
    });
    const T6 = Array.from(
        "\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"
      ),
      Jj = T6.reduce((t, e, r) => ((t[r] = e), t), []),
      Xj = T6.reduce((t, e, r) => ((t[e.codePointAt(0)] = r), t), []);
    function Qj(t) {
      return t.reduce((e, r) => ((e += Jj[r]), e), "");
    }
    function eM(t) {
      const e = [];
      for (const r of t) {
        const i = Xj[r.codePointAt(0)];
        if (i === void 0) throw new Error(`Non-base256emoji character: ${r}`);
        e.push(i);
      }
      return new Uint8Array(e);
    }
    const tM = zp({
      prefix: "\u{1F680}",
      name: "base256emoji",
      encode: Qj,
      decode: eM,
    });
    var rM = Object.freeze({ __proto__: null, base256emoji: tM }),
      iM = R6,
      k6 = 128,
      sM = 127,
      nM = ~sM,
      oM = Math.pow(2, 31);
    function R6(t, e, r) {
      (e = e || []), (r = r || 0);
      for (var i = r; t >= oM; ) (e[r++] = (t & 255) | k6), (t /= 128);
      for (; t & nM; ) (e[r++] = (t & 255) | k6), (t >>>= 7);
      return (e[r] = t | 0), (R6.bytes = r - i + 1), e;
    }
    var aM = iw,
      cM = 128,
      $6 = 127;
    function iw(t, i) {
      var r = 0,
        i = i || 0,
        s = 0,
        n = i,
        o,
        a = t.length;
      do {
        if (n >= a)
          throw ((iw.bytes = 0), new RangeError("Could not decode varint"));
        (o = t[n++]),
          (r += s < 28 ? (o & $6) << s : (o & $6) * Math.pow(2, s)),
          (s += 7);
      } while (o >= cM);
      return (iw.bytes = n - i), r;
    }
    var lM = Math.pow(2, 7),
      uM = Math.pow(2, 14),
      hM = Math.pow(2, 21),
      dM = Math.pow(2, 28),
      pM = Math.pow(2, 35),
      fM = Math.pow(2, 42),
      gM = Math.pow(2, 49),
      wM = Math.pow(2, 56),
      mM = Math.pow(2, 63),
      yM = function (t) {
        return t < lM
          ? 1
          : t < uM
          ? 2
          : t < hM
          ? 3
          : t < dM
          ? 4
          : t < pM
          ? 5
          : t < fM
          ? 6
          : t < gM
          ? 7
          : t < wM
          ? 8
          : t < mM
          ? 9
          : 10;
      },
      bM = { encode: iM, decode: aM, encodingLength: yM },
      F6 = bM;
    const B6 = (t, e, r = 0) => (F6.encode(t, e, r), e),
      L6 = (t) => F6.encodingLength(t),
      sw = (t, e) => {
        const r = e.byteLength,
          i = L6(t),
          s = i + L6(r),
          n = new Uint8Array(s + r);
        return B6(t, n, 0), B6(r, n, i), n.set(e, s), new vM(t, r, e, n);
      };
    class vM {
      constructor(e, r, i, s) {
        (this.code = e), (this.size = r), (this.digest = i), (this.bytes = s);
      }
    }
    const U6 = ({ name: t, code: e, encode: r }) => new EM(t, e, r);
    class EM {
      constructor(e, r, i) {
        (this.name = e), (this.code = r), (this.encode = i);
      }
      digest(e) {
        if (e instanceof Uint8Array) {
          const r = this.encode(e);
          return r instanceof Uint8Array
            ? sw(this.code, r)
            : r.then((i) => sw(this.code, i));
        } else throw Error("Unknown type, must be binary type");
      }
    }
    const D6 = (t) => async (e) =>
        new Uint8Array(await crypto.subtle.digest(t, e)),
      CM = U6({ name: "sha2-256", code: 18, encode: D6("SHA-256") }),
      xM = U6({ name: "sha2-512", code: 19, encode: D6("SHA-512") });
    var IM = Object.freeze({ __proto__: null, sha256: CM, sha512: xM });
    const j6 = 0,
      _M = "identity",
      M6 = O6;
    var AM = Object.freeze({
      __proto__: null,
      identity: {
        code: j6,
        name: _M,
        encode: M6,
        digest: (t) => sw(j6, M6(t)),
      },
    });
    new TextEncoder(), new TextDecoder();
    const z6 = Rr(
      Rr(
        Rr(Rr(Rr(Rr(Rr(Rr(Rr(Rr({}, vj), Cj), Ij), Aj), Oj), Dj), zj), Vj),
        Yj
      ),
      rM
    );
    Rr(Rr({}, IM), AM);
    function SM(t = 0) {
      return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null
        ? globalThis.Buffer.allocUnsafe(t)
        : new Uint8Array(t);
    }
    function q6(t, e, r, i) {
      return {
        name: t,
        prefix: e,
        encoder: { name: t, prefix: e, encode: r },
        decoder: { decode: i },
      };
    }
    const H6 = q6(
        "utf8",
        "u",
        (t) => "u" + new TextDecoder("utf8").decode(t),
        (t) => new TextEncoder().encode(t.substring(1))
      ),
      nw = q6(
        "ascii",
        "a",
        (t) => {
          let e = "a";
          for (let r = 0; r < t.length; r++) e += String.fromCharCode(t[r]);
          return e;
        },
        (t) => {
          t = t.substring(1);
          const e = SM(t.length);
          for (let r = 0; r < t.length; r++) e[r] = t.charCodeAt(r);
          return e;
        }
      ),
      PM = Rr(
        {
          utf8: H6,
          "utf-8": H6,
          hex: z6.base16,
          latin1: nw,
          ascii: nw,
          binary: nw,
        },
        z6
      );
    function OM(t, e = "utf8") {
      const r = PM[e];
      if (!r) throw new Error(`Unsupported encoding "${e}"`);
      return (e === "utf8" || e === "utf-8") &&
        globalThis.Buffer != null &&
        globalThis.Buffer.from != null
        ? globalThis.Buffer.from(t, "utf8")
        : r.decoder.decode(`${r.prefix}${t}`);
    }
    var NM = Object.defineProperty,
      TM = (t, e, r) =>
        e in t
          ? NM(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      As = (t, e, r) => TM(t, typeof e != "symbol" ? e + "" : e, r);
    class kM {
      constructor(e, r) {
        (this.core = e),
          (this.logger = r),
          As(this, "keychain", new Map()),
          As(this, "name", RD),
          As(this, "version", $D),
          As(this, "initialized", !1),
          As(this, "storagePrefix", Is),
          As(this, "init", async () => {
            if (!this.initialized) {
              const i = await this.getKeyChain();
              typeof i < "u" && (this.keychain = i), (this.initialized = !0);
            }
          }),
          As(this, "has", (i) => (this.isInitialized(), this.keychain.has(i))),
          As(this, "set", async (i, s) => {
            this.isInitialized(), this.keychain.set(i, s), await this.persist();
          }),
          As(this, "get", (i) => {
            this.isInitialized();
            const s = this.keychain.get(i);
            if (typeof s > "u") {
              const { message: n } = J("NO_MATCHING_KEY", `${this.name}: ${i}`);
              throw new Error(n);
            }
            return s;
          }),
          As(this, "del", async (i) => {
            this.isInitialized(), this.keychain.delete(i), await this.persist();
          }),
          (this.core = e),
          (this.logger = Ve(r, this.name));
      }
      get context() {
        return it(this.logger);
      }
      get storageKey() {
        return (
          this.storagePrefix +
          this.version +
          this.core.customStoragePrefix +
          "//" +
          this.name
        );
      }
      async setKeyChain(e) {
        await this.core.storage.setItem(this.storageKey, h1(e));
      }
      async getKeyChain() {
        const e = await this.core.storage.getItem(this.storageKey);
        return typeof e < "u" ? d1(e) : void 0;
      }
      async persist() {
        await this.setKeyChain(this.keychain);
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e } = J("NOT_INITIALIZED", this.name);
          throw new Error(e);
        }
      }
    }
    var RM = Object.defineProperty,
      $M = (t, e, r) =>
        e in t
          ? RM(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      pr = (t, e, r) => $M(t, typeof e != "symbol" ? e + "" : e, r);
    class FM {
      constructor(e, r, i) {
        (this.core = e),
          (this.logger = r),
          pr(this, "name", TD),
          pr(this, "keychain"),
          pr(this, "randomSessionIdentifier", j1()),
          pr(this, "initialized", !1),
          pr(this, "init", async () => {
            this.initialized ||
              (await this.keychain.init(), (this.initialized = !0));
          }),
          pr(
            this,
            "hasKeys",
            (s) => (this.isInitialized(), this.keychain.has(s))
          ),
          pr(this, "getClientId", async () => {
            this.isInitialized();
            const s = await this.getClientSeed(),
              n = pp(s);
            return o1(n.publicKey);
          }),
          pr(this, "generateKeyPair", () => {
            this.isInitialized();
            const s = mB();
            return this.setPrivateKey(s.publicKey, s.privateKey);
          }),
          pr(this, "signJWT", async (s) => {
            this.isInitialized();
            const n = await this.getClientSeed(),
              o = pp(n),
              a = this.randomSessionIdentifier;
            return await V3(a, s, kD, o);
          }),
          pr(this, "generateSharedKey", (s, n, o) => {
            this.isInitialized();
            const a = this.getPrivateKey(s),
              c = yB(a, n);
            return this.setSymKey(c, o);
          }),
          pr(this, "setSymKey", async (s, n) => {
            this.isInitialized();
            const o = n || Sp(s);
            return await this.keychain.set(o, s), o;
          }),
          pr(this, "deleteKeyPair", async (s) => {
            this.isInitialized(), await this.keychain.del(s);
          }),
          pr(this, "deleteSymKey", async (s) => {
            this.isInitialized(), await this.keychain.del(s);
          }),
          pr(this, "encode", async (s, n, o) => {
            this.isInitialized();
            const a = O4(o),
              c = ys(n);
            if (T4(a)) return EB(c, o?.encoding);
            if (N4(a)) {
              const d = a.senderPublicKey,
                g = a.receiverPublicKey;
              s = await this.generateSharedKey(d, g);
            }
            const l = this.getSymKey(s),
              { type: u, senderPublicKey: h } = a;
            return bB({
              type: u,
              symKey: l,
              message: c,
              senderPublicKey: h,
              encoding: o?.encoding,
            });
          }),
          pr(this, "decode", async (s, n, o) => {
            this.isInitialized();
            const a = xB(n, o);
            if (T4(a)) {
              const c = CB(n, o?.encoding);
              return Ws(c);
            }
            if (N4(a)) {
              const c = a.receiverPublicKey,
                l = a.senderPublicKey;
              s = await this.generateSharedKey(c, l);
            }
            try {
              const c = this.getSymKey(s),
                l = vB({ symKey: c, encoded: n, encoding: o?.encoding });
              return Ws(l);
            } catch (c) {
              this.logger.error(
                `Failed to decode message from topic: '${s}', clientId: '${await this.getClientId()}'`
              ),
                this.logger.error(c);
            }
          }),
          pr(this, "getPayloadType", (s, n = Xi) => {
            const o = Au({ encoded: s, encoding: n });
            return Mo(o.type);
          }),
          pr(this, "getPayloadSenderPublicKey", (s, n = Xi) => {
            const o = Au({ encoded: s, encoding: n });
            return o.senderPublicKey ? et(o.senderPublicKey, Tr) : void 0;
          }),
          (this.core = e),
          (this.logger = Ve(r, this.name)),
          (this.keychain = i || new kM(this.core, this.logger));
      }
      get context() {
        return it(this.logger);
      }
      async setPrivateKey(e, r) {
        return await this.keychain.set(e, r), e;
      }
      getPrivateKey(e) {
        return this.keychain.get(e);
      }
      async getClientSeed() {
        let e = "";
        try {
          e = this.keychain.get(x6);
        } catch {
          (e = j1()), await this.keychain.set(x6, e);
        }
        return OM(e, "base16");
      }
      getSymKey(e) {
        return this.keychain.get(e);
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e } = J("NOT_INITIALIZED", this.name);
          throw new Error(e);
        }
      }
    }
    var BM = Object.defineProperty,
      LM = Object.defineProperties,
      UM = Object.getOwnPropertyDescriptors,
      V6 = Object.getOwnPropertySymbols,
      DM = Object.prototype.hasOwnProperty,
      jM = Object.prototype.propertyIsEnumerable,
      ow = (t, e, r) =>
        e in t
          ? BM(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      MM = (t, e) => {
        for (var r in e || (e = {})) DM.call(e, r) && ow(t, r, e[r]);
        if (V6) for (var r of V6(e)) jM.call(e, r) && ow(t, r, e[r]);
        return t;
      },
      zM = (t, e) => LM(t, UM(e)),
      di = (t, e, r) => ow(t, typeof e != "symbol" ? e + "" : e, r);
    class qM extends AU {
      constructor(e, r) {
        super(e, r),
          (this.logger = e),
          (this.core = r),
          di(this, "messages", new Map()),
          di(this, "messagesWithoutClientAck", new Map()),
          di(this, "name", FD),
          di(this, "version", BD),
          di(this, "initialized", !1),
          di(this, "storagePrefix", Is),
          di(this, "init", async () => {
            if (!this.initialized) {
              this.logger.trace("Initialized");
              try {
                const i = await this.getRelayerMessages();
                typeof i < "u" && (this.messages = i);
                const s = await this.getRelayerMessagesWithoutClientAck();
                typeof s < "u" && (this.messagesWithoutClientAck = s),
                  this.logger.debug(
                    `Successfully Restored records for ${this.name}`
                  ),
                  this.logger.trace({
                    type: "method",
                    method: "restore",
                    size: this.messages.size,
                  });
              } catch (i) {
                this.logger.debug(`Failed to Restore records for ${this.name}`),
                  this.logger.error(i);
              } finally {
                this.initialized = !0;
              }
            }
          }),
          di(this, "set", async (i, s, n) => {
            this.isInitialized();
            const o = Cs(s);
            let a = this.messages.get(i);
            if ((typeof a > "u" && (a = {}), typeof a[o] < "u")) return o;
            if (((a[o] = s), this.messages.set(i, a), n === Mp.inbound)) {
              const c = this.messagesWithoutClientAck.get(i) || {};
              this.messagesWithoutClientAck.set(i, zM(MM({}, c), { [o]: s }));
            }
            return await this.persist(), o;
          }),
          di(this, "get", (i) => {
            this.isInitialized();
            let s = this.messages.get(i);
            return typeof s > "u" && (s = {}), s;
          }),
          di(this, "getWithoutAck", (i) => {
            this.isInitialized();
            const s = {};
            for (const n of i) {
              const o = this.messagesWithoutClientAck.get(n) || {};
              s[n] = Object.values(o);
            }
            return s;
          }),
          di(this, "has", (i, s) => {
            this.isInitialized();
            const n = this.get(i),
              o = Cs(s);
            return typeof n[o] < "u";
          }),
          di(this, "ack", async (i, s) => {
            this.isInitialized();
            const n = this.messagesWithoutClientAck.get(i);
            if (typeof n > "u") return;
            const o = Cs(s);
            delete n[o],
              Object.keys(n).length === 0
                ? this.messagesWithoutClientAck.delete(i)
                : this.messagesWithoutClientAck.set(i, n),
              await this.persist();
          }),
          di(this, "del", async (i) => {
            this.isInitialized(),
              this.messages.delete(i),
              this.messagesWithoutClientAck.delete(i),
              await this.persist();
          }),
          (this.logger = Ve(e, this.name)),
          (this.core = r);
      }
      get context() {
        return it(this.logger);
      }
      get storageKey() {
        return (
          this.storagePrefix +
          this.version +
          this.core.customStoragePrefix +
          "//" +
          this.name
        );
      }
      get storageKeyWithoutClientAck() {
        return (
          this.storagePrefix +
          this.version +
          this.core.customStoragePrefix +
          "//" +
          this.name +
          "_withoutClientAck"
        );
      }
      async setRelayerMessages(e) {
        await this.core.storage.setItem(this.storageKey, h1(e));
      }
      async setRelayerMessagesWithoutClientAck(e) {
        await this.core.storage.setItem(this.storageKeyWithoutClientAck, h1(e));
      }
      async getRelayerMessages() {
        const e = await this.core.storage.getItem(this.storageKey);
        return typeof e < "u" ? d1(e) : void 0;
      }
      async getRelayerMessagesWithoutClientAck() {
        const e = await this.core.storage.getItem(
          this.storageKeyWithoutClientAck
        );
        return typeof e < "u" ? d1(e) : void 0;
      }
      async persist() {
        await this.setRelayerMessages(this.messages),
          await this.setRelayerMessagesWithoutClientAck(
            this.messagesWithoutClientAck
          );
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e } = J("NOT_INITIALIZED", this.name);
          throw new Error(e);
        }
      }
    }
    var HM = Object.defineProperty,
      VM = Object.defineProperties,
      WM = Object.getOwnPropertyDescriptors,
      W6 = Object.getOwnPropertySymbols,
      KM = Object.prototype.hasOwnProperty,
      GM = Object.prototype.propertyIsEnumerable,
      aw = (t, e, r) =>
        e in t
          ? HM(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      qp = (t, e) => {
        for (var r in e || (e = {})) KM.call(e, r) && aw(t, r, e[r]);
        if (W6) for (var r of W6(e)) GM.call(e, r) && aw(t, r, e[r]);
        return t;
      },
      cw = (t, e) => VM(t, WM(e)),
      rs = (t, e, r) => aw(t, typeof e != "symbol" ? e + "" : e, r);
    class ZM extends SU {
      constructor(e, r) {
        super(e, r),
          (this.relayer = e),
          (this.logger = r),
          rs(this, "events", new rt.exports.EventEmitter()),
          rs(this, "name", LD),
          rs(this, "queue", new Map()),
          rs(this, "publishTimeout", z.toMiliseconds(z.ONE_MINUTE)),
          rs(this, "initialPublishTimeout", z.toMiliseconds(z.ONE_SECOND * 15)),
          rs(this, "needsTransportRestart", !1),
          rs(this, "publish", async (i, s, n) => {
            var o;
            this.logger.debug("Publishing Payload"),
              this.logger.trace({
                type: "method",
                method: "publish",
                params: { topic: i, message: s, opts: n },
              });
            const a = n?.ttl || I6,
              c = Pp(n),
              l = n?.prompt || !1,
              u = n?.tag || 0,
              h = n?.id || ui().toString(),
              d = {
                topic: i,
                message: s,
                opts: {
                  ttl: a,
                  relay: c,
                  prompt: l,
                  tag: u,
                  id: h,
                  attestation: n?.attestation,
                  tvf: n?.tvf,
                },
              },
              g = `Failed to publish payload, please try again. id:${h} tag:${u}`;
            try {
              const p = new Promise(async (w) => {
                const f = ({ id: y }) => {
                  d.opts.id === y &&
                    (this.removeRequestFromQueue(y),
                    this.relayer.events.removeListener(Jt.publish, f),
                    w(d));
                };
                this.relayer.events.on(Jt.publish, f);
                const m = Vn(
                  new Promise((y, E) => {
                    this.rpcPublish({
                      topic: i,
                      message: s,
                      ttl: a,
                      prompt: l,
                      tag: u,
                      id: h,
                      attestation: n?.attestation,
                      tvf: n?.tvf,
                    })
                      .then(y)
                      .catch((C) => {
                        this.logger.warn(C, C?.message), E(C);
                      });
                  }),
                  this.initialPublishTimeout,
                  `Failed initial publish, retrying.... id:${h} tag:${u}`
                );
                try {
                  await m, this.events.removeListener(Jt.publish, f);
                } catch (y) {
                  this.queue.set(h, cw(qp({}, d), { attempt: 1 })),
                    this.logger.warn(y, y?.message);
                }
              });
              this.logger.trace({
                type: "method",
                method: "publish",
                params: { id: h, topic: i, message: s, opts: n },
              }),
                await Vn(p, this.publishTimeout, g);
            } catch (p) {
              if (
                (this.logger.debug("Failed to Publish Payload"),
                this.logger.error(p),
                (o = n?.internal) != null && o.throwOnFailedPublish)
              )
                throw p;
            } finally {
              this.queue.delete(h);
            }
          }),
          rs(this, "on", (i, s) => {
            this.events.on(i, s);
          }),
          rs(this, "once", (i, s) => {
            this.events.once(i, s);
          }),
          rs(this, "off", (i, s) => {
            this.events.off(i, s);
          }),
          rs(this, "removeListener", (i, s) => {
            this.events.removeListener(i, s);
          }),
          (this.relayer = e),
          (this.logger = Ve(r, this.name)),
          this.registerEventListeners();
      }
      get context() {
        return it(this.logger);
      }
      async rpcPublish(e) {
        var r, i, s, n;
        const {
            topic: o,
            message: a,
            ttl: c = I6,
            prompt: l,
            tag: u,
            id: h,
            attestation: d,
            tvf: g,
          } = e,
          p = {
            method: Su(Pp().protocol).publish,
            params: qp(
              {
                topic: o,
                message: a,
                ttl: c,
                prompt: l,
                tag: u,
                attestation: d,
              },
              g
            ),
            id: h,
          };
        hr((r = p.params) == null ? void 0 : r.prompt) &&
          ((i = p.params) == null || delete i.prompt),
          hr((s = p.params) == null ? void 0 : s.tag) &&
            ((n = p.params) == null || delete n.tag),
          this.logger.debug("Outgoing Relay Payload"),
          this.logger.trace({
            type: "message",
            direction: "outgoing",
            request: p,
          });
        const w = await this.relayer.request(p);
        return (
          this.relayer.events.emit(Jt.publish, e),
          this.logger.debug("Successfully Published Payload"),
          w
        );
      }
      removeRequestFromQueue(e) {
        this.queue.delete(e);
      }
      checkQueue() {
        this.queue.forEach(async (e, r) => {
          const i = e.attempt + 1;
          this.queue.set(r, cw(qp({}, e), { attempt: i }));
          const { topic: s, message: n, opts: o, attestation: a } = e;
          this.logger.warn(
            {},
            `Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${i}`
          ),
            await this.rpcPublish(
              cw(qp({}, e), {
                topic: s,
                message: n,
                ttl: o.ttl,
                prompt: o.prompt,
                tag: o.tag,
                id: o.id,
                attestation: a,
                tvf: o.tvf,
              })
            ),
            this.logger.warn({}, `Publisher: queue->published: ${e.opts.id}`);
        });
      }
      registerEventListeners() {
        this.relayer.core.heartbeat.on(Ti.pulse, () => {
          if (this.needsTransportRestart) {
            (this.needsTransportRestart = !1),
              this.relayer.events.emit(Jt.connection_stalled);
            return;
          }
          this.checkQueue();
        }),
          this.relayer.on(Jt.message_ack, (e) => {
            this.removeRequestFromQueue(e.id.toString());
          });
      }
    }
    var YM = Object.defineProperty,
      JM = (t, e, r) =>
        e in t
          ? YM(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Ac = (t, e, r) => JM(t, typeof e != "symbol" ? e + "" : e, r);
    class XM {
      constructor() {
        Ac(this, "map", new Map()),
          Ac(this, "set", (e, r) => {
            const i = this.get(e);
            this.exists(e, r) || this.map.set(e, [...i, r]);
          }),
          Ac(this, "get", (e) => this.map.get(e) || []),
          Ac(this, "exists", (e, r) => this.get(e).includes(r)),
          Ac(this, "delete", (e, r) => {
            if (typeof r > "u") {
              this.map.delete(e);
              return;
            }
            if (!this.map.has(e)) return;
            const i = this.get(e);
            if (!this.exists(e, r)) return;
            const s = i.filter((n) => n !== r);
            if (!s.length) {
              this.map.delete(e);
              return;
            }
            this.map.set(e, s);
          }),
          Ac(this, "clear", () => {
            this.map.clear();
          });
      }
      get topics() {
        return Array.from(this.map.keys());
      }
    }
    var QM = Object.defineProperty,
      ez = Object.defineProperties,
      tz = Object.getOwnPropertyDescriptors,
      K6 = Object.getOwnPropertySymbols,
      rz = Object.prototype.hasOwnProperty,
      iz = Object.prototype.propertyIsEnumerable,
      lw = (t, e, r) =>
        e in t
          ? QM(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Mu = (t, e) => {
        for (var r in e || (e = {})) rz.call(e, r) && lw(t, r, e[r]);
        if (K6) for (var r of K6(e)) iz.call(e, r) && lw(t, r, e[r]);
        return t;
      },
      uw = (t, e) => ez(t, tz(e)),
      st = (t, e, r) => lw(t, typeof e != "symbol" ? e + "" : e, r);
    class sz extends NU {
      constructor(e, r) {
        super(e, r),
          (this.relayer = e),
          (this.logger = r),
          st(this, "subscriptions", new Map()),
          st(this, "topicMap", new XM()),
          st(this, "events", new rt.exports.EventEmitter()),
          st(this, "name", HD),
          st(this, "version", VD),
          st(this, "pending", new Map()),
          st(this, "cached", []),
          st(this, "initialized", !1),
          st(this, "storagePrefix", Is),
          st(this, "subscribeTimeout", z.toMiliseconds(z.ONE_MINUTE)),
          st(
            this,
            "initialSubscribeTimeout",
            z.toMiliseconds(z.ONE_SECOND * 15)
          ),
          st(this, "clientId"),
          st(this, "batchSubscribeTopicsLimit", 500),
          st(this, "init", async () => {
            this.initialized ||
              (this.logger.trace("Initialized"),
              this.registerEventListeners(),
              await this.restore()),
              (this.initialized = !0);
          }),
          st(this, "subscribe", async (i, s) => {
            this.isInitialized(),
              this.logger.debug("Subscribing Topic"),
              this.logger.trace({
                type: "method",
                method: "subscribe",
                params: { topic: i, opts: s },
              });
            try {
              const n = Pp(s),
                o = { topic: i, relay: n, transportType: s?.transportType };
              this.pending.set(i, o);
              const a = await this.rpcSubscribe(i, n, s);
              return (
                typeof a == "string" &&
                  (this.onSubscribe(a, o),
                  this.logger.debug("Successfully Subscribed Topic"),
                  this.logger.trace({
                    type: "method",
                    method: "subscribe",
                    params: { topic: i, opts: s },
                  })),
                a
              );
            } catch (n) {
              throw (
                (this.logger.debug("Failed to Subscribe Topic"),
                this.logger.error(n),
                n)
              );
            }
          }),
          st(this, "unsubscribe", async (i, s) => {
            this.isInitialized(),
              typeof s?.id < "u"
                ? await this.unsubscribeById(i, s.id, s)
                : await this.unsubscribeByTopic(i, s);
          }),
          st(
            this,
            "isSubscribed",
            (i) =>
              new Promise((s) => {
                s(this.topicMap.topics.includes(i));
              })
          ),
          st(
            this,
            "isKnownTopic",
            (i) =>
              new Promise((s) => {
                s(
                  this.topicMap.topics.includes(i) ||
                    this.pending.has(i) ||
                    this.cached.some((n) => n.topic === i)
                );
              })
          ),
          st(this, "on", (i, s) => {
            this.events.on(i, s);
          }),
          st(this, "once", (i, s) => {
            this.events.once(i, s);
          }),
          st(this, "off", (i, s) => {
            this.events.off(i, s);
          }),
          st(this, "removeListener", (i, s) => {
            this.events.removeListener(i, s);
          }),
          st(this, "start", async () => {
            await this.onConnect();
          }),
          st(this, "stop", async () => {
            await this.onDisconnect();
          }),
          st(this, "restart", async () => {
            await this.restore(), await this.onRestart();
          }),
          st(this, "checkPending", async () => {
            if (
              this.pending.size === 0 &&
              (!this.initialized || !this.relayer.connected)
            )
              return;
            const i = [];
            this.pending.forEach((s) => {
              i.push(s);
            }),
              await this.batchSubscribe(i);
          }),
          st(this, "registerEventListeners", () => {
            this.relayer.core.heartbeat.on(Ti.pulse, async () => {
              await this.checkPending();
            }),
              this.events.on(hi.created, async (i) => {
                const s = hi.created;
                this.logger.info(`Emitting ${s}`),
                  this.logger.debug({ type: "event", event: s, data: i }),
                  await this.persist();
              }),
              this.events.on(hi.deleted, async (i) => {
                const s = hi.deleted;
                this.logger.info(`Emitting ${s}`),
                  this.logger.debug({ type: "event", event: s, data: i }),
                  await this.persist();
              });
          }),
          (this.relayer = e),
          (this.logger = Ve(r, this.name)),
          (this.clientId = "");
      }
      get context() {
        return it(this.logger);
      }
      get storageKey() {
        return (
          this.storagePrefix +
          this.version +
          this.relayer.core.customStoragePrefix +
          "//" +
          this.name
        );
      }
      get length() {
        return this.subscriptions.size;
      }
      get ids() {
        return Array.from(this.subscriptions.keys());
      }
      get values() {
        return Array.from(this.subscriptions.values());
      }
      get topics() {
        return this.topicMap.topics;
      }
      get hasAnyTopics() {
        return (
          this.topicMap.topics.length > 0 ||
          this.pending.size > 0 ||
          this.cached.length > 0 ||
          this.subscriptions.size > 0
        );
      }
      hasSubscription(e, r) {
        let i = !1;
        try {
          i = this.getSubscription(e).topic === r;
        } catch {}
        return i;
      }
      reset() {
        (this.cached = []), (this.initialized = !0);
      }
      onDisable() {
        this.values.length > 0 && (this.cached = this.values),
          this.subscriptions.clear(),
          this.topicMap.clear();
      }
      async unsubscribeByTopic(e, r) {
        const i = this.topicMap.get(e);
        await Promise.all(
          i.map(async (s) => await this.unsubscribeById(e, s, r))
        );
      }
      async unsubscribeById(e, r, i) {
        this.logger.debug("Unsubscribing Topic"),
          this.logger.trace({
            type: "method",
            method: "unsubscribe",
            params: { topic: e, id: r, opts: i },
          });
        try {
          const s = Pp(i);
          await this.restartToComplete({ topic: e, id: r, relay: s }),
            await this.rpcUnsubscribe(e, r, s);
          const n = Ge("USER_DISCONNECTED", `${this.name}, ${e}`);
          await this.onUnsubscribe(e, r, n),
            this.logger.debug("Successfully Unsubscribed Topic"),
            this.logger.trace({
              type: "method",
              method: "unsubscribe",
              params: { topic: e, id: r, opts: i },
            });
        } catch (s) {
          throw (
            (this.logger.debug("Failed to Unsubscribe Topic"),
            this.logger.error(s),
            s)
          );
        }
      }
      async rpcSubscribe(e, r, i) {
        var s;
        (!i || i?.transportType === gt.relay) &&
          (await this.restartToComplete({ topic: e, id: e, relay: r }));
        const n = { method: Su(r.protocol).subscribe, params: { topic: e } };
        this.logger.debug("Outgoing Relay Payload"),
          this.logger.trace({
            type: "payload",
            direction: "outgoing",
            request: n,
          });
        const o = (s = i?.internal) == null ? void 0 : s.throwOnFailedPublish;
        try {
          const a = await this.getSubscriptionId(e);
          if (i?.transportType === gt.link_mode)
            return (
              setTimeout(() => {
                (this.relayer.connected || this.relayer.connecting) &&
                  this.relayer.request(n).catch((u) => this.logger.warn(u));
              }, z.toMiliseconds(z.ONE_SECOND)),
              a
            );
          const c = new Promise(async (u) => {
              const h = (d) => {
                d.topic === e &&
                  (this.events.removeListener(hi.created, h), u(d.id));
              };
              this.events.on(hi.created, h);
              try {
                const d = await Vn(
                  new Promise((g, p) => {
                    this.relayer
                      .request(n)
                      .catch((w) => {
                        this.logger.warn(w, w?.message), p(w);
                      })
                      .then(g);
                  }),
                  this.initialSubscribeTimeout,
                  `Subscribing to ${e} failed, please try again`
                );
                this.events.removeListener(hi.created, h), u(d);
              } catch {}
            }),
            l = await Vn(
              c,
              this.subscribeTimeout,
              `Subscribing to ${e} failed, please try again`
            );
          if (!l && o)
            throw new Error(`Subscribing to ${e} failed, please try again`);
          return l ? a : null;
        } catch (a) {
          if (
            (this.logger.debug("Outgoing Relay Subscribe Payload stalled"),
            this.relayer.events.emit(Jt.connection_stalled),
            o)
          )
            throw a;
        }
        return null;
      }
      async rpcBatchSubscribe(e) {
        if (!e.length) return;
        const r = e[0].relay,
          i = {
            method: Su(r.protocol).batchSubscribe,
            params: { topics: e.map((s) => s.topic) },
          };
        this.logger.debug("Outgoing Relay Payload"),
          this.logger.trace({
            type: "payload",
            direction: "outgoing",
            request: i,
          });
        try {
          await await Vn(
            new Promise((s) => {
              this.relayer
                .request(i)
                .catch((n) => this.logger.warn(n))
                .then(s);
            }),
            this.subscribeTimeout,
            "rpcBatchSubscribe failed, please try again"
          );
        } catch {
          this.relayer.events.emit(Jt.connection_stalled);
        }
      }
      async rpcBatchFetchMessages(e) {
        if (!e.length) return;
        const r = e[0].relay,
          i = {
            method: Su(r.protocol).batchFetchMessages,
            params: { topics: e.map((n) => n.topic) },
          };
        this.logger.debug("Outgoing Relay Payload"),
          this.logger.trace({
            type: "payload",
            direction: "outgoing",
            request: i,
          });
        let s;
        try {
          s = await await Vn(
            new Promise((n, o) => {
              this.relayer
                .request(i)
                .catch((a) => {
                  this.logger.warn(a), o(a);
                })
                .then(n);
            }),
            this.subscribeTimeout,
            "rpcBatchFetchMessages failed, please try again"
          );
        } catch {
          this.relayer.events.emit(Jt.connection_stalled);
        }
        return s;
      }
      rpcUnsubscribe(e, r, i) {
        const s = {
          method: Su(i.protocol).unsubscribe,
          params: { topic: e, id: r },
        };
        return (
          this.logger.debug("Outgoing Relay Payload"),
          this.logger.trace({
            type: "payload",
            direction: "outgoing",
            request: s,
          }),
          this.relayer.request(s)
        );
      }
      onSubscribe(e, r) {
        this.setSubscription(e, uw(Mu({}, r), { id: e })),
          this.pending.delete(r.topic);
      }
      onBatchSubscribe(e) {
        e.length &&
          e.forEach((r) => {
            this.setSubscription(r.id, Mu({}, r)), this.pending.delete(r.topic);
          });
      }
      async onUnsubscribe(e, r, i) {
        this.events.removeAllListeners(r),
          this.hasSubscription(r, e) && this.deleteSubscription(r, i),
          await this.relayer.messages.del(e);
      }
      async setRelayerSubscriptions(e) {
        await this.relayer.core.storage.setItem(this.storageKey, e);
      }
      async getRelayerSubscriptions() {
        return await this.relayer.core.storage.getItem(this.storageKey);
      }
      setSubscription(e, r) {
        this.logger.debug("Setting subscription"),
          this.logger.trace({
            type: "method",
            method: "setSubscription",
            id: e,
            subscription: r,
          }),
          this.addSubscription(e, r);
      }
      addSubscription(e, r) {
        this.subscriptions.set(e, Mu({}, r)),
          this.topicMap.set(r.topic, e),
          this.events.emit(hi.created, r);
      }
      getSubscription(e) {
        this.logger.debug("Getting subscription"),
          this.logger.trace({
            type: "method",
            method: "getSubscription",
            id: e,
          });
        const r = this.subscriptions.get(e);
        if (!r) {
          const { message: i } = J("NO_MATCHING_KEY", `${this.name}: ${e}`);
          throw new Error(i);
        }
        return r;
      }
      deleteSubscription(e, r) {
        this.logger.debug("Deleting subscription"),
          this.logger.trace({
            type: "method",
            method: "deleteSubscription",
            id: e,
            reason: r,
          });
        const i = this.getSubscription(e);
        this.subscriptions.delete(e),
          this.topicMap.delete(i.topic, e),
          this.events.emit(hi.deleted, uw(Mu({}, i), { reason: r }));
      }
      async persist() {
        await this.setRelayerSubscriptions(this.values),
          this.events.emit(hi.sync);
      }
      async onRestart() {
        if (this.cached.length) {
          const e = [...this.cached],
            r = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
          for (let i = 0; i < r; i++) {
            const s = e.splice(0, this.batchSubscribeTopicsLimit);
            await this.batchSubscribe(s);
          }
        }
        this.events.emit(hi.resubscribed);
      }
      async restore() {
        try {
          const e = await this.getRelayerSubscriptions();
          if (typeof e > "u" || !e.length) return;
          if (this.subscriptions.size) {
            const { message: r } = J("RESTORE_WILL_OVERRIDE", this.name);
            throw (
              (this.logger.error(r),
              this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`),
              new Error(r))
            );
          }
          (this.cached = e),
            this.logger.debug(
              `Successfully Restored subscriptions for ${this.name}`
            ),
            this.logger.trace({
              type: "method",
              method: "restore",
              subscriptions: this.values,
            });
        } catch (e) {
          this.logger.debug(`Failed to Restore subscriptions for ${this.name}`),
            this.logger.error(e);
        }
      }
      async batchSubscribe(e) {
        e.length &&
          (await this.rpcBatchSubscribe(e),
          this.onBatchSubscribe(
            await Promise.all(
              e.map(async (r) =>
                uw(Mu({}, r), { id: await this.getSubscriptionId(r.topic) })
              )
            )
          ));
      }
      async batchFetchMessages(e) {
        if (!e.length) return;
        this.logger.trace(
          `Fetching batch messages for ${e.length} subscriptions`
        );
        const r = await this.rpcBatchFetchMessages(e);
        r &&
          r.messages &&
          (await o$(z.toMiliseconds(z.ONE_SECOND)),
          await this.relayer.handleBatchMessageEvents(r.messages));
      }
      async onConnect() {
        await this.restart(), this.reset();
      }
      onDisconnect() {
        this.onDisable();
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e } = J("NOT_INITIALIZED", this.name);
          throw new Error(e);
        }
      }
      async restartToComplete(e) {
        !this.relayer.connected &&
          !this.relayer.connecting &&
          (this.cached.push(e), await this.relayer.transportOpen());
      }
      async getClientId() {
        return (
          this.clientId ||
            (this.clientId = await this.relayer.core.crypto.getClientId()),
          this.clientId
        );
      }
      async getSubscriptionId(e) {
        return Cs(e + (await this.getClientId()));
      }
    }
    var nz = Object.defineProperty,
      G6 = Object.getOwnPropertySymbols,
      oz = Object.prototype.hasOwnProperty,
      az = Object.prototype.propertyIsEnumerable,
      hw = (t, e, r) =>
        e in t
          ? nz(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Z6 = (t, e) => {
        for (var r in e || (e = {})) oz.call(e, r) && hw(t, r, e[r]);
        if (G6) for (var r of G6(e)) az.call(e, r) && hw(t, r, e[r]);
        return t;
      },
      Le = (t, e, r) => hw(t, typeof e != "symbol" ? e + "" : e, r);
    class cz extends PU {
      constructor(e) {
        super(e),
          Le(this, "protocol", "wc"),
          Le(this, "version", 2),
          Le(this, "core"),
          Le(this, "logger"),
          Le(this, "events", new rt.exports.EventEmitter()),
          Le(this, "provider"),
          Le(this, "messages"),
          Le(this, "subscriber"),
          Le(this, "publisher"),
          Le(this, "name", DD),
          Le(this, "transportExplicitlyClosed", !1),
          Le(this, "initialized", !1),
          Le(this, "connectionAttemptInProgress", !1),
          Le(this, "relayUrl"),
          Le(this, "projectId"),
          Le(this, "packageName"),
          Le(this, "bundleId"),
          Le(this, "hasExperiencedNetworkDisruption", !1),
          Le(this, "pingTimeout"),
          Le(
            this,
            "heartBeatTimeout",
            z.toMiliseconds(z.THIRTY_SECONDS + z.FIVE_SECONDS)
          ),
          Le(this, "reconnectTimeout"),
          Le(this, "connectPromise"),
          Le(this, "reconnectInProgress", !1),
          Le(this, "requestsInFlight", []),
          Le(this, "connectTimeout", z.toMiliseconds(z.ONE_SECOND * 15)),
          Le(this, "request", async (r) => {
            var i, s;
            this.logger.debug("Publishing Request Payload");
            const n = r.id || ui().toString();
            await this.toEstablishConnection();
            try {
              this.logger.trace(
                {
                  id: n,
                  method: r.method,
                  topic: (i = r.params) == null ? void 0 : i.topic,
                },
                "relayer.request - publishing..."
              );
              const o = `${n}:${
                ((s = r.params) == null ? void 0 : s.tag) || ""
              }`;
              this.requestsInFlight.push(o);
              const a = await this.provider.request(r);
              return (
                (this.requestsInFlight = this.requestsInFlight.filter(
                  (c) => c !== o
                )),
                a
              );
            } catch (o) {
              throw (this.logger.debug(`Failed to Publish Request: ${n}`), o);
            }
          }),
          Le(this, "resetPingTimeout", () => {
            gp() &&
              (clearTimeout(this.pingTimeout),
              (this.pingTimeout = setTimeout(() => {
                var r, i, s, n;
                try {
                  this.logger.debug(
                    {},
                    "pingTimeout: Connection stalled, terminating..."
                  ),
                    (n =
                      (s =
                        (i =
                          (r = this.provider) == null
                            ? void 0
                            : r.connection) == null
                          ? void 0
                          : i.socket) == null
                        ? void 0
                        : s.terminate) == null || n.call(s);
                } catch (o) {
                  this.logger.warn(o, o?.message);
                }
              }, this.heartBeatTimeout)));
          }),
          Le(this, "onPayloadHandler", (r) => {
            this.onProviderPayload(r), this.resetPingTimeout();
          }),
          Le(this, "onConnectHandler", () => {
            this.logger.warn({}, "Relayer connected \u{1F6DC}"),
              this.startPingTimeout(),
              this.events.emit(Jt.connect);
          }),
          Le(this, "onDisconnectHandler", () => {
            this.logger.warn({}, "Relayer disconnected \u{1F6D1}"),
              (this.requestsInFlight = []),
              this.onProviderDisconnect();
          }),
          Le(this, "onProviderErrorHandler", (r) => {
            this.logger.fatal(`Fatal socket error: ${r.message}`),
              this.events.emit(Jt.error, r),
              this.logger.fatal(
                "Fatal socket error received, closing transport"
              ),
              this.transportClose();
          }),
          Le(this, "registerProviderListeners", () => {
            this.provider.on(ki.payload, this.onPayloadHandler),
              this.provider.on(ki.connect, this.onConnectHandler),
              this.provider.on(ki.disconnect, this.onDisconnectHandler),
              this.provider.on(ki.error, this.onProviderErrorHandler);
          }),
          (this.core = e.core),
          (this.logger =
            typeof e.logger < "u" && typeof e.logger != "string"
              ? Ve(e.logger, this.name)
              : li(tn({ level: e.logger || UD }))),
          (this.messages = new qM(this.logger, e.core)),
          (this.subscriber = new sz(this, this.logger)),
          (this.publisher = new ZM(this, this.logger)),
          (this.relayUrl = e?.relayUrl || A6),
          (this.projectId = e.projectId),
          HR() ? (this.packageName = y5()) : VR() && (this.bundleId = y5()),
          (this.provider = {});
      }
      async init() {
        if (
          (this.logger.trace("Initialized"),
          this.registerEventListeners(),
          await Promise.all([this.messages.init(), this.subscriber.init()]),
          (this.initialized = !0),
          this.subscriber.hasAnyTopics)
        )
          try {
            await this.transportOpen();
          } catch (e) {
            this.logger.warn(e, e?.message);
          }
      }
      get context() {
        return it(this.logger);
      }
      get connected() {
        var e, r, i;
        return (
          ((i =
            (r = (e = this.provider) == null ? void 0 : e.connection) == null
              ? void 0
              : r.socket) == null
            ? void 0
            : i.readyState) === 1 || !1
        );
      }
      get connecting() {
        var e, r, i;
        return (
          ((i =
            (r = (e = this.provider) == null ? void 0 : e.connection) == null
              ? void 0
              : r.socket) == null
            ? void 0
            : i.readyState) === 0 ||
          this.connectPromise !== void 0 ||
          !1
        );
      }
      async publish(e, r, i) {
        this.isInitialized(),
          await this.publisher.publish(e, r, i),
          await this.recordMessageEvent(
            {
              topic: e,
              message: r,
              publishedAt: Date.now(),
              transportType: gt.relay,
            },
            Mp.outbound
          );
      }
      async subscribe(e, r) {
        var i, s, n;
        this.isInitialized(),
          (!(r != null && r.transportType) || r?.transportType === "relay") &&
            (await this.toEstablishConnection());
        const o =
          typeof ((i = r?.internal) == null ? void 0 : i.throwOnFailedPublish) >
          "u"
            ? !0
            : (s = r?.internal) == null
            ? void 0
            : s.throwOnFailedPublish;
        let a =
            ((n = this.subscriber.topicMap.get(e)) == null ? void 0 : n[0]) ||
            "",
          c;
        const l = (u) => {
          u.topic === e && (this.subscriber.off(hi.created, l), c());
        };
        return (
          await Promise.all([
            new Promise((u) => {
              (c = u), this.subscriber.on(hi.created, l);
            }),
            new Promise(async (u, h) => {
              (a =
                (await this.subscriber
                  .subscribe(
                    e,
                    Z6({ internal: { throwOnFailedPublish: o } }, r)
                  )
                  .catch((d) => {
                    o && h(d);
                  })) || a),
                u();
            }),
          ]),
          a
        );
      }
      async unsubscribe(e, r) {
        this.isInitialized(), await this.subscriber.unsubscribe(e, r);
      }
      on(e, r) {
        this.events.on(e, r);
      }
      once(e, r) {
        this.events.once(e, r);
      }
      off(e, r) {
        this.events.off(e, r);
      }
      removeListener(e, r) {
        this.events.removeListener(e, r);
      }
      async transportDisconnect() {
        this.provider.disconnect &&
        (this.hasExperiencedNetworkDisruption || this.connected)
          ? await Vn(
              this.provider.disconnect(),
              2e3,
              "provider.disconnect()"
            ).catch(() => this.onProviderDisconnect())
          : this.onProviderDisconnect();
      }
      async transportClose() {
        (this.transportExplicitlyClosed = !0), await this.transportDisconnect();
      }
      async transportOpen(e) {
        if (!this.subscriber.hasAnyTopics) {
          this.logger.warn(
            "Starting WS connection skipped because the client has no topics to work with."
          );
          return;
        }
        if (
          (this.connectPromise
            ? (this.logger.debug(
                {},
                "Waiting for existing connection attempt to resolve..."
              ),
              await this.connectPromise,
              this.logger.debug({}, "Existing connection attempt resolved"))
            : ((this.connectPromise = new Promise(async (r, i) => {
                await this.connect(e)
                  .then(r)
                  .catch(i)
                  .finally(() => {
                    this.connectPromise = void 0;
                  });
              })),
              await this.connectPromise),
          !this.connected)
        )
          throw new Error(
            `Couldn't establish socket connection to the relay server: ${this.relayUrl}`
          );
      }
      async restartTransport(e) {
        this.logger.debug({}, "Restarting transport..."),
          !this.connectionAttemptInProgress &&
            ((this.relayUrl = e || this.relayUrl),
            await this.confirmOnlineStateOrThrow(),
            await this.transportClose(),
            await this.transportOpen());
      }
      async confirmOnlineStateOrThrow() {
        if (!(await M4()))
          throw new Error(
            "No internet connection detected. Please restart your network and try again."
          );
      }
      async handleBatchMessageEvents(e) {
        if (e?.length === 0) {
          this.logger.trace("Batch message events is empty. Ignoring...");
          return;
        }
        const r = e.sort((i, s) => i.publishedAt - s.publishedAt);
        this.logger.debug(`Batch of ${r.length} message events sorted`);
        for (const i of r)
          try {
            await this.onMessageEvent(i);
          } catch (s) {
            this.logger.warn(
              s,
              "Error while processing batch message event: " + s?.message
            );
          }
        this.logger.trace(`Batch of ${r.length} message events processed`);
      }
      async onLinkMessageEvent(e, r) {
        const { topic: i } = e;
        if (!r.sessionExists) {
          const s = Ft(z.FIVE_MINUTES),
            n = { topic: i, expiry: s, relay: { protocol: "irn" }, active: !1 };
          await this.core.pairing.pairings.set(i, n);
        }
        this.events.emit(Jt.message, e),
          await this.recordMessageEvent(e, Mp.inbound);
      }
      async connect(e) {
        await this.confirmOnlineStateOrThrow(),
          e &&
            e !== this.relayUrl &&
            ((this.relayUrl = e), await this.transportDisconnect()),
          (this.connectionAttemptInProgress = !0),
          (this.transportExplicitlyClosed = !1);
        let r = 1;
        for (; r < 6; ) {
          try {
            if (this.transportExplicitlyClosed) break;
            this.logger.debug(
              {},
              `Connecting to ${this.relayUrl}, attempt: ${r}...`
            ),
              await this.createProvider(),
              await new Promise(async (i, s) => {
                const n = () => {
                  s(
                    new Error(
                      "Connection interrupted while trying to subscribe"
                    )
                  );
                };
                this.provider.once(ki.disconnect, n),
                  await Vn(
                    new Promise((o, a) => {
                      this.provider.connect().then(o).catch(a);
                    }),
                    this.connectTimeout,
                    `Socket stalled when trying to connect to ${this.relayUrl}`
                  )
                    .catch((o) => {
                      s(o);
                    })
                    .finally(() => {
                      this.provider.off(ki.disconnect, n),
                        clearTimeout(this.reconnectTimeout);
                    }),
                  await new Promise(async (o, a) => {
                    const c = () => {
                      a(
                        new Error(
                          "Connection interrupted while trying to subscribe"
                        )
                      );
                    };
                    this.provider.once(ki.disconnect, c),
                      await this.subscriber
                        .start()
                        .then(o)
                        .catch(a)
                        .finally(() => {
                          this.provider.off(ki.disconnect, c);
                        });
                  }),
                  (this.hasExperiencedNetworkDisruption = !1),
                  i();
              });
          } catch (i) {
            await this.subscriber.stop();
            const s = i;
            this.logger.warn({}, s.message),
              (this.hasExperiencedNetworkDisruption = !0);
          } finally {
            this.connectionAttemptInProgress = !1;
          }
          if (this.connected) {
            this.logger.debug(
              {},
              `Connected to ${this.relayUrl} successfully on attempt: ${r}`
            );
            break;
          }
          await new Promise((i) => setTimeout(i, z.toMiliseconds(r * 1))), r++;
        }
      }
      startPingTimeout() {
        var e, r, i, s, n;
        if (gp())
          try {
            (r = (e = this.provider) == null ? void 0 : e.connection) != null &&
              r.socket &&
              ((n =
                (s = (i = this.provider) == null ? void 0 : i.connection) ==
                null
                  ? void 0
                  : s.socket) == null ||
                n.on("ping", () => {
                  this.resetPingTimeout();
                })),
              this.resetPingTimeout();
          } catch (o) {
            this.logger.warn(o, o?.message);
          }
      }
      async createProvider() {
        this.provider.connection && this.unregisterProviderListeners();
        const e = await this.core.crypto.signJWT(this.relayUrl);
        (this.provider = new bt(
          new y6(
            YR({
              sdkVersion: rw,
              protocol: this.protocol,
              version: this.version,
              relayUrl: this.relayUrl,
              projectId: this.projectId,
              auth: e,
              useOnCloseEvent: !0,
              bundleId: this.bundleId,
              packageName: this.packageName,
            })
          )
        )),
          this.registerProviderListeners();
      }
      async recordMessageEvent(e, r) {
        const { topic: i, message: s } = e;
        await this.messages.set(i, s, r);
      }
      async shouldIgnoreMessageEvent(e) {
        const { topic: r, message: i } = e;
        if (!i || i.length === 0)
          return this.logger.warn(`Ignoring invalid/empty message: ${i}`), !0;
        if (!(await this.subscriber.isKnownTopic(r)))
          return (
            this.logger.warn(`Ignoring message for unknown topic ${r}`), !0
          );
        const s = this.messages.has(r, i);
        return s && this.logger.warn(`Ignoring duplicate message: ${i}`), s;
      }
      async onProviderPayload(e) {
        if (
          (this.logger.debug("Incoming Relay Payload"),
          this.logger.trace({
            type: "payload",
            direction: "incoming",
            payload: e,
          }),
          _c(e))
        ) {
          if (!e.method.endsWith(jD)) return;
          const r = e.params,
            { topic: i, message: s, publishedAt: n, attestation: o } = r.data,
            a = {
              topic: i,
              message: s,
              publishedAt: n,
              transportType: gt.relay,
              attestation: o,
            };
          this.logger.debug("Emitting Relayer Payload"),
            this.logger.trace(Z6({ type: "event", event: r.id }, a)),
            this.events.emit(r.id, a),
            await this.acknowledgePayload(e),
            await this.onMessageEvent(a);
        } else qo(e) && this.events.emit(Jt.message_ack, e);
      }
      async onMessageEvent(e) {
        (await this.shouldIgnoreMessageEvent(e)) ||
          (await this.recordMessageEvent(e, Mp.inbound),
          this.events.emit(Jt.message, e));
      }
      async acknowledgePayload(e) {
        const r = Jn(e.id, !0);
        await this.provider.connection.send(r);
      }
      unregisterProviderListeners() {
        this.provider.off(ki.payload, this.onPayloadHandler),
          this.provider.off(ki.connect, this.onConnectHandler),
          this.provider.off(ki.disconnect, this.onDisconnectHandler),
          this.provider.off(ki.error, this.onProviderErrorHandler),
          clearTimeout(this.pingTimeout);
      }
      async registerEventListeners() {
        let e = await M4();
        cL(async (r) => {
          e !== r &&
            ((e = r),
            r
              ? await this.transportOpen().catch((i) =>
                  this.logger.error(i, i?.message)
                )
              : ((this.hasExperiencedNetworkDisruption = !0),
                await this.transportDisconnect(),
                (this.transportExplicitlyClosed = !1)));
        }),
          this.core.heartbeat.on(Ti.pulse, async () => {
            if (!this.transportExplicitlyClosed && !this.connected && hL())
              try {
                await this.confirmOnlineStateOrThrow(),
                  await this.transportOpen();
              } catch (r) {
                this.logger.warn(r, r?.message);
              }
          });
      }
      async onProviderDisconnect() {
        clearTimeout(this.pingTimeout),
          this.events.emit(Jt.disconnect),
          (this.connectionAttemptInProgress = !1),
          !this.reconnectInProgress &&
            ((this.reconnectInProgress = !0),
            await this.subscriber.stop(),
            this.subscriber.hasAnyTopics &&
              (this.transportExplicitlyClosed ||
                (this.reconnectTimeout = setTimeout(async () => {
                  await this.transportOpen().catch((e) =>
                    this.logger.error(e, e?.message)
                  ),
                    (this.reconnectTimeout = void 0),
                    (this.reconnectInProgress = !1);
                }, z.toMiliseconds(MD)))));
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e } = J("NOT_INITIALIZED", this.name);
          throw new Error(e);
        }
      }
      async toEstablishConnection() {
        if ((await this.confirmOnlineStateOrThrow(), !this.connected)) {
          if (this.connectPromise) {
            await this.connectPromise;
            return;
          }
          await this.connect();
        }
      }
    }
    function lz() {}
    function Y6(t) {
      if (!t || typeof t != "object") return !1;
      const e = Object.getPrototypeOf(t);
      return e === null ||
        e === Object.prototype ||
        Object.getPrototypeOf(e) === null
        ? Object.prototype.toString.call(t) === "[object Object]"
        : !1;
    }
    function J6(t) {
      return Object.getOwnPropertySymbols(t).filter((e) =>
        Object.prototype.propertyIsEnumerable.call(t, e)
      );
    }
    function X6(t) {
      return t == null
        ? t === void 0
          ? "[object Undefined]"
          : "[object Null]"
        : Object.prototype.toString.call(t);
    }
    const uz = "[object RegExp]",
      hz = "[object String]",
      dz = "[object Number]",
      pz = "[object Boolean]",
      Q6 = "[object Arguments]",
      fz = "[object Symbol]",
      gz = "[object Date]",
      wz = "[object Map]",
      mz = "[object Set]",
      yz = "[object Array]",
      bz = "[object Function]",
      vz = "[object ArrayBuffer]",
      dw = "[object Object]",
      Ez = "[object Error]",
      Cz = "[object DataView]",
      xz = "[object Uint8Array]",
      Iz = "[object Uint8ClampedArray]",
      _z = "[object Uint16Array]",
      Az = "[object Uint32Array]",
      Sz = "[object BigUint64Array]",
      Pz = "[object Int8Array]",
      Oz = "[object Int16Array]",
      Nz = "[object Int32Array]",
      Tz = "[object BigInt64Array]",
      kz = "[object Float32Array]",
      Rz = "[object Float64Array]";
    function $z(t, e) {
      return t === e || (Number.isNaN(t) && Number.isNaN(e));
    }
    function Fz(t, e, r) {
      return zu(t, e, void 0, void 0, void 0, void 0, r);
    }
    function zu(t, e, r, i, s, n, o) {
      const a = o(t, e, r, i, s, n);
      if (a !== void 0) return a;
      if (typeof t == typeof e)
        switch (typeof t) {
          case "bigint":
          case "string":
          case "boolean":
          case "symbol":
          case "undefined":
            return t === e;
          case "number":
            return t === e || Object.is(t, e);
          case "function":
            return t === e;
          case "object":
            return qu(t, e, n, o);
        }
      return qu(t, e, n, o);
    }
    function qu(t, e, r, i) {
      if (Object.is(t, e)) return !0;
      let s = X6(t),
        n = X6(e);
      if ((s === Q6 && (s = dw), n === Q6 && (n = dw), s !== n)) return !1;
      switch (s) {
        case hz:
          return t.toString() === e.toString();
        case dz: {
          const c = t.valueOf(),
            l = e.valueOf();
          return $z(c, l);
        }
        case pz:
        case gz:
        case fz:
          return Object.is(t.valueOf(), e.valueOf());
        case uz:
          return t.source === e.source && t.flags === e.flags;
        case bz:
          return t === e;
      }
      r = r ?? new Map();
      const o = r.get(t),
        a = r.get(e);
      if (o != null && a != null) return o === e;
      r.set(t, e), r.set(e, t);
      try {
        switch (s) {
          case wz: {
            if (t.size !== e.size) return !1;
            for (const [c, l] of t.entries())
              if (!e.has(c) || !zu(l, e.get(c), c, t, e, r, i)) return !1;
            return !0;
          }
          case mz: {
            if (t.size !== e.size) return !1;
            const c = Array.from(t.values()),
              l = Array.from(e.values());
            for (let u = 0; u < c.length; u++) {
              const h = c[u],
                d = l.findIndex((g) => zu(h, g, void 0, t, e, r, i));
              if (d === -1) return !1;
              l.splice(d, 1);
            }
            return !0;
          }
          case yz:
          case xz:
          case Iz:
          case _z:
          case Az:
          case Sz:
          case Pz:
          case Oz:
          case Nz:
          case Tz:
          case kz:
          case Rz: {
            if (
              (typeof Fe < "u" && Fe.isBuffer(t) !== Fe.isBuffer(e)) ||
              t.length !== e.length
            )
              return !1;
            for (let c = 0; c < t.length; c++)
              if (!zu(t[c], e[c], c, t, e, r, i)) return !1;
            return !0;
          }
          case vz:
            return t.byteLength !== e.byteLength
              ? !1
              : qu(new Uint8Array(t), new Uint8Array(e), r, i);
          case Cz:
            return t.byteLength !== e.byteLength ||
              t.byteOffset !== e.byteOffset
              ? !1
              : qu(new Uint8Array(t), new Uint8Array(e), r, i);
          case Ez:
            return t.name === e.name && t.message === e.message;
          case dw: {
            if (!(qu(t.constructor, e.constructor, r, i) || (Y6(t) && Y6(e))))
              return !1;
            const c = [...Object.keys(t), ...J6(t)],
              l = [...Object.keys(e), ...J6(e)];
            if (c.length !== l.length) return !1;
            for (let u = 0; u < c.length; u++) {
              const h = c[u],
                d = t[h];
              if (!Object.hasOwn(e, h)) return !1;
              const g = e[h];
              if (!zu(d, g, h, t, e, r, i)) return !1;
            }
            return !0;
          }
          default:
            return !1;
        }
      } finally {
        r.delete(t), r.delete(e);
      }
    }
    function Bz(t, e) {
      return Fz(t, e, lz);
    }
    var Lz = Object.defineProperty,
      e8 = Object.getOwnPropertySymbols,
      Uz = Object.prototype.hasOwnProperty,
      Dz = Object.prototype.propertyIsEnumerable,
      pw = (t, e, r) =>
        e in t
          ? Lz(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      t8 = (t, e) => {
        for (var r in e || (e = {})) Uz.call(e, r) && pw(t, r, e[r]);
        if (e8) for (var r of e8(e)) Dz.call(e, r) && pw(t, r, e[r]);
        return t;
      },
      Kr = (t, e, r) => pw(t, typeof e != "symbol" ? e + "" : e, r);
    class Ko extends OU {
      constructor(e, r, i, s = Is, n = void 0) {
        super(e, r, i, s),
          (this.core = e),
          (this.logger = r),
          (this.name = i),
          Kr(this, "map", new Map()),
          Kr(this, "version", zD),
          Kr(this, "cached", []),
          Kr(this, "initialized", !1),
          Kr(this, "getKey"),
          Kr(this, "storagePrefix", Is),
          Kr(this, "recentlyDeleted", []),
          Kr(this, "recentlyDeletedLimit", 200),
          Kr(this, "init", async () => {
            this.initialized ||
              (this.logger.trace("Initialized"),
              await this.restore(),
              this.cached.forEach((o) => {
                this.getKey && o !== null && !hr(o)
                  ? this.map.set(this.getKey(o), o)
                  : DB(o)
                  ? this.map.set(o.id, o)
                  : jB(o) && this.map.set(o.topic, o);
              }),
              (this.cached = []),
              (this.initialized = !0));
          }),
          Kr(this, "set", async (o, a) => {
            this.isInitialized(),
              this.map.has(o)
                ? await this.update(o, a)
                : (this.logger.debug("Setting value"),
                  this.logger.trace({
                    type: "method",
                    method: "set",
                    key: o,
                    value: a,
                  }),
                  this.map.set(o, a),
                  await this.persist());
          }),
          Kr(
            this,
            "get",
            (o) => (
              this.isInitialized(),
              this.logger.debug("Getting value"),
              this.logger.trace({ type: "method", method: "get", key: o }),
              this.getData(o)
            )
          ),
          Kr(
            this,
            "getAll",
            (o) => (
              this.isInitialized(),
              o
                ? this.values.filter((a) =>
                    Object.keys(o).every((c) => Bz(a[c], o[c]))
                  )
                : this.values
            )
          ),
          Kr(this, "update", async (o, a) => {
            this.isInitialized(),
              this.logger.debug("Updating value"),
              this.logger.trace({
                type: "method",
                method: "update",
                key: o,
                update: a,
              });
            const c = t8(t8({}, this.getData(o)), a);
            this.map.set(o, c), await this.persist();
          }),
          Kr(this, "delete", async (o, a) => {
            this.isInitialized(),
              this.map.has(o) &&
                (this.logger.debug("Deleting value"),
                this.logger.trace({
                  type: "method",
                  method: "delete",
                  key: o,
                  reason: a,
                }),
                this.map.delete(o),
                this.addToRecentlyDeleted(o),
                await this.persist());
          }),
          (this.logger = Ve(r, this.name)),
          (this.storagePrefix = s),
          (this.getKey = n);
      }
      get context() {
        return it(this.logger);
      }
      get storageKey() {
        return (
          this.storagePrefix +
          this.version +
          this.core.customStoragePrefix +
          "//" +
          this.name
        );
      }
      get length() {
        return this.map.size;
      }
      get keys() {
        return Array.from(this.map.keys());
      }
      get values() {
        return Array.from(this.map.values());
      }
      addToRecentlyDeleted(e) {
        this.recentlyDeleted.push(e),
          this.recentlyDeleted.length >= this.recentlyDeletedLimit &&
            this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
      }
      async setDataStore(e) {
        await this.core.storage.setItem(this.storageKey, e);
      }
      async getDataStore() {
        return await this.core.storage.getItem(this.storageKey);
      }
      getData(e) {
        const r = this.map.get(e);
        if (!r) {
          if (this.recentlyDeleted.includes(e)) {
            const { message: s } = J(
              "MISSING_OR_INVALID",
              `Record was recently deleted - ${this.name}: ${e}`
            );
            throw (this.logger.error(s), new Error(s));
          }
          const { message: i } = J("NO_MATCHING_KEY", `${this.name}: ${e}`);
          throw (this.logger.error(i), new Error(i));
        }
        return r;
      }
      async persist() {
        await this.setDataStore(this.values);
      }
      async restore() {
        try {
          const e = await this.getDataStore();
          if (typeof e > "u" || !e.length) return;
          if (this.map.size) {
            const { message: r } = J("RESTORE_WILL_OVERRIDE", this.name);
            throw (this.logger.error(r), new Error(r));
          }
          (this.cached = e),
            this.logger.debug(`Successfully Restored value for ${this.name}`),
            this.logger.trace({
              type: "method",
              method: "restore",
              value: this.values,
            });
        } catch (e) {
          this.logger.debug(`Failed to Restore value for ${this.name}`),
            this.logger.error(e);
        }
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e } = J("NOT_INITIALIZED", this.name);
          throw new Error(e);
        }
      }
    }
    var jz = Object.defineProperty,
      Mz = (t, e, r) =>
        e in t
          ? jz(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Pe = (t, e, r) => Mz(t, typeof e != "symbol" ? e + "" : e, r);
    class zz {
      constructor(e, r) {
        (this.core = e),
          (this.logger = r),
          Pe(this, "name", WD),
          Pe(this, "version", KD),
          Pe(this, "events", new rt.exports()),
          Pe(this, "pairings"),
          Pe(this, "initialized", !1),
          Pe(this, "storagePrefix", Is),
          Pe(this, "ignoredPayloadTypes", [en]),
          Pe(this, "registeredMethods", []),
          Pe(this, "init", async () => {
            this.initialized ||
              (await this.pairings.init(),
              await this.cleanup(),
              this.registerRelayerEvents(),
              this.registerExpirerEvents(),
              (this.initialized = !0),
              this.logger.trace("Initialized"));
          }),
          Pe(this, "register", ({ methods: i }) => {
            this.isInitialized(),
              (this.registeredMethods = [
                ...new Set([...this.registeredMethods, ...i]),
              ]);
          }),
          Pe(this, "create", async (i) => {
            this.isInitialized();
            const s = j1(),
              n = await this.core.crypto.setSymKey(s),
              o = Ft(z.FIVE_MINUTES),
              a = { protocol: _6 },
              c = {
                topic: n,
                expiry: o,
                relay: a,
                active: !1,
                methods: i?.methods,
              },
              l = R4({
                protocol: this.core.protocol,
                version: this.core.version,
                topic: n,
                symKey: s,
                relay: a,
                expiryTimestamp: o,
                methods: i?.methods,
              });
            return (
              this.events.emit(Ho.create, c),
              this.core.expirer.set(n, o),
              await this.pairings.set(n, c),
              await this.core.relayer.subscribe(n, {
                transportType: i?.transportType,
              }),
              { topic: n, uri: l }
            );
          }),
          Pe(this, "pair", async (i) => {
            this.isInitialized();
            const s = this.core.eventClient.createEvent({
              properties: { topic: i?.uri, trace: [_s.pairing_started] },
            });
            this.isValidPair(i, s);
            const {
              topic: n,
              symKey: o,
              relay: a,
              expiryTimestamp: c,
              methods: l,
            } = k4(i.uri);
            (s.props.properties.topic = n),
              s.addTrace(_s.pairing_uri_validation_success),
              s.addTrace(_s.pairing_uri_not_expired);
            let u;
            if (this.pairings.keys.includes(n)) {
              if (
                ((u = this.pairings.get(n)),
                s.addTrace(_s.existing_pairing),
                u.active)
              )
                throw (
                  (s.setError(nn.active_pairing_already_exists),
                  new Error(
                    `Pairing already exists: ${n}. Please try again with a new connection URI.`
                  ))
                );
              s.addTrace(_s.pairing_not_expired);
            }
            const h = c || Ft(z.FIVE_MINUTES),
              d = { topic: n, relay: a, expiry: h, active: !1, methods: l };
            this.core.expirer.set(n, h),
              await this.pairings.set(n, d),
              s.addTrace(_s.store_new_pairing),
              i.activatePairing && (await this.activate({ topic: n })),
              this.events.emit(Ho.create, d),
              s.addTrace(_s.emit_inactive_pairing),
              this.core.crypto.keychain.has(n) ||
                (await this.core.crypto.setSymKey(o, n)),
              s.addTrace(_s.subscribing_pairing_topic);
            try {
              await this.core.relayer.confirmOnlineStateOrThrow();
            } catch {
              s.setError(nn.no_internet_connection);
            }
            try {
              await this.core.relayer.subscribe(n, { relay: a });
            } catch (g) {
              throw (s.setError(nn.subscribe_pairing_topic_failure), g);
            }
            return s.addTrace(_s.subscribe_pairing_topic_success), d;
          }),
          Pe(this, "activate", async ({ topic: i }) => {
            this.isInitialized();
            const s = Ft(z.FIVE_MINUTES);
            this.core.expirer.set(i, s),
              await this.pairings.update(i, { active: !0, expiry: s });
          }),
          Pe(this, "ping", async (i) => {
            this.isInitialized(),
              await this.isValidPing(i),
              this.logger.warn(
                "ping() is deprecated and will be removed in the next major release."
              );
            const { topic: s } = i;
            if (this.pairings.keys.includes(s)) {
              const n = await this.sendRequest(s, "wc_pairingPing", {}),
                { done: o, resolve: a, reject: c } = Bo();
              this.events.once(He("pairing_ping", n), ({ error: l }) => {
                l ? c(l) : a();
              }),
                await o();
            }
          }),
          Pe(this, "updateExpiry", async ({ topic: i, expiry: s }) => {
            this.isInitialized(), await this.pairings.update(i, { expiry: s });
          }),
          Pe(this, "updateMetadata", async ({ topic: i, metadata: s }) => {
            this.isInitialized(),
              await this.pairings.update(i, { peerMetadata: s });
          }),
          Pe(
            this,
            "getPairings",
            () => (this.isInitialized(), this.pairings.values)
          ),
          Pe(this, "disconnect", async (i) => {
            this.isInitialized(), await this.isValidDisconnect(i);
            const { topic: s } = i;
            this.pairings.keys.includes(s) &&
              (await this.sendRequest(
                s,
                "wc_pairingDelete",
                Ge("USER_DISCONNECTED")
              ),
              await this.deletePairing(s));
          }),
          Pe(this, "formatUriFromPairing", (i) => {
            this.isInitialized();
            const { topic: s, relay: n, expiry: o, methods: a } = i,
              c = this.core.crypto.keychain.get(s);
            return R4({
              protocol: this.core.protocol,
              version: this.core.version,
              topic: s,
              symKey: c,
              relay: n,
              expiryTimestamp: o,
              methods: a,
            });
          }),
          Pe(this, "sendRequest", async (i, s, n) => {
            const o = kr(s, n),
              a = await this.core.crypto.encode(i, o),
              c = Lu[s].req;
            return (
              this.core.history.set(i, o),
              this.core.relayer.publish(i, a, c),
              o.id
            );
          }),
          Pe(this, "sendResult", async (i, s, n) => {
            const o = Jn(i, n),
              a = await this.core.crypto.encode(s, o),
              c = (await this.core.history.get(s, i)).request.method,
              l = Lu[c].res;
            await this.core.relayer.publish(s, a, l),
              await this.core.history.resolve(o);
          }),
          Pe(this, "sendError", async (i, s, n) => {
            const o = Ic(i, n),
              a = await this.core.crypto.encode(s, o),
              c = (await this.core.history.get(s, i)).request.method,
              l = Lu[c] ? Lu[c].res : Lu.unregistered_method.res;
            await this.core.relayer.publish(s, a, l),
              await this.core.history.resolve(o);
          }),
          Pe(this, "deletePairing", async (i, s) => {
            await this.core.relayer.unsubscribe(i),
              await Promise.all([
                this.pairings.delete(i, Ge("USER_DISCONNECTED")),
                this.core.crypto.deleteSymKey(i),
                s ? Promise.resolve() : this.core.expirer.del(i),
              ]);
          }),
          Pe(this, "cleanup", async () => {
            const i = this.pairings.getAll().filter((s) => Wn(s.expiry));
            await Promise.all(i.map((s) => this.deletePairing(s.topic)));
          }),
          Pe(this, "onRelayEventRequest", async (i) => {
            const { topic: s, payload: n } = i;
            switch (n.method) {
              case "wc_pairingPing":
                return await this.onPairingPingRequest(s, n);
              case "wc_pairingDelete":
                return await this.onPairingDeleteRequest(s, n);
              default:
                return await this.onUnknownRpcMethodRequest(s, n);
            }
          }),
          Pe(this, "onRelayEventResponse", async (i) => {
            const { topic: s, payload: n } = i,
              o = (await this.core.history.get(s, n.id)).request.method;
            switch (o) {
              case "wc_pairingPing":
                return this.onPairingPingResponse(s, n);
              default:
                return this.onUnknownRpcMethodResponse(o);
            }
          }),
          Pe(this, "onPairingPingRequest", async (i, s) => {
            const { id: n } = s;
            try {
              this.isValidPing({ topic: i }),
                await this.sendResult(n, i, !0),
                this.events.emit(Ho.ping, { id: n, topic: i });
            } catch (o) {
              await this.sendError(n, i, o), this.logger.error(o);
            }
          }),
          Pe(this, "onPairingPingResponse", (i, s) => {
            const { id: n } = s;
            setTimeout(() => {
              Bt(s)
                ? this.events.emit(He("pairing_ping", n), {})
                : Ct(s) &&
                  this.events.emit(He("pairing_ping", n), { error: s.error });
            }, 500);
          }),
          Pe(this, "onPairingDeleteRequest", async (i, s) => {
            const { id: n } = s;
            try {
              this.isValidDisconnect({ topic: i }),
                await this.deletePairing(i),
                this.events.emit(Ho.delete, { id: n, topic: i });
            } catch (o) {
              await this.sendError(n, i, o), this.logger.error(o);
            }
          }),
          Pe(this, "onUnknownRpcMethodRequest", async (i, s) => {
            const { id: n, method: o } = s;
            try {
              if (this.registeredMethods.includes(o)) return;
              const a = Ge("WC_METHOD_UNSUPPORTED", o);
              await this.sendError(n, i, a), this.logger.error(a);
            } catch (a) {
              await this.sendError(n, i, a), this.logger.error(a);
            }
          }),
          Pe(this, "onUnknownRpcMethodResponse", (i) => {
            this.registeredMethods.includes(i) ||
              this.logger.error(Ge("WC_METHOD_UNSUPPORTED", i));
          }),
          Pe(this, "isValidPair", (i, s) => {
            var n;
            if (!Vr(i)) {
              const { message: a } = J(
                "MISSING_OR_INVALID",
                `pair() params: ${i}`
              );
              throw (s.setError(nn.malformed_pairing_uri), new Error(a));
            }
            if (!UB(i.uri)) {
              const { message: a } = J(
                "MISSING_OR_INVALID",
                `pair() uri: ${i.uri}`
              );
              throw (s.setError(nn.malformed_pairing_uri), new Error(a));
            }
            const o = k4(i?.uri);
            if (!((n = o?.relay) != null && n.protocol)) {
              const { message: a } = J(
                "MISSING_OR_INVALID",
                "pair() uri#relay-protocol"
              );
              throw (s.setError(nn.malformed_pairing_uri), new Error(a));
            }
            if (!(o != null && o.symKey)) {
              const { message: a } = J(
                "MISSING_OR_INVALID",
                "pair() uri#symKey"
              );
              throw (s.setError(nn.malformed_pairing_uri), new Error(a));
            }
            if (
              o != null &&
              o.expiryTimestamp &&
              z.toMiliseconds(o?.expiryTimestamp) < Date.now()
            ) {
              s.setError(nn.pairing_expired);
              const { message: a } = J(
                "EXPIRED",
                "pair() URI has expired. Please try again with a new connection URI."
              );
              throw new Error(a);
            }
          }),
          Pe(this, "isValidPing", async (i) => {
            if (!Vr(i)) {
              const { message: n } = J(
                "MISSING_OR_INVALID",
                `ping() params: ${i}`
              );
              throw new Error(n);
            }
            const { topic: s } = i;
            await this.isValidPairingTopic(s);
          }),
          Pe(this, "isValidDisconnect", async (i) => {
            if (!Vr(i)) {
              const { message: n } = J(
                "MISSING_OR_INVALID",
                `disconnect() params: ${i}`
              );
              throw new Error(n);
            }
            const { topic: s } = i;
            await this.isValidPairingTopic(s);
          }),
          Pe(this, "isValidPairingTopic", async (i) => {
            if (!Nt(i, !1)) {
              const { message: s } = J(
                "MISSING_OR_INVALID",
                `pairing topic should be a string: ${i}`
              );
              throw new Error(s);
            }
            if (!this.pairings.keys.includes(i)) {
              const { message: s } = J(
                "NO_MATCHING_KEY",
                `pairing topic doesn't exist: ${i}`
              );
              throw new Error(s);
            }
            if (Wn(this.pairings.get(i).expiry)) {
              await this.deletePairing(i);
              const { message: s } = J("EXPIRED", `pairing topic: ${i}`);
              throw new Error(s);
            }
          }),
          (this.core = e),
          (this.logger = Ve(r, this.name)),
          (this.pairings = new Ko(
            this.core,
            this.logger,
            this.name,
            this.storagePrefix
          ));
      }
      get context() {
        return it(this.logger);
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e } = J("NOT_INITIALIZED", this.name);
          throw new Error(e);
        }
      }
      registerRelayerEvents() {
        this.core.relayer.on(Jt.message, async (e) => {
          const { topic: r, message: i, transportType: s } = e;
          if (
            this.pairings.keys.includes(r) &&
            s !== gt.link_mode &&
            !this.ignoredPayloadTypes.includes(
              this.core.crypto.getPayloadType(i)
            )
          )
            try {
              const n = await this.core.crypto.decode(r, i);
              _c(n)
                ? (this.core.history.set(r, n),
                  await this.onRelayEventRequest({ topic: r, payload: n }))
                : qo(n) &&
                  (await this.core.history.resolve(n),
                  await this.onRelayEventResponse({ topic: r, payload: n }),
                  this.core.history.delete(r, n.id)),
                await this.core.relayer.messages.ack(r, i);
            } catch (n) {
              this.logger.error(n);
            }
        });
      }
      registerExpirerEvents() {
        this.core.expirer.on(Ri.expired, async (e) => {
          const { topic: r } = C5(e.target);
          r &&
            this.pairings.keys.includes(r) &&
            (await this.deletePairing(r, !0),
            this.events.emit(Ho.expire, { topic: r }));
        });
      }
    }
    var qz = Object.defineProperty,
      Hz = (t, e, r) =>
        e in t
          ? qz(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      fr = (t, e, r) => Hz(t, typeof e != "symbol" ? e + "" : e, r);
    class Vz extends _U {
      constructor(e, r) {
        super(e, r),
          (this.core = e),
          (this.logger = r),
          fr(this, "records", new Map()),
          fr(this, "events", new rt.exports.EventEmitter()),
          fr(this, "name", GD),
          fr(this, "version", ZD),
          fr(this, "cached", []),
          fr(this, "initialized", !1),
          fr(this, "storagePrefix", Is),
          fr(this, "init", async () => {
            this.initialized ||
              (this.logger.trace("Initialized"),
              await this.restore(),
              this.cached.forEach((i) => this.records.set(i.id, i)),
              (this.cached = []),
              this.registerEventListeners(),
              (this.initialized = !0));
          }),
          fr(this, "set", (i, s, n) => {
            if (
              (this.isInitialized(),
              this.logger.debug("Setting JSON-RPC request history record"),
              this.logger.trace({
                type: "method",
                method: "set",
                topic: i,
                request: s,
                chainId: n,
              }),
              this.records.has(s.id))
            )
              return;
            const o = {
              id: s.id,
              topic: i,
              request: { method: s.method, params: s.params || null },
              chainId: n,
              expiry: Ft(z.THIRTY_DAYS),
            };
            this.records.set(o.id, o),
              this.persist(),
              this.events.emit(es.created, o);
          }),
          fr(this, "resolve", async (i) => {
            if (
              (this.isInitialized(),
              this.logger.debug("Updating JSON-RPC response history record"),
              this.logger.trace({
                type: "method",
                method: "update",
                response: i,
              }),
              !this.records.has(i.id))
            )
              return;
            const s = await this.getRecord(i.id);
            typeof s.response > "u" &&
              ((s.response = Ct(i) ? { error: i.error } : { result: i.result }),
              this.records.set(s.id, s),
              this.persist(),
              this.events.emit(es.updated, s));
          }),
          fr(
            this,
            "get",
            async (i, s) => (
              this.isInitialized(),
              this.logger.debug("Getting record"),
              this.logger.trace({
                type: "method",
                method: "get",
                topic: i,
                id: s,
              }),
              await this.getRecord(s)
            )
          ),
          fr(this, "delete", (i, s) => {
            this.isInitialized(),
              this.logger.debug("Deleting record"),
              this.logger.trace({ type: "method", method: "delete", id: s }),
              this.values.forEach((n) => {
                if (n.topic === i) {
                  if (typeof s < "u" && n.id !== s) return;
                  this.records.delete(n.id), this.events.emit(es.deleted, n);
                }
              }),
              this.persist();
          }),
          fr(
            this,
            "exists",
            async (i, s) => (
              this.isInitialized(),
              this.records.has(s) ? (await this.getRecord(s)).topic === i : !1
            )
          ),
          fr(this, "on", (i, s) => {
            this.events.on(i, s);
          }),
          fr(this, "once", (i, s) => {
            this.events.once(i, s);
          }),
          fr(this, "off", (i, s) => {
            this.events.off(i, s);
          }),
          fr(this, "removeListener", (i, s) => {
            this.events.removeListener(i, s);
          }),
          (this.logger = Ve(r, this.name));
      }
      get context() {
        return it(this.logger);
      }
      get storageKey() {
        return (
          this.storagePrefix +
          this.version +
          this.core.customStoragePrefix +
          "//" +
          this.name
        );
      }
      get size() {
        return this.records.size;
      }
      get keys() {
        return Array.from(this.records.keys());
      }
      get values() {
        return Array.from(this.records.values());
      }
      get pending() {
        const e = [];
        return (
          this.values.forEach((r) => {
            if (typeof r.response < "u") return;
            const i = {
              topic: r.topic,
              request: kr(r.request.method, r.request.params, r.id),
              chainId: r.chainId,
            };
            return e.push(i);
          }),
          e
        );
      }
      async setJsonRpcRecords(e) {
        await this.core.storage.setItem(this.storageKey, e);
      }
      async getJsonRpcRecords() {
        return await this.core.storage.getItem(this.storageKey);
      }
      getRecord(e) {
        this.isInitialized();
        const r = this.records.get(e);
        if (!r) {
          const { message: i } = J("NO_MATCHING_KEY", `${this.name}: ${e}`);
          throw new Error(i);
        }
        return r;
      }
      async persist() {
        await this.setJsonRpcRecords(this.values), this.events.emit(es.sync);
      }
      async restore() {
        try {
          const e = await this.getJsonRpcRecords();
          if (typeof e > "u" || !e.length) return;
          if (this.records.size) {
            const { message: r } = J("RESTORE_WILL_OVERRIDE", this.name);
            throw (this.logger.error(r), new Error(r));
          }
          (this.cached = e),
            this.logger.debug(`Successfully Restored records for ${this.name}`),
            this.logger.trace({
              type: "method",
              method: "restore",
              records: this.values,
            });
        } catch (e) {
          this.logger.debug(`Failed to Restore records for ${this.name}`),
            this.logger.error(e);
        }
      }
      registerEventListeners() {
        this.events.on(es.created, (e) => {
          const r = es.created;
          this.logger.info(`Emitting ${r}`),
            this.logger.debug({ type: "event", event: r, record: e });
        }),
          this.events.on(es.updated, (e) => {
            const r = es.updated;
            this.logger.info(`Emitting ${r}`),
              this.logger.debug({ type: "event", event: r, record: e });
          }),
          this.events.on(es.deleted, (e) => {
            const r = es.deleted;
            this.logger.info(`Emitting ${r}`),
              this.logger.debug({ type: "event", event: r, record: e });
          }),
          this.core.heartbeat.on(Ti.pulse, () => {
            this.cleanup();
          });
      }
      cleanup() {
        try {
          this.isInitialized();
          let e = !1;
          this.records.forEach((r) => {
            z.toMiliseconds(r.expiry || 0) - Date.now() <= 0 &&
              (this.logger.info(`Deleting expired history log: ${r.id}`),
              this.records.delete(r.id),
              this.events.emit(es.deleted, r, !1),
              (e = !0));
          }),
            e && this.persist();
        } catch (e) {
          this.logger.warn(e);
        }
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e } = J("NOT_INITIALIZED", this.name);
          throw new Error(e);
        }
      }
    }
    var Wz = Object.defineProperty,
      Kz = (t, e, r) =>
        e in t
          ? Wz(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Ar = (t, e, r) => Kz(t, typeof e != "symbol" ? e + "" : e, r);
    class Gz extends TU {
      constructor(e, r) {
        super(e, r),
          (this.core = e),
          (this.logger = r),
          Ar(this, "expirations", new Map()),
          Ar(this, "events", new rt.exports.EventEmitter()),
          Ar(this, "name", YD),
          Ar(this, "version", JD),
          Ar(this, "cached", []),
          Ar(this, "initialized", !1),
          Ar(this, "storagePrefix", Is),
          Ar(this, "init", async () => {
            this.initialized ||
              (this.logger.trace("Initialized"),
              await this.restore(),
              this.cached.forEach((i) => this.expirations.set(i.target, i)),
              (this.cached = []),
              this.registerEventListeners(),
              (this.initialized = !0));
          }),
          Ar(this, "has", (i) => {
            try {
              const s = this.formatTarget(i);
              return typeof this.getExpiration(s) < "u";
            } catch {
              return !1;
            }
          }),
          Ar(this, "set", (i, s) => {
            this.isInitialized();
            const n = this.formatTarget(i),
              o = { target: n, expiry: s };
            this.expirations.set(n, o),
              this.checkExpiry(n, o),
              this.events.emit(Ri.created, { target: n, expiration: o });
          }),
          Ar(this, "get", (i) => {
            this.isInitialized();
            const s = this.formatTarget(i);
            return this.getExpiration(s);
          }),
          Ar(this, "del", (i) => {
            if ((this.isInitialized(), this.has(i))) {
              const s = this.formatTarget(i),
                n = this.getExpiration(s);
              this.expirations.delete(s),
                this.events.emit(Ri.deleted, { target: s, expiration: n });
            }
          }),
          Ar(this, "on", (i, s) => {
            this.events.on(i, s);
          }),
          Ar(this, "once", (i, s) => {
            this.events.once(i, s);
          }),
          Ar(this, "off", (i, s) => {
            this.events.off(i, s);
          }),
          Ar(this, "removeListener", (i, s) => {
            this.events.removeListener(i, s);
          }),
          (this.logger = Ve(r, this.name));
      }
      get context() {
        return it(this.logger);
      }
      get storageKey() {
        return (
          this.storagePrefix +
          this.version +
          this.core.customStoragePrefix +
          "//" +
          this.name
        );
      }
      get length() {
        return this.expirations.size;
      }
      get keys() {
        return Array.from(this.expirations.keys());
      }
      get values() {
        return Array.from(this.expirations.values());
      }
      formatTarget(e) {
        if (typeof e == "string") return JR(e);
        if (typeof e == "number") return XR(e);
        const { message: r } = J("UNKNOWN_TYPE", `Target type: ${typeof e}`);
        throw new Error(r);
      }
      async setExpirations(e) {
        await this.core.storage.setItem(this.storageKey, e);
      }
      async getExpirations() {
        return await this.core.storage.getItem(this.storageKey);
      }
      async persist() {
        await this.setExpirations(this.values), this.events.emit(Ri.sync);
      }
      async restore() {
        try {
          const e = await this.getExpirations();
          if (typeof e > "u" || !e.length) return;
          if (this.expirations.size) {
            const { message: r } = J("RESTORE_WILL_OVERRIDE", this.name);
            throw (this.logger.error(r), new Error(r));
          }
          (this.cached = e),
            this.logger.debug(
              `Successfully Restored expirations for ${this.name}`
            ),
            this.logger.trace({
              type: "method",
              method: "restore",
              expirations: this.values,
            });
        } catch (e) {
          this.logger.debug(`Failed to Restore expirations for ${this.name}`),
            this.logger.error(e);
        }
      }
      getExpiration(e) {
        const r = this.expirations.get(e);
        if (!r) {
          const { message: i } = J("NO_MATCHING_KEY", `${this.name}: ${e}`);
          throw (this.logger.warn(i), new Error(i));
        }
        return r;
      }
      checkExpiry(e, r) {
        const { expiry: i } = r;
        z.toMiliseconds(i) - Date.now() <= 0 && this.expire(e, r);
      }
      expire(e, r) {
        this.expirations.delete(e),
          this.events.emit(Ri.expired, { target: e, expiration: r });
      }
      checkExpirations() {
        this.core.relayer.connected &&
          this.expirations.forEach((e, r) => this.checkExpiry(r, e));
      }
      registerEventListeners() {
        this.core.heartbeat.on(Ti.pulse, () => this.checkExpirations()),
          this.events.on(Ri.created, (e) => {
            const r = Ri.created;
            this.logger.info(`Emitting ${r}`),
              this.logger.debug({ type: "event", event: r, data: e }),
              this.persist();
          }),
          this.events.on(Ri.expired, (e) => {
            const r = Ri.expired;
            this.logger.info(`Emitting ${r}`),
              this.logger.debug({ type: "event", event: r, data: e }),
              this.persist();
          }),
          this.events.on(Ri.deleted, (e) => {
            const r = Ri.deleted;
            this.logger.info(`Emitting ${r}`),
              this.logger.debug({ type: "event", event: r, data: e }),
              this.persist();
          });
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e } = J("NOT_INITIALIZED", this.name);
          throw new Error(e);
        }
      }
    }
    var Zz = Object.defineProperty,
      Yz = (t, e, r) =>
        e in t
          ? Zz(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Tt = (t, e, r) => Yz(t, typeof e != "symbol" ? e + "" : e, r);
    class Jz extends kU {
      constructor(e, r, i) {
        super(e, r, i),
          (this.core = e),
          (this.logger = r),
          (this.store = i),
          Tt(this, "name", XD),
          Tt(this, "abortController"),
          Tt(this, "isDevEnv"),
          Tt(this, "verifyUrlV3", ej),
          Tt(this, "storagePrefix", Is),
          Tt(this, "version", C6),
          Tt(this, "publicKey"),
          Tt(this, "fetchPromise"),
          Tt(this, "init", async () => {
            var s;
            this.isDevEnv ||
              ((this.publicKey = await this.store.getItem(this.storeKey)),
              this.publicKey &&
                z.toMiliseconds(
                  (s = this.publicKey) == null ? void 0 : s.expiresAt
                ) < Date.now() &&
                (this.logger.debug("verify v2 public key expired"),
                await this.removePublicKey()));
          }),
          Tt(this, "register", async (s) => {
            if (!cc() || this.isDevEnv) return;
            const n = window.location.origin,
              { id: o, decryptedId: a } = s,
              c = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${n}&id=${o}&decryptedId=${a}`;
            try {
              const l = Gi(),
                u = this.startAbortTimer(z.ONE_SECOND * 5),
                h = await new Promise((d, g) => {
                  const p = () => {
                    window.removeEventListener("message", f),
                      l.body.removeChild(w),
                      g("attestation aborted");
                  };
                  this.abortController.signal.addEventListener("abort", p);
                  const w = l.createElement("iframe");
                  (w.src = c),
                    (w.style.display = "none"),
                    w.addEventListener("error", p, {
                      signal: this.abortController.signal,
                    });
                  const f = (m) => {
                    if (m.data && typeof m.data == "string")
                      try {
                        const y = JSON.parse(m.data);
                        if (y.type === "verify_attestation") {
                          if (oc(y.attestation).payload.id !== o) return;
                          clearInterval(u),
                            l.body.removeChild(w),
                            this.abortController.signal.removeEventListener(
                              "abort",
                              p
                            ),
                            window.removeEventListener("message", f),
                            d(y.attestation === null ? "" : y.attestation);
                        }
                      } catch (y) {
                        this.logger.warn(y);
                      }
                  };
                  l.body.appendChild(w),
                    window.addEventListener("message", f, {
                      signal: this.abortController.signal,
                    });
                });
              return this.logger.debug("jwt attestation", h), h;
            } catch (l) {
              this.logger.warn(l);
            }
            return "";
          }),
          Tt(this, "resolve", async (s) => {
            if (this.isDevEnv) return "";
            const { attestationId: n, hash: o, encryptedId: a } = s;
            if (n === "") {
              this.logger.debug("resolve: attestationId is empty, skipping");
              return;
            }
            if (n) {
              if (oc(n).payload.id !== a) return;
              const l = await this.isValidJwtAttestation(n);
              if (l) {
                if (!l.isVerified) {
                  this.logger.warn(
                    "resolve: jwt attestation: origin url not verified"
                  );
                  return;
                }
                return l;
              }
            }
            if (!o) return;
            const c = this.getVerifyUrl(s?.verifyUrl);
            return this.fetchAttestation(o, c);
          }),
          Tt(this, "fetchAttestation", async (s, n) => {
            this.logger.debug(`resolving attestation: ${s} from url: ${n}`);
            const o = this.startAbortTimer(z.ONE_SECOND * 5),
              a = await fetch(`${n}/attestation/${s}?v2Supported=true`, {
                signal: this.abortController.signal,
              });
            return clearTimeout(o), a.status === 200 ? await a.json() : void 0;
          }),
          Tt(this, "getVerifyUrl", (s) => {
            let n = s || Uu;
            return (
              tj.includes(n) ||
                (this.logger.info(
                  `verify url: ${n}, not included in trusted list, assigning default: ${Uu}`
                ),
                (n = Uu)),
              n
            );
          }),
          Tt(this, "fetchPublicKey", async () => {
            try {
              this.logger.debug(
                `fetching public key from: ${this.verifyUrlV3}`
              );
              const s = this.startAbortTimer(z.FIVE_SECONDS),
                n = await fetch(`${this.verifyUrlV3}/public-key`, {
                  signal: this.abortController.signal,
                });
              return clearTimeout(s), await n.json();
            } catch (s) {
              this.logger.warn(s);
            }
          }),
          Tt(this, "persistPublicKey", async (s) => {
            this.logger.debug("persisting public key to local storage", s),
              await this.store.setItem(this.storeKey, s),
              (this.publicKey = s);
          }),
          Tt(this, "removePublicKey", async () => {
            this.logger.debug("removing verify v2 public key from storage"),
              await this.store.removeItem(this.storeKey),
              (this.publicKey = void 0);
          }),
          Tt(this, "isValidJwtAttestation", async (s) => {
            const n = await this.getPublicKey();
            try {
              if (n) return this.validateAttestation(s, n);
            } catch (a) {
              this.logger.error(a),
                this.logger.warn("error validating attestation");
            }
            const o = await this.fetchAndPersistPublicKey();
            try {
              if (o) return this.validateAttestation(s, o);
            } catch (a) {
              this.logger.error(a),
                this.logger.warn("error validating attestation");
            }
          }),
          Tt(this, "getPublicKey", async () =>
            this.publicKey
              ? this.publicKey
              : await this.fetchAndPersistPublicKey()
          ),
          Tt(this, "fetchAndPersistPublicKey", async () => {
            if (this.fetchPromise)
              return await this.fetchPromise, this.publicKey;
            this.fetchPromise = new Promise(async (n) => {
              const o = await this.fetchPublicKey();
              o && (await this.persistPublicKey(o), n(o));
            });
            const s = await this.fetchPromise;
            return (this.fetchPromise = void 0), s;
          }),
          Tt(this, "validateAttestation", (s, n) => {
            const o = _B(s, n.publicKey),
              a = {
                hasExpired: z.toMiliseconds(o.exp) < Date.now(),
                payload: o,
              };
            if (a.hasExpired)
              throw (
                (this.logger.warn("resolve: jwt attestation expired"),
                new Error("JWT attestation expired"))
              );
            return {
              origin: a.payload.origin,
              isScam: a.payload.isScam,
              isVerified: a.payload.isVerified,
            };
          }),
          (this.logger = Ve(r, this.name)),
          (this.abortController = new AbortController()),
          (this.isDevEnv = p1()),
          this.init();
      }
      get storeKey() {
        return (
          this.storagePrefix +
          this.version +
          this.core.customStoragePrefix +
          "//verify:public:key"
        );
      }
      get context() {
        return it(this.logger);
      }
      startAbortTimer(e) {
        return (
          (this.abortController = new AbortController()),
          setTimeout(() => this.abortController.abort(), z.toMiliseconds(e))
        );
      }
    }
    var Xz = Object.defineProperty,
      Qz = (t, e, r) =>
        e in t
          ? Xz(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      r8 = (t, e, r) => Qz(t, typeof e != "symbol" ? e + "" : e, r);
    class eq extends RU {
      constructor(e, r) {
        super(e, r),
          (this.projectId = e),
          (this.logger = r),
          r8(this, "context", rj),
          r8(this, "registerDeviceToken", async (i) => {
            const {
                clientId: s,
                token: n,
                notificationType: o,
                enableEncrypted: a = !1,
              } = i,
              c = `${ij}/${this.projectId}/clients`;
            await fetch(c, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                client_id: s,
                type: o,
                token: n,
                always_raw: a,
              }),
            });
          }),
          (this.logger = Ve(r, this.context));
      }
    }
    var tq = Object.defineProperty,
      i8 = Object.getOwnPropertySymbols,
      rq = Object.prototype.hasOwnProperty,
      iq = Object.prototype.propertyIsEnumerable,
      fw = (t, e, r) =>
        e in t
          ? tq(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Hu = (t, e) => {
        for (var r in e || (e = {})) rq.call(e, r) && fw(t, r, e[r]);
        if (i8) for (var r of i8(e)) iq.call(e, r) && fw(t, r, e[r]);
        return t;
      },
      Xt = (t, e, r) => fw(t, typeof e != "symbol" ? e + "" : e, r);
    class sq extends $U {
      constructor(e, r, i = !0) {
        super(e, r, i),
          (this.core = e),
          (this.logger = r),
          Xt(this, "context", nj),
          Xt(this, "storagePrefix", Is),
          Xt(this, "storageVersion", sj),
          Xt(this, "events", new Map()),
          Xt(this, "shouldPersist", !1),
          Xt(this, "init", async () => {
            if (!p1())
              try {
                const s = {
                  eventId: I5(),
                  timestamp: Date.now(),
                  domain: this.getAppDomain(),
                  props: {
                    event: "INIT",
                    type: "",
                    properties: {
                      client_id: await this.core.crypto.getClientId(),
                      user_agent: v5(
                        this.core.relayer.protocol,
                        this.core.relayer.version,
                        rw
                      ),
                    },
                  },
                };
                await this.sendEvent([s]);
              } catch (s) {
                this.logger.warn(s);
              }
          }),
          Xt(this, "createEvent", (s) => {
            const {
                event: n = "ERROR",
                type: o = "",
                properties: { topic: a, trace: c },
              } = s,
              l = I5(),
              u = this.core.projectId || "",
              h = Date.now(),
              d = Hu(
                {
                  eventId: l,
                  timestamp: h,
                  props: {
                    event: n,
                    type: o,
                    properties: { topic: a, trace: c },
                  },
                  bundleId: u,
                  domain: this.getAppDomain(),
                },
                this.setMethods(l)
              );
            return (
              this.telemetryEnabled &&
                (this.events.set(l, d), (this.shouldPersist = !0)),
              d
            );
          }),
          Xt(this, "getEvent", (s) => {
            const { eventId: n, topic: o } = s;
            if (n) return this.events.get(n);
            const a = Array.from(this.events.values()).find(
              (c) => c.props.properties.topic === o
            );
            if (a) return Hu(Hu({}, a), this.setMethods(a.eventId));
          }),
          Xt(this, "deleteEvent", (s) => {
            const { eventId: n } = s;
            this.events.delete(n), (this.shouldPersist = !0);
          }),
          Xt(this, "setEventListeners", () => {
            this.core.heartbeat.on(Ti.pulse, async () => {
              this.shouldPersist && (await this.persist()),
                this.events.forEach((s) => {
                  z.fromMiliseconds(Date.now()) -
                    z.fromMiliseconds(s.timestamp) >
                    oj &&
                    (this.events.delete(s.eventId), (this.shouldPersist = !0));
                });
            });
          }),
          Xt(this, "setMethods", (s) => ({
            addTrace: (n) => this.addTrace(s, n),
            setError: (n) => this.setError(s, n),
          })),
          Xt(this, "addTrace", (s, n) => {
            const o = this.events.get(s);
            o &&
              (o.props.properties.trace.push(n),
              this.events.set(s, o),
              (this.shouldPersist = !0));
          }),
          Xt(this, "setError", (s, n) => {
            const o = this.events.get(s);
            o &&
              ((o.props.type = n),
              (o.timestamp = Date.now()),
              this.events.set(s, o),
              (this.shouldPersist = !0));
          }),
          Xt(this, "persist", async () => {
            await this.core.storage.setItem(
              this.storageKey,
              Array.from(this.events.values())
            ),
              (this.shouldPersist = !1);
          }),
          Xt(this, "restore", async () => {
            try {
              const s =
                (await this.core.storage.getItem(this.storageKey)) || [];
              if (!s.length) return;
              s.forEach((n) => {
                this.events.set(
                  n.eventId,
                  Hu(Hu({}, n), this.setMethods(n.eventId))
                );
              });
            } catch (s) {
              this.logger.warn(s);
            }
          }),
          Xt(this, "submit", async () => {
            if (!this.telemetryEnabled || this.events.size === 0) return;
            const s = [];
            for (const [n, o] of this.events) o.props.type && s.push(o);
            if (s.length !== 0)
              try {
                if ((await this.sendEvent(s)).ok)
                  for (const n of s)
                    this.events.delete(n.eventId), (this.shouldPersist = !0);
              } catch (n) {
                this.logger.warn(n);
              }
          }),
          Xt(this, "sendEvent", async (s) => {
            const n = this.getAppDomain() ? "" : "&sp=desktop";
            return await fetch(
              `${aj}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${rw}${n}`,
              { method: "POST", body: JSON.stringify(s) }
            );
          }),
          Xt(this, "getAppDomain", () => b5().url),
          (this.logger = Ve(r, this.context)),
          (this.telemetryEnabled = i),
          i
            ? this.restore().then(async () => {
                await this.submit(), this.setEventListeners();
              })
            : this.persist();
      }
      get storageKey() {
        return (
          this.storagePrefix +
          this.storageVersion +
          this.core.customStoragePrefix +
          "//" +
          this.context
        );
      }
    }
    var nq = Object.defineProperty,
      s8 = Object.getOwnPropertySymbols,
      oq = Object.prototype.hasOwnProperty,
      aq = Object.prototype.propertyIsEnumerable,
      gw = (t, e, r) =>
        e in t
          ? nq(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      n8 = (t, e) => {
        for (var r in e || (e = {})) oq.call(e, r) && gw(t, r, e[r]);
        if (s8) for (var r of s8(e)) aq.call(e, r) && gw(t, r, e[r]);
        return t;
      },
      dt = (t, e, r) => gw(t, typeof e != "symbol" ? e + "" : e, r);
    class ww extends EU {
      constructor(e) {
        var r;
        super(e),
          dt(this, "protocol", E6),
          dt(this, "version", C6),
          dt(this, "name", jp),
          dt(this, "relayUrl"),
          dt(this, "projectId"),
          dt(this, "customStoragePrefix"),
          dt(this, "events", new rt.exports.EventEmitter()),
          dt(this, "logger"),
          dt(this, "heartbeat"),
          dt(this, "relayer"),
          dt(this, "crypto"),
          dt(this, "storage"),
          dt(this, "history"),
          dt(this, "expirer"),
          dt(this, "pairing"),
          dt(this, "verify"),
          dt(this, "echoClient"),
          dt(this, "linkModeSupportedApps"),
          dt(this, "eventClient"),
          dt(this, "initialized", !1),
          dt(this, "logChunkController"),
          dt(this, "on", (a, c) => this.events.on(a, c)),
          dt(this, "once", (a, c) => this.events.once(a, c)),
          dt(this, "off", (a, c) => this.events.off(a, c)),
          dt(this, "removeListener", (a, c) =>
            this.events.removeListener(a, c)
          ),
          dt(
            this,
            "dispatchEnvelope",
            ({ topic: a, message: c, sessionExists: l }) => {
              if (!a || !c) return;
              const u = {
                topic: a,
                message: c,
                publishedAt: Date.now(),
                transportType: gt.link_mode,
              };
              this.relayer.onLinkMessageEvent(u, { sessionExists: l });
            }
          );
        const i = this.getGlobalCore(e?.customStoragePrefix);
        if (i)
          try {
            return (
              (this.customStoragePrefix = i.customStoragePrefix),
              (this.logger = i.logger),
              (this.heartbeat = i.heartbeat),
              (this.crypto = i.crypto),
              (this.history = i.history),
              (this.expirer = i.expirer),
              (this.storage = i.storage),
              (this.relayer = i.relayer),
              (this.pairing = i.pairing),
              (this.verify = i.verify),
              (this.echoClient = i.echoClient),
              (this.linkModeSupportedApps = i.linkModeSupportedApps),
              (this.eventClient = i.eventClient),
              (this.initialized = i.initialized),
              (this.logChunkController = i.logChunkController),
              i
            );
          } catch (a) {
            console.warn("Failed to copy globalThis core", a);
          }
        (this.projectId = e?.projectId),
          (this.relayUrl = e?.relayUrl || A6),
          (this.customStoragePrefix =
            e != null && e.customStoragePrefix
              ? `:${e.customStoragePrefix}`
              : "");
        const s = tn({
            level:
              typeof e?.logger == "string" && e.logger ? e.logger : OD.logger,
            name: jp,
          }),
          { logger: n, chunkLoggerController: o } = J1({
            opts: s,
            maxSizeInBytes: e?.maxLogBlobSizeInBytes,
            loggerOverride: e?.logger,
          });
        (this.logChunkController = o),
          (r = this.logChunkController) != null &&
            r.downloadLogsBlobInBrowser &&
            (window.downloadLogsBlobInBrowser = async () => {
              var a, c;
              (a = this.logChunkController) != null &&
                a.downloadLogsBlobInBrowser &&
                ((c = this.logChunkController) == null ||
                  c.downloadLogsBlobInBrowser({
                    clientId: await this.crypto.getClientId(),
                  }));
            }),
          (this.logger = Ve(n, this.name)),
          (this.heartbeat = new Tp()),
          (this.crypto = new FM(this, this.logger, e?.keychain)),
          (this.history = new Vz(this, this.logger)),
          (this.expirer = new Gz(this, this.logger)),
          (this.storage =
            e != null && e.storage
              ? e.storage
              : new G4(n8(n8({}, ND), e?.storageOptions))),
          (this.relayer = new cz({
            core: this,
            logger: this.logger,
            relayUrl: this.relayUrl,
            projectId: this.projectId,
          })),
          (this.pairing = new zz(this, this.logger)),
          (this.verify = new Jz(this, this.logger, this.storage)),
          (this.echoClient = new eq(this.projectId || "", this.logger)),
          (this.linkModeSupportedApps = []),
          (this.eventClient = new sq(this, this.logger, e?.telemetryEnabled)),
          this.setGlobalCore(this);
      }
      static async init(e) {
        const r = new ww(e);
        await r.initialize();
        const i = await r.crypto.getClientId();
        return await r.storage.setItem(qD, i), r;
      }
      get context() {
        return it(this.logger);
      }
      async start() {
        this.initialized || (await this.initialize());
      }
      async getLogsBlob() {
        var e;
        return (e = this.logChunkController) == null
          ? void 0
          : e.logsToBlob({ clientId: await this.crypto.getClientId() });
      }
      async addLinkModeSupportedApp(e) {
        this.linkModeSupportedApps.includes(e) ||
          (this.linkModeSupportedApps.push(e),
          await this.storage.setItem(S6, this.linkModeSupportedApps));
      }
      async initialize() {
        this.logger.trace("Initialized");
        try {
          await this.crypto.init(),
            await this.history.init(),
            await this.expirer.init(),
            await this.relayer.init(),
            await this.heartbeat.init(),
            await this.pairing.init(),
            (this.linkModeSupportedApps =
              (await this.storage.getItem(S6)) || []),
            (this.initialized = !0),
            this.logger.info("Core Initialization Success");
        } catch (e) {
          throw (
            (this.logger.warn(
              `Core Initialization Failure at epoch ${Date.now()}`,
              e
            ),
            this.logger.error(e.message),
            e)
          );
        }
      }
      getGlobalCore(e = "") {
        try {
          if (this.isGlobalCoreDisabled()) return;
          const r = `_walletConnectCore_${e}`,
            i = `${r}_count`;
          return (
            (globalThis[i] = (globalThis[i] || 0) + 1),
            globalThis[i] > 1 &&
              console.warn(
                `WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[i]} times.`
              ),
            globalThis[r]
          );
        } catch (r) {
          console.warn("Failed to get globalThis WalletConnect core", r);
          return;
        }
      }
      setGlobalCore(e) {
        var r;
        try {
          if (this.isGlobalCoreDisabled()) return;
          const i = `_walletConnectCore_${
            ((r = e.opts) == null ? void 0 : r.customStoragePrefix) || ""
          }`;
          globalThis[i] = e;
        } catch (i) {
          console.warn("Failed to set globalThis WalletConnect core", i);
        }
      }
      isGlobalCoreDisabled() {
        try {
          return typeof ut < "u" && {}.DISABLE_GLOBAL_CORE === "true";
        } catch {
          return !0;
        }
      }
    }
    const cq = ww,
      o8 = "wc",
      a8 = 2,
      c8 = "client",
      mw = `${o8}@${a8}:${c8}:`,
      yw = {
        name: c8,
        logger: "error",
        controller: !1,
        relayUrl: "wss://relay.walletconnect.org",
      },
      l8 = "WALLETCONNECT_DEEPLINK_CHOICE",
      lq = "proposal",
      u8 = "Proposal expired",
      uq = "session",
      Sc = z.SEVEN_DAYS,
      hq = "engine",
      Qt = {
        wc_sessionPropose: {
          req: { ttl: z.FIVE_MINUTES, prompt: !0, tag: 1100 },
          res: { ttl: z.FIVE_MINUTES, prompt: !1, tag: 1101 },
          reject: { ttl: z.FIVE_MINUTES, prompt: !1, tag: 1120 },
          autoReject: { ttl: z.FIVE_MINUTES, prompt: !1, tag: 1121 },
        },
        wc_sessionSettle: {
          req: { ttl: z.FIVE_MINUTES, prompt: !1, tag: 1102 },
          res: { ttl: z.FIVE_MINUTES, prompt: !1, tag: 1103 },
        },
        wc_sessionUpdate: {
          req: { ttl: z.ONE_DAY, prompt: !1, tag: 1104 },
          res: { ttl: z.ONE_DAY, prompt: !1, tag: 1105 },
        },
        wc_sessionExtend: {
          req: { ttl: z.ONE_DAY, prompt: !1, tag: 1106 },
          res: { ttl: z.ONE_DAY, prompt: !1, tag: 1107 },
        },
        wc_sessionRequest: {
          req: { ttl: z.FIVE_MINUTES, prompt: !0, tag: 1108 },
          res: { ttl: z.FIVE_MINUTES, prompt: !1, tag: 1109 },
        },
        wc_sessionEvent: {
          req: { ttl: z.FIVE_MINUTES, prompt: !0, tag: 1110 },
          res: { ttl: z.FIVE_MINUTES, prompt: !1, tag: 1111 },
        },
        wc_sessionDelete: {
          req: { ttl: z.ONE_DAY, prompt: !1, tag: 1112 },
          res: { ttl: z.ONE_DAY, prompt: !1, tag: 1113 },
        },
        wc_sessionPing: {
          req: { ttl: z.ONE_DAY, prompt: !1, tag: 1114 },
          res: { ttl: z.ONE_DAY, prompt: !1, tag: 1115 },
        },
        wc_sessionAuthenticate: {
          req: { ttl: z.ONE_HOUR, prompt: !0, tag: 1116 },
          res: { ttl: z.ONE_HOUR, prompt: !1, tag: 1117 },
          reject: { ttl: z.FIVE_MINUTES, prompt: !1, tag: 1118 },
          autoReject: { ttl: z.FIVE_MINUTES, prompt: !1, tag: 1119 },
        },
      },
      bw = { min: z.FIVE_MINUTES, max: z.SEVEN_DAYS },
      Ss = { idle: "IDLE", active: "ACTIVE" },
      h8 = {
        eth_sendTransaction: { key: "" },
        eth_sendRawTransaction: { key: "" },
        wallet_sendCalls: { key: "" },
        solana_signTransaction: { key: "signature" },
        solana_signAllTransactions: { key: "transactions" },
        solana_signAndSendTransaction: { key: "signature" },
      },
      dq = "request",
      pq = [
        "wc_sessionPropose",
        "wc_sessionRequest",
        "wc_authRequest",
        "wc_sessionAuthenticate",
      ],
      fq = "wc",
      gq = "auth",
      wq = "authKeys",
      mq = "pairingTopics",
      yq = "requests",
      Hp = `${fq}@${1.5}:${gq}:`,
      Vp = `${Hp}:PUB_KEY`;
    var bq = Object.defineProperty,
      vq = Object.defineProperties,
      Eq = Object.getOwnPropertyDescriptors,
      d8 = Object.getOwnPropertySymbols,
      Cq = Object.prototype.hasOwnProperty,
      xq = Object.prototype.propertyIsEnumerable,
      vw = (t, e, r) =>
        e in t
          ? bq(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      nt = (t, e) => {
        for (var r in e || (e = {})) Cq.call(e, r) && vw(t, r, e[r]);
        if (d8) for (var r of d8(e)) xq.call(e, r) && vw(t, r, e[r]);
        return t;
      },
      $r = (t, e) => vq(t, Eq(e)),
      W = (t, e, r) => vw(t, typeof e != "symbol" ? e + "" : e, r);
    class Iq extends UU {
      constructor(e) {
        super(e),
          W(this, "name", hq),
          W(this, "events", new rt.exports()),
          W(this, "initialized", !1),
          W(this, "requestQueue", { state: Ss.idle, queue: [] }),
          W(this, "sessionRequestQueue", { state: Ss.idle, queue: [] }),
          W(this, "requestQueueDelay", z.ONE_SECOND),
          W(this, "expectedPairingMethodMap", new Map()),
          W(this, "recentlyDeletedMap", new Map()),
          W(this, "recentlyDeletedLimit", 200),
          W(this, "relayMessageCache", []),
          W(this, "pendingSessions", new Map()),
          W(this, "init", async () => {
            this.initialized ||
              (await this.cleanup(),
              this.registerRelayerEvents(),
              this.registerExpirerEvents(),
              this.registerPairingEvents(),
              await this.registerLinkModeListeners(),
              this.client.core.pairing.register({ methods: Object.keys(Qt) }),
              (this.initialized = !0),
              setTimeout(async () => {
                await this.processPendingMessageEvents(),
                  (this.sessionRequestQueue.queue =
                    this.getPendingSessionRequests()),
                  this.processSessionRequestQueue();
              }, z.toMiliseconds(this.requestQueueDelay)));
          }),
          W(this, "connect", async (r) => {
            this.isInitialized(), await this.confirmOnlineStateOrThrow();
            const i = $r(nt({}, r), {
              requiredNamespaces: r.requiredNamespaces || {},
              optionalNamespaces: r.optionalNamespaces || {},
            });
            await this.isValidConnect(i);
            const {
              pairingTopic: s,
              requiredNamespaces: n,
              optionalNamespaces: o,
              sessionProperties: a,
              scopedProperties: c,
              relays: l,
            } = i;
            let u = s,
              h,
              d = !1;
            try {
              if (u) {
                const A = this.client.core.pairing.pairings.get(u);
                this.client.logger.warn(
                  "connect() with existing pairing topic is deprecated and will be removed in the next major release."
                ),
                  (d = A.active);
              }
            } catch (A) {
              throw (
                (this.client.logger.error(
                  `connect() -> pairing.get(${u}) failed`
                ),
                A)
              );
            }
            if (!u || !d) {
              const { topic: A, uri: P } =
                await this.client.core.pairing.create();
              (u = A), (h = P);
            }
            if (!u) {
              const { message: A } = J(
                "NO_MATCHING_KEY",
                `connect() pairing topic: ${u}`
              );
              throw new Error(A);
            }
            const g = await this.client.core.crypto.generateKeyPair(),
              p = Qt.wc_sessionPropose.req.ttl || z.FIVE_MINUTES,
              w = Ft(p),
              f = $r(
                nt(
                  nt(
                    {
                      requiredNamespaces: n,
                      optionalNamespaces: o,
                      relays: l ?? [{ protocol: _6 }],
                      proposer: {
                        publicKey: g,
                        metadata: this.client.metadata,
                      },
                      expiryTimestamp: w,
                      pairingTopic: u,
                    },
                    a && { sessionProperties: a }
                  ),
                  c && { scopedProperties: c }
                ),
                { id: Yt() }
              ),
              m = He("session_connect", f.id),
              { reject: y, resolve: E, done: C } = Bo(p, u8),
              O = ({ id: A }) => {
                A === f.id &&
                  (this.client.events.off("proposal_expire", O),
                  this.pendingSessions.delete(f.id),
                  this.events.emit(m, { error: { message: u8, code: 0 } }));
              };
            return (
              this.client.events.on("proposal_expire", O),
              this.events.once(m, ({ error: A, session: P }) => {
                this.client.events.off("proposal_expire", O),
                  A ? y(A) : P && E(P);
              }),
              await this.sendRequest({
                topic: u,
                method: "wc_sessionPropose",
                params: f,
                throwOnFailedPublish: !0,
                clientRpcId: f.id,
              }),
              await this.setProposal(f.id, f),
              { uri: h, approval: C }
            );
          }),
          W(this, "pair", async (r) => {
            this.isInitialized(), await this.confirmOnlineStateOrThrow();
            try {
              return await this.client.core.pairing.pair(r);
            } catch (i) {
              throw (this.client.logger.error("pair() failed"), i);
            }
          }),
          W(this, "approve", async (r) => {
            var i, s, n;
            const o = this.client.core.eventClient.createEvent({
              properties: {
                topic: (i = r?.id) == null ? void 0 : i.toString(),
                trace: [ts.session_approve_started],
              },
            });
            try {
              this.isInitialized(), await this.confirmOnlineStateOrThrow();
            } catch (x) {
              throw (o.setError(Vo.no_internet_connection), x);
            }
            try {
              await this.isValidProposalId(r?.id);
            } catch (x) {
              throw (
                (this.client.logger.error(
                  `approve() -> proposal.get(${r?.id}) failed`
                ),
                o.setError(Vo.proposal_not_found),
                x)
              );
            }
            try {
              await this.isValidApprove(r);
            } catch (x) {
              throw (
                (this.client.logger.error(
                  "approve() -> isValidApprove() failed"
                ),
                o.setError(Vo.session_approve_namespace_validation_failure),
                x)
              );
            }
            const {
                id: a,
                relayProtocol: c,
                namespaces: l,
                sessionProperties: u,
                scopedProperties: h,
                sessionConfig: d,
              } = r,
              g = this.client.proposal.get(a);
            this.client.core.eventClient.deleteEvent({ eventId: o.eventId });
            const {
              pairingTopic: p,
              proposer: w,
              requiredNamespaces: f,
              optionalNamespaces: m,
            } = g;
            let y =
              (s = this.client.core.eventClient) == null
                ? void 0
                : s.getEvent({ topic: p });
            y ||
              (y =
                (n = this.client.core.eventClient) == null
                  ? void 0
                  : n.createEvent({
                      type: ts.session_approve_started,
                      properties: {
                        topic: p,
                        trace: [
                          ts.session_approve_started,
                          ts.session_namespaces_validation_success,
                        ],
                      },
                    }));
            const E = await this.client.core.crypto.generateKeyPair(),
              C = w.publicKey,
              O = await this.client.core.crypto.generateSharedKey(E, C),
              A = nt(
                nt(
                  nt(
                    {
                      relay: { protocol: c ?? "irn" },
                      namespaces: l,
                      controller: {
                        publicKey: E,
                        metadata: this.client.metadata,
                      },
                      expiry: Ft(Sc),
                    },
                    u && { sessionProperties: u }
                  ),
                  h && { scopedProperties: h }
                ),
                d && { sessionConfig: d }
              ),
              P = gt.relay;
            y.addTrace(ts.subscribing_session_topic);
            try {
              await this.client.core.relayer.subscribe(O, { transportType: P });
            } catch (x) {
              throw (y.setError(Vo.subscribe_session_topic_failure), x);
            }
            y.addTrace(ts.subscribe_session_topic_success);
            const N = $r(nt({}, A), {
              topic: O,
              requiredNamespaces: f,
              optionalNamespaces: m,
              pairingTopic: p,
              acknowledged: !1,
              self: A.controller,
              peer: { publicKey: w.publicKey, metadata: w.metadata },
              controller: E,
              transportType: gt.relay,
            });
            await this.client.session.set(O, N), y.addTrace(ts.store_session);
            try {
              y.addTrace(ts.publishing_session_settle),
                await this.sendRequest({
                  topic: O,
                  method: "wc_sessionSettle",
                  params: A,
                  throwOnFailedPublish: !0,
                }).catch((x) => {
                  throw (y?.setError(Vo.session_settle_publish_failure), x);
                }),
                y.addTrace(ts.session_settle_publish_success),
                y.addTrace(ts.publishing_session_approve),
                await this.sendResult({
                  id: a,
                  topic: p,
                  result: {
                    relay: { protocol: c ?? "irn" },
                    responderPublicKey: E,
                  },
                  throwOnFailedPublish: !0,
                }).catch((x) => {
                  throw (y?.setError(Vo.session_approve_publish_failure), x);
                }),
                y.addTrace(ts.session_approve_publish_success);
            } catch (x) {
              throw (
                (this.client.logger.error(x),
                this.client.session.delete(O, Ge("USER_DISCONNECTED")),
                await this.client.core.relayer.unsubscribe(O),
                x)
              );
            }
            return (
              this.client.core.eventClient.deleteEvent({ eventId: y.eventId }),
              await this.client.core.pairing.updateMetadata({
                topic: p,
                metadata: w.metadata,
              }),
              await this.client.proposal.delete(a, Ge("USER_DISCONNECTED")),
              await this.client.core.pairing.activate({ topic: p }),
              await this.setExpiry(O, Ft(Sc)),
              {
                topic: O,
                acknowledged: () => Promise.resolve(this.client.session.get(O)),
              }
            );
          }),
          W(this, "reject", async (r) => {
            this.isInitialized(), await this.confirmOnlineStateOrThrow();
            try {
              await this.isValidReject(r);
            } catch (o) {
              throw (
                (this.client.logger.error("reject() -> isValidReject() failed"),
                o)
              );
            }
            const { id: i, reason: s } = r;
            let n;
            try {
              n = this.client.proposal.get(i).pairingTopic;
            } catch (o) {
              throw (
                (this.client.logger.error(
                  `reject() -> proposal.get(${i}) failed`
                ),
                o)
              );
            }
            n &&
              (await this.sendError({
                id: i,
                topic: n,
                error: s,
                rpcOpts: Qt.wc_sessionPropose.reject,
              }),
              await this.client.proposal.delete(i, Ge("USER_DISCONNECTED")));
          }),
          W(this, "update", async (r) => {
            this.isInitialized(), await this.confirmOnlineStateOrThrow();
            try {
              await this.isValidUpdate(r);
            } catch (h) {
              throw (
                (this.client.logger.error("update() -> isValidUpdate() failed"),
                h)
              );
            }
            const { topic: i, namespaces: s } = r,
              { done: n, resolve: o, reject: a } = Bo(),
              c = Yt(),
              l = ui().toString(),
              u = this.client.session.get(i).namespaces;
            return (
              this.events.once(He("session_update", c), ({ error: h }) => {
                h ? a(h) : o();
              }),
              await this.client.session.update(i, { namespaces: s }),
              await this.sendRequest({
                topic: i,
                method: "wc_sessionUpdate",
                params: { namespaces: s },
                throwOnFailedPublish: !0,
                clientRpcId: c,
                relayRpcId: l,
              }).catch((h) => {
                this.client.logger.error(h),
                  this.client.session.update(i, { namespaces: u }),
                  a(h);
              }),
              { acknowledged: n }
            );
          }),
          W(this, "extend", async (r) => {
            this.isInitialized(), await this.confirmOnlineStateOrThrow();
            try {
              await this.isValidExtend(r);
            } catch (c) {
              throw (
                (this.client.logger.error("extend() -> isValidExtend() failed"),
                c)
              );
            }
            const { topic: i } = r,
              s = Yt(),
              { done: n, resolve: o, reject: a } = Bo();
            return (
              this.events.once(He("session_extend", s), ({ error: c }) => {
                c ? a(c) : o();
              }),
              await this.setExpiry(i, Ft(Sc)),
              this.sendRequest({
                topic: i,
                method: "wc_sessionExtend",
                params: {},
                clientRpcId: s,
                throwOnFailedPublish: !0,
              }).catch((c) => {
                a(c);
              }),
              { acknowledged: n }
            );
          }),
          W(this, "request", async (r) => {
            this.isInitialized();
            try {
              await this.isValidRequest(r);
            } catch (m) {
              throw (
                (this.client.logger.error(
                  "request() -> isValidRequest() failed"
                ),
                m)
              );
            }
            const {
                chainId: i,
                request: s,
                topic: n,
                expiry: o = Qt.wc_sessionRequest.req.ttl,
              } = r,
              a = this.client.session.get(n);
            a?.transportType === gt.relay &&
              (await this.confirmOnlineStateOrThrow());
            const c = Yt(),
              l = ui().toString(),
              {
                done: u,
                resolve: h,
                reject: d,
              } = Bo(o, "Request expired. Please try again.");
            this.events.once(
              He("session_request", c),
              ({ error: m, result: y }) => {
                m ? d(m) : h(y);
              }
            );
            const g = "wc_sessionRequest",
              p = this.getAppLinkIfEnabled(a.peer.metadata, a.transportType);
            if (p)
              return (
                await this.sendRequest({
                  clientRpcId: c,
                  relayRpcId: l,
                  topic: n,
                  method: g,
                  params: {
                    request: $r(nt({}, s), { expiryTimestamp: Ft(o) }),
                    chainId: i,
                  },
                  expiry: o,
                  throwOnFailedPublish: !0,
                  appLink: p,
                }).catch((m) => d(m)),
                this.client.events.emit("session_request_sent", {
                  topic: n,
                  request: s,
                  chainId: i,
                  id: c,
                }),
                await u()
              );
            const w = {
                request: $r(nt({}, s), { expiryTimestamp: Ft(o) }),
                chainId: i,
              },
              f = this.shouldSetTVF(g, w);
            return await Promise.all([
              new Promise(async (m) => {
                await this.sendRequest(
                  nt(
                    {
                      clientRpcId: c,
                      relayRpcId: l,
                      topic: n,
                      method: g,
                      params: w,
                      expiry: o,
                      throwOnFailedPublish: !0,
                    },
                    f && { tvf: this.getTVFParams(c, w) }
                  )
                ).catch((y) => d(y)),
                  this.client.events.emit("session_request_sent", {
                    topic: n,
                    request: s,
                    chainId: i,
                    id: c,
                  }),
                  m();
              }),
              new Promise(async (m) => {
                var y;
                if (!((y = a.sessionConfig) != null && y.disableDeepLink)) {
                  const E = await r$(this.client.core.storage, l8);
                  await QR({ id: c, topic: n, wcDeepLink: E });
                }
                m();
              }),
              u(),
            ]).then((m) => m[2]);
          }),
          W(this, "respond", async (r) => {
            this.isInitialized(), await this.isValidRespond(r);
            const { topic: i, response: s } = r,
              { id: n } = s,
              o = this.client.session.get(i);
            o.transportType === gt.relay &&
              (await this.confirmOnlineStateOrThrow());
            const a = this.getAppLinkIfEnabled(
              o.peer.metadata,
              o.transportType
            );
            Bt(s)
              ? await this.sendResult({
                  id: n,
                  topic: i,
                  result: s.result,
                  throwOnFailedPublish: !0,
                  appLink: a,
                })
              : Ct(s) &&
                (await this.sendError({
                  id: n,
                  topic: i,
                  error: s.error,
                  appLink: a,
                })),
              this.cleanupAfterResponse(r);
          }),
          W(this, "ping", async (r) => {
            this.isInitialized(), await this.confirmOnlineStateOrThrow();
            try {
              await this.isValidPing(r);
            } catch (s) {
              throw (
                (this.client.logger.error("ping() -> isValidPing() failed"), s)
              );
            }
            const { topic: i } = r;
            if (this.client.session.keys.includes(i)) {
              const s = Yt(),
                n = ui().toString(),
                { done: o, resolve: a, reject: c } = Bo();
              this.events.once(He("session_ping", s), ({ error: l }) => {
                l ? c(l) : a();
              }),
                await Promise.all([
                  this.sendRequest({
                    topic: i,
                    method: "wc_sessionPing",
                    params: {},
                    throwOnFailedPublish: !0,
                    clientRpcId: s,
                    relayRpcId: n,
                  }),
                  o(),
                ]);
            } else
              this.client.core.pairing.pairings.keys.includes(i) &&
                (this.client.logger.warn(
                  "ping() on pairing topic is deprecated and will be removed in the next major release."
                ),
                await this.client.core.pairing.ping({ topic: i }));
          }),
          W(this, "emit", async (r) => {
            this.isInitialized(),
              await this.confirmOnlineStateOrThrow(),
              await this.isValidEmit(r);
            const { topic: i, event: s, chainId: n } = r,
              o = ui().toString(),
              a = Yt();
            await this.sendRequest({
              topic: i,
              method: "wc_sessionEvent",
              params: { event: s, chainId: n },
              throwOnFailedPublish: !0,
              relayRpcId: o,
              clientRpcId: a,
            });
          }),
          W(this, "disconnect", async (r) => {
            this.isInitialized(),
              await this.confirmOnlineStateOrThrow(),
              await this.isValidDisconnect(r);
            const { topic: i } = r;
            if (this.client.session.keys.includes(i))
              await this.sendRequest({
                topic: i,
                method: "wc_sessionDelete",
                params: Ge("USER_DISCONNECTED"),
                throwOnFailedPublish: !0,
              }),
                await this.deleteSession({ topic: i, emitEvent: !1 });
            else if (this.client.core.pairing.pairings.keys.includes(i))
              await this.client.core.pairing.disconnect({ topic: i });
            else {
              const { message: s } = J(
                "MISMATCHED_TOPIC",
                `Session or pairing topic not found: ${i}`
              );
              throw new Error(s);
            }
          }),
          W(
            this,
            "find",
            (r) => (
              this.isInitialized(),
              this.client.session.getAll().filter((i) => BB(i, r))
            )
          ),
          W(this, "getPendingSessionRequests", () =>
            this.client.pendingRequest.getAll()
          ),
          W(this, "authenticate", async (r, i) => {
            var s;
            this.isInitialized(), this.isValidAuthenticate(r);
            const n =
                i &&
                this.client.core.linkModeSupportedApps.includes(i) &&
                ((s = this.client.metadata.redirect) == null
                  ? void 0
                  : s.linkMode),
              o = n ? gt.link_mode : gt.relay;
            o === gt.relay && (await this.confirmOnlineStateOrThrow());
            const {
                chains: a,
                statement: c = "",
                uri: l,
                domain: u,
                nonce: h,
                type: d,
                exp: g,
                nbf: p,
                methods: w = [],
                expiry: f,
              } = r,
              m = [...(r.resources || [])],
              { topic: y, uri: E } = await this.client.core.pairing.create({
                methods: ["wc_sessionAuthenticate"],
                transportType: o,
              });
            this.client.logger.info({
              message: "Generated new pairing",
              pairing: { topic: y, uri: E },
            });
            const C = await this.client.core.crypto.generateKeyPair(),
              O = Sp(C);
            if (
              (await Promise.all([
                this.client.auth.authKeys.set(Vp, {
                  responseTopic: O,
                  publicKey: C,
                }),
                this.client.auth.pairingTopics.set(O, {
                  topic: O,
                  pairingTopic: y,
                }),
              ]),
              await this.client.core.relayer.subscribe(O, { transportType: o }),
              this.client.logger.info(
                `sending request to new pairing topic: ${y}`
              ),
              w.length > 0)
            ) {
              const { namespace: _ } = ac(a[0]);
              let R = K$(_, "request", w);
              bp(m) && (R = Z$(R, m.pop())), m.push(R);
            }
            const A =
                f && f > Qt.wc_sessionAuthenticate.req.ttl
                  ? f
                  : Qt.wc_sessionAuthenticate.req.ttl,
              P = {
                authPayload: {
                  type: d ?? "caip122",
                  chains: a,
                  statement: c,
                  aud: l,
                  domain: u,
                  version: "1",
                  nonce: h,
                  iat: new Date().toISOString(),
                  exp: g,
                  nbf: p,
                  resources: m,
                },
                requester: { publicKey: C, metadata: this.client.metadata },
                expiryTimestamp: Ft(A),
              },
              N = {
                eip155: {
                  chains: a,
                  methods: [...new Set(["personal_sign", ...w])],
                  events: ["chainChanged", "accountsChanged"],
                },
              },
              x = {
                requiredNamespaces: {},
                optionalNamespaces: N,
                relays: [{ protocol: "irn" }],
                pairingTopic: y,
                proposer: { publicKey: C, metadata: this.client.metadata },
                expiryTimestamp: Ft(Qt.wc_sessionPropose.req.ttl),
                id: Yt(),
              },
              { done: $, resolve: k, reject: F } = Bo(A, "Request expired"),
              j = Yt(),
              I = He("session_connect", x.id),
              b = He("session_request", j),
              v = async ({ error: _, session: R }) => {
                this.events.off(b, S), _ ? F(_) : R && k({ session: R });
              },
              S = async (_) => {
                var R, U, D;
                if (
                  (await this.deletePendingAuthRequest(j, {
                    message: "fulfilled",
                    code: 0,
                  }),
                  _.error)
                ) {
                  const te = Ge(
                    "WC_METHOD_UNSUPPORTED",
                    "wc_sessionAuthenticate"
                  );
                  return _.error.code === te.code
                    ? void 0
                    : (this.events.off(I, v), F(_.error.message));
                }
                await this.deleteProposal(x.id), this.events.off(I, v);
                const { cacaos: H, responder: q } = _.result,
                  V = [],
                  Y = [];
                for (const te of H) {
                  (await D5({
                    cacao: te,
                    projectId: this.client.core.projectId,
                  })) ||
                    (this.client.logger.error(
                      te,
                      "Signature verification failed"
                    ),
                    F(
                      Ge(
                        "SESSION_SETTLEMENT_FAILED",
                        "Signature verification failed"
                      )
                    ));
                  const { p: ve } = te,
                    Ee = bp(ve.resources),
                    Ce = [b1(ve.iss)],
                    Ie = yp(ve.iss);
                  if (Ee) {
                    const mt = z5(Ee),
                      Ir = q5(Ee);
                    V.push(...mt), Ce.push(...Ir);
                  }
                  for (const mt of Ce) Y.push(`${mt}:${Ie}`);
                }
                const ae = await this.client.core.crypto.generateSharedKey(
                  C,
                  q.publicKey
                );
                let re;
                V.length > 0 &&
                  ((re = {
                    topic: ae,
                    acknowledged: !0,
                    self: { publicKey: C, metadata: this.client.metadata },
                    peer: q,
                    controller: q.publicKey,
                    expiry: Ft(Sc),
                    requiredNamespaces: {},
                    optionalNamespaces: {},
                    relay: { protocol: "irn" },
                    pairingTopic: y,
                    namespaces: $4([...new Set(V)], [...new Set(Y)]),
                    transportType: o,
                  }),
                  await this.client.core.relayer.subscribe(ae, {
                    transportType: o,
                  }),
                  await this.client.session.set(ae, re),
                  y &&
                    (await this.client.core.pairing.updateMetadata({
                      topic: y,
                      metadata: q.metadata,
                    })),
                  (re = this.client.session.get(ae))),
                  (R = this.client.metadata.redirect) != null &&
                    R.linkMode &&
                    (U = q.metadata.redirect) != null &&
                    U.linkMode &&
                    (D = q.metadata.redirect) != null &&
                    D.universal &&
                    i &&
                    (this.client.core.addLinkModeSupportedApp(
                      q.metadata.redirect.universal
                    ),
                    this.client.session.update(ae, {
                      transportType: gt.link_mode,
                    })),
                  k({ auths: H, session: re });
              };
            this.events.once(I, v), this.events.once(b, S);
            let T;
            try {
              if (n) {
                const _ = kr("wc_sessionAuthenticate", P, j);
                this.client.core.history.set(y, _);
                const R = await this.client.core.crypto.encode("", _, {
                  type: Iu,
                  encoding: Yn,
                });
                T = Op(i, y, R);
              } else
                await Promise.all([
                  this.sendRequest({
                    topic: y,
                    method: "wc_sessionAuthenticate",
                    params: P,
                    expiry: r.expiry,
                    throwOnFailedPublish: !0,
                    clientRpcId: j,
                  }),
                  this.sendRequest({
                    topic: y,
                    method: "wc_sessionPropose",
                    params: x,
                    expiry: Qt.wc_sessionPropose.req.ttl,
                    throwOnFailedPublish: !0,
                    clientRpcId: x.id,
                  }),
                ]);
            } catch (_) {
              throw (this.events.off(I, v), this.events.off(b, S), _);
            }
            return (
              await this.setProposal(x.id, x),
              await this.setAuthRequest(j, {
                request: $r(nt({}, P), { verifyContext: {} }),
                pairingTopic: y,
                transportType: o,
              }),
              { uri: T ?? E, response: $ }
            );
          }),
          W(this, "approveSessionAuthenticate", async (r) => {
            const { id: i, auths: s } = r,
              n = this.client.core.eventClient.createEvent({
                properties: {
                  topic: i.toString(),
                  trace: [Wo.authenticated_session_approve_started],
                },
              });
            try {
              this.isInitialized();
            } catch (f) {
              throw (n.setError(Du.no_internet_connection), f);
            }
            const o = this.getPendingAuthRequest(i);
            if (!o)
              throw (
                (n.setError(Du.authenticated_session_pending_request_not_found),
                new Error(`Could not find pending auth request with id ${i}`))
              );
            const a = o.transportType || gt.relay;
            a === gt.relay && (await this.confirmOnlineStateOrThrow());
            const c = o.requester.publicKey,
              l = await this.client.core.crypto.generateKeyPair(),
              u = Sp(c),
              h = { type: en, receiverPublicKey: c, senderPublicKey: l },
              d = [],
              g = [];
            for (const f of s) {
              if (
                !(await D5({ cacao: f, projectId: this.client.core.projectId }))
              ) {
                n.setError(Du.invalid_cacao);
                const O = Ge(
                  "SESSION_SETTLEMENT_FAILED",
                  "Signature verification failed"
                );
                throw (
                  (await this.sendError({
                    id: i,
                    topic: u,
                    error: O,
                    encodeOpts: h,
                  }),
                  new Error(O.message))
                );
              }
              n.addTrace(Wo.cacaos_verified);
              const { p: m } = f,
                y = bp(m.resources),
                E = [b1(m.iss)],
                C = yp(m.iss);
              if (y) {
                const O = z5(y),
                  A = q5(y);
                d.push(...O), E.push(...A);
              }
              for (const O of E) g.push(`${O}:${C}`);
            }
            const p = await this.client.core.crypto.generateSharedKey(l, c);
            n.addTrace(Wo.create_authenticated_session_topic);
            let w;
            if (d?.length > 0) {
              (w = {
                topic: p,
                acknowledged: !0,
                self: { publicKey: l, metadata: this.client.metadata },
                peer: { publicKey: c, metadata: o.requester.metadata },
                controller: c,
                expiry: Ft(Sc),
                authentication: s,
                requiredNamespaces: {},
                optionalNamespaces: {},
                relay: { protocol: "irn" },
                pairingTopic: o.pairingTopic,
                namespaces: $4([...new Set(d)], [...new Set(g)]),
                transportType: a,
              }),
                n.addTrace(Wo.subscribing_authenticated_session_topic);
              try {
                await this.client.core.relayer.subscribe(p, {
                  transportType: a,
                });
              } catch (f) {
                throw (
                  (n.setError(Du.subscribe_authenticated_session_topic_failure),
                  f)
                );
              }
              n.addTrace(Wo.subscribe_authenticated_session_topic_success),
                await this.client.session.set(p, w),
                n.addTrace(Wo.store_authenticated_session),
                await this.client.core.pairing.updateMetadata({
                  topic: o.pairingTopic,
                  metadata: o.requester.metadata,
                });
            }
            n.addTrace(Wo.publishing_authenticated_session_approve);
            try {
              await this.sendResult({
                topic: u,
                id: i,
                result: {
                  cacaos: s,
                  responder: { publicKey: l, metadata: this.client.metadata },
                },
                encodeOpts: h,
                throwOnFailedPublish: !0,
                appLink: this.getAppLinkIfEnabled(o.requester.metadata, a),
              });
            } catch (f) {
              throw (
                (n.setError(Du.authenticated_session_approve_publish_failure),
                f)
              );
            }
            return (
              await this.client.auth.requests.delete(i, {
                message: "fulfilled",
                code: 0,
              }),
              await this.client.core.pairing.activate({
                topic: o.pairingTopic,
              }),
              this.client.core.eventClient.deleteEvent({ eventId: n.eventId }),
              { session: w }
            );
          }),
          W(this, "rejectSessionAuthenticate", async (r) => {
            this.isInitialized();
            const { id: i, reason: s } = r,
              n = this.getPendingAuthRequest(i);
            if (!n)
              throw new Error(
                `Could not find pending auth request with id ${i}`
              );
            n.transportType === gt.relay &&
              (await this.confirmOnlineStateOrThrow());
            const o = n.requester.publicKey,
              a = await this.client.core.crypto.generateKeyPair(),
              c = Sp(o),
              l = { type: en, receiverPublicKey: o, senderPublicKey: a };
            await this.sendError({
              id: i,
              topic: c,
              error: s,
              encodeOpts: l,
              rpcOpts: Qt.wc_sessionAuthenticate.reject,
              appLink: this.getAppLinkIfEnabled(
                n.requester.metadata,
                n.transportType
              ),
            }),
              await this.client.auth.requests.delete(i, {
                message: "rejected",
                code: 0,
              }),
              await this.client.proposal.delete(i, Ge("USER_DISCONNECTED"));
          }),
          W(this, "formatAuthMessage", (r) => {
            this.isInitialized();
            const { request: i, iss: s } = r;
            return j5(i, s);
          }),
          W(this, "processRelayMessageCache", () => {
            setTimeout(async () => {
              if (this.relayMessageCache.length !== 0)
                for (; this.relayMessageCache.length > 0; )
                  try {
                    const r = this.relayMessageCache.shift();
                    r && (await this.onRelayMessage(r));
                  } catch (r) {
                    this.client.logger.error(r);
                  }
            }, 50);
          }),
          W(this, "cleanupDuplicatePairings", async (r) => {
            if (r.pairingTopic)
              try {
                const i = this.client.core.pairing.pairings.get(r.pairingTopic),
                  s = this.client.core.pairing.pairings.getAll().filter((n) => {
                    var o, a;
                    return (
                      ((o = n.peerMetadata) == null ? void 0 : o.url) &&
                      ((a = n.peerMetadata) == null ? void 0 : a.url) ===
                        r.peer.metadata.url &&
                      n.topic &&
                      n.topic !== i.topic
                    );
                  });
                if (s.length === 0) return;
                this.client.logger.info(
                  `Cleaning up ${s.length} duplicate pairing(s)`
                ),
                  await Promise.all(
                    s.map((n) =>
                      this.client.core.pairing.disconnect({ topic: n.topic })
                    )
                  ),
                  this.client.logger.info(
                    "Duplicate pairings clean up finished"
                  );
              } catch (i) {
                this.client.logger.error(i);
              }
          }),
          W(this, "deleteSession", async (r) => {
            var i;
            const {
                topic: s,
                expirerHasDeleted: n = !1,
                emitEvent: o = !0,
                id: a = 0,
              } = r,
              { self: c } = this.client.session.get(s);
            await this.client.core.relayer.unsubscribe(s),
              await this.client.session.delete(s, Ge("USER_DISCONNECTED")),
              this.addToRecentlyDeleted(s, "session"),
              this.client.core.crypto.keychain.has(c.publicKey) &&
                (await this.client.core.crypto.deleteKeyPair(c.publicKey)),
              this.client.core.crypto.keychain.has(s) &&
                (await this.client.core.crypto.deleteSymKey(s)),
              n || this.client.core.expirer.del(s),
              this.client.core.storage
                .removeItem(l8)
                .catch((l) => this.client.logger.warn(l)),
              this.getPendingSessionRequests().forEach((l) => {
                l.topic === s &&
                  this.deletePendingSessionRequest(
                    l.id,
                    Ge("USER_DISCONNECTED")
                  );
              }),
              s ===
                ((i = this.sessionRequestQueue.queue[0]) == null
                  ? void 0
                  : i.topic) && (this.sessionRequestQueue.state = Ss.idle),
              o &&
                this.client.events.emit("session_delete", { id: a, topic: s });
          }),
          W(this, "deleteProposal", async (r, i) => {
            if (i)
              try {
                const s = this.client.proposal.get(r);
                this.client.core.eventClient
                  .getEvent({ topic: s.pairingTopic })
                  ?.setError(Vo.proposal_expired);
              } catch {}
            await Promise.all([
              this.client.proposal.delete(r, Ge("USER_DISCONNECTED")),
              i ? Promise.resolve() : this.client.core.expirer.del(r),
            ]),
              this.addToRecentlyDeleted(r, "proposal");
          }),
          W(this, "deletePendingSessionRequest", async (r, i, s = !1) => {
            await Promise.all([
              this.client.pendingRequest.delete(r, i),
              s ? Promise.resolve() : this.client.core.expirer.del(r),
            ]),
              this.addToRecentlyDeleted(r, "request"),
              (this.sessionRequestQueue.queue =
                this.sessionRequestQueue.queue.filter((n) => n.id !== r)),
              s &&
                ((this.sessionRequestQueue.state = Ss.idle),
                this.client.events.emit("session_request_expire", { id: r }));
          }),
          W(this, "deletePendingAuthRequest", async (r, i, s = !1) => {
            await Promise.all([
              this.client.auth.requests.delete(r, i),
              s ? Promise.resolve() : this.client.core.expirer.del(r),
            ]);
          }),
          W(this, "setExpiry", async (r, i) => {
            this.client.session.keys.includes(r) &&
              (this.client.core.expirer.set(r, i),
              await this.client.session.update(r, { expiry: i }));
          }),
          W(this, "setProposal", async (r, i) => {
            this.client.core.expirer.set(r, Ft(Qt.wc_sessionPropose.req.ttl)),
              await this.client.proposal.set(r, i);
          }),
          W(this, "setAuthRequest", async (r, i) => {
            const {
              request: s,
              pairingTopic: n,
              transportType: o = gt.relay,
            } = i;
            this.client.core.expirer.set(r, s.expiryTimestamp),
              await this.client.auth.requests.set(r, {
                authPayload: s.authPayload,
                requester: s.requester,
                expiryTimestamp: s.expiryTimestamp,
                id: r,
                pairingTopic: n,
                verifyContext: s.verifyContext,
                transportType: o,
              });
          }),
          W(this, "setPendingSessionRequest", async (r) => {
            const { id: i, topic: s, params: n, verifyContext: o } = r,
              a = n.request.expiryTimestamp || Ft(Qt.wc_sessionRequest.req.ttl);
            this.client.core.expirer.set(i, a),
              await this.client.pendingRequest.set(i, {
                id: i,
                topic: s,
                params: n,
                verifyContext: o,
              });
          }),
          W(this, "sendRequest", async (r) => {
            const {
                topic: i,
                method: s,
                params: n,
                expiry: o,
                relayRpcId: a,
                clientRpcId: c,
                throwOnFailedPublish: l,
                appLink: u,
                tvf: h,
              } = r,
              d = kr(s, n, c);
            let g;
            const p = !!u;
            try {
              const m = p ? Yn : Xi;
              g = await this.client.core.crypto.encode(i, d, { encoding: m });
            } catch (m) {
              throw (
                (await this.cleanup(),
                this.client.logger.error(
                  `sendRequest() -> core.crypto.encode() for topic ${i} failed`
                ),
                m)
              );
            }
            let w;
            if (pq.includes(s)) {
              const m = Cs(JSON.stringify(d)),
                y = Cs(g);
              w = await this.client.core.verify.register({
                id: y,
                decryptedId: m,
              });
            }
            const f = Qt[s].req;
            if (
              ((f.attestation = w),
              o && (f.ttl = o),
              a && (f.id = a),
              this.client.core.history.set(i, d),
              p)
            ) {
              const m = Op(u, i, g);
              await globalThis.Linking.openURL(m, this.client.name);
            } else {
              const m = Qt[s].req;
              o && (m.ttl = o),
                a && (m.id = a),
                (m.tvf = $r(nt({}, h), { correlationId: d.id })),
                l
                  ? ((m.internal = $r(nt({}, m.internal), {
                      throwOnFailedPublish: !0,
                    })),
                    await this.client.core.relayer.publish(i, g, m))
                  : this.client.core.relayer
                      .publish(i, g, m)
                      .catch((y) => this.client.logger.error(y));
            }
            return d.id;
          }),
          W(this, "sendResult", async (r) => {
            const {
                id: i,
                topic: s,
                result: n,
                throwOnFailedPublish: o,
                encodeOpts: a,
                appLink: c,
              } = r,
              l = Jn(i, n);
            let u;
            const h = c && typeof globalThis?.Linking < "u";
            try {
              const p = h ? Yn : Xi;
              u = await this.client.core.crypto.encode(
                s,
                l,
                $r(nt({}, a || {}), { encoding: p })
              );
            } catch (p) {
              throw (
                (await this.cleanup(),
                this.client.logger.error(
                  `sendResult() -> core.crypto.encode() for topic ${s} failed`
                ),
                p)
              );
            }
            let d, g;
            try {
              d = await this.client.core.history.get(s, i);
              const p = d.request;
              try {
                this.shouldSetTVF(p.method, p.params) &&
                  (g = this.getTVFParams(i, p.params, n));
              } catch (w) {
                this.client.logger.warn(
                  "sendResult() -> getTVFParams() failed",
                  w
                );
              }
            } catch (p) {
              throw (
                (this.client.logger.error(
                  `sendResult() -> history.get(${s}, ${i}) failed`
                ),
                p)
              );
            }
            if (h) {
              const p = Op(c, s, u);
              await globalThis.Linking.openURL(p, this.client.name);
            } else {
              const p = d.request.method,
                w = Qt[p].res;
              (w.tvf = $r(nt({}, g), { correlationId: i })),
                o
                  ? ((w.internal = $r(nt({}, w.internal), {
                      throwOnFailedPublish: !0,
                    })),
                    await this.client.core.relayer.publish(s, u, w))
                  : this.client.core.relayer
                      .publish(s, u, w)
                      .catch((f) => this.client.logger.error(f));
            }
            await this.client.core.history.resolve(l);
          }),
          W(this, "sendError", async (r) => {
            const {
                id: i,
                topic: s,
                error: n,
                encodeOpts: o,
                rpcOpts: a,
                appLink: c,
              } = r,
              l = Ic(i, n);
            let u;
            const h = c && typeof globalThis?.Linking < "u";
            try {
              const g = h ? Yn : Xi;
              u = await this.client.core.crypto.encode(
                s,
                l,
                $r(nt({}, o || {}), { encoding: g })
              );
            } catch (g) {
              throw (
                (await this.cleanup(),
                this.client.logger.error(
                  `sendError() -> core.crypto.encode() for topic ${s} failed`
                ),
                g)
              );
            }
            let d;
            try {
              d = await this.client.core.history.get(s, i);
            } catch (g) {
              throw (
                (this.client.logger.error(
                  `sendError() -> history.get(${s}, ${i}) failed`
                ),
                g)
              );
            }
            if (h) {
              const g = Op(c, s, u);
              await globalThis.Linking.openURL(g, this.client.name);
            } else {
              const g = d.request.method,
                p = a || Qt[g].res;
              this.client.core.relayer.publish(s, u, p);
            }
            await this.client.core.history.resolve(l);
          }),
          W(this, "cleanup", async () => {
            const r = [],
              i = [];
            this.client.session.getAll().forEach((s) => {
              let n = !1;
              Wn(s.expiry) && (n = !0),
                this.client.core.crypto.keychain.has(s.topic) || (n = !0),
                n && r.push(s.topic);
            }),
              this.client.proposal.getAll().forEach((s) => {
                Wn(s.expiryTimestamp) && i.push(s.id);
              }),
              await Promise.all([
                ...r.map((s) => this.deleteSession({ topic: s })),
                ...i.map((s) => this.deleteProposal(s)),
              ]);
          }),
          W(this, "onProviderMessageEvent", async (r) => {
            !this.initialized || this.relayMessageCache.length > 0
              ? this.relayMessageCache.push(r)
              : await this.onRelayMessage(r);
          }),
          W(this, "onRelayEventRequest", async (r) => {
            this.requestQueue.queue.push(r), await this.processRequestsQueue();
          }),
          W(this, "processRequestsQueue", async () => {
            if (this.requestQueue.state === Ss.active) {
              this.client.logger.info(
                "Request queue already active, skipping..."
              );
              return;
            }
            for (
              this.client.logger.info(
                `Request queue starting with ${this.requestQueue.queue.length} requests`
              );
              this.requestQueue.queue.length > 0;

            ) {
              this.requestQueue.state = Ss.active;
              const r = this.requestQueue.queue.shift();
              if (r)
                try {
                  await this.processRequest(r);
                } catch (i) {
                  this.client.logger.warn(i);
                }
            }
            this.requestQueue.state = Ss.idle;
          }),
          W(this, "processRequest", async (r) => {
            const {
                topic: i,
                payload: s,
                attestation: n,
                transportType: o,
                encryptedId: a,
              } = r,
              c = s.method;
            if (
              !this.shouldIgnorePairingRequest({ topic: i, requestMethod: c })
            )
              switch (c) {
                case "wc_sessionPropose":
                  return await this.onSessionProposeRequest({
                    topic: i,
                    payload: s,
                    attestation: n,
                    encryptedId: a,
                  });
                case "wc_sessionSettle":
                  return await this.onSessionSettleRequest(i, s);
                case "wc_sessionUpdate":
                  return await this.onSessionUpdateRequest(i, s);
                case "wc_sessionExtend":
                  return await this.onSessionExtendRequest(i, s);
                case "wc_sessionPing":
                  return await this.onSessionPingRequest(i, s);
                case "wc_sessionDelete":
                  return await this.onSessionDeleteRequest(i, s);
                case "wc_sessionRequest":
                  return await this.onSessionRequest({
                    topic: i,
                    payload: s,
                    attestation: n,
                    encryptedId: a,
                    transportType: o,
                  });
                case "wc_sessionEvent":
                  return await this.onSessionEventRequest(i, s);
                case "wc_sessionAuthenticate":
                  return await this.onSessionAuthenticateRequest({
                    topic: i,
                    payload: s,
                    attestation: n,
                    encryptedId: a,
                    transportType: o,
                  });
                default:
                  return this.client.logger.info(
                    `Unsupported request method ${c}`
                  );
              }
          }),
          W(this, "onRelayEventResponse", async (r) => {
            const { topic: i, payload: s, transportType: n } = r,
              o = (await this.client.core.history.get(i, s.id)).request.method;
            switch (o) {
              case "wc_sessionPropose":
                return this.onSessionProposeResponse(i, s, n);
              case "wc_sessionSettle":
                return this.onSessionSettleResponse(i, s);
              case "wc_sessionUpdate":
                return this.onSessionUpdateResponse(i, s);
              case "wc_sessionExtend":
                return this.onSessionExtendResponse(i, s);
              case "wc_sessionPing":
                return this.onSessionPingResponse(i, s);
              case "wc_sessionRequest":
                return this.onSessionRequestResponse(i, s);
              case "wc_sessionAuthenticate":
                return this.onSessionAuthenticateResponse(i, s);
              default:
                return this.client.logger.info(
                  `Unsupported response method ${o}`
                );
            }
          }),
          W(this, "onRelayEventUnknownPayload", (r) => {
            const { topic: i } = r,
              { message: s } = J(
                "MISSING_OR_INVALID",
                `Decoded payload on topic ${i} is not identifiable as a JSON-RPC request or a response.`
              );
            throw new Error(s);
          }),
          W(this, "shouldIgnorePairingRequest", (r) => {
            const { topic: i, requestMethod: s } = r,
              n = this.expectedPairingMethodMap.get(i);
            return !n || n.includes(s)
              ? !1
              : !!(
                  n.includes("wc_sessionAuthenticate") &&
                  this.client.events.listenerCount("session_authenticate") > 0
                );
          }),
          W(this, "onSessionProposeRequest", async (r) => {
            const { topic: i, payload: s, attestation: n, encryptedId: o } = r,
              { params: a, id: c } = s;
            try {
              const l = this.client.core.eventClient.getEvent({ topic: i });
              this.client.events.listenerCount("session_proposal") === 0 &&
                (console.warn("No listener for session_proposal event"),
                l?.setError(nn.proposal_listener_not_found)),
                this.isValidConnect(nt({}, s.params));
              const u = a.expiryTimestamp || Ft(Qt.wc_sessionPropose.req.ttl),
                h = nt({ id: c, pairingTopic: i, expiryTimestamp: u }, a);
              await this.setProposal(c, h);
              const d = await this.getVerifyContext({
                attestationId: n,
                hash: Cs(JSON.stringify(s)),
                encryptedId: o,
                metadata: h.proposer.metadata,
              });
              l?.addTrace(_s.emit_session_proposal),
                this.client.events.emit("session_proposal", {
                  id: c,
                  params: h,
                  verifyContext: d,
                });
            } catch (l) {
              await this.sendError({
                id: c,
                topic: i,
                error: l,
                rpcOpts: Qt.wc_sessionPropose.autoReject,
              }),
                this.client.logger.error(l);
            }
          }),
          W(this, "onSessionProposeResponse", async (r, i, s) => {
            const { id: n } = i;
            if (Bt(i)) {
              const { result: o } = i;
              this.client.logger.trace({
                type: "method",
                method: "onSessionProposeResponse",
                result: o,
              });
              const a = this.client.proposal.get(n);
              this.client.logger.trace({
                type: "method",
                method: "onSessionProposeResponse",
                proposal: a,
              });
              const c = a.proposer.publicKey;
              this.client.logger.trace({
                type: "method",
                method: "onSessionProposeResponse",
                selfPublicKey: c,
              });
              const l = o.responderPublicKey;
              this.client.logger.trace({
                type: "method",
                method: "onSessionProposeResponse",
                peerPublicKey: l,
              });
              const u = await this.client.core.crypto.generateSharedKey(c, l);
              this.pendingSessions.set(n, {
                sessionTopic: u,
                pairingTopic: r,
                proposalId: n,
                publicKey: c,
              });
              const h = await this.client.core.relayer.subscribe(u, {
                transportType: s,
              });
              this.client.logger.trace({
                type: "method",
                method: "onSessionProposeResponse",
                subscriptionId: h,
              }),
                await this.client.core.pairing.activate({ topic: r });
            } else if (Ct(i)) {
              await this.client.proposal.delete(n, Ge("USER_DISCONNECTED"));
              const o = He("session_connect", n);
              if (this.events.listenerCount(o) === 0)
                throw new Error(`emitting ${o} without any listeners, 954`);
              this.events.emit(o, { error: i.error });
            }
          }),
          W(this, "onSessionSettleRequest", async (r, i) => {
            const { id: s, params: n } = i;
            try {
              this.isValidSessionSettleRequest(n);
              const {
                  relay: o,
                  controller: a,
                  expiry: c,
                  namespaces: l,
                  sessionProperties: u,
                  scopedProperties: h,
                  sessionConfig: d,
                } = i.params,
                g = [...this.pendingSessions.values()].find(
                  (f) => f.sessionTopic === r
                );
              if (!g)
                return this.client.logger.error(
                  `Pending session not found for topic ${r}`
                );
              const p = this.client.proposal.get(g.proposalId),
                w = $r(
                  nt(
                    nt(
                      nt(
                        {
                          topic: r,
                          relay: o,
                          expiry: c,
                          namespaces: l,
                          acknowledged: !0,
                          pairingTopic: g.pairingTopic,
                          requiredNamespaces: p.requiredNamespaces,
                          optionalNamespaces: p.optionalNamespaces,
                          controller: a.publicKey,
                          self: {
                            publicKey: g.publicKey,
                            metadata: this.client.metadata,
                          },
                          peer: {
                            publicKey: a.publicKey,
                            metadata: a.metadata,
                          },
                        },
                        u && { sessionProperties: u }
                      ),
                      h && { scopedProperties: h }
                    ),
                    d && { sessionConfig: d }
                  ),
                  { transportType: gt.relay }
                );
              await this.client.session.set(w.topic, w),
                await this.setExpiry(w.topic, w.expiry),
                await this.client.core.pairing.updateMetadata({
                  topic: g.pairingTopic,
                  metadata: w.peer.metadata,
                }),
                this.client.events.emit("session_connect", { session: w }),
                this.events.emit(He("session_connect", g.proposalId), {
                  session: w,
                }),
                this.pendingSessions.delete(g.proposalId),
                this.deleteProposal(g.proposalId, !1),
                this.cleanupDuplicatePairings(w),
                await this.sendResult({
                  id: i.id,
                  topic: r,
                  result: !0,
                  throwOnFailedPublish: !0,
                });
            } catch (o) {
              await this.sendError({ id: s, topic: r, error: o }),
                this.client.logger.error(o);
            }
          }),
          W(this, "onSessionSettleResponse", async (r, i) => {
            const { id: s } = i;
            Bt(i)
              ? (await this.client.session.update(r, { acknowledged: !0 }),
                this.events.emit(He("session_approve", s), {}))
              : Ct(i) &&
                (await this.client.session.delete(r, Ge("USER_DISCONNECTED")),
                this.events.emit(He("session_approve", s), { error: i.error }));
          }),
          W(this, "onSessionUpdateRequest", async (r, i) => {
            const { params: s, id: n } = i;
            try {
              const o = `${r}_session_update`,
                a = Nu.get(o);
              if (a && this.isRequestOutOfSync(a, n)) {
                this.client.logger.warn(
                  `Discarding out of sync request - ${n}`
                ),
                  this.sendError({
                    id: n,
                    topic: r,
                    error: Ge("INVALID_UPDATE_REQUEST"),
                  });
                return;
              }
              this.isValidUpdate(nt({ topic: r }, s));
              try {
                Nu.set(o, n),
                  await this.client.session.update(r, {
                    namespaces: s.namespaces,
                  }),
                  await this.sendResult({
                    id: n,
                    topic: r,
                    result: !0,
                    throwOnFailedPublish: !0,
                  });
              } catch (c) {
                throw (Nu.delete(o), c);
              }
              this.client.events.emit("session_update", {
                id: n,
                topic: r,
                params: s,
              });
            } catch (o) {
              await this.sendError({ id: n, topic: r, error: o }),
                this.client.logger.error(o);
            }
          }),
          W(
            this,
            "isRequestOutOfSync",
            (r, i) => i.toString().slice(0, -3) < r.toString().slice(0, -3)
          ),
          W(this, "onSessionUpdateResponse", (r, i) => {
            const { id: s } = i,
              n = He("session_update", s);
            if (this.events.listenerCount(n) === 0)
              throw new Error(`emitting ${n} without any listeners`);
            Bt(i)
              ? this.events.emit(He("session_update", s), {})
              : Ct(i) &&
                this.events.emit(He("session_update", s), { error: i.error });
          }),
          W(this, "onSessionExtendRequest", async (r, i) => {
            const { id: s } = i;
            try {
              this.isValidExtend({ topic: r }),
                await this.setExpiry(r, Ft(Sc)),
                await this.sendResult({
                  id: s,
                  topic: r,
                  result: !0,
                  throwOnFailedPublish: !0,
                }),
                this.client.events.emit("session_extend", { id: s, topic: r });
            } catch (n) {
              await this.sendError({ id: s, topic: r, error: n }),
                this.client.logger.error(n);
            }
          }),
          W(this, "onSessionExtendResponse", (r, i) => {
            const { id: s } = i,
              n = He("session_extend", s);
            if (this.events.listenerCount(n) === 0)
              throw new Error(`emitting ${n} without any listeners`);
            Bt(i)
              ? this.events.emit(He("session_extend", s), {})
              : Ct(i) &&
                this.events.emit(He("session_extend", s), { error: i.error });
          }),
          W(this, "onSessionPingRequest", async (r, i) => {
            const { id: s } = i;
            try {
              this.isValidPing({ topic: r }),
                await this.sendResult({
                  id: s,
                  topic: r,
                  result: !0,
                  throwOnFailedPublish: !0,
                }),
                this.client.events.emit("session_ping", { id: s, topic: r });
            } catch (n) {
              await this.sendError({ id: s, topic: r, error: n }),
                this.client.logger.error(n);
            }
          }),
          W(this, "onSessionPingResponse", (r, i) => {
            const { id: s } = i,
              n = He("session_ping", s);
            setTimeout(() => {
              if (this.events.listenerCount(n) === 0)
                throw new Error(`emitting ${n} without any listeners 2176`);
              Bt(i)
                ? this.events.emit(He("session_ping", s), {})
                : Ct(i) &&
                  this.events.emit(He("session_ping", s), { error: i.error });
            }, 500);
          }),
          W(this, "onSessionDeleteRequest", async (r, i) => {
            const { id: s } = i;
            try {
              this.isValidDisconnect({ topic: r, reason: i.params }),
                Promise.all([
                  new Promise((n) => {
                    this.client.core.relayer.once(Jt.publish, async () => {
                      n(await this.deleteSession({ topic: r, id: s }));
                    });
                  }),
                  this.sendResult({
                    id: s,
                    topic: r,
                    result: !0,
                    throwOnFailedPublish: !0,
                  }),
                  this.cleanupPendingSentRequestsForTopic({
                    topic: r,
                    error: Ge("USER_DISCONNECTED"),
                  }),
                ]).catch((n) => this.client.logger.error(n));
            } catch (n) {
              this.client.logger.error(n);
            }
          }),
          W(this, "onSessionRequest", async (r) => {
            var i, s, n;
            const {
                topic: o,
                payload: a,
                attestation: c,
                encryptedId: l,
                transportType: u,
              } = r,
              { id: h, params: d } = a;
            try {
              await this.isValidRequest(nt({ topic: o }, d));
              const g = this.client.session.get(o),
                p = await this.getVerifyContext({
                  attestationId: c,
                  hash: Cs(JSON.stringify(kr("wc_sessionRequest", d, h))),
                  encryptedId: l,
                  metadata: g.peer.metadata,
                  transportType: u,
                }),
                w = { id: h, topic: o, params: d, verifyContext: p };
              await this.setPendingSessionRequest(w),
                u === gt.link_mode &&
                  (i = g.peer.metadata.redirect) != null &&
                  i.universal &&
                  this.client.core.addLinkModeSupportedApp(
                    (s = g.peer.metadata.redirect) == null
                      ? void 0
                      : s.universal
                  ),
                (n = this.client.signConfig) != null && n.disableRequestQueue
                  ? this.emitSessionRequest(w)
                  : (this.addSessionRequestToSessionRequestQueue(w),
                    this.processSessionRequestQueue());
            } catch (g) {
              await this.sendError({ id: h, topic: o, error: g }),
                this.client.logger.error(g);
            }
          }),
          W(this, "onSessionRequestResponse", (r, i) => {
            const { id: s } = i,
              n = He("session_request", s);
            if (this.events.listenerCount(n) === 0)
              throw new Error(`emitting ${n} without any listeners`);
            Bt(i)
              ? this.events.emit(He("session_request", s), { result: i.result })
              : Ct(i) &&
                this.events.emit(He("session_request", s), { error: i.error });
          }),
          W(this, "onSessionEventRequest", async (r, i) => {
            const { id: s, params: n } = i;
            try {
              const o = `${r}_session_event_${n.event.name}`,
                a = Nu.get(o);
              if (a && this.isRequestOutOfSync(a, s)) {
                this.client.logger.info(
                  `Discarding out of sync request - ${s}`
                );
                return;
              }
              this.isValidEmit(nt({ topic: r }, n)),
                this.client.events.emit("session_event", {
                  id: s,
                  topic: r,
                  params: n,
                }),
                Nu.set(o, s);
            } catch (o) {
              await this.sendError({ id: s, topic: r, error: o }),
                this.client.logger.error(o);
            }
          }),
          W(this, "onSessionAuthenticateResponse", (r, i) => {
            const { id: s } = i;
            this.client.logger.trace({
              type: "method",
              method: "onSessionAuthenticateResponse",
              topic: r,
              payload: i,
            }),
              Bt(i)
                ? this.events.emit(He("session_request", s), {
                    result: i.result,
                  })
                : Ct(i) &&
                  this.events.emit(He("session_request", s), {
                    error: i.error,
                  });
          }),
          W(this, "onSessionAuthenticateRequest", async (r) => {
            var i;
            const {
              topic: s,
              payload: n,
              attestation: o,
              encryptedId: a,
              transportType: c,
            } = r;
            try {
              const {
                  requester: l,
                  authPayload: u,
                  expiryTimestamp: h,
                } = n.params,
                d = await this.getVerifyContext({
                  attestationId: o,
                  hash: Cs(JSON.stringify(n)),
                  encryptedId: a,
                  metadata: l.metadata,
                  transportType: c,
                }),
                g = {
                  requester: l,
                  pairingTopic: s,
                  id: n.id,
                  authPayload: u,
                  verifyContext: d,
                  expiryTimestamp: h,
                };
              await this.setAuthRequest(n.id, {
                request: g,
                pairingTopic: s,
                transportType: c,
              }),
                c === gt.link_mode &&
                  (i = l.metadata.redirect) != null &&
                  i.universal &&
                  this.client.core.addLinkModeSupportedApp(
                    l.metadata.redirect.universal
                  ),
                this.client.events.emit("session_authenticate", {
                  topic: s,
                  params: n.params,
                  id: n.id,
                  verifyContext: d,
                });
            } catch (l) {
              this.client.logger.error(l);
              const u = n.params.requester.publicKey,
                h = await this.client.core.crypto.generateKeyPair(),
                d = this.getAppLinkIfEnabled(n.params.requester.metadata, c),
                g = { type: en, receiverPublicKey: u, senderPublicKey: h };
              await this.sendError({
                id: n.id,
                topic: s,
                error: l,
                encodeOpts: g,
                rpcOpts: Qt.wc_sessionAuthenticate.autoReject,
                appLink: d,
              });
            }
          }),
          W(this, "addSessionRequestToSessionRequestQueue", (r) => {
            this.sessionRequestQueue.queue.push(r);
          }),
          W(this, "cleanupAfterResponse", (r) => {
            this.deletePendingSessionRequest(r.response.id, {
              message: "fulfilled",
              code: 0,
            }),
              setTimeout(() => {
                (this.sessionRequestQueue.state = Ss.idle),
                  this.processSessionRequestQueue();
              }, z.toMiliseconds(this.requestQueueDelay));
          }),
          W(
            this,
            "cleanupPendingSentRequestsForTopic",
            ({ topic: r, error: i }) => {
              const s = this.client.core.history.pending;
              s.length > 0 &&
                s
                  .filter(
                    (n) =>
                      n.topic === r && n.request.method === "wc_sessionRequest"
                  )
                  .forEach((n) => {
                    const o = n.request.id,
                      a = He("session_request", o);
                    if (this.events.listenerCount(a) === 0)
                      throw new Error(`emitting ${a} without any listeners`);
                    this.events.emit(He("session_request", n.request.id), {
                      error: i,
                    });
                  });
            }
          ),
          W(this, "processSessionRequestQueue", () => {
            if (this.sessionRequestQueue.state === Ss.active) {
              this.client.logger.info(
                "session request queue is already active."
              );
              return;
            }
            const r = this.sessionRequestQueue.queue[0];
            if (!r) {
              this.client.logger.info("session request queue is empty.");
              return;
            }
            try {
              (this.sessionRequestQueue.state = Ss.active),
                this.emitSessionRequest(r);
            } catch (i) {
              this.client.logger.error(i);
            }
          }),
          W(this, "emitSessionRequest", (r) => {
            this.client.events.emit("session_request", r);
          }),
          W(this, "onPairingCreated", (r) => {
            if (
              (r.methods &&
                this.expectedPairingMethodMap.set(r.topic, r.methods),
              r.active)
            )
              return;
            const i = this.client.proposal
              .getAll()
              .find((s) => s.pairingTopic === r.topic);
            i &&
              this.onSessionProposeRequest({
                topic: r.topic,
                payload: kr(
                  "wc_sessionPropose",
                  $r(nt({}, i), {
                    requiredNamespaces: i.requiredNamespaces,
                    optionalNamespaces: i.optionalNamespaces,
                    relays: i.relays,
                    proposer: i.proposer,
                    sessionProperties: i.sessionProperties,
                    scopedProperties: i.scopedProperties,
                  }),
                  i.id
                ),
              });
          }),
          W(this, "isValidConnect", async (r) => {
            if (!Vr(r)) {
              const { message: l } = J(
                "MISSING_OR_INVALID",
                `connect() params: ${JSON.stringify(r)}`
              );
              throw new Error(l);
            }
            const {
              pairingTopic: i,
              requiredNamespaces: s,
              optionalNamespaces: n,
              sessionProperties: o,
              scopedProperties: a,
              relays: c,
            } = r;
            if ((hr(i) || (await this.isValidPairingTopic(i)), !GB(c, !0))) {
              const { message: l } = J(
                "MISSING_OR_INVALID",
                `connect() relays: ${c}`
              );
              throw new Error(l);
            }
            if (
              (!hr(s) &&
                Ou(s) !== 0 &&
                this.validateNamespaces(s, "requiredNamespaces"),
              !hr(n) &&
                Ou(n) !== 0 &&
                this.validateNamespaces(n, "optionalNamespaces"),
              hr(o) || this.validateSessionProps(o, "sessionProperties"),
              !hr(a))
            ) {
              this.validateSessionProps(a, "scopedProperties");
              const l = Object.keys(s || {}).concat(Object.keys(n || {}));
              if (!Object.keys(a).every((u) => l.includes(u)))
                throw new Error(
                  `Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(
                    a
                  )}, required/optional namespaces: ${JSON.stringify(l)}`
                );
            }
          }),
          W(this, "validateNamespaces", (r, i) => {
            const s = KB(r, "connect()", i);
            if (s) throw new Error(s.message);
          }),
          W(this, "isValidApprove", async (r) => {
            if (!Vr(r))
              throw new Error(
                J("MISSING_OR_INVALID", `approve() params: ${r}`).message
              );
            const {
              id: i,
              namespaces: s,
              relayProtocol: n,
              sessionProperties: o,
              scopedProperties: a,
            } = r;
            this.checkRecentlyDeleted(i), await this.isValidProposalId(i);
            const c = this.client.proposal.get(i),
              l = q1(s, "approve()");
            if (l) throw new Error(l.message);
            const u = D4(c.requiredNamespaces, s, "approve()");
            if (u) throw new Error(u.message);
            if (!Nt(n, !0)) {
              const { message: h } = J(
                "MISSING_OR_INVALID",
                `approve() relayProtocol: ${n}`
              );
              throw new Error(h);
            }
            if (
              (hr(o) || this.validateSessionProps(o, "sessionProperties"),
              !hr(a))
            ) {
              this.validateSessionProps(a, "scopedProperties");
              const h = new Set(Object.keys(s));
              if (!Object.keys(a).every((d) => h.has(d)))
                throw new Error(
                  `Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(
                    a
                  )}, approved namespaces: ${Array.from(h).join(", ")}`
                );
            }
          }),
          W(this, "isValidReject", async (r) => {
            if (!Vr(r)) {
              const { message: n } = J(
                "MISSING_OR_INVALID",
                `reject() params: ${r}`
              );
              throw new Error(n);
            }
            const { id: i, reason: s } = r;
            if (
              (this.checkRecentlyDeleted(i),
              await this.isValidProposalId(i),
              !YB(s))
            ) {
              const { message: n } = J(
                "MISSING_OR_INVALID",
                `reject() reason: ${JSON.stringify(s)}`
              );
              throw new Error(n);
            }
          }),
          W(this, "isValidSessionSettleRequest", (r) => {
            if (!Vr(r)) {
              const { message: l } = J(
                "MISSING_OR_INVALID",
                `onSessionSettleRequest() params: ${r}`
              );
              throw new Error(l);
            }
            const { relay: i, controller: s, namespaces: n, expiry: o } = r;
            if (!L4(i)) {
              const { message: l } = J(
                "MISSING_OR_INVALID",
                "onSessionSettleRequest() relay protocol should be a string"
              );
              throw new Error(l);
            }
            const a = MB(s, "onSessionSettleRequest()");
            if (a) throw new Error(a.message);
            const c = q1(n, "onSessionSettleRequest()");
            if (c) throw new Error(c.message);
            if (Wn(o)) {
              const { message: l } = J("EXPIRED", "onSessionSettleRequest()");
              throw new Error(l);
            }
          }),
          W(this, "isValidUpdate", async (r) => {
            if (!Vr(r)) {
              const { message: c } = J(
                "MISSING_OR_INVALID",
                `update() params: ${r}`
              );
              throw new Error(c);
            }
            const { topic: i, namespaces: s } = r;
            this.checkRecentlyDeleted(i), await this.isValidSessionTopic(i);
            const n = this.client.session.get(i),
              o = q1(s, "update()");
            if (o) throw new Error(o.message);
            const a = D4(n.requiredNamespaces, s, "update()");
            if (a) throw new Error(a.message);
          }),
          W(this, "isValidExtend", async (r) => {
            if (!Vr(r)) {
              const { message: s } = J(
                "MISSING_OR_INVALID",
                `extend() params: ${r}`
              );
              throw new Error(s);
            }
            const { topic: i } = r;
            this.checkRecentlyDeleted(i), await this.isValidSessionTopic(i);
          }),
          W(this, "isValidRequest", async (r) => {
            if (!Vr(r)) {
              const { message: c } = J(
                "MISSING_OR_INVALID",
                `request() params: ${r}`
              );
              throw new Error(c);
            }
            const { topic: i, request: s, chainId: n, expiry: o } = r;
            this.checkRecentlyDeleted(i), await this.isValidSessionTopic(i);
            const { namespaces: a } = this.client.session.get(i);
            if (!U4(a, n)) {
              const { message: c } = J(
                "MISSING_OR_INVALID",
                `request() chainId: ${n}`
              );
              throw new Error(c);
            }
            if (!JB(s)) {
              const { message: c } = J(
                "MISSING_OR_INVALID",
                `request() ${JSON.stringify(s)}`
              );
              throw new Error(c);
            }
            if (!eL(a, n, s.method)) {
              const { message: c } = J(
                "MISSING_OR_INVALID",
                `request() method: ${s.method}`
              );
              throw new Error(c);
            }
            if (o && !sL(o, bw)) {
              const { message: c } = J(
                "MISSING_OR_INVALID",
                `request() expiry: ${o}. Expiry must be a number (in seconds) between ${bw.min} and ${bw.max}`
              );
              throw new Error(c);
            }
          }),
          W(this, "isValidRespond", async (r) => {
            var i;
            if (!Vr(r)) {
              const { message: o } = J(
                "MISSING_OR_INVALID",
                `respond() params: ${r}`
              );
              throw new Error(o);
            }
            const { topic: s, response: n } = r;
            try {
              await this.isValidSessionTopic(s);
            } catch (o) {
              throw (
                ((i = r?.response) != null &&
                  i.id &&
                  this.cleanupAfterResponse(r),
                o)
              );
            }
            if (!XB(n)) {
              const { message: o } = J(
                "MISSING_OR_INVALID",
                `respond() response: ${JSON.stringify(n)}`
              );
              throw new Error(o);
            }
          }),
          W(this, "isValidPing", async (r) => {
            if (!Vr(r)) {
              const { message: s } = J(
                "MISSING_OR_INVALID",
                `ping() params: ${r}`
              );
              throw new Error(s);
            }
            const { topic: i } = r;
            await this.isValidSessionOrPairingTopic(i);
          }),
          W(this, "isValidEmit", async (r) => {
            if (!Vr(r)) {
              const { message: a } = J(
                "MISSING_OR_INVALID",
                `emit() params: ${r}`
              );
              throw new Error(a);
            }
            const { topic: i, event: s, chainId: n } = r;
            await this.isValidSessionTopic(i);
            const { namespaces: o } = this.client.session.get(i);
            if (!U4(o, n)) {
              const { message: a } = J(
                "MISSING_OR_INVALID",
                `emit() chainId: ${n}`
              );
              throw new Error(a);
            }
            if (!QB(s)) {
              const { message: a } = J(
                "MISSING_OR_INVALID",
                `emit() event: ${JSON.stringify(s)}`
              );
              throw new Error(a);
            }
            if (!tL(o, n, s.name)) {
              const { message: a } = J(
                "MISSING_OR_INVALID",
                `emit() event: ${JSON.stringify(s)}`
              );
              throw new Error(a);
            }
          }),
          W(this, "isValidDisconnect", async (r) => {
            if (!Vr(r)) {
              const { message: s } = J(
                "MISSING_OR_INVALID",
                `disconnect() params: ${r}`
              );
              throw new Error(s);
            }
            const { topic: i } = r;
            await this.isValidSessionOrPairingTopic(i);
          }),
          W(this, "isValidAuthenticate", (r) => {
            const { chains: i, uri: s, domain: n, nonce: o } = r;
            if (!Array.isArray(i) || i.length === 0)
              throw new Error(
                "chains is required and must be a non-empty array"
              );
            if (!Nt(s, !1)) throw new Error("uri is required parameter");
            if (!Nt(n, !1)) throw new Error("domain is required parameter");
            if (!Nt(o, !1)) throw new Error("nonce is required parameter");
            if ([...new Set(i.map((c) => ac(c).namespace))].length > 1)
              throw new Error(
                "Multi-namespace requests are not supported. Please request single namespace only."
              );
            const { namespace: a } = ac(i[0]);
            if (a !== "eip155")
              throw new Error(
                "Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains."
              );
          }),
          W(this, "getVerifyContext", async (r) => {
            const {
                attestationId: i,
                hash: s,
                encryptedId: n,
                metadata: o,
                transportType: a,
              } = r,
              c = {
                verified: {
                  verifyUrl: o.verifyUrl || Uu,
                  validation: "UNKNOWN",
                  origin: o.url || "",
                },
              };
            try {
              if (a === gt.link_mode) {
                const u = this.getAppLinkIfEnabled(o, a);
                return (
                  (c.verified.validation =
                    u && new URL(u).origin === new URL(o.url).origin
                      ? "VALID"
                      : "INVALID"),
                  c
                );
              }
              const l = await this.client.core.verify.resolve({
                attestationId: i,
                hash: s,
                encryptedId: n,
                verifyUrl: o.verifyUrl,
              });
              l &&
                ((c.verified.origin = l.origin),
                (c.verified.isScam = l.isScam),
                (c.verified.validation =
                  l.origin === new URL(o.url).origin ? "VALID" : "INVALID"));
            } catch (l) {
              this.client.logger.warn(l);
            }
            return (
              this.client.logger.debug(`Verify context: ${JSON.stringify(c)}`),
              c
            );
          }),
          W(this, "validateSessionProps", (r, i) => {
            Object.values(r).forEach((s, n) => {
              if (s == null) {
                const { message: o } = J(
                  "MISSING_OR_INVALID",
                  `${i} must contain an existing value for each key. Received: ${s} for key ${
                    Object.keys(r)[n]
                  }`
                );
                throw new Error(o);
              }
            });
          }),
          W(this, "getPendingAuthRequest", (r) => {
            const i = this.client.auth.requests.get(r);
            return typeof i == "object" ? i : void 0;
          }),
          W(this, "addToRecentlyDeleted", (r, i) => {
            if (
              (this.recentlyDeletedMap.set(r, i),
              this.recentlyDeletedMap.size >= this.recentlyDeletedLimit)
            ) {
              let s = 0;
              const n = this.recentlyDeletedLimit / 2;
              for (const o of this.recentlyDeletedMap.keys()) {
                if (s++ >= n) break;
                this.recentlyDeletedMap.delete(o);
              }
            }
          }),
          W(this, "checkRecentlyDeleted", (r) => {
            const i = this.recentlyDeletedMap.get(r);
            if (i) {
              const { message: s } = J(
                "MISSING_OR_INVALID",
                `Record was recently deleted - ${i}: ${r}`
              );
              throw new Error(s);
            }
          }),
          W(this, "isLinkModeEnabled", (r, i) => {
            var s, n, o, a, c, l, u, h, d;
            return !r || i !== gt.link_mode
              ? !1
              : ((n =
                  (s = this.client.metadata) == null ? void 0 : s.redirect) ==
                null
                  ? void 0
                  : n.linkMode) === !0 &&
                  ((a =
                    (o = this.client.metadata) == null ? void 0 : o.redirect) ==
                  null
                    ? void 0
                    : a.universal) !== void 0 &&
                  ((l =
                    (c = this.client.metadata) == null ? void 0 : c.redirect) ==
                  null
                    ? void 0
                    : l.universal) !== "" &&
                  ((u = r?.redirect) == null ? void 0 : u.universal) !==
                    void 0 &&
                  ((h = r?.redirect) == null ? void 0 : h.universal) !== "" &&
                  ((d = r?.redirect) == null ? void 0 : d.linkMode) === !0 &&
                  this.client.core.linkModeSupportedApps.includes(
                    r.redirect.universal
                  ) &&
                  typeof globalThis?.Linking < "u";
          }),
          W(this, "getAppLinkIfEnabled", (r, i) => {
            var s;
            return this.isLinkModeEnabled(r, i)
              ? (s = r?.redirect) == null
                ? void 0
                : s.universal
              : void 0;
          }),
          W(this, "handleLinkModeMessage", ({ url: r }) => {
            if (!r || !r.includes("wc_ev") || !r.includes("topic")) return;
            const i = x5(r, "topic") || "",
              s = decodeURIComponent(x5(r, "wc_ev") || ""),
              n = this.client.session.keys.includes(i);
            n && this.client.session.update(i, { transportType: gt.link_mode }),
              this.client.core.dispatchEnvelope({
                topic: i,
                message: s,
                sessionExists: n,
              });
          }),
          W(this, "registerLinkModeListeners", async () => {
            var r;
            if (
              p1() ||
              (Hn() &&
                (r = this.client.metadata.redirect) != null &&
                r.linkMode)
            ) {
              const i = globalThis?.Linking;
              if (typeof i < "u") {
                i.addEventListener(
                  "url",
                  this.handleLinkModeMessage,
                  this.client.name
                );
                const s = await i.getInitialURL();
                s &&
                  setTimeout(() => {
                    this.handleLinkModeMessage({ url: s });
                  }, 50);
              }
            }
          }),
          W(this, "shouldSetTVF", (r, i) => {
            if (!i || r !== "wc_sessionRequest") return !1;
            const { request: s } = i;
            return Object.keys(h8).includes(s.method);
          }),
          W(this, "getTVFParams", (r, i, s) => {
            var n, o;
            try {
              const a = i.request.method,
                c = this.extractTxHashesFromResult(a, s);
              return $r(
                nt(
                  { correlationId: r, rpcMethods: [a], chainId: i.chainId },
                  this.isValidContractData(i.request.params) && {
                    contractAddresses: [
                      (o = (n = i.request.params) == null ? void 0 : n[0]) ==
                      null
                        ? void 0
                        : o.to,
                    ],
                  }
                ),
                { txHashes: c }
              );
            } catch (a) {
              this.client.logger.warn("Error getting TVF params", a);
            }
            return {};
          }),
          W(this, "isValidContractData", (r) => {
            var i;
            if (!r) return !1;
            try {
              const s = r?.data || ((i = r?.[0]) == null ? void 0 : i.data);
              if (!s.startsWith("0x")) return !1;
              const n = s.slice(2);
              return /^[0-9a-fA-F]*$/.test(n) ? n.length % 2 === 0 : !1;
            } catch {}
            return !1;
          }),
          W(this, "extractTxHashesFromResult", (r, i) => {
            try {
              const s = h8[r];
              if (typeof i == "string") return [i];
              const n = i[s.key];
              if (Qi(n))
                return r === "solana_signAllTransactions"
                  ? n.map((o) => R$(o))
                  : n;
              if (typeof n == "string") return [n];
            } catch (s) {
              this.client.logger.warn(
                "Error extracting tx hashes from result",
                s
              );
            }
            return [];
          });
      }
      async processPendingMessageEvents() {
        try {
          const e = this.client.session.keys,
            r = this.client.core.relayer.messages.getWithoutAck(e);
          for (const [i, s] of Object.entries(r))
            for (const n of s)
              try {
                await this.onProviderMessageEvent({
                  topic: i,
                  message: n,
                  publishedAt: Date.now(),
                });
              } catch {
                this.client.logger.warn(
                  `Error processing pending message event for topic: ${i}, message: ${n}`
                );
              }
        } catch (e) {
          this.client.logger.warn("processPendingMessageEvents failed", e);
        }
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e } = J("NOT_INITIALIZED", this.name);
          throw new Error(e);
        }
      }
      async confirmOnlineStateOrThrow() {
        await this.client.core.relayer.confirmOnlineStateOrThrow();
      }
      registerRelayerEvents() {
        this.client.core.relayer.on(Jt.message, (e) => {
          this.onProviderMessageEvent(e);
        });
      }
      async onRelayMessage(e) {
        const { topic: r, message: i, attestation: s, transportType: n } = e,
          { publicKey: o } = this.client.auth.authKeys.keys.includes(Vp)
            ? this.client.auth.authKeys.get(Vp)
            : { responseTopic: void 0, publicKey: void 0 };
        try {
          const a = await this.client.core.crypto.decode(r, i, {
            receiverPublicKey: o,
            encoding: n === gt.link_mode ? Yn : Xi,
          });
          _c(a)
            ? (this.client.core.history.set(r, a),
              await this.onRelayEventRequest({
                topic: r,
                payload: a,
                attestation: s,
                transportType: n,
                encryptedId: Cs(i),
              }))
            : qo(a)
            ? (await this.client.core.history.resolve(a),
              await this.onRelayEventResponse({
                topic: r,
                payload: a,
                transportType: n,
              }),
              this.client.core.history.delete(r, a.id))
            : await this.onRelayEventUnknownPayload({
                topic: r,
                payload: a,
                transportType: n,
              }),
            await this.client.core.relayer.messages.ack(r, i);
        } catch (a) {
          this.client.logger.error(a);
        }
      }
      registerExpirerEvents() {
        this.client.core.expirer.on(Ri.expired, async (e) => {
          const { topic: r, id: i } = C5(e.target);
          if (i && this.client.pendingRequest.keys.includes(i))
            return await this.deletePendingSessionRequest(i, J("EXPIRED"), !0);
          if (i && this.client.auth.requests.keys.includes(i))
            return await this.deletePendingAuthRequest(i, J("EXPIRED"), !0);
          r
            ? this.client.session.keys.includes(r) &&
              (await this.deleteSession({ topic: r, expirerHasDeleted: !0 }),
              this.client.events.emit("session_expire", { topic: r }))
            : i &&
              (await this.deleteProposal(i, !0),
              this.client.events.emit("proposal_expire", { id: i }));
        });
      }
      registerPairingEvents() {
        this.client.core.pairing.events.on(Ho.create, (e) =>
          this.onPairingCreated(e)
        ),
          this.client.core.pairing.events.on(Ho.delete, (e) => {
            this.addToRecentlyDeleted(e.topic, "pairing");
          });
      }
      isValidPairingTopic(e) {
        if (!Nt(e, !1)) {
          const { message: r } = J(
            "MISSING_OR_INVALID",
            `pairing topic should be a string: ${e}`
          );
          throw new Error(r);
        }
        if (!this.client.core.pairing.pairings.keys.includes(e)) {
          const { message: r } = J(
            "NO_MATCHING_KEY",
            `pairing topic doesn't exist: ${e}`
          );
          throw new Error(r);
        }
        if (Wn(this.client.core.pairing.pairings.get(e).expiry)) {
          const { message: r } = J("EXPIRED", `pairing topic: ${e}`);
          throw new Error(r);
        }
      }
      async isValidSessionTopic(e) {
        if (!Nt(e, !1)) {
          const { message: r } = J(
            "MISSING_OR_INVALID",
            `session topic should be a string: ${e}`
          );
          throw new Error(r);
        }
        if (
          (this.checkRecentlyDeleted(e), !this.client.session.keys.includes(e))
        ) {
          const { message: r } = J(
            "NO_MATCHING_KEY",
            `session topic doesn't exist: ${e}`
          );
          throw new Error(r);
        }
        if (Wn(this.client.session.get(e).expiry)) {
          await this.deleteSession({ topic: e });
          const { message: r } = J("EXPIRED", `session topic: ${e}`);
          throw new Error(r);
        }
        if (!this.client.core.crypto.keychain.has(e)) {
          const { message: r } = J(
            "MISSING_OR_INVALID",
            `session topic does not exist in keychain: ${e}`
          );
          throw (await this.deleteSession({ topic: e }), new Error(r));
        }
      }
      async isValidSessionOrPairingTopic(e) {
        if (
          (this.checkRecentlyDeleted(e), this.client.session.keys.includes(e))
        )
          await this.isValidSessionTopic(e);
        else if (this.client.core.pairing.pairings.keys.includes(e))
          this.isValidPairingTopic(e);
        else if (Nt(e, !1)) {
          const { message: r } = J(
            "NO_MATCHING_KEY",
            `session or pairing topic doesn't exist: ${e}`
          );
          throw new Error(r);
        } else {
          const { message: r } = J(
            "MISSING_OR_INVALID",
            `session or pairing topic should be a string: ${e}`
          );
          throw new Error(r);
        }
      }
      async isValidProposalId(e) {
        if (!ZB(e)) {
          const { message: r } = J(
            "MISSING_OR_INVALID",
            `proposal id should be a number: ${e}`
          );
          throw new Error(r);
        }
        if (!this.client.proposal.keys.includes(e)) {
          const { message: r } = J(
            "NO_MATCHING_KEY",
            `proposal id doesn't exist: ${e}`
          );
          throw new Error(r);
        }
        if (Wn(this.client.proposal.get(e).expiryTimestamp)) {
          await this.deleteProposal(e);
          const { message: r } = J("EXPIRED", `proposal id: ${e}`);
          throw new Error(r);
        }
      }
    }
    class _q extends Ko {
      constructor(e, r) {
        super(e, r, lq, mw), (this.core = e), (this.logger = r);
      }
    }
    class Aq extends Ko {
      constructor(e, r) {
        super(e, r, uq, mw), (this.core = e), (this.logger = r);
      }
    }
    class Sq extends Ko {
      constructor(e, r) {
        super(e, r, dq, mw, (i) => i.id), (this.core = e), (this.logger = r);
      }
    }
    class Pq extends Ko {
      constructor(e, r) {
        super(e, r, wq, Hp, () => Vp), (this.core = e), (this.logger = r);
      }
    }
    class Oq extends Ko {
      constructor(e, r) {
        super(e, r, mq, Hp), (this.core = e), (this.logger = r);
      }
    }
    class Nq extends Ko {
      constructor(e, r) {
        super(e, r, yq, Hp, (i) => i.id), (this.core = e), (this.logger = r);
      }
    }
    var Tq = Object.defineProperty,
      kq = (t, e, r) =>
        e in t
          ? Tq(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Ew = (t, e, r) => kq(t, typeof e != "symbol" ? e + "" : e, r);
    class Rq {
      constructor(e, r) {
        (this.core = e),
          (this.logger = r),
          Ew(this, "authKeys"),
          Ew(this, "pairingTopics"),
          Ew(this, "requests"),
          (this.authKeys = new Pq(this.core, this.logger)),
          (this.pairingTopics = new Oq(this.core, this.logger)),
          (this.requests = new Nq(this.core, this.logger));
      }
      async init() {
        await this.authKeys.init(),
          await this.pairingTopics.init(),
          await this.requests.init();
      }
    }
    var $q = Object.defineProperty,
      Fq = (t, e, r) =>
        e in t
          ? $q(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Oe = (t, e, r) => Fq(t, typeof e != "symbol" ? e + "" : e, r);
    class Cw extends LU {
      constructor(e) {
        super(e),
          Oe(this, "protocol", o8),
          Oe(this, "version", a8),
          Oe(this, "name", yw.name),
          Oe(this, "metadata"),
          Oe(this, "core"),
          Oe(this, "logger"),
          Oe(this, "events", new rt.exports.EventEmitter()),
          Oe(this, "engine"),
          Oe(this, "session"),
          Oe(this, "proposal"),
          Oe(this, "pendingRequest"),
          Oe(this, "auth"),
          Oe(this, "signConfig"),
          Oe(this, "on", (i, s) => this.events.on(i, s)),
          Oe(this, "once", (i, s) => this.events.once(i, s)),
          Oe(this, "off", (i, s) => this.events.off(i, s)),
          Oe(this, "removeListener", (i, s) =>
            this.events.removeListener(i, s)
          ),
          Oe(this, "removeAllListeners", (i) =>
            this.events.removeAllListeners(i)
          ),
          Oe(this, "connect", async (i) => {
            try {
              return await this.engine.connect(i);
            } catch (s) {
              throw (this.logger.error(s.message), s);
            }
          }),
          Oe(this, "pair", async (i) => {
            try {
              return await this.engine.pair(i);
            } catch (s) {
              throw (this.logger.error(s.message), s);
            }
          }),
          Oe(this, "approve", async (i) => {
            try {
              return await this.engine.approve(i);
            } catch (s) {
              throw (this.logger.error(s.message), s);
            }
          }),
          Oe(this, "reject", async (i) => {
            try {
              return await this.engine.reject(i);
            } catch (s) {
              throw (this.logger.error(s.message), s);
            }
          }),
          Oe(this, "update", async (i) => {
            try {
              return await this.engine.update(i);
            } catch (s) {
              throw (this.logger.error(s.message), s);
            }
          }),
          Oe(this, "extend", async (i) => {
            try {
              return await this.engine.extend(i);
            } catch (s) {
              throw (this.logger.error(s.message), s);
            }
          }),
          Oe(this, "request", async (i) => {
            try {
              return await this.engine.request(i);
            } catch (s) {
              throw (this.logger.error(s.message), s);
            }
          }),
          Oe(this, "respond", async (i) => {
            try {
              return await this.engine.respond(i);
            } catch (s) {
              throw (this.logger.error(s.message), s);
            }
          }),
          Oe(this, "ping", async (i) => {
            try {
              return await this.engine.ping(i);
            } catch (s) {
              throw (this.logger.error(s.message), s);
            }
          }),
          Oe(this, "emit", async (i) => {
            try {
              return await this.engine.emit(i);
            } catch (s) {
              throw (this.logger.error(s.message), s);
            }
          }),
          Oe(this, "disconnect", async (i) => {
            try {
              return await this.engine.disconnect(i);
            } catch (s) {
              throw (this.logger.error(s.message), s);
            }
          }),
          Oe(this, "find", (i) => {
            try {
              return this.engine.find(i);
            } catch (s) {
              throw (this.logger.error(s.message), s);
            }
          }),
          Oe(this, "getPendingSessionRequests", () => {
            try {
              return this.engine.getPendingSessionRequests();
            } catch (i) {
              throw (this.logger.error(i.message), i);
            }
          }),
          Oe(this, "authenticate", async (i, s) => {
            try {
              return await this.engine.authenticate(i, s);
            } catch (n) {
              throw (this.logger.error(n.message), n);
            }
          }),
          Oe(this, "formatAuthMessage", (i) => {
            try {
              return this.engine.formatAuthMessage(i);
            } catch (s) {
              throw (this.logger.error(s.message), s);
            }
          }),
          Oe(this, "approveSessionAuthenticate", async (i) => {
            try {
              return await this.engine.approveSessionAuthenticate(i);
            } catch (s) {
              throw (this.logger.error(s.message), s);
            }
          }),
          Oe(this, "rejectSessionAuthenticate", async (i) => {
            try {
              return await this.engine.rejectSessionAuthenticate(i);
            } catch (s) {
              throw (this.logger.error(s.message), s);
            }
          }),
          (this.name = e?.name || yw.name),
          (this.metadata = KR(e?.metadata)),
          (this.signConfig = e?.signConfig);
        const r =
          typeof e?.logger < "u" && typeof e?.logger != "string"
            ? e.logger
            : li(tn({ level: e?.logger || yw.logger }));
        (this.core = e?.core || new cq(e)),
          (this.logger = Ve(r, this.name)),
          (this.session = new Aq(this.core, this.logger)),
          (this.proposal = new _q(this.core, this.logger)),
          (this.pendingRequest = new Sq(this.core, this.logger)),
          (this.engine = new Iq(this)),
          (this.auth = new Rq(this.core, this.logger));
      }
      static async init(e) {
        const r = new Cw(e);
        return await r.initialize(), r;
      }
      get context() {
        return it(this.logger);
      }
      get pairing() {
        return this.core.pairing.pairings;
      }
      async initialize() {
        this.logger.trace("Initialized");
        try {
          await this.core.start(),
            await this.session.init(),
            await this.proposal.init(),
            await this.pendingRequest.init(),
            await this.auth.init(),
            await this.engine.init(),
            this.logger.info("SignClient Initialization Success"),
            setTimeout(() => {
              this.engine.processRelayMessageCache();
            }, z.toMiliseconds(z.ONE_SECOND));
        } catch (e) {
          throw (
            (this.logger.info("SignClient Initialization Failure"),
            this.logger.error(e.message),
            e)
          );
        }
      }
    }
    var xw = { exports: {} };
    (function (t, e) {
      var r =
          (typeof globalThis < "u" && globalThis) ||
          (typeof self < "u" && self) ||
          (typeof qt < "u" && qt),
        i = (function () {
          function n() {
            (this.fetch = !1), (this.DOMException = r.DOMException);
          }
          return (n.prototype = r), new n();
        })();
      (function (n) {
        (function (o) {
          var a =
              (typeof n < "u" && n) ||
              (typeof self < "u" && self) ||
              (typeof qt < "u" && qt) ||
              {},
            c = {
              searchParams: "URLSearchParams" in a,
              iterable: "Symbol" in a && "iterator" in Symbol,
              blob:
                "FileReader" in a &&
                "Blob" in a &&
                (function () {
                  try {
                    return new Blob(), !0;
                  } catch {
                    return !1;
                  }
                })(),
              formData: "FormData" in a,
              arrayBuffer: "ArrayBuffer" in a,
            };
          function l(b) {
            return b && DataView.prototype.isPrototypeOf(b);
          }
          if (c.arrayBuffer)
            var u = [
                "[object Int8Array]",
                "[object Uint8Array]",
                "[object Uint8ClampedArray]",
                "[object Int16Array]",
                "[object Uint16Array]",
                "[object Int32Array]",
                "[object Uint32Array]",
                "[object Float32Array]",
                "[object Float64Array]",
              ],
              h =
                ArrayBuffer.isView ||
                function (b) {
                  return b && u.indexOf(Object.prototype.toString.call(b)) > -1;
                };
          function d(b) {
            if (
              (typeof b != "string" && (b = String(b)),
              /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(b) || b === "")
            )
              throw new TypeError(
                'Invalid character in header field name: "' + b + '"'
              );
            return b.toLowerCase();
          }
          function g(b) {
            return typeof b != "string" && (b = String(b)), b;
          }
          function p(b) {
            var v = {
              next: function () {
                var S = b.shift();
                return { done: S === void 0, value: S };
              },
            };
            return (
              c.iterable &&
                (v[Symbol.iterator] = function () {
                  return v;
                }),
              v
            );
          }
          function w(b) {
            (this.map = {}),
              b instanceof w
                ? b.forEach(function (v, S) {
                    this.append(S, v);
                  }, this)
                : Array.isArray(b)
                ? b.forEach(function (v) {
                    if (v.length != 2)
                      throw new TypeError(
                        "Headers constructor: expected name/value pair to be length 2, found" +
                          v.length
                      );
                    this.append(v[0], v[1]);
                  }, this)
                : b &&
                  Object.getOwnPropertyNames(b).forEach(function (v) {
                    this.append(v, b[v]);
                  }, this);
          }
          (w.prototype.append = function (b, v) {
            (b = d(b)), (v = g(v));
            var S = this.map[b];
            this.map[b] = S ? S + ", " + v : v;
          }),
            (w.prototype.delete = function (b) {
              delete this.map[d(b)];
            }),
            (w.prototype.get = function (b) {
              return (b = d(b)), this.has(b) ? this.map[b] : null;
            }),
            (w.prototype.has = function (b) {
              return this.map.hasOwnProperty(d(b));
            }),
            (w.prototype.set = function (b, v) {
              this.map[d(b)] = g(v);
            }),
            (w.prototype.forEach = function (b, v) {
              for (var S in this.map)
                this.map.hasOwnProperty(S) && b.call(v, this.map[S], S, this);
            }),
            (w.prototype.keys = function () {
              var b = [];
              return (
                this.forEach(function (v, S) {
                  b.push(S);
                }),
                p(b)
              );
            }),
            (w.prototype.values = function () {
              var b = [];
              return (
                this.forEach(function (v) {
                  b.push(v);
                }),
                p(b)
              );
            }),
            (w.prototype.entries = function () {
              var b = [];
              return (
                this.forEach(function (v, S) {
                  b.push([S, v]);
                }),
                p(b)
              );
            }),
            c.iterable && (w.prototype[Symbol.iterator] = w.prototype.entries);
          function f(b) {
            if (!b._noBody) {
              if (b.bodyUsed)
                return Promise.reject(new TypeError("Already read"));
              b.bodyUsed = !0;
            }
          }
          function m(b) {
            return new Promise(function (v, S) {
              (b.onload = function () {
                v(b.result);
              }),
                (b.onerror = function () {
                  S(b.error);
                });
            });
          }
          function y(b) {
            var v = new FileReader(),
              S = m(v);
            return v.readAsArrayBuffer(b), S;
          }
          function E(b) {
            var v = new FileReader(),
              S = m(v),
              T = /charset=([A-Za-z0-9_-]+)/.exec(b.type),
              _ = T ? T[1] : "utf-8";
            return v.readAsText(b, _), S;
          }
          function C(b) {
            for (
              var v = new Uint8Array(b), S = new Array(v.length), T = 0;
              T < v.length;
              T++
            )
              S[T] = String.fromCharCode(v[T]);
            return S.join("");
          }
          function O(b) {
            if (b.slice) return b.slice(0);
            var v = new Uint8Array(b.byteLength);
            return v.set(new Uint8Array(b)), v.buffer;
          }
          function A() {
            return (
              (this.bodyUsed = !1),
              (this._initBody = function (b) {
                (this.bodyUsed = this.bodyUsed),
                  (this._bodyInit = b),
                  b
                    ? typeof b == "string"
                      ? (this._bodyText = b)
                      : c.blob && Blob.prototype.isPrototypeOf(b)
                      ? (this._bodyBlob = b)
                      : c.formData && FormData.prototype.isPrototypeOf(b)
                      ? (this._bodyFormData = b)
                      : c.searchParams &&
                        URLSearchParams.prototype.isPrototypeOf(b)
                      ? (this._bodyText = b.toString())
                      : c.arrayBuffer && c.blob && l(b)
                      ? ((this._bodyArrayBuffer = O(b.buffer)),
                        (this._bodyInit = new Blob([this._bodyArrayBuffer])))
                      : c.arrayBuffer &&
                        (ArrayBuffer.prototype.isPrototypeOf(b) || h(b))
                      ? (this._bodyArrayBuffer = O(b))
                      : (this._bodyText = b = Object.prototype.toString.call(b))
                    : ((this._noBody = !0), (this._bodyText = "")),
                  this.headers.get("content-type") ||
                    (typeof b == "string"
                      ? this.headers.set(
                          "content-type",
                          "text/plain;charset=UTF-8"
                        )
                      : this._bodyBlob && this._bodyBlob.type
                      ? this.headers.set("content-type", this._bodyBlob.type)
                      : c.searchParams &&
                        URLSearchParams.prototype.isPrototypeOf(b) &&
                        this.headers.set(
                          "content-type",
                          "application/x-www-form-urlencoded;charset=UTF-8"
                        ));
              }),
              c.blob &&
                (this.blob = function () {
                  var b = f(this);
                  if (b) return b;
                  if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                  if (this._bodyArrayBuffer)
                    return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                  if (this._bodyFormData)
                    throw new Error("could not read FormData body as blob");
                  return Promise.resolve(new Blob([this._bodyText]));
                }),
              (this.arrayBuffer = function () {
                if (this._bodyArrayBuffer) {
                  var b = f(this);
                  return (
                    b ||
                    (ArrayBuffer.isView(this._bodyArrayBuffer)
                      ? Promise.resolve(
                          this._bodyArrayBuffer.buffer.slice(
                            this._bodyArrayBuffer.byteOffset,
                            this._bodyArrayBuffer.byteOffset +
                              this._bodyArrayBuffer.byteLength
                          )
                        )
                      : Promise.resolve(this._bodyArrayBuffer))
                  );
                } else {
                  if (c.blob) return this.blob().then(y);
                  throw new Error("could not read as ArrayBuffer");
                }
              }),
              (this.text = function () {
                var b = f(this);
                if (b) return b;
                if (this._bodyBlob) return E(this._bodyBlob);
                if (this._bodyArrayBuffer)
                  return Promise.resolve(C(this._bodyArrayBuffer));
                if (this._bodyFormData)
                  throw new Error("could not read FormData body as text");
                return Promise.resolve(this._bodyText);
              }),
              c.formData &&
                (this.formData = function () {
                  return this.text().then($);
                }),
              (this.json = function () {
                return this.text().then(JSON.parse);
              }),
              this
            );
          }
          var P = [
            "CONNECT",
            "DELETE",
            "GET",
            "HEAD",
            "OPTIONS",
            "PATCH",
            "POST",
            "PUT",
            "TRACE",
          ];
          function N(b) {
            var v = b.toUpperCase();
            return P.indexOf(v) > -1 ? v : b;
          }
          function x(b, v) {
            if (!(this instanceof x))
              throw new TypeError(
                'Please use the "new" operator, this DOM object constructor cannot be called as a function.'
              );
            v = v || {};
            var S = v.body;
            if (b instanceof x) {
              if (b.bodyUsed) throw new TypeError("Already read");
              (this.url = b.url),
                (this.credentials = b.credentials),
                v.headers || (this.headers = new w(b.headers)),
                (this.method = b.method),
                (this.mode = b.mode),
                (this.signal = b.signal),
                !S &&
                  b._bodyInit != null &&
                  ((S = b._bodyInit), (b.bodyUsed = !0));
            } else this.url = String(b);
            if (
              ((this.credentials =
                v.credentials || this.credentials || "same-origin"),
              (v.headers || !this.headers) && (this.headers = new w(v.headers)),
              (this.method = N(v.method || this.method || "GET")),
              (this.mode = v.mode || this.mode || null),
              (this.signal =
                v.signal ||
                this.signal ||
                (function () {
                  if ("AbortController" in a) {
                    var R = new AbortController();
                    return R.signal;
                  }
                })()),
              (this.referrer = null),
              (this.method === "GET" || this.method === "HEAD") && S)
            )
              throw new TypeError("Body not allowed for GET or HEAD requests");
            if (
              (this._initBody(S),
              (this.method === "GET" || this.method === "HEAD") &&
                (v.cache === "no-store" || v.cache === "no-cache"))
            ) {
              var T = /([?&])_=[^&]*/;
              if (T.test(this.url))
                this.url = this.url.replace(T, "$1_=" + new Date().getTime());
              else {
                var _ = /\?/;
                this.url +=
                  (_.test(this.url) ? "&" : "?") + "_=" + new Date().getTime();
              }
            }
          }
          x.prototype.clone = function () {
            return new x(this, { body: this._bodyInit });
          };
          function $(b) {
            var v = new FormData();
            return (
              b
                .trim()
                .split("&")
                .forEach(function (S) {
                  if (S) {
                    var T = S.split("="),
                      _ = T.shift().replace(/\+/g, " "),
                      R = T.join("=").replace(/\+/g, " ");
                    v.append(decodeURIComponent(_), decodeURIComponent(R));
                  }
                }),
              v
            );
          }
          function k(b) {
            var v = new w(),
              S = b.replace(/\r?\n[\t ]+/g, " ");
            return (
              S.split("\r")
                .map(function (T) {
                  return T.indexOf(`
`) === 0
                    ? T.substr(1, T.length)
                    : T;
                })
                .forEach(function (T) {
                  var _ = T.split(":"),
                    R = _.shift().trim();
                  if (R) {
                    var U = _.join(":").trim();
                    try {
                      v.append(R, U);
                    } catch (D) {
                      console.warn("Response " + D.message);
                    }
                  }
                }),
              v
            );
          }
          A.call(x.prototype);
          function F(b, v) {
            if (!(this instanceof F))
              throw new TypeError(
                'Please use the "new" operator, this DOM object constructor cannot be called as a function.'
              );
            if (
              (v || (v = {}),
              (this.type = "default"),
              (this.status = v.status === void 0 ? 200 : v.status),
              this.status < 200 || this.status > 599)
            )
              throw new RangeError(
                "Failed to construct 'Response': The status provided (0) is outside the range [200, 599]."
              );
            (this.ok = this.status >= 200 && this.status < 300),
              (this.statusText =
                v.statusText === void 0 ? "" : "" + v.statusText),
              (this.headers = new w(v.headers)),
              (this.url = v.url || ""),
              this._initBody(b);
          }
          A.call(F.prototype),
            (F.prototype.clone = function () {
              return new F(this._bodyInit, {
                status: this.status,
                statusText: this.statusText,
                headers: new w(this.headers),
                url: this.url,
              });
            }),
            (F.error = function () {
              var b = new F(null, { status: 200, statusText: "" });
              return (b.ok = !1), (b.status = 0), (b.type = "error"), b;
            });
          var j = [301, 302, 303, 307, 308];
          (F.redirect = function (b, v) {
            if (j.indexOf(v) === -1)
              throw new RangeError("Invalid status code");
            return new F(null, { status: v, headers: { location: b } });
          }),
            (o.DOMException = a.DOMException);
          try {
            new o.DOMException();
          } catch {
            (o.DOMException = function (b, v) {
              (this.message = b), (this.name = v);
              var S = Error(b);
              this.stack = S.stack;
            }),
              (o.DOMException.prototype = Object.create(Error.prototype)),
              (o.DOMException.prototype.constructor = o.DOMException);
          }
          function I(b, v) {
            return new Promise(function (S, T) {
              var _ = new x(b, v);
              if (_.signal && _.signal.aborted)
                return T(new o.DOMException("Aborted", "AbortError"));
              var R = new XMLHttpRequest();
              function U() {
                R.abort();
              }
              (R.onload = function () {
                var q = {
                  statusText: R.statusText,
                  headers: k(R.getAllResponseHeaders() || ""),
                };
                _.url.indexOf("file://") === 0 &&
                (R.status < 200 || R.status > 599)
                  ? (q.status = 200)
                  : (q.status = R.status),
                  (q.url =
                    "responseURL" in R
                      ? R.responseURL
                      : q.headers.get("X-Request-URL"));
                var V = "response" in R ? R.response : R.responseText;
                setTimeout(function () {
                  S(new F(V, q));
                }, 0);
              }),
                (R.onerror = function () {
                  setTimeout(function () {
                    T(new TypeError("Network request failed"));
                  }, 0);
                }),
                (R.ontimeout = function () {
                  setTimeout(function () {
                    T(new TypeError("Network request timed out"));
                  }, 0);
                }),
                (R.onabort = function () {
                  setTimeout(function () {
                    T(new o.DOMException("Aborted", "AbortError"));
                  }, 0);
                });
              function D(q) {
                try {
                  return q === "" && a.location.href ? a.location.href : q;
                } catch {
                  return q;
                }
              }
              if (
                (R.open(_.method, D(_.url), !0),
                _.credentials === "include"
                  ? (R.withCredentials = !0)
                  : _.credentials === "omit" && (R.withCredentials = !1),
                "responseType" in R &&
                  (c.blob
                    ? (R.responseType = "blob")
                    : c.arrayBuffer && (R.responseType = "arraybuffer")),
                v &&
                  typeof v.headers == "object" &&
                  !(
                    v.headers instanceof w ||
                    (a.Headers && v.headers instanceof a.Headers)
                  ))
              ) {
                var H = [];
                Object.getOwnPropertyNames(v.headers).forEach(function (q) {
                  H.push(d(q)), R.setRequestHeader(q, g(v.headers[q]));
                }),
                  _.headers.forEach(function (q, V) {
                    H.indexOf(V) === -1 && R.setRequestHeader(V, q);
                  });
              } else
                _.headers.forEach(function (q, V) {
                  R.setRequestHeader(V, q);
                });
              _.signal &&
                (_.signal.addEventListener("abort", U),
                (R.onreadystatechange = function () {
                  R.readyState === 4 &&
                    _.signal.removeEventListener("abort", U);
                })),
                R.send(typeof _._bodyInit > "u" ? null : _._bodyInit);
            });
          }
          return (
            (I.polyfill = !0),
            a.fetch ||
              ((a.fetch = I),
              (a.Headers = w),
              (a.Request = x),
              (a.Response = F)),
            (o.Headers = w),
            (o.Request = x),
            (o.Response = F),
            (o.fetch = I),
            Object.defineProperty(o, "__esModule", { value: !0 }),
            o
          );
        })({});
      })(i),
        (i.fetch.ponyfill = !0),
        delete i.fetch.polyfill;
      var s = r.fetch ? r : i;
      (e = s.fetch),
        (e.default = s.fetch),
        (e.fetch = s.fetch),
        (e.Headers = s.Headers),
        (e.Request = s.Request),
        (e.Response = s.Response),
        (t.exports = e);
    })(xw, xw.exports);
    var p8 = So(xw.exports),
      Bq = Object.defineProperty,
      Lq = Object.defineProperties,
      Uq = Object.getOwnPropertyDescriptors,
      f8 = Object.getOwnPropertySymbols,
      Dq = Object.prototype.hasOwnProperty,
      jq = Object.prototype.propertyIsEnumerable,
      g8 = (t, e, r) =>
        e in t
          ? Bq(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      w8 = (t, e) => {
        for (var r in e || (e = {})) Dq.call(e, r) && g8(t, r, e[r]);
        if (f8) for (var r of f8(e)) jq.call(e, r) && g8(t, r, e[r]);
        return t;
      },
      m8 = (t, e) => Lq(t, Uq(e));
    const Mq = {
        Accept: "application/json",
        "Content-Type": "application/json",
      },
      zq = "POST",
      y8 = { headers: Mq, method: zq },
      b8 = 10;
    class xt {
      constructor(e, r = !1) {
        if (
          ((this.url = e),
          (this.disableProviderPing = r),
          (this.events = new rt.exports.EventEmitter()),
          (this.isAvailable = !1),
          (this.registering = !1),
          !p6(e))
        )
          throw new Error(
            `Provided URL is not compatible with HTTP connection: ${e}`
          );
        (this.url = e), (this.disableProviderPing = r);
      }
      get connected() {
        return this.isAvailable;
      }
      get connecting() {
        return this.registering;
      }
      on(e, r) {
        this.events.on(e, r);
      }
      once(e, r) {
        this.events.once(e, r);
      }
      off(e, r) {
        this.events.off(e, r);
      }
      removeListener(e, r) {
        this.events.removeListener(e, r);
      }
      async open(e = this.url) {
        await this.register(e);
      }
      async close() {
        if (!this.isAvailable) throw new Error("Connection already closed");
        this.onClose();
      }
      async send(e) {
        this.isAvailable || (await this.register());
        try {
          const r = ys(e),
            i = await (await p8(this.url, m8(w8({}, y8), { body: r }))).json();
          this.onPayload({ data: i });
        } catch (r) {
          this.onError(e.id, r);
        }
      }
      async register(e = this.url) {
        if (!p6(e))
          throw new Error(
            `Provided URL is not compatible with HTTP connection: ${e}`
          );
        if (this.registering) {
          const r = this.events.getMaxListeners();
          return (
            (this.events.listenerCount("register_error") >= r ||
              this.events.listenerCount("open") >= r) &&
              this.events.setMaxListeners(r + 1),
            new Promise((i, s) => {
              this.events.once("register_error", (n) => {
                this.resetMaxListeners(), s(n);
              }),
                this.events.once("open", () => {
                  if ((this.resetMaxListeners(), typeof this.isAvailable > "u"))
                    return s(
                      new Error("HTTP connection is missing or invalid")
                    );
                  i();
                });
            })
          );
        }
        (this.url = e), (this.registering = !0);
        try {
          if (!this.disableProviderPing) {
            const r = ys({ id: 1, jsonrpc: "2.0", method: "test", params: [] });
            await p8(e, m8(w8({}, y8), { body: r }));
          }
          this.onOpen();
        } catch (r) {
          const i = this.parseError(r);
          throw (this.events.emit("register_error", i), this.onClose(), i);
        }
      }
      onOpen() {
        (this.isAvailable = !0),
          (this.registering = !1),
          this.events.emit("open");
      }
      onClose() {
        (this.isAvailable = !1),
          (this.registering = !1),
          this.events.emit("close");
      }
      onPayload(e) {
        if (typeof e.data > "u") return;
        const r = typeof e.data == "string" ? Ws(e.data) : e.data;
        this.events.emit("payload", r);
      }
      onError(e, r) {
        const i = this.parseError(r),
          s = i.message || i.toString(),
          n = Ic(e, s);
        this.events.emit("payload", n);
      }
      parseError(e, r = this.url) {
        return a6(e, r, "HTTP");
      }
      resetMaxListeners() {
        this.events.getMaxListeners() > b8 && this.events.setMaxListeners(b8);
      }
    }
    var qq = Object.defineProperty,
      v8 = Object.getOwnPropertySymbols,
      Hq = Object.prototype.hasOwnProperty,
      Vq = Object.prototype.propertyIsEnumerable,
      E8 = (t, e, r) =>
        e in t
          ? qq(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      C8 = (t, e) => {
        for (var r in e || (e = {})) Hq.call(e, r) && E8(t, r, e[r]);
        if (v8) for (var r of v8(e)) Vq.call(e, r) && E8(t, r, e[r]);
        return t;
      };
    const x8 = "error",
      Wq = "wss://relay.walletconnect.org",
      Kq = "wc",
      Gq = "universal_provider",
      Wp = `${Kq}@2:${Gq}:`,
      I8 = "https://rpc.walletconnect.org/v1/",
      Pc = "generic",
      Zq = `${I8}bundler`,
      $i = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
    function Yq() {}
    function Iw(t) {
      return t == null || (typeof t != "object" && typeof t != "function");
    }
    function _w(t) {
      return ArrayBuffer.isView(t) && !(t instanceof DataView);
    }
    function Jq(t) {
      if (Iw(t)) return t;
      if (
        Array.isArray(t) ||
        _w(t) ||
        t instanceof ArrayBuffer ||
        (typeof SharedArrayBuffer < "u" && t instanceof SharedArrayBuffer)
      )
        return t.slice(0);
      const e = Object.getPrototypeOf(t),
        r = e.constructor;
      if (t instanceof Date || t instanceof Map || t instanceof Set)
        return new r(t);
      if (t instanceof RegExp) {
        const i = new r(t);
        return (i.lastIndex = t.lastIndex), i;
      }
      if (t instanceof DataView) return new r(t.buffer.slice(0));
      if (t instanceof Error) {
        const i = new r(t.message);
        return (i.stack = t.stack), (i.name = t.name), (i.cause = t.cause), i;
      }
      if (typeof File < "u" && t instanceof File)
        return new r([t], t.name, {
          type: t.type,
          lastModified: t.lastModified,
        });
      if (typeof t == "object") {
        const i = Object.create(e);
        return Object.assign(i, t);
      }
      return t;
    }
    function _8(t) {
      return typeof t == "object" && t !== null;
    }
    function A8(t) {
      return Object.getOwnPropertySymbols(t).filter((e) =>
        Object.prototype.propertyIsEnumerable.call(t, e)
      );
    }
    function S8(t) {
      return t == null
        ? t === void 0
          ? "[object Undefined]"
          : "[object Null]"
        : Object.prototype.toString.call(t);
    }
    const Xq = "[object RegExp]",
      P8 = "[object String]",
      O8 = "[object Number]",
      N8 = "[object Boolean]",
      T8 = "[object Arguments]",
      Qq = "[object Symbol]",
      eH = "[object Date]",
      tH = "[object Map]",
      rH = "[object Set]",
      iH = "[object Array]",
      sH = "[object ArrayBuffer]",
      nH = "[object Object]",
      oH = "[object DataView]",
      aH = "[object Uint8Array]",
      cH = "[object Uint8ClampedArray]",
      lH = "[object Uint16Array]",
      uH = "[object Uint32Array]",
      hH = "[object Int8Array]",
      dH = "[object Int16Array]",
      pH = "[object Int32Array]",
      fH = "[object Float32Array]",
      gH = "[object Float64Array]";
    function wH(t, e) {
      return Oc(t, void 0, t, new Map(), e);
    }
    function Oc(t, e, r, i = new Map(), s = void 0) {
      const n = s?.(t, e, r, i);
      if (n != null) return n;
      if (Iw(t)) return t;
      if (i.has(t)) return i.get(t);
      if (Array.isArray(t)) {
        const o = new Array(t.length);
        i.set(t, o);
        for (let a = 0; a < t.length; a++) o[a] = Oc(t[a], a, r, i, s);
        return (
          Object.hasOwn(t, "index") && (o.index = t.index),
          Object.hasOwn(t, "input") && (o.input = t.input),
          o
        );
      }
      if (t instanceof Date) return new Date(t.getTime());
      if (t instanceof RegExp) {
        const o = new RegExp(t.source, t.flags);
        return (o.lastIndex = t.lastIndex), o;
      }
      if (t instanceof Map) {
        const o = new Map();
        i.set(t, o);
        for (const [a, c] of t) o.set(a, Oc(c, a, r, i, s));
        return o;
      }
      if (t instanceof Set) {
        const o = new Set();
        i.set(t, o);
        for (const a of t) o.add(Oc(a, void 0, r, i, s));
        return o;
      }
      if (typeof Fe < "u" && Fe.isBuffer(t)) return t.subarray();
      if (_w(t)) {
        const o = new (Object.getPrototypeOf(t).constructor)(t.length);
        i.set(t, o);
        for (let a = 0; a < t.length; a++) o[a] = Oc(t[a], a, r, i, s);
        return o;
      }
      if (
        t instanceof ArrayBuffer ||
        (typeof SharedArrayBuffer < "u" && t instanceof SharedArrayBuffer)
      )
        return t.slice(0);
      if (t instanceof DataView) {
        const o = new DataView(t.buffer.slice(0), t.byteOffset, t.byteLength);
        return i.set(t, o), Go(o, t, r, i, s), o;
      }
      if (typeof File < "u" && t instanceof File) {
        const o = new File([t], t.name, { type: t.type });
        return i.set(t, o), Go(o, t, r, i, s), o;
      }
      if (t instanceof Blob) {
        const o = new Blob([t], { type: t.type });
        return i.set(t, o), Go(o, t, r, i, s), o;
      }
      if (t instanceof Error) {
        const o = new t.constructor();
        return (
          i.set(t, o),
          (o.message = t.message),
          (o.name = t.name),
          (o.stack = t.stack),
          (o.cause = t.cause),
          Go(o, t, r, i, s),
          o
        );
      }
      if (typeof t == "object" && mH(t)) {
        const o = Object.create(Object.getPrototypeOf(t));
        return i.set(t, o), Go(o, t, r, i, s), o;
      }
      return t;
    }
    function Go(t, e, r = t, i, s) {
      const n = [...Object.keys(e), ...A8(e)];
      for (let o = 0; o < n.length; o++) {
        const a = n[o],
          c = Object.getOwnPropertyDescriptor(t, a);
        (c == null || c.writable) && (t[a] = Oc(e[a], a, r, i, s));
      }
    }
    function mH(t) {
      switch (S8(t)) {
        case T8:
        case iH:
        case sH:
        case oH:
        case N8:
        case eH:
        case fH:
        case gH:
        case hH:
        case dH:
        case pH:
        case tH:
        case O8:
        case nH:
        case Xq:
        case rH:
        case P8:
        case Qq:
        case aH:
        case cH:
        case lH:
        case uH:
          return !0;
        default:
          return !1;
      }
    }
    function yH(t, e) {
      return wH(t, (r, i, s, n) => {
        const o = e?.(r, i, s, n);
        if (o != null) return o;
        if (typeof t == "object")
          switch (Object.prototype.toString.call(t)) {
            case O8:
            case P8:
            case N8: {
              const a = new t.constructor(t?.valueOf());
              return Go(a, t), a;
            }
            case T8: {
              const a = {};
              return (
                Go(a, t),
                (a.length = t.length),
                (a[Symbol.iterator] = t[Symbol.iterator]),
                a
              );
            }
            default:
              return;
          }
      });
    }
    function k8(t) {
      return yH(t);
    }
    function R8(t) {
      return (
        t !== null && typeof t == "object" && S8(t) === "[object Arguments]"
      );
    }
    function bH(t) {
      return _w(t);
    }
    function vH(t) {
      var e;
      if (typeof t != "object" || t == null) return !1;
      if (Object.getPrototypeOf(t) === null) return !0;
      if (Object.prototype.toString.call(t) !== "[object Object]") {
        const i = t[Symbol.toStringTag];
        return i == null ||
          !(
            (e = Object.getOwnPropertyDescriptor(t, Symbol.toStringTag)) !=
              null && e.writable
          )
          ? !1
          : t.toString() === `[object ${i}]`;
      }
      let r = t;
      for (; Object.getPrototypeOf(r) !== null; ) r = Object.getPrototypeOf(r);
      return Object.getPrototypeOf(t) === r;
    }
    function EH(t, ...e) {
      const r = e.slice(0, -1),
        i = e[e.length - 1];
      let s = t;
      for (let n = 0; n < r.length; n++) {
        const o = r[n];
        s = Aw(s, o, i, new Map());
      }
      return s;
    }
    function Aw(t, e, r, i) {
      var s;
      if ((Iw(t) && (t = Object(t)), e == null || typeof e != "object"))
        return t;
      if (i.has(e)) return Jq(i.get(e));
      if ((i.set(e, t), Array.isArray(e))) {
        e = e.slice();
        for (let o = 0; o < e.length; o++)
          e[o] = (s = e[o]) != null ? s : void 0;
      }
      const n = [...Object.keys(e), ...A8(e)];
      for (let o = 0; o < n.length; o++) {
        const a = n[o];
        let c = e[a],
          l = t[a];
        if (
          (R8(c) && (c = C8({}, c)),
          R8(l) && (l = C8({}, l)),
          typeof Fe < "u" && Fe.isBuffer(c) && (c = k8(c)),
          Array.isArray(c))
        )
          if (typeof l == "object" && l != null) {
            const h = [],
              d = Reflect.ownKeys(l);
            for (let g = 0; g < d.length; g++) {
              const p = d[g];
              h[p] = l[p];
            }
            l = h;
          } else l = [];
        const u = r(l, c, a, t, e, i);
        u != null
          ? (t[a] = u)
          : Array.isArray(c) || (_8(l) && _8(c))
          ? (t[a] = Aw(l, c, r, i))
          : l == null && vH(c)
          ? (t[a] = Aw({}, c, r, i))
          : l == null && bH(c)
          ? (t[a] = k8(c))
          : (l === void 0 || c !== void 0) && (t[a] = c);
      }
      return t;
    }
    function CH(t, ...e) {
      return EH(t, ...e, Yq);
    }
    var xH = Object.defineProperty,
      IH = Object.defineProperties,
      _H = Object.getOwnPropertyDescriptors,
      $8 = Object.getOwnPropertySymbols,
      AH = Object.prototype.hasOwnProperty,
      SH = Object.prototype.propertyIsEnumerable,
      F8 = (t, e, r) =>
        e in t
          ? xH(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Kp = (t, e) => {
        for (var r in e || (e = {})) AH.call(e, r) && F8(t, r, e[r]);
        if ($8) for (var r of $8(e)) SH.call(e, r) && F8(t, r, e[r]);
        return t;
      },
      PH = (t, e) => IH(t, _H(e));
    function pi(t, e, r) {
      var i;
      const s = ac(t);
      return (
        ((i = e.rpcMap) == null ? void 0 : i[s.reference]) ||
        `${I8}?chainId=${s.namespace}:${s.reference}&projectId=${r}`
      );
    }
    function Zo(t) {
      return t.includes(":") ? t.split(":")[1] : t;
    }
    function B8(t) {
      return t.map((e) => `${e.split(":")[0]}:${e.split(":")[1]}`);
    }
    function OH(t, e) {
      const r = Object.keys(e.namespaces).filter((s) => s.includes(t));
      if (!r.length) return [];
      const i = [];
      return (
        r.forEach((s) => {
          const n = e.namespaces[s].accounts;
          i.push(...n);
        }),
        i
      );
    }
    function Sw(t = {}, e = {}) {
      const r = L8(t),
        i = L8(e);
      return CH(r, i);
    }
    function L8(t) {
      var e, r, i, s;
      const n = {};
      if (!Ou(t)) return n;
      for (const [o, a] of Object.entries(t)) {
        const c = M1(o) ? [o] : a.chains,
          l = a.methods || [],
          u = a.events || [],
          h = a.rpcMap || {},
          d = Pu(o);
        n[d] = PH(Kp(Kp({}, n[d]), a), {
          chains: wp(c, (e = n[d]) == null ? void 0 : e.chains),
          methods: wp(l, (r = n[d]) == null ? void 0 : r.methods),
          events: wp(u, (i = n[d]) == null ? void 0 : i.events),
          rpcMap: Kp(Kp({}, h), (s = n[d]) == null ? void 0 : s.rpcMap),
        });
      }
      return n;
    }
    function U8(t) {
      return t.includes(":") ? t.split(":")[2] : t;
    }
    function D8(t) {
      const e = {};
      for (const [r, i] of Object.entries(t)) {
        const s = i.methods || [],
          n = i.events || [],
          o = i.accounts || [],
          a = M1(r) ? [r] : i.chains ? i.chains : B8(i.accounts);
        e[r] = { chains: a, methods: s, events: n, accounts: o };
      }
      return e;
    }
    function Pw(t) {
      return typeof t == "number"
        ? t
        : t.includes("0x")
        ? parseInt(t, 16)
        : ((t = t.includes(":") ? t.split(":")[1] : t),
          isNaN(Number(t)) ? t : Number(t));
    }
    const j8 = {},
      Ue = (t) => j8[t],
      Ow = (t, e) => {
        j8[t] = e;
      };
    var NH = Object.defineProperty,
      TH = (t, e, r) =>
        e in t
          ? NH(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Nc = (t, e, r) => TH(t, typeof e != "symbol" ? e + "" : e, r);
    class kH {
      constructor(e) {
        Nc(this, "name", "polkadot"),
          Nc(this, "client"),
          Nc(this, "httpProviders"),
          Nc(this, "events"),
          Nc(this, "namespace"),
          Nc(this, "chainId"),
          (this.namespace = e.namespace),
          (this.events = Ue("events")),
          (this.client = Ue("client")),
          (this.chainId = this.getDefaultChain()),
          (this.httpProviders = this.createHttpProviders());
      }
      updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1];
      }
      request(e) {
        return this.namespace.methods.includes(e.request.method)
          ? this.client.request(e)
          : this.getHttpProvider().request(e.request);
      }
      setDefaultChain(e, r) {
        this.httpProviders[e] || this.setHttpProvider(e, r),
          (this.chainId = e),
          this.events.emit($i.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
      }
      getAccounts() {
        const e = this.namespace.accounts;
        return e
          ? e
              .filter((r) => r.split(":")[1] === this.chainId.toString())
              .map((r) => r.split(":")[2]) || []
          : [];
      }
      createHttpProviders() {
        const e = {};
        return (
          this.namespace.chains.forEach((r) => {
            var i;
            const s = Zo(r);
            e[s] = this.createHttpProvider(
              s,
              (i = this.namespace.rpcMap) == null ? void 0 : i[r]
            );
          }),
          e
        );
      }
      getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
          r = this.httpProviders[e];
        if (typeof r > "u")
          throw new Error(`JSON-RPC provider for ${e} not found`);
        return r;
      }
      setHttpProvider(e, r) {
        const i = this.createHttpProvider(e, r);
        i && (this.httpProviders[e] = i);
      }
      createHttpProvider(e, r) {
        const i = r || pi(e, this.namespace, this.client.core.projectId);
        if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new bt(new xt(i, Ue("disableProviderPing")));
      }
    }
    var RH = Object.defineProperty,
      $H = Object.defineProperties,
      FH = Object.getOwnPropertyDescriptors,
      M8 = Object.getOwnPropertySymbols,
      BH = Object.prototype.hasOwnProperty,
      LH = Object.prototype.propertyIsEnumerable,
      Nw = (t, e, r) =>
        e in t
          ? RH(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      z8 = (t, e) => {
        for (var r in e || (e = {})) BH.call(e, r) && Nw(t, r, e[r]);
        if (M8) for (var r of M8(e)) LH.call(e, r) && Nw(t, r, e[r]);
        return t;
      },
      q8 = (t, e) => $H(t, FH(e)),
      Tc = (t, e, r) => Nw(t, typeof e != "symbol" ? e + "" : e, r);
    class UH {
      constructor(e) {
        Tc(this, "name", "eip155"),
          Tc(this, "client"),
          Tc(this, "chainId"),
          Tc(this, "namespace"),
          Tc(this, "httpProviders"),
          Tc(this, "events"),
          (this.namespace = e.namespace),
          (this.events = Ue("events")),
          (this.client = Ue("client")),
          (this.httpProviders = this.createHttpProviders()),
          (this.chainId = parseInt(this.getDefaultChain()));
      }
      async request(e) {
        switch (e.request.method) {
          case "eth_requestAccounts":
            return this.getAccounts();
          case "eth_accounts":
            return this.getAccounts();
          case "wallet_switchEthereumChain":
            return await this.handleSwitchChain(e);
          case "eth_chainId":
            return parseInt(this.getDefaultChain());
          case "wallet_getCapabilities":
            return await this.getCapabilities(e);
          case "wallet_getCallsStatus":
            return await this.getCallStatus(e);
        }
        return this.namespace.methods.includes(e.request.method)
          ? await this.client.request(e)
          : this.getHttpProvider().request(e.request);
      }
      updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e);
      }
      setDefaultChain(e, r) {
        this.httpProviders[e] || this.setHttpProvider(parseInt(e), r),
          (this.chainId = parseInt(e)),
          this.events.emit($i.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      getDefaultChain() {
        if (this.chainId) return this.chainId.toString();
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1];
      }
      createHttpProvider(e, r) {
        const i =
          r ||
          pi(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
        if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new bt(new xt(i, Ue("disableProviderPing")));
      }
      setHttpProvider(e, r) {
        const i = this.createHttpProvider(e, r);
        i && (this.httpProviders[e] = i);
      }
      createHttpProviders() {
        const e = {};
        return (
          this.namespace.chains.forEach((r) => {
            var i;
            const s = parseInt(Zo(r));
            e[s] = this.createHttpProvider(
              s,
              (i = this.namespace.rpcMap) == null ? void 0 : i[r]
            );
          }),
          e
        );
      }
      getAccounts() {
        const e = this.namespace.accounts;
        return e
          ? [
              ...new Set(
                e
                  .filter((r) => r.split(":")[1] === this.chainId.toString())
                  .map((r) => r.split(":")[2])
              ),
            ]
          : [];
      }
      getHttpProvider() {
        const e = this.chainId,
          r = this.httpProviders[e];
        if (typeof r > "u")
          throw new Error(`JSON-RPC provider for ${e} not found`);
        return r;
      }
      async handleSwitchChain(e) {
        var r, i;
        let s = e.request.params
          ? (r = e.request.params[0]) == null
            ? void 0
            : r.chainId
          : "0x0";
        s = s.startsWith("0x") ? s : `0x${s}`;
        const n = parseInt(s, 16);
        if (this.isChainApproved(n)) this.setDefaultChain(`${n}`);
        else if (this.namespace.methods.includes("wallet_switchEthereumChain"))
          await this.client.request({
            topic: e.topic,
            request: { method: e.request.method, params: [{ chainId: s }] },
            chainId: (i = this.namespace.chains) == null ? void 0 : i[0],
          }),
            this.setDefaultChain(`${n}`);
        else
          throw new Error(
            `Failed to switch to chain 'eip155:${n}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`
          );
        return null;
      }
      isChainApproved(e) {
        return this.namespace.chains.includes(`${this.name}:${e}`);
      }
      async getCapabilities(e) {
        var r, i, s;
        const n =
          (i = (r = e.request) == null ? void 0 : r.params) == null
            ? void 0
            : i[0];
        if (!n)
          throw new Error(
            "Missing address parameter in `wallet_getCapabilities` request"
          );
        const o = this.client.session.get(e.topic),
          a =
            ((s = o?.sessionProperties) == null ? void 0 : s.capabilities) ||
            {};
        if (a != null && a[n]) return a?.[n];
        const c = await this.client.request(e);
        try {
          await this.client.session.update(e.topic, {
            sessionProperties: q8(z8({}, o.sessionProperties || {}), {
              capabilities: q8(z8({}, a || {}), { [n]: c }),
            }),
          });
        } catch (l) {
          console.warn("Failed to update session with capabilities", l);
        }
        return c;
      }
      async getCallStatus(e) {
        var r, i;
        const s = this.client.session.get(e.topic),
          n = (r = s.sessionProperties) == null ? void 0 : r.bundler_name;
        if (n) {
          const a = this.getBundlerUrl(e.chainId, n);
          try {
            return await this.getUserOperationReceipt(a, e);
          } catch (c) {
            console.warn("Failed to fetch call status from bundler", c, a);
          }
        }
        const o = (i = s.sessionProperties) == null ? void 0 : i.bundler_url;
        if (o)
          try {
            return await this.getUserOperationReceipt(o, e);
          } catch (a) {
            console.warn(
              "Failed to fetch call status from custom bundler",
              a,
              o
            );
          }
        if (this.namespace.methods.includes(e.request.method))
          return await this.client.request(e);
        throw new Error("Fetching call status not approved by the wallet.");
      }
      async getUserOperationReceipt(e, r) {
        var i;
        const s = new URL(e),
          n = await fetch(s, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(
              kr("eth_getUserOperationReceipt", [
                (i = r.request.params) == null ? void 0 : i[0],
              ])
            ),
          });
        if (!n.ok)
          throw new Error(
            `Failed to fetch user operation receipt - ${n.status}`
          );
        return await n.json();
      }
      getBundlerUrl(e, r) {
        return `${Zq}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${r}`;
      }
    }
    var DH = Object.defineProperty,
      jH = (t, e, r) =>
        e in t
          ? DH(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      kc = (t, e, r) => jH(t, typeof e != "symbol" ? e + "" : e, r);
    class MH {
      constructor(e) {
        kc(this, "name", "solana"),
          kc(this, "client"),
          kc(this, "httpProviders"),
          kc(this, "events"),
          kc(this, "namespace"),
          kc(this, "chainId"),
          (this.namespace = e.namespace),
          (this.events = Ue("events")),
          (this.client = Ue("client")),
          (this.chainId = this.getDefaultChain()),
          (this.httpProviders = this.createHttpProviders());
      }
      updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      request(e) {
        return this.namespace.methods.includes(e.request.method)
          ? this.client.request(e)
          : this.getHttpProvider().request(e.request);
      }
      setDefaultChain(e, r) {
        this.httpProviders[e] || this.setHttpProvider(e, r),
          (this.chainId = e),
          this.events.emit($i.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
      }
      getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1];
      }
      getAccounts() {
        const e = this.namespace.accounts;
        return e
          ? [
              ...new Set(
                e
                  .filter((r) => r.split(":")[1] === this.chainId.toString())
                  .map((r) => r.split(":")[2])
              ),
            ]
          : [];
      }
      createHttpProviders() {
        const e = {};
        return (
          this.namespace.chains.forEach((r) => {
            var i;
            const s = Zo(r);
            e[s] = this.createHttpProvider(
              s,
              (i = this.namespace.rpcMap) == null ? void 0 : i[r]
            );
          }),
          e
        );
      }
      getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
          r = this.httpProviders[e];
        if (typeof r > "u")
          throw new Error(`JSON-RPC provider for ${e} not found`);
        return r;
      }
      setHttpProvider(e, r) {
        const i = this.createHttpProvider(e, r);
        i && (this.httpProviders[e] = i);
      }
      createHttpProvider(e, r) {
        const i = r || pi(e, this.namespace, this.client.core.projectId);
        if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new bt(new xt(i, Ue("disableProviderPing")));
      }
    }
    var zH = Object.defineProperty,
      qH = (t, e, r) =>
        e in t
          ? zH(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Rc = (t, e, r) => qH(t, typeof e != "symbol" ? e + "" : e, r);
    class HH {
      constructor(e) {
        Rc(this, "name", "cosmos"),
          Rc(this, "client"),
          Rc(this, "httpProviders"),
          Rc(this, "events"),
          Rc(this, "namespace"),
          Rc(this, "chainId"),
          (this.namespace = e.namespace),
          (this.events = Ue("events")),
          (this.client = Ue("client")),
          (this.chainId = this.getDefaultChain()),
          (this.httpProviders = this.createHttpProviders());
      }
      updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1];
      }
      request(e) {
        return this.namespace.methods.includes(e.request.method)
          ? this.client.request(e)
          : this.getHttpProvider().request(e.request);
      }
      setDefaultChain(e, r) {
        this.httpProviders[e] || this.setHttpProvider(e, r),
          (this.chainId = e),
          this.events.emit(
            $i.DEFAULT_CHAIN_CHANGED,
            `${this.name}:${this.chainId}`
          );
      }
      getAccounts() {
        const e = this.namespace.accounts;
        return e
          ? [
              ...new Set(
                e
                  .filter((r) => r.split(":")[1] === this.chainId.toString())
                  .map((r) => r.split(":")[2])
              ),
            ]
          : [];
      }
      createHttpProviders() {
        const e = {};
        return (
          this.namespace.chains.forEach((r) => {
            var i;
            const s = Zo(r);
            e[s] = this.createHttpProvider(
              s,
              (i = this.namespace.rpcMap) == null ? void 0 : i[r]
            );
          }),
          e
        );
      }
      getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
          r = this.httpProviders[e];
        if (typeof r > "u")
          throw new Error(`JSON-RPC provider for ${e} not found`);
        return r;
      }
      setHttpProvider(e, r) {
        const i = this.createHttpProvider(e, r);
        i && (this.httpProviders[e] = i);
      }
      createHttpProvider(e, r) {
        const i = r || pi(e, this.namespace, this.client.core.projectId);
        if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new bt(new xt(i, Ue("disableProviderPing")));
      }
    }
    var VH = Object.defineProperty,
      WH = (t, e, r) =>
        e in t
          ? VH(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      $c = (t, e, r) => WH(t, typeof e != "symbol" ? e + "" : e, r);
    class KH {
      constructor(e) {
        $c(this, "name", "algorand"),
          $c(this, "client"),
          $c(this, "httpProviders"),
          $c(this, "events"),
          $c(this, "namespace"),
          $c(this, "chainId"),
          (this.namespace = e.namespace),
          (this.events = Ue("events")),
          (this.client = Ue("client")),
          (this.chainId = this.getDefaultChain()),
          (this.httpProviders = this.createHttpProviders());
      }
      updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      request(e) {
        return this.namespace.methods.includes(e.request.method)
          ? this.client.request(e)
          : this.getHttpProvider().request(e.request);
      }
      setDefaultChain(e, r) {
        if (!this.httpProviders[e]) {
          const i =
            r ||
            pi(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
          if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);
          this.setHttpProvider(e, i);
        }
        (this.chainId = e),
          this.events.emit(
            $i.DEFAULT_CHAIN_CHANGED,
            `${this.name}:${this.chainId}`
          );
      }
      getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1];
      }
      getAccounts() {
        const e = this.namespace.accounts;
        return e
          ? [
              ...new Set(
                e
                  .filter((r) => r.split(":")[1] === this.chainId.toString())
                  .map((r) => r.split(":")[2])
              ),
            ]
          : [];
      }
      createHttpProviders() {
        const e = {};
        return (
          this.namespace.chains.forEach((r) => {
            var i;
            e[r] = this.createHttpProvider(
              r,
              (i = this.namespace.rpcMap) == null ? void 0 : i[r]
            );
          }),
          e
        );
      }
      getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
          r = this.httpProviders[e];
        if (typeof r > "u")
          throw new Error(`JSON-RPC provider for ${e} not found`);
        return r;
      }
      setHttpProvider(e, r) {
        const i = this.createHttpProvider(e, r);
        i && (this.httpProviders[e] = i);
      }
      createHttpProvider(e, r) {
        const i = r || pi(e, this.namespace, this.client.core.projectId);
        return typeof i > "u"
          ? void 0
          : new bt(new xt(i, Ue("disableProviderPing")));
      }
    }
    var GH = Object.defineProperty,
      ZH = (t, e, r) =>
        e in t
          ? GH(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Fc = (t, e, r) => ZH(t, typeof e != "symbol" ? e + "" : e, r);
    class YH {
      constructor(e) {
        Fc(this, "name", "cip34"),
          Fc(this, "client"),
          Fc(this, "httpProviders"),
          Fc(this, "events"),
          Fc(this, "namespace"),
          Fc(this, "chainId"),
          (this.namespace = e.namespace),
          (this.events = Ue("events")),
          (this.client = Ue("client")),
          (this.chainId = this.getDefaultChain()),
          (this.httpProviders = this.createHttpProviders());
      }
      updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1];
      }
      request(e) {
        return this.namespace.methods.includes(e.request.method)
          ? this.client.request(e)
          : this.getHttpProvider().request(e.request);
      }
      setDefaultChain(e, r) {
        this.httpProviders[e] || this.setHttpProvider(e, r),
          (this.chainId = e),
          this.events.emit(
            $i.DEFAULT_CHAIN_CHANGED,
            `${this.name}:${this.chainId}`
          );
      }
      getAccounts() {
        const e = this.namespace.accounts;
        return e
          ? [
              ...new Set(
                e
                  .filter((r) => r.split(":")[1] === this.chainId.toString())
                  .map((r) => r.split(":")[2])
              ),
            ]
          : [];
      }
      createHttpProviders() {
        const e = {};
        return (
          this.namespace.chains.forEach((r) => {
            const i = this.getCardanoRPCUrl(r),
              s = Zo(r);
            e[s] = this.createHttpProvider(s, i);
          }),
          e
        );
      }
      getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
          r = this.httpProviders[e];
        if (typeof r > "u")
          throw new Error(`JSON-RPC provider for ${e} not found`);
        return r;
      }
      getCardanoRPCUrl(e) {
        const r = this.namespace.rpcMap;
        if (r) return r[e];
      }
      setHttpProvider(e, r) {
        const i = this.createHttpProvider(e, r);
        i && (this.httpProviders[e] = i);
      }
      createHttpProvider(e, r) {
        const i = r || this.getCardanoRPCUrl(e);
        if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new bt(new xt(i, Ue("disableProviderPing")));
      }
    }
    var JH = Object.defineProperty,
      XH = (t, e, r) =>
        e in t
          ? JH(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Bc = (t, e, r) => XH(t, typeof e != "symbol" ? e + "" : e, r);
    class QH {
      constructor(e) {
        Bc(this, "name", "elrond"),
          Bc(this, "client"),
          Bc(this, "httpProviders"),
          Bc(this, "events"),
          Bc(this, "namespace"),
          Bc(this, "chainId"),
          (this.namespace = e.namespace),
          (this.events = Ue("events")),
          (this.client = Ue("client")),
          (this.chainId = this.getDefaultChain()),
          (this.httpProviders = this.createHttpProviders());
      }
      updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      request(e) {
        return this.namespace.methods.includes(e.request.method)
          ? this.client.request(e)
          : this.getHttpProvider().request(e.request);
      }
      setDefaultChain(e, r) {
        this.httpProviders[e] || this.setHttpProvider(e, r),
          (this.chainId = e),
          this.events.emit($i.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
      }
      getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1];
      }
      getAccounts() {
        const e = this.namespace.accounts;
        return e
          ? [
              ...new Set(
                e
                  .filter((r) => r.split(":")[1] === this.chainId.toString())
                  .map((r) => r.split(":")[2])
              ),
            ]
          : [];
      }
      createHttpProviders() {
        const e = {};
        return (
          this.namespace.chains.forEach((r) => {
            var i;
            const s = Zo(r);
            e[s] = this.createHttpProvider(
              s,
              (i = this.namespace.rpcMap) == null ? void 0 : i[r]
            );
          }),
          e
        );
      }
      getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
          r = this.httpProviders[e];
        if (typeof r > "u")
          throw new Error(`JSON-RPC provider for ${e} not found`);
        return r;
      }
      setHttpProvider(e, r) {
        const i = this.createHttpProvider(e, r);
        i && (this.httpProviders[e] = i);
      }
      createHttpProvider(e, r) {
        const i = r || pi(e, this.namespace, this.client.core.projectId);
        if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new bt(new xt(i, Ue("disableProviderPing")));
      }
    }
    var eV = Object.defineProperty,
      tV = (t, e, r) =>
        e in t
          ? eV(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Lc = (t, e, r) => tV(t, typeof e != "symbol" ? e + "" : e, r);
    class rV {
      constructor(e) {
        Lc(this, "name", "multiversx"),
          Lc(this, "client"),
          Lc(this, "httpProviders"),
          Lc(this, "events"),
          Lc(this, "namespace"),
          Lc(this, "chainId"),
          (this.namespace = e.namespace),
          (this.events = Ue("events")),
          (this.client = Ue("client")),
          (this.chainId = this.getDefaultChain()),
          (this.httpProviders = this.createHttpProviders());
      }
      updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      request(e) {
        return this.namespace.methods.includes(e.request.method)
          ? this.client.request(e)
          : this.getHttpProvider().request(e.request);
      }
      setDefaultChain(e, r) {
        this.httpProviders[e] || this.setHttpProvider(e, r),
          (this.chainId = e),
          this.events.emit($i.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
      }
      getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1];
      }
      getAccounts() {
        const e = this.namespace.accounts;
        return e
          ? [
              ...new Set(
                e
                  .filter((r) => r.split(":")[1] === this.chainId.toString())
                  .map((r) => r.split(":")[2])
              ),
            ]
          : [];
      }
      createHttpProviders() {
        const e = {};
        return (
          this.namespace.chains.forEach((r) => {
            var i;
            const s = Zo(r);
            e[s] = this.createHttpProvider(
              s,
              (i = this.namespace.rpcMap) == null ? void 0 : i[r]
            );
          }),
          e
        );
      }
      getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
          r = this.httpProviders[e];
        if (typeof r > "u")
          throw new Error(`JSON-RPC provider for ${e} not found`);
        return r;
      }
      setHttpProvider(e, r) {
        const i = this.createHttpProvider(e, r);
        i && (this.httpProviders[e] = i);
      }
      createHttpProvider(e, r) {
        const i = r || pi(e, this.namespace, this.client.core.projectId);
        if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new bt(new xt(i, Ue("disableProviderPing")));
      }
    }
    var iV = Object.defineProperty,
      sV = (t, e, r) =>
        e in t
          ? iV(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Uc = (t, e, r) => sV(t, typeof e != "symbol" ? e + "" : e, r);
    class nV {
      constructor(e) {
        Uc(this, "name", "near"),
          Uc(this, "client"),
          Uc(this, "httpProviders"),
          Uc(this, "events"),
          Uc(this, "namespace"),
          Uc(this, "chainId"),
          (this.namespace = e.namespace),
          (this.events = Ue("events")),
          (this.client = Ue("client")),
          (this.chainId = this.getDefaultChain()),
          (this.httpProviders = this.createHttpProviders());
      }
      updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1];
      }
      request(e) {
        return this.namespace.methods.includes(e.request.method)
          ? this.client.request(e)
          : this.getHttpProvider().request(e.request);
      }
      setDefaultChain(e, r) {
        if (((this.chainId = e), !this.httpProviders[e])) {
          const i = r || pi(`${this.name}:${e}`, this.namespace);
          if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);
          this.setHttpProvider(e, i);
        }
        this.events.emit(
          $i.DEFAULT_CHAIN_CHANGED,
          `${this.name}:${this.chainId}`
        );
      }
      getAccounts() {
        const e = this.namespace.accounts;
        return e
          ? e
              .filter((r) => r.split(":")[1] === this.chainId.toString())
              .map((r) => r.split(":")[2]) || []
          : [];
      }
      createHttpProviders() {
        const e = {};
        return (
          this.namespace.chains.forEach((r) => {
            var i;
            e[r] = this.createHttpProvider(
              r,
              (i = this.namespace.rpcMap) == null ? void 0 : i[r]
            );
          }),
          e
        );
      }
      getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
          r = this.httpProviders[e];
        if (typeof r > "u")
          throw new Error(`JSON-RPC provider for ${e} not found`);
        return r;
      }
      setHttpProvider(e, r) {
        const i = this.createHttpProvider(e, r);
        i && (this.httpProviders[e] = i);
      }
      createHttpProvider(e, r) {
        const i = r || pi(e, this.namespace);
        return typeof i > "u"
          ? void 0
          : new bt(new xt(i, Ue("disableProviderPing")));
      }
    }
    var oV = Object.defineProperty,
      aV = (t, e, r) =>
        e in t
          ? oV(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Dc = (t, e, r) => aV(t, typeof e != "symbol" ? e + "" : e, r);
    class cV {
      constructor(e) {
        Dc(this, "name", "tezos"),
          Dc(this, "client"),
          Dc(this, "httpProviders"),
          Dc(this, "events"),
          Dc(this, "namespace"),
          Dc(this, "chainId"),
          (this.namespace = e.namespace),
          (this.events = Ue("events")),
          (this.client = Ue("client")),
          (this.chainId = this.getDefaultChain()),
          (this.httpProviders = this.createHttpProviders());
      }
      updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1];
      }
      request(e) {
        return this.namespace.methods.includes(e.request.method)
          ? this.client.request(e)
          : this.getHttpProvider().request(e.request);
      }
      setDefaultChain(e, r) {
        if (((this.chainId = e), !this.httpProviders[e])) {
          const i = r || pi(`${this.name}:${e}`, this.namespace);
          if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);
          this.setHttpProvider(e, i);
        }
        this.events.emit(
          $i.DEFAULT_CHAIN_CHANGED,
          `${this.name}:${this.chainId}`
        );
      }
      getAccounts() {
        const e = this.namespace.accounts;
        return e
          ? e
              .filter((r) => r.split(":")[1] === this.chainId.toString())
              .map((r) => r.split(":")[2]) || []
          : [];
      }
      createHttpProviders() {
        const e = {};
        return (
          this.namespace.chains.forEach((r) => {
            e[r] = this.createHttpProvider(r);
          }),
          e
        );
      }
      getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
          r = this.httpProviders[e];
        if (typeof r > "u")
          throw new Error(`JSON-RPC provider for ${e} not found`);
        return r;
      }
      setHttpProvider(e, r) {
        const i = this.createHttpProvider(e, r);
        i && (this.httpProviders[e] = i);
      }
      createHttpProvider(e, r) {
        const i = r || pi(e, this.namespace);
        return typeof i > "u" ? void 0 : new bt(new xt(i));
      }
    }
    var lV = Object.defineProperty,
      uV = (t, e, r) =>
        e in t
          ? lV(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      jc = (t, e, r) => uV(t, typeof e != "symbol" ? e + "" : e, r);
    class hV {
      constructor(e) {
        jc(this, "name", Pc),
          jc(this, "client"),
          jc(this, "httpProviders"),
          jc(this, "events"),
          jc(this, "namespace"),
          jc(this, "chainId"),
          (this.namespace = e.namespace),
          (this.events = Ue("events")),
          (this.client = Ue("client")),
          (this.chainId = this.getDefaultChain()),
          (this.httpProviders = this.createHttpProviders());
      }
      updateNamespace(e) {
        (this.namespace.chains = [
          ...new Set((this.namespace.chains || []).concat(e.chains || [])),
        ]),
          (this.namespace.accounts = [
            ...new Set(
              (this.namespace.accounts || []).concat(e.accounts || [])
            ),
          ]),
          (this.namespace.methods = [
            ...new Set((this.namespace.methods || []).concat(e.methods || [])),
          ]),
          (this.namespace.events = [
            ...new Set((this.namespace.events || []).concat(e.events || [])),
          ]),
          (this.httpProviders = this.createHttpProviders());
      }
      requestAccounts() {
        return this.getAccounts();
      }
      request(e) {
        return this.namespace.methods.includes(e.request.method)
          ? this.client.request(e)
          : this.getHttpProvider(e.chainId).request(e.request);
      }
      setDefaultChain(e, r) {
        this.httpProviders[e] || this.setHttpProvider(e, r),
          (this.chainId = e),
          this.events.emit($i.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
      }
      getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1];
      }
      getAccounts() {
        const e = this.namespace.accounts;
        return e
          ? [
              ...new Set(
                e
                  .filter((r) => r.split(":")[1] === this.chainId.toString())
                  .map((r) => r.split(":")[2])
              ),
            ]
          : [];
      }
      createHttpProviders() {
        var e, r;
        const i = {};
        return (
          (r = (e = this.namespace) == null ? void 0 : e.accounts) == null ||
            r.forEach((s) => {
              const n = ac(s);
              i[`${n.namespace}:${n.reference}`] = this.createHttpProvider(s);
            }),
          i
        );
      }
      getHttpProvider(e) {
        const r = this.httpProviders[e];
        if (typeof r > "u")
          throw new Error(`JSON-RPC provider for ${e} not found`);
        return r;
      }
      setHttpProvider(e, r) {
        const i = this.createHttpProvider(e, r);
        i && (this.httpProviders[e] = i);
      }
      createHttpProvider(e, r) {
        const i = r || pi(e, this.namespace, this.client.core.projectId);
        if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new bt(new xt(i, Ue("disableProviderPing")));
      }
    }
    var dV = Object.defineProperty,
      pV = Object.defineProperties,
      fV = Object.getOwnPropertyDescriptors,
      H8 = Object.getOwnPropertySymbols,
      gV = Object.prototype.hasOwnProperty,
      wV = Object.prototype.propertyIsEnumerable,
      Tw = (t, e, r) =>
        e in t
          ? dV(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Gp = (t, e) => {
        for (var r in e || (e = {})) gV.call(e, r) && Tw(t, r, e[r]);
        if (H8) for (var r of H8(e)) wV.call(e, r) && Tw(t, r, e[r]);
        return t;
      },
      kw = (t, e) => pV(t, fV(e)),
      Fi = (t, e, r) => Tw(t, typeof e != "symbol" ? e + "" : e, r);
    class Rw {
      constructor(e) {
        Fi(this, "client"),
          Fi(this, "namespaces"),
          Fi(this, "optionalNamespaces"),
          Fi(this, "sessionProperties"),
          Fi(this, "scopedProperties"),
          Fi(this, "events", new rt.exports()),
          Fi(this, "rpcProviders", {}),
          Fi(this, "session"),
          Fi(this, "providerOpts"),
          Fi(this, "logger"),
          Fi(this, "uri"),
          Fi(this, "disableProviderPing", !1),
          (this.providerOpts = e),
          (this.logger =
            typeof e?.logger < "u" && typeof e?.logger != "string"
              ? e.logger
              : li(tn({ level: e?.logger || x8 }))),
          (this.disableProviderPing = e?.disableProviderPing || !1);
      }
      static async init(e) {
        const r = new Rw(e);
        return await r.initialize(), r;
      }
      async request(e, r, i) {
        const [s, n] = this.validateChain(r);
        if (!this.session)
          throw new Error("Please call connect() before request()");
        return await this.getProvider(s).request({
          request: Gp({}, e),
          chainId: `${s}:${n}`,
          topic: this.session.topic,
          expiry: i,
        });
      }
      sendAsync(e, r, i, s) {
        const n = new Date().getTime();
        this.request(e, i, s)
          .then((o) => r(null, Jn(n, o)))
          .catch((o) => r(o, void 0));
      }
      async enable() {
        if (!this.client) throw new Error("Sign Client not initialized");
        return (
          this.session ||
            (await this.connect({
              namespaces: this.namespaces,
              optionalNamespaces: this.optionalNamespaces,
              sessionProperties: this.sessionProperties,
              scopedProperties: this.scopedProperties,
            })),
          await this.requestAccounts()
        );
      }
      async disconnect() {
        var e;
        if (!this.session)
          throw new Error("Please call connect() before enable()");
        await this.client.disconnect({
          topic: (e = this.session) == null ? void 0 : e.topic,
          reason: Ge("USER_DISCONNECTED"),
        }),
          await this.cleanup();
      }
      async connect(e) {
        if (!this.client) throw new Error("Sign Client not initialized");
        if (
          (this.setNamespaces(e),
          await this.cleanupPendingPairings(),
          !e.skipPairing)
        )
          return await this.pair(e.pairingTopic);
      }
      async authenticate(e, r) {
        if (!this.client) throw new Error("Sign Client not initialized");
        this.setNamespaces(e), await this.cleanupPendingPairings();
        const { uri: i, response: s } = await this.client.authenticate(e, r);
        i && ((this.uri = i), this.events.emit("display_uri", i));
        const n = await s();
        if (((this.session = n.session), this.session)) {
          const o = D8(this.session.namespaces);
          (this.namespaces = Sw(this.namespaces, o)),
            await this.persist("namespaces", this.namespaces),
            this.onConnect();
        }
        return n;
      }
      on(e, r) {
        this.events.on(e, r);
      }
      once(e, r) {
        this.events.once(e, r);
      }
      removeListener(e, r) {
        this.events.removeListener(e, r);
      }
      off(e, r) {
        this.events.off(e, r);
      }
      get isWalletConnect() {
        return !0;
      }
      async pair(e) {
        const { uri: r, approval: i } = await this.client.connect({
          pairingTopic: e,
          requiredNamespaces: this.namespaces,
          optionalNamespaces: this.optionalNamespaces,
          sessionProperties: this.sessionProperties,
          scopedProperties: this.scopedProperties,
        });
        r && ((this.uri = r), this.events.emit("display_uri", r));
        const s = await i();
        this.session = s;
        const n = D8(s.namespaces);
        return (
          (this.namespaces = Sw(this.namespaces, n)),
          await this.persist("namespaces", this.namespaces),
          await this.persist("optionalNamespaces", this.optionalNamespaces),
          this.onConnect(),
          this.session
        );
      }
      setDefaultChain(e, r) {
        try {
          if (!this.session) return;
          const [i, s] = this.validateChain(e),
            n = this.getProvider(i);
          n.name === Pc
            ? n.setDefaultChain(`${i}:${s}`, r)
            : n.setDefaultChain(s, r);
        } catch (i) {
          if (!/Please call connect/.test(i.message)) throw i;
        }
      }
      async cleanupPendingPairings(e = {}) {
        this.logger.info("Cleaning up inactive pairings...");
        const r = this.client.pairing.getAll();
        if (Qi(r)) {
          for (const i of r)
            e.deletePairings
              ? this.client.core.expirer.set(i.topic, 0)
              : await this.client.core.relayer.subscriber.unsubscribe(i.topic);
          this.logger.info(`Inactive pairings cleared: ${r.length}`);
        }
      }
      abortPairingAttempt() {
        this.logger.warn(
          "abortPairingAttempt is deprecated. This is now a no-op."
        );
      }
      async checkStorage() {
        (this.namespaces = (await this.getFromStore("namespaces")) || {}),
          (this.optionalNamespaces =
            (await this.getFromStore("optionalNamespaces")) || {}),
          this.session && this.createProviders();
      }
      async initialize() {
        this.logger.trace("Initialized"),
          await this.createClient(),
          await this.checkStorage(),
          this.registerEventListeners();
      }
      async createClient() {
        var e, r;
        if (
          ((this.client =
            this.providerOpts.client ||
            (await Cw.init({
              core: this.providerOpts.core,
              logger: this.providerOpts.logger || x8,
              relayUrl: this.providerOpts.relayUrl || Wq,
              projectId: this.providerOpts.projectId,
              metadata: this.providerOpts.metadata,
              storageOptions: this.providerOpts.storageOptions,
              storage: this.providerOpts.storage,
              name: this.providerOpts.name,
              customStoragePrefix: this.providerOpts.customStoragePrefix,
              telemetryEnabled: this.providerOpts.telemetryEnabled,
            }))),
          this.providerOpts.session)
        )
          try {
            this.session = this.client.session.get(
              this.providerOpts.session.topic
            );
          } catch (i) {
            throw (
              (this.logger.error("Failed to get session", i),
              new Error(
                `The provided session: ${
                  (r = (e = this.providerOpts) == null ? void 0 : e.session) ==
                  null
                    ? void 0
                    : r.topic
                } doesn't exist in the Sign client`
              ))
            );
          }
        else {
          const i = this.client.session.getAll();
          this.session = i[0];
        }
        this.logger.trace("SignClient Initialized");
      }
      createProviders() {
        if (!this.client) throw new Error("Sign Client not initialized");
        if (!this.session)
          throw new Error(
            "Session not initialized. Please call connect() before enable()"
          );
        const e = [
          ...new Set(Object.keys(this.session.namespaces).map((r) => Pu(r))),
        ];
        Ow("client", this.client),
          Ow("events", this.events),
          Ow("disableProviderPing", this.disableProviderPing),
          e.forEach((r) => {
            if (!this.session) return;
            const i = OH(r, this.session),
              s = B8(i),
              n = Sw(this.namespaces, this.optionalNamespaces),
              o = kw(Gp({}, n[r]), { accounts: i, chains: s });
            switch (r) {
              case "eip155":
                this.rpcProviders[r] = new UH({ namespace: o });
                break;
              case "algorand":
                this.rpcProviders[r] = new KH({ namespace: o });
                break;
              case "solana":
                this.rpcProviders[r] = new MH({ namespace: o });
                break;
              case "cosmos":
                this.rpcProviders[r] = new HH({ namespace: o });
                break;
              case "polkadot":
                this.rpcProviders[r] = new kH({ namespace: o });
                break;
              case "cip34":
                this.rpcProviders[r] = new YH({ namespace: o });
                break;
              case "elrond":
                this.rpcProviders[r] = new QH({ namespace: o });
                break;
              case "multiversx":
                this.rpcProviders[r] = new rV({ namespace: o });
                break;
              case "near":
                this.rpcProviders[r] = new nV({ namespace: o });
                break;
              case "tezos":
                this.rpcProviders[r] = new cV({ namespace: o });
                break;
              default:
                this.rpcProviders[Pc]
                  ? this.rpcProviders[Pc].updateNamespace(o)
                  : (this.rpcProviders[Pc] = new hV({ namespace: o }));
            }
          });
      }
      registerEventListeners() {
        if (typeof this.client > "u")
          throw new Error("Sign Client is not initialized");
        this.client.on("session_ping", (e) => {
          var r;
          const { topic: i } = e;
          i === ((r = this.session) == null ? void 0 : r.topic) &&
            this.events.emit("session_ping", e);
        }),
          this.client.on("session_event", (e) => {
            var r;
            const { params: i, topic: s } = e;
            if (s !== ((r = this.session) == null ? void 0 : r.topic)) return;
            const { event: n } = i;
            if (n.name === "accountsChanged") {
              const o = n.data;
              o && Qi(o) && this.events.emit("accountsChanged", o.map(U8));
            } else if (n.name === "chainChanged") {
              const o = i.chainId,
                a = i.event.data,
                c = Pu(o),
                l = Pw(o) !== Pw(a) ? `${c}:${Pw(a)}` : o;
              this.onChainChanged(l);
            } else this.events.emit(n.name, n.data);
            this.events.emit("session_event", e);
          }),
          this.client.on("session_update", ({ topic: e, params: r }) => {
            var i, s;
            if (e !== ((i = this.session) == null ? void 0 : i.topic)) return;
            const { namespaces: n } = r,
              o = (s = this.client) == null ? void 0 : s.session.get(e);
            (this.session = kw(Gp({}, o), { namespaces: n })),
              this.onSessionUpdate(),
              this.events.emit("session_update", { topic: e, params: r });
          }),
          this.client.on("session_delete", async (e) => {
            var r;
            e.topic === ((r = this.session) == null ? void 0 : r.topic) &&
              (await this.cleanup(),
              this.events.emit("session_delete", e),
              this.events.emit(
                "disconnect",
                kw(Gp({}, Ge("USER_DISCONNECTED")), { data: e.topic })
              ));
          }),
          this.on($i.DEFAULT_CHAIN_CHANGED, (e) => {
            this.onChainChanged(e, !0);
          });
      }
      getProvider(e) {
        return this.rpcProviders[e] || this.rpcProviders[Pc];
      }
      onSessionUpdate() {
        Object.keys(this.rpcProviders).forEach((e) => {
          var r;
          this.getProvider(e).updateNamespace(
            (r = this.session) == null ? void 0 : r.namespaces[e]
          );
        });
      }
      setNamespaces(e) {
        const {
          namespaces: r,
          optionalNamespaces: i,
          sessionProperties: s,
          scopedProperties: n,
        } = e;
        r && Object.keys(r).length && (this.namespaces = r),
          i && Object.keys(i).length && (this.optionalNamespaces = i),
          (this.sessionProperties = s),
          (this.scopedProperties = n);
      }
      validateChain(e) {
        const [r, i] = e?.split(":") || ["", ""];
        if (!this.namespaces || !Object.keys(this.namespaces).length)
          return [r, i];
        if (
          r &&
          !Object.keys(this.namespaces || {})
            .map((o) => Pu(o))
            .includes(r)
        )
          throw new Error(
            `Namespace '${r}' is not configured. Please call connect() first with namespace config.`
          );
        if (r && i) return [r, i];
        const s = Pu(Object.keys(this.namespaces)[0]),
          n = this.rpcProviders[s].getDefaultChain();
        return [s, n];
      }
      async requestAccounts() {
        const [e] = this.validateChain();
        return await this.getProvider(e).requestAccounts();
      }
      async onChainChanged(e, r = !1) {
        if (!this.namespaces) return;
        const [i, s] = this.validateChain(e);
        if (!s) return;
        this.updateNamespaceChain(i, s), this.events.emit("chainChanged", s);
        const n = this.getProvider(i).getDefaultChain();
        r || this.getProvider(i).setDefaultChain(s),
          this.emitAccountsChangedOnChainChange({
            namespace: i,
            previousChainId: n,
            newChainId: e,
          }),
          await this.persist("namespaces", this.namespaces);
      }
      emitAccountsChangedOnChainChange({
        namespace: e,
        previousChainId: r,
        newChainId: i,
      }) {
        var s, n;
        try {
          if (r === i) return;
          const o =
            (n = (s = this.session) == null ? void 0 : s.namespaces[e]) == null
              ? void 0
              : n.accounts;
          if (!o) return;
          const a = o.filter((c) => c.includes(`${i}:`)).map(U8);
          if (!Qi(a)) return;
          this.events.emit("accountsChanged", a);
        } catch (o) {
          this.logger.warn("Failed to emit accountsChanged on chain change", o);
        }
      }
      updateNamespaceChain(e, r) {
        if (!this.namespaces) return;
        const i = this.namespaces[e] ? e : `${e}:${r}`,
          s = { chains: [], methods: [], events: [], defaultChain: r };
        this.namespaces[i]
          ? this.namespaces[i] && (this.namespaces[i].defaultChain = r)
          : (this.namespaces[i] = s);
      }
      onConnect() {
        this.createProviders(),
          this.events.emit("connect", { session: this.session });
      }
      async cleanup() {
        (this.namespaces = void 0),
          (this.optionalNamespaces = void 0),
          (this.sessionProperties = void 0),
          await this.deleteFromStore("namespaces"),
          await this.deleteFromStore("optionalNamespaces"),
          await this.deleteFromStore("sessionProperties"),
          (this.session = void 0),
          await this.cleanupPendingPairings({ deletePairings: !0 }),
          await this.cleanupStorage();
      }
      async persist(e, r) {
        var i;
        const s = ((i = this.session) == null ? void 0 : i.topic) || "";
        await this.client.core.storage.setItem(`${Wp}/${e}${s}`, r);
      }
      async getFromStore(e) {
        var r;
        const i = ((r = this.session) == null ? void 0 : r.topic) || "";
        return await this.client.core.storage.getItem(`${Wp}/${e}${i}`);
      }
      async deleteFromStore(e) {
        var r;
        const i = ((r = this.session) == null ? void 0 : r.topic) || "";
        await this.client.core.storage.removeItem(`${Wp}/${e}${i}`);
      }
      async cleanupStorage() {
        var e;
        try {
          if (((e = this.client) == null ? void 0 : e.session.length) > 0)
            return;
          const r = await this.client.core.storage.getKeys();
          for (const i of r)
            i.startsWith(Wp) && (await this.client.core.storage.removeItem(i));
        } catch (r) {
          this.logger.warn("Failed to cleanup storage", r);
        }
      }
    }
    const mV = Rw,
      yV = "wc",
      bV = "ethereum_provider",
      vV = `${yV}@2:${bV}:`,
      EV = "https://rpc.walletconnect.org/v1/",
      Zp = ["eth_sendTransaction", "personal_sign"],
      V8 = [
        "eth_accounts",
        "eth_requestAccounts",
        "eth_sendRawTransaction",
        "eth_sign",
        "eth_signTransaction",
        "eth_signTypedData",
        "eth_signTypedData_v3",
        "eth_signTypedData_v4",
        "eth_sendTransaction",
        "personal_sign",
        "wallet_switchEthereumChain",
        "wallet_addEthereumChain",
        "wallet_getPermissions",
        "wallet_requestPermissions",
        "wallet_registerOnboarding",
        "wallet_watchAsset",
        "wallet_scanQRCode",
        "wallet_sendCalls",
        "wallet_getCapabilities",
        "wallet_getCallsStatus",
        "wallet_showCallsStatus",
      ],
      Yp = ["chainChanged", "accountsChanged"],
      W8 = [
        "chainChanged",
        "accountsChanged",
        "message",
        "disconnect",
        "connect",
      ],
      CV = async () => {
        const { createAppKit: t } = await Promise.resolve().then(function () {
          return ole;
        });
        return t;
      };
    var xV = Object.defineProperty,
      IV = Object.defineProperties,
      _V = Object.getOwnPropertyDescriptors,
      K8 = Object.getOwnPropertySymbols,
      AV = Object.prototype.hasOwnProperty,
      SV = Object.prototype.propertyIsEnumerable,
      $w = (t, e, r) =>
        e in t
          ? xV(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Yo = (t, e) => {
        for (var r in e || (e = {})) AV.call(e, r) && $w(t, r, e[r]);
        if (K8) for (var r of K8(e)) SV.call(e, r) && $w(t, r, e[r]);
        return t;
      },
      Vu = (t, e) => IV(t, _V(e)),
      fi = (t, e, r) => $w(t, typeof e != "symbol" ? e + "" : e, r);
    function Jp(t) {
      return Number(t[0].split(":")[1]);
    }
    function Xp(t) {
      return `0x${t.toString(16)}`;
    }
    function PV(t) {
      const {
        chains: e,
        optionalChains: r,
        methods: i,
        optionalMethods: s,
        events: n,
        optionalEvents: o,
        rpcMap: a,
      } = t;
      if (!Qi(e)) throw new Error("Invalid chains");
      const c = {
          chains: e,
          methods: i || Zp,
          events: n || Yp,
          rpcMap: Yo({}, e.length ? { [Jp(e)]: a[Jp(e)] } : {}),
        },
        l = n?.filter((g) => !Yp.includes(g)),
        u = i?.filter((g) => !Zp.includes(g));
      if (
        !r &&
        !o &&
        !s &&
        !(l != null && l.length) &&
        !(u != null && u.length)
      )
        return { required: e.length ? c : void 0 };
      const h = (l?.length && u?.length) || !r,
        d = {
          chains: [...new Set(h ? c.chains.concat(r || []) : r)],
          methods: [
            ...new Set(c.methods.concat(s != null && s.length ? s : V8)),
          ],
          events: [...new Set(c.events.concat(o != null && o.length ? o : W8))],
          rpcMap: a,
        };
      return {
        required: e.length ? c : void 0,
        optional: r.length ? d : void 0,
      };
    }
    class Qp {
      constructor() {
        fi(this, "events", new rt.exports.EventEmitter()),
          fi(this, "namespace", "eip155"),
          fi(this, "accounts", []),
          fi(this, "signer"),
          fi(this, "chainId", 1),
          fi(this, "modal"),
          fi(this, "rpc"),
          fi(this, "STORAGE_KEY", vV),
          fi(this, "on", (e, r) => (this.events.on(e, r), this)),
          fi(this, "once", (e, r) => (this.events.once(e, r), this)),
          fi(
            this,
            "removeListener",
            (e, r) => (this.events.removeListener(e, r), this)
          ),
          fi(this, "off", (e, r) => (this.events.off(e, r), this)),
          fi(this, "parseAccount", (e) =>
            this.isCompatibleChainId(e) ? this.parseAccountId(e).address : e
          ),
          (this.signer = {}),
          (this.rpc = {});
      }
      static async init(e) {
        const r = new Qp();
        return await r.initialize(e), r;
      }
      async request(e, r) {
        return await this.signer.request(
          e,
          this.formatChainId(this.chainId),
          r
        );
      }
      sendAsync(e, r, i) {
        this.signer.sendAsync(e, r, this.formatChainId(this.chainId), i);
      }
      get connected() {
        return this.signer.client
          ? this.signer.client.core.relayer.connected
          : !1;
      }
      get connecting() {
        return this.signer.client
          ? this.signer.client.core.relayer.connecting
          : !1;
      }
      async enable() {
        return (
          this.session || (await this.connect()),
          await this.request({ method: "eth_requestAccounts" })
        );
      }
      async connect(e) {
        var r;
        if (!this.signer.client)
          throw new Error("Provider not initialized. Call init() first");
        this.loadConnectOpts(e);
        const { required: i, optional: s } = PV(this.rpc);
        try {
          const n = await new Promise(async (a, c) => {
            var l, u;
            this.rpc.showQrModal &&
              ((l = this.modal) == null || l.open(),
              (u = this.modal) == null ||
                u.subscribeState((d) => {
                  !d.open &&
                    !this.signer.session &&
                    (this.signer.abortPairingAttempt(),
                    c(
                      new Error("Connection request reset. Please try again.")
                    ));
                }));
            const h =
              e != null && e.scopedProperties
                ? { [this.namespace]: e.scopedProperties }
                : void 0;
            await this.signer
              .connect(
                Vu(
                  Yo(
                    { namespaces: Yo({}, i && { [this.namespace]: i }) },
                    s && { optionalNamespaces: { [this.namespace]: s } }
                  ),
                  { pairingTopic: e?.pairingTopic, scopedProperties: h }
                )
              )
              .then((d) => {
                a(d);
              })
              .catch((d) => {
                var g;
                (g = this.modal) == null ||
                  g.showErrorMessage("Unable to connect"),
                  c(new Error(d.message));
              });
          });
          if (!n) return;
          const o = p5(n.namespaces, [this.namespace]);
          this.setChainIds(this.rpc.chains.length ? this.rpc.chains : o),
            this.setAccounts(o),
            this.events.emit("connect", { chainId: Xp(this.chainId) });
        } catch (n) {
          throw (this.signer.logger.error(n), n);
        } finally {
          (r = this.modal) == null || r.close();
        }
      }
      async authenticate(e, r) {
        var i;
        if (!this.signer.client)
          throw new Error("Provider not initialized. Call init() first");
        this.loadConnectOpts({ chains: e?.chains });
        try {
          const s = await new Promise(async (o, a) => {
              var c, l;
              this.rpc.showQrModal &&
                ((c = this.modal) == null || c.open(),
                (l = this.modal) == null ||
                  l.subscribeState((u) => {
                    !u.open &&
                      !this.signer.session &&
                      (this.signer.abortPairingAttempt(),
                      a(
                        new Error("Connection request reset. Please try again.")
                      ));
                  })),
                await this.signer
                  .authenticate(Vu(Yo({}, e), { chains: this.rpc.chains }), r)
                  .then((u) => {
                    o(u);
                  })
                  .catch((u) => {
                    var h;
                    (h = this.modal) == null ||
                      h.showErrorMessage("Unable to connect"),
                      a(new Error(u.message));
                  });
            }),
            n = s.session;
          if (n) {
            const o = p5(n.namespaces, [this.namespace]);
            this.setChainIds(this.rpc.chains.length ? this.rpc.chains : o),
              this.setAccounts(o),
              this.events.emit("connect", { chainId: Xp(this.chainId) });
          }
          return s;
        } catch (s) {
          throw (this.signer.logger.error(s), s);
        } finally {
          (i = this.modal) == null || i.close();
        }
      }
      async disconnect() {
        this.session && (await this.signer.disconnect()), this.reset();
      }
      get isWalletConnect() {
        return !0;
      }
      get session() {
        return this.signer.session;
      }
      registerEventListeners() {
        this.signer.on("session_event", (e) => {
          const { params: r } = e,
            { event: i } = r;
          i.name === "accountsChanged"
            ? ((this.accounts = this.parseAccounts(i.data)),
              this.events.emit("accountsChanged", this.accounts))
            : i.name === "chainChanged"
            ? this.setChainId(this.formatChainId(i.data))
            : this.events.emit(i.name, i.data),
            this.events.emit("session_event", e);
        }),
          this.signer.on("accountsChanged", (e) => {
            (this.accounts = this.parseAccounts(e)),
              this.events.emit("accountsChanged", this.accounts);
          }),
          this.signer.on("chainChanged", (e) => {
            const r = parseInt(e);
            (this.chainId = r),
              this.events.emit("chainChanged", Xp(this.chainId)),
              this.persist();
          }),
          this.signer.on("session_update", (e) => {
            this.events.emit("session_update", e);
          }),
          this.signer.on("session_delete", (e) => {
            this.reset(),
              this.events.emit("session_delete", e),
              this.events.emit(
                "disconnect",
                Vu(Yo({}, Ge("USER_DISCONNECTED")), {
                  data: e.topic,
                  name: "USER_DISCONNECTED",
                })
              );
          }),
          this.signer.on("display_uri", (e) => {
            this.events.emit("display_uri", e);
          });
      }
      switchEthereumChain(e) {
        this.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: e.toString(16) }],
        });
      }
      isCompatibleChainId(e) {
        return typeof e == "string" ? e.startsWith(`${this.namespace}:`) : !1;
      }
      formatChainId(e) {
        return `${this.namespace}:${e}`;
      }
      parseChainId(e) {
        return Number(e.split(":")[1]);
      }
      setChainIds(e) {
        const r = e
          .filter((i) => this.isCompatibleChainId(i))
          .map((i) => this.parseChainId(i));
        r.length &&
          ((this.chainId = r[0]),
          this.events.emit("chainChanged", Xp(this.chainId)),
          this.persist());
      }
      setChainId(e) {
        if (this.isCompatibleChainId(e)) {
          const r = this.parseChainId(e);
          (this.chainId = r), this.switchEthereumChain(r);
        }
      }
      parseAccountId(e) {
        const [r, i, s] = e.split(":");
        return { chainId: `${r}:${i}`, address: s };
      }
      setAccounts(e) {
        (this.accounts = e
          .filter(
            (r) =>
              this.parseChainId(this.parseAccountId(r).chainId) === this.chainId
          )
          .map((r) => this.parseAccountId(r).address)),
          this.events.emit("accountsChanged", this.accounts);
      }
      getRpcConfig(e) {
        var r, i;
        const s = (r = e?.chains) != null ? r : [],
          n = (i = e?.optionalChains) != null ? i : [],
          o = s.concat(n);
        if (!o.length)
          throw new Error(
            "No chains specified in either `chains` or `optionalChains`"
          );
        const a = s.length ? e?.methods || Zp : [],
          c = s.length ? e?.events || Yp : [],
          l = e?.optionalMethods || [],
          u = e?.optionalEvents || [],
          h = e?.rpcMap || this.buildRpcMap(o, e.projectId),
          d = e?.qrModalOptions || void 0;
        return {
          chains: s?.map((g) => this.formatChainId(g)),
          optionalChains: n.map((g) => this.formatChainId(g)),
          methods: a,
          events: c,
          optionalMethods: l,
          optionalEvents: u,
          rpcMap: h,
          showQrModal: !!(e != null && e.showQrModal),
          qrModalOptions: d,
          projectId: e.projectId,
          metadata: e.metadata,
        };
      }
      buildRpcMap(e, r) {
        const i = {};
        return (
          e.forEach((s) => {
            i[s] = this.getRpcUrl(s, r);
          }),
          i
        );
      }
      async initialize(e) {
        if (
          ((this.rpc = this.getRpcConfig(e)),
          (this.chainId = this.rpc.chains.length
            ? Jp(this.rpc.chains)
            : Jp(this.rpc.optionalChains)),
          (this.signer = await mV.init({
            projectId: this.rpc.projectId,
            metadata: this.rpc.metadata,
            disableProviderPing: e.disableProviderPing,
            relayUrl: e.relayUrl,
            storage: e.storage,
            storageOptions: e.storageOptions,
            customStoragePrefix: e.customStoragePrefix,
            telemetryEnabled: e.telemetryEnabled,
            logger: e.logger,
          })),
          this.registerEventListeners(),
          await this.loadPersistedSession(),
          this.rpc.showQrModal)
        ) {
          let r;
          try {
            const i = await CV(),
              { convertWCMToAppKitOptions: s } = await Promise.resolve().then(
                function () {
                  return wle;
                }
              ),
              n = s(
                Vu(Yo({}, this.rpc.qrModalOptions), {
                  chains: [
                    ...new Set([
                      ...this.rpc.chains,
                      ...this.rpc.optionalChains,
                    ]),
                  ],
                  metadata: this.rpc.metadata,
                  projectId: this.rpc.projectId,
                })
              );
            if (!n.networks.length)
              throw new Error("No networks found for WalletConnect\xB7");
            r = i(
              Vu(Yo({}, n), {
                universalProvider: this.signer,
                manualWCControl: !0,
              })
            );
          } catch (i) {
            throw (
              (console.warn(i),
              new Error(
                "To use QR modal, please install @reown/appkit package"
              ))
            );
          }
          if (r)
            try {
              this.modal = r;
            } catch (i) {
              throw (
                (this.signer.logger.error(i),
                new Error("Could not generate WalletConnectModal Instance"))
              );
            }
        }
      }
      loadConnectOpts(e) {
        if (!e) return;
        const { chains: r, optionalChains: i, rpcMap: s } = e;
        r &&
          Qi(r) &&
          ((this.rpc.chains = r.map((n) => this.formatChainId(n))),
          r.forEach((n) => {
            this.rpc.rpcMap[n] = s?.[n] || this.getRpcUrl(n);
          })),
          i &&
            Qi(i) &&
            ((this.rpc.optionalChains = []),
            (this.rpc.optionalChains = i?.map((n) => this.formatChainId(n))),
            i.forEach((n) => {
              this.rpc.rpcMap[n] = s?.[n] || this.getRpcUrl(n);
            }));
      }
      getRpcUrl(e, r) {
        var i;
        return (
          ((i = this.rpc.rpcMap) == null ? void 0 : i[e]) ||
          `${EV}?chainId=eip155:${e}&projectId=${r || this.rpc.projectId}`
        );
      }
      async loadPersistedSession() {
        if (this.session)
          try {
            const e = await this.signer.client.core.storage.getItem(
                `${this.STORAGE_KEY}/chainId`
              ),
              r = this.session.namespaces[`${this.namespace}:${e}`]
                ? this.session.namespaces[`${this.namespace}:${e}`]
                : this.session.namespaces[this.namespace];
            this.setChainIds(e ? [this.formatChainId(e)] : r?.accounts),
              this.setAccounts(r?.accounts);
          } catch (e) {
            this.signer.logger.error(
              "Failed to load persisted session, clearing state..."
            ),
              this.signer.logger.error(e),
              await this.disconnect().catch((r) => this.signer.logger.warn(r));
          }
      }
      reset() {
        (this.chainId = 1), (this.accounts = []);
      }
      persist() {
        this.session &&
          this.signer.client.core.storage.setItem(
            `${this.STORAGE_KEY}/chainId`,
            this.chainId
          );
      }
      parseAccounts(e) {
        return typeof e == "string" || e instanceof String
          ? [this.parseAccount(e)]
          : e.map((r) => this.parseAccount(r));
      }
    }
    const OV = Qp;
    var G8 = { exports: {} };
    (function (t, e) {
      (function (r, i) {
        t.exports = i();
      })(qt, function () {
        var r = 1e3,
          i = 6e4,
          s = 36e5,
          n = "millisecond",
          o = "second",
          a = "minute",
          c = "hour",
          l = "day",
          u = "week",
          h = "month",
          d = "quarter",
          g = "year",
          p = "date",
          w = "Invalid Date",
          f =
            /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
          m =
            /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
          y = {
            name: "en",
            weekdays:
              "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split(
                "_"
              ),
            months:
              "January_February_March_April_May_June_July_August_September_October_November_December".split(
                "_"
              ),
            ordinal: function (I) {
              var b = ["th", "st", "nd", "rd"],
                v = I % 100;
              return "[" + I + (b[(v - 20) % 10] || b[v] || b[0]) + "]";
            },
          },
          E = function (I, b, v) {
            var S = String(I);
            return !S || S.length >= b
              ? I
              : "" + Array(b + 1 - S.length).join(v) + I;
          },
          C = {
            s: E,
            z: function (I) {
              var b = -I.utcOffset(),
                v = Math.abs(b),
                S = Math.floor(v / 60),
                T = v % 60;
              return (b <= 0 ? "+" : "-") + E(S, 2, "0") + ":" + E(T, 2, "0");
            },
            m: function I(b, v) {
              if (b.date() < v.date()) return -I(v, b);
              var S = 12 * (v.year() - b.year()) + (v.month() - b.month()),
                T = b.clone().add(S, h),
                _ = v - T < 0,
                R = b.clone().add(S + (_ ? -1 : 1), h);
              return +(-(S + (v - T) / (_ ? T - R : R - T)) || 0);
            },
            a: function (I) {
              return I < 0 ? Math.ceil(I) || 0 : Math.floor(I);
            },
            p: function (I) {
              return (
                { M: h, y: g, w: u, d: l, D: p, h: c, m: a, s: o, ms: n, Q: d }[
                  I
                ] ||
                String(I || "")
                  .toLowerCase()
                  .replace(/s$/, "")
              );
            },
            u: function (I) {
              return I === void 0;
            },
          },
          O = "en",
          A = {};
        A[O] = y;
        var P = "$isDayjsObject",
          N = function (I) {
            return I instanceof F || !(!I || !I[P]);
          },
          x = function I(b, v, S) {
            var T;
            if (!b) return O;
            if (typeof b == "string") {
              var _ = b.toLowerCase();
              A[_] && (T = _), v && ((A[_] = v), (T = _));
              var R = b.split("-");
              if (!T && R.length > 1) return I(R[0]);
            } else {
              var U = b.name;
              (A[U] = b), (T = U);
            }
            return !S && T && (O = T), T || (!S && O);
          },
          $ = function (I, b) {
            if (N(I)) return I.clone();
            var v = typeof b == "object" ? b : {};
            return (v.date = I), (v.args = arguments), new F(v);
          },
          k = C;
        (k.l = x),
          (k.i = N),
          (k.w = function (I, b) {
            return $(I, {
              locale: b.$L,
              utc: b.$u,
              x: b.$x,
              $offset: b.$offset,
            });
          });
        var F = (function () {
            function I(v) {
              (this.$L = x(v.locale, null, !0)),
                this.parse(v),
                (this.$x = this.$x || v.x || {}),
                (this[P] = !0);
            }
            var b = I.prototype;
            return (
              (b.parse = function (v) {
                (this.$d = (function (S) {
                  var T = S.date,
                    _ = S.utc;
                  if (T === null) return new Date(NaN);
                  if (k.u(T)) return new Date();
                  if (T instanceof Date) return new Date(T);
                  if (typeof T == "string" && !/Z$/i.test(T)) {
                    var R = T.match(f);
                    if (R) {
                      var U = R[2] - 1 || 0,
                        D = (R[7] || "0").substring(0, 3);
                      return _
                        ? new Date(
                            Date.UTC(
                              R[1],
                              U,
                              R[3] || 1,
                              R[4] || 0,
                              R[5] || 0,
                              R[6] || 0,
                              D
                            )
                          )
                        : new Date(
                            R[1],
                            U,
                            R[3] || 1,
                            R[4] || 0,
                            R[5] || 0,
                            R[6] || 0,
                            D
                          );
                    }
                  }
                  return new Date(T);
                })(v)),
                  this.init();
              }),
              (b.init = function () {
                var v = this.$d;
                (this.$y = v.getFullYear()),
                  (this.$M = v.getMonth()),
                  (this.$D = v.getDate()),
                  (this.$W = v.getDay()),
                  (this.$H = v.getHours()),
                  (this.$m = v.getMinutes()),
                  (this.$s = v.getSeconds()),
                  (this.$ms = v.getMilliseconds());
              }),
              (b.$utils = function () {
                return k;
              }),
              (b.isValid = function () {
                return this.$d.toString() !== w;
              }),
              (b.isSame = function (v, S) {
                var T = $(v);
                return this.startOf(S) <= T && T <= this.endOf(S);
              }),
              (b.isAfter = function (v, S) {
                return $(v) < this.startOf(S);
              }),
              (b.isBefore = function (v, S) {
                return this.endOf(S) < $(v);
              }),
              (b.$g = function (v, S, T) {
                return k.u(v) ? this[S] : this.set(T, v);
              }),
              (b.unix = function () {
                return Math.floor(this.valueOf() / 1e3);
              }),
              (b.valueOf = function () {
                return this.$d.getTime();
              }),
              (b.startOf = function (v, S) {
                var T = this,
                  _ = !!k.u(S) || S,
                  R = k.p(v),
                  U = function (te, ve) {
                    var Ee = k.w(
                      T.$u ? Date.UTC(T.$y, ve, te) : new Date(T.$y, ve, te),
                      T
                    );
                    return _ ? Ee : Ee.endOf(l);
                  },
                  D = function (te, ve) {
                    return k.w(
                      T.toDate()[te].apply(
                        T.toDate("s"),
                        (_ ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(ve)
                      ),
                      T
                    );
                  },
                  H = this.$W,
                  q = this.$M,
                  V = this.$D,
                  Y = "set" + (this.$u ? "UTC" : "");
                switch (R) {
                  case g:
                    return _ ? U(1, 0) : U(31, 11);
                  case h:
                    return _ ? U(1, q) : U(0, q + 1);
                  case u:
                    var ae = this.$locale().weekStart || 0,
                      re = (H < ae ? H + 7 : H) - ae;
                    return U(_ ? V - re : V + (6 - re), q);
                  case l:
                  case p:
                    return D(Y + "Hours", 0);
                  case c:
                    return D(Y + "Minutes", 1);
                  case a:
                    return D(Y + "Seconds", 2);
                  case o:
                    return D(Y + "Milliseconds", 3);
                  default:
                    return this.clone();
                }
              }),
              (b.endOf = function (v) {
                return this.startOf(v, !1);
              }),
              (b.$set = function (v, S) {
                var T,
                  _ = k.p(v),
                  R = "set" + (this.$u ? "UTC" : ""),
                  U = ((T = {}),
                  (T[l] = R + "Date"),
                  (T[p] = R + "Date"),
                  (T[h] = R + "Month"),
                  (T[g] = R + "FullYear"),
                  (T[c] = R + "Hours"),
                  (T[a] = R + "Minutes"),
                  (T[o] = R + "Seconds"),
                  (T[n] = R + "Milliseconds"),
                  T)[_],
                  D = _ === l ? this.$D + (S - this.$W) : S;
                if (_ === h || _ === g) {
                  var H = this.clone().set(p, 1);
                  H.$d[U](D),
                    H.init(),
                    (this.$d = H.set(p, Math.min(this.$D, H.daysInMonth())).$d);
                } else U && this.$d[U](D);
                return this.init(), this;
              }),
              (b.set = function (v, S) {
                return this.clone().$set(v, S);
              }),
              (b.get = function (v) {
                return this[k.p(v)]();
              }),
              (b.add = function (v, S) {
                var T,
                  _ = this;
                v = Number(v);
                var R = k.p(S),
                  U = function (q) {
                    var V = $(_);
                    return k.w(V.date(V.date() + Math.round(q * v)), _);
                  };
                if (R === h) return this.set(h, this.$M + v);
                if (R === g) return this.set(g, this.$y + v);
                if (R === l) return U(1);
                if (R === u) return U(7);
                var D =
                    ((T = {}), (T[a] = i), (T[c] = s), (T[o] = r), T)[R] || 1,
                  H = this.$d.getTime() + v * D;
                return k.w(H, this);
              }),
              (b.subtract = function (v, S) {
                return this.add(-1 * v, S);
              }),
              (b.format = function (v) {
                var S = this,
                  T = this.$locale();
                if (!this.isValid()) return T.invalidDate || w;
                var _ = v || "YYYY-MM-DDTHH:mm:ssZ",
                  R = k.z(this),
                  U = this.$H,
                  D = this.$m,
                  H = this.$M,
                  q = T.weekdays,
                  V = T.months,
                  Y = T.meridiem,
                  ae = function (ve, Ee, Ce, Ie) {
                    return (ve && (ve[Ee] || ve(S, _))) || Ce[Ee].slice(0, Ie);
                  },
                  re = function (ve) {
                    return k.s(U % 12 || 12, ve, "0");
                  },
                  te =
                    Y ||
                    function (ve, Ee, Ce) {
                      var Ie = ve < 12 ? "AM" : "PM";
                      return Ce ? Ie.toLowerCase() : Ie;
                    };
                return _.replace(m, function (ve, Ee) {
                  return (
                    Ee ||
                    (function (Ce) {
                      switch (Ce) {
                        case "YY":
                          return String(S.$y).slice(-2);
                        case "YYYY":
                          return k.s(S.$y, 4, "0");
                        case "M":
                          return H + 1;
                        case "MM":
                          return k.s(H + 1, 2, "0");
                        case "MMM":
                          return ae(T.monthsShort, H, V, 3);
                        case "MMMM":
                          return ae(V, H);
                        case "D":
                          return S.$D;
                        case "DD":
                          return k.s(S.$D, 2, "0");
                        case "d":
                          return String(S.$W);
                        case "dd":
                          return ae(T.weekdaysMin, S.$W, q, 2);
                        case "ddd":
                          return ae(T.weekdaysShort, S.$W, q, 3);
                        case "dddd":
                          return q[S.$W];
                        case "H":
                          return String(U);
                        case "HH":
                          return k.s(U, 2, "0");
                        case "h":
                          return re(1);
                        case "hh":
                          return re(2);
                        case "a":
                          return te(U, D, !0);
                        case "A":
                          return te(U, D, !1);
                        case "m":
                          return String(D);
                        case "mm":
                          return k.s(D, 2, "0");
                        case "s":
                          return String(S.$s);
                        case "ss":
                          return k.s(S.$s, 2, "0");
                        case "SSS":
                          return k.s(S.$ms, 3, "0");
                        case "Z":
                          return R;
                      }
                      return null;
                    })(ve) ||
                    R.replace(":", "")
                  );
                });
              }),
              (b.utcOffset = function () {
                return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
              }),
              (b.diff = function (v, S, T) {
                var _,
                  R = this,
                  U = k.p(S),
                  D = $(v),
                  H = (D.utcOffset() - this.utcOffset()) * i,
                  q = this - D,
                  V = function () {
                    return k.m(R, D);
                  };
                switch (U) {
                  case g:
                    _ = V() / 12;
                    break;
                  case h:
                    _ = V();
                    break;
                  case d:
                    _ = V() / 3;
                    break;
                  case u:
                    _ = (q - H) / 6048e5;
                    break;
                  case l:
                    _ = (q - H) / 864e5;
                    break;
                  case c:
                    _ = q / s;
                    break;
                  case a:
                    _ = q / i;
                    break;
                  case o:
                    _ = q / r;
                    break;
                  default:
                    _ = q;
                }
                return T ? _ : k.a(_);
              }),
              (b.daysInMonth = function () {
                return this.endOf(h).$D;
              }),
              (b.$locale = function () {
                return A[this.$L];
              }),
              (b.locale = function (v, S) {
                if (!v) return this.$L;
                var T = this.clone(),
                  _ = x(v, S, !0);
                return _ && (T.$L = _), T;
              }),
              (b.clone = function () {
                return k.w(this.$d, this);
              }),
              (b.toDate = function () {
                return new Date(this.valueOf());
              }),
              (b.toJSON = function () {
                return this.isValid() ? this.toISOString() : null;
              }),
              (b.toISOString = function () {
                return this.$d.toISOString();
              }),
              (b.toString = function () {
                return this.$d.toUTCString();
              }),
              I
            );
          })(),
          j = F.prototype;
        return (
          ($.prototype = j),
          [
            ["$ms", n],
            ["$s", o],
            ["$m", a],
            ["$H", c],
            ["$W", l],
            ["$M", h],
            ["$y", g],
            ["$D", p],
          ].forEach(function (I) {
            j[I[1]] = function (b) {
              return this.$g(b, I[0], I[1]);
            };
          }),
          ($.extend = function (I, b) {
            return I.$i || (I(b, F, $), (I.$i = !0)), $;
          }),
          ($.locale = x),
          ($.isDayjs = N),
          ($.unix = function (I) {
            return $(1e3 * I);
          }),
          ($.en = A[O]),
          ($.Ls = A),
          ($.p = {}),
          $
        );
      });
    })(G8);
    var Fw = G8.exports,
      Z8 = { exports: {} };
    (function (t, e) {
      (function (r, i) {
        t.exports = i();
      })(qt, function () {
        return {
          name: "en",
          weekdays:
            "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split(
              "_"
            ),
          months:
            "January_February_March_April_May_June_July_August_September_October_November_December".split(
              "_"
            ),
          ordinal: function (r) {
            var i = ["th", "st", "nd", "rd"],
              s = r % 100;
            return "[" + r + (i[(s - 20) % 10] || i[s] || i[0]) + "]";
          },
        };
      });
    })(Z8);
    var NV = Z8.exports,
      Y8 = { exports: {} };
    (function (t, e) {
      (function (r, i) {
        t.exports = i();
      })(qt, function () {
        return function (r, i, s) {
          r = r || {};
          var n = i.prototype,
            o = {
              future: "in %s",
              past: "%s ago",
              s: "a few seconds",
              m: "a minute",
              mm: "%d minutes",
              h: "an hour",
              hh: "%d hours",
              d: "a day",
              dd: "%d days",
              M: "a month",
              MM: "%d months",
              y: "a year",
              yy: "%d years",
            };
          function a(l, u, h, d) {
            return n.fromToBase(l, u, h, d);
          }
          (s.en.relativeTime = o),
            (n.fromToBase = function (l, u, h, d, g) {
              for (
                var p,
                  w,
                  f,
                  m = h.$locale().relativeTime || o,
                  y = r.thresholds || [
                    { l: "s", r: 44, d: "second" },
                    { l: "m", r: 89 },
                    { l: "mm", r: 44, d: "minute" },
                    { l: "h", r: 89 },
                    { l: "hh", r: 21, d: "hour" },
                    { l: "d", r: 35 },
                    { l: "dd", r: 25, d: "day" },
                    { l: "M", r: 45 },
                    { l: "MM", r: 10, d: "month" },
                    { l: "y", r: 17 },
                    { l: "yy", d: "year" },
                  ],
                  E = y.length,
                  C = 0;
                C < E;
                C += 1
              ) {
                var O = y[C];
                O.d && (p = d ? s(l).diff(h, O.d, !0) : h.diff(l, O.d, !0));
                var A = (r.rounding || Math.round)(Math.abs(p));
                if (((f = p > 0), A <= O.r || !O.r)) {
                  A <= 1 && C > 0 && (O = y[C - 1]);
                  var P = m[O.l];
                  g && (A = g("" + A)),
                    (w =
                      typeof P == "string"
                        ? P.replace("%d", A)
                        : P(A, u, O.l, f));
                  break;
                }
              }
              if (u) return w;
              var N = f ? m.future : m.past;
              return typeof N == "function" ? N(w) : N.replace("%s", w);
            }),
            (n.to = function (l, u) {
              return a(l, u, this, !0);
            }),
            (n.from = function (l, u) {
              return a(l, u, this);
            });
          var c = function (l) {
            return l.$u ? s.utc() : s();
          };
          (n.toNow = function (l) {
            return this.to(c(this), l);
          }),
            (n.fromNow = function (l) {
              return this.from(c(this), l);
            });
        };
      });
    })(Y8);
    var TV = Y8.exports,
      J8 = { exports: {} };
    (function (t, e) {
      (function (r, i) {
        t.exports = i();
      })(qt, function () {
        return function (r, i, s) {
          s.updateLocale = function (n, o) {
            var a = s.Ls[n];
            if (a)
              return (
                (o ? Object.keys(o) : []).forEach(function (c) {
                  a[c] = o[c];
                }),
                a
              );
          };
        };
      });
    })(J8);
    var kV = J8.exports;
    Fw.extend(TV), Fw.extend(kV);
    const RV = {
      ...NV,
      name: "en-web3-modal",
      relativeTime: {
        future: "in %s",
        past: "%s ago",
        s: "%d sec",
        m: "1 min",
        mm: "%d min",
        h: "1 hr",
        hh: "%d hrs",
        d: "1 d",
        dd: "%d d",
        M: "1 mo",
        MM: "%d mo",
        y: "1 yr",
        yy: "%d yr",
      },
    };
    Fw.locale("en-web3-modal", RV);
    const X8 = {
      caipNetworkIdToNumber(t) {
        return t ? Number(t.split(":")[1]) : void 0;
      },
      parseEvmChainId(t) {
        return typeof t == "string" ? this.caipNetworkIdToNumber(t) : t;
      },
      getNetworksByNamespace(t, e) {
        return t?.filter((r) => r.chainNamespace === e) || [];
      },
      getFirstNetworkByNamespace(t, e) {
        return this.getNetworksByNamespace(t, e)[0];
      },
    };
    var $V = 20,
      FV = 1,
      Jo = 1e6,
      Q8 = 1e6,
      BV = -7,
      LV = 21,
      UV = !1,
      Wu = "[big.js] ",
      Xo = Wu + "Invalid ",
      ef = Xo + "decimal places",
      DV = Xo + "rounding mode",
      eE = Wu + "Division by zero",
      Ze = {},
      Ps = void 0,
      jV = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
    function tE() {
      function t(e) {
        var r = this;
        if (!(r instanceof t)) return e === Ps ? tE() : new t(e);
        if (e instanceof t) (r.s = e.s), (r.e = e.e), (r.c = e.c.slice());
        else {
          if (typeof e != "string") {
            if (t.strict === !0 && typeof e != "bigint")
              throw TypeError(Xo + "value");
            e = e === 0 && 1 / e < 0 ? "-0" : String(e);
          }
          MV(r, e);
        }
        r.constructor = t;
      }
      return (
        (t.prototype = Ze),
        (t.DP = $V),
        (t.RM = FV),
        (t.NE = BV),
        (t.PE = LV),
        (t.strict = UV),
        (t.roundDown = 0),
        (t.roundHalfUp = 1),
        (t.roundHalfEven = 2),
        (t.roundUp = 3),
        t
      );
    }
    function MV(t, e) {
      var r, i, s;
      if (!jV.test(e)) throw Error(Xo + "number");
      for (
        t.s = e.charAt(0) == "-" ? ((e = e.slice(1)), -1) : 1,
          (r = e.indexOf(".")) > -1 && (e = e.replace(".", "")),
          (i = e.search(/e/i)) > 0
            ? (r < 0 && (r = i),
              (r += +e.slice(i + 1)),
              (e = e.substring(0, i)))
            : r < 0 && (r = e.length),
          s = e.length,
          i = 0;
        i < s && e.charAt(i) == "0";

      )
        ++i;
      if (i == s) t.c = [(t.e = 0)];
      else {
        for (; s > 0 && e.charAt(--s) == "0"; );
        for (t.e = r - i - 1, t.c = [], r = 0; i <= s; )
          t.c[r++] = +e.charAt(i++);
      }
      return t;
    }
    function Qo(t, e, r, i) {
      var s = t.c;
      if (
        (r === Ps && (r = t.constructor.RM),
        r !== 0 && r !== 1 && r !== 2 && r !== 3)
      )
        throw Error(DV);
      if (e < 1)
        (i =
          (r === 3 && (i || !!s[0])) ||
          (e === 0 &&
            ((r === 1 && s[0] >= 5) ||
              (r === 2 && (s[0] > 5 || (s[0] === 5 && (i || s[1] !== Ps))))))),
          (s.length = 1),
          i ? ((t.e = t.e - e + 1), (s[0] = 1)) : (s[0] = t.e = 0);
      else if (e < s.length) {
        if (
          ((i =
            (r === 1 && s[e] >= 5) ||
            (r === 2 &&
              (s[e] > 5 ||
                (s[e] === 5 && (i || s[e + 1] !== Ps || s[e - 1] & 1)))) ||
            (r === 3 && (i || !!s[0]))),
          (s.length = e),
          i)
        ) {
          for (; ++s[--e] > 9; )
            if (((s[e] = 0), e === 0)) {
              ++t.e, s.unshift(1);
              break;
            }
        }
        for (e = s.length; !s[--e]; ) s.pop();
      }
      return t;
    }
    function ea(t, e, r) {
      var i = t.e,
        s = t.c.join(""),
        n = s.length;
      if (e)
        s =
          s.charAt(0) +
          (n > 1 ? "." + s.slice(1) : "") +
          (i < 0 ? "e" : "e+") +
          i;
      else if (i < 0) {
        for (; ++i; ) s = "0" + s;
        s = "0." + s;
      } else if (i > 0)
        if (++i > n) for (i -= n; i--; ) s += "0";
        else i < n && (s = s.slice(0, i) + "." + s.slice(i));
      else n > 1 && (s = s.charAt(0) + "." + s.slice(1));
      return t.s < 0 && r ? "-" + s : s;
    }
    (Ze.abs = function () {
      var t = new this.constructor(this);
      return (t.s = 1), t;
    }),
      (Ze.cmp = function (t) {
        var e,
          r = this,
          i = r.c,
          s = (t = new r.constructor(t)).c,
          n = r.s,
          o = t.s,
          a = r.e,
          c = t.e;
        if (!i[0] || !s[0]) return i[0] ? n : s[0] ? -o : 0;
        if (n != o) return n;
        if (((e = n < 0), a != c)) return (a > c) ^ e ? 1 : -1;
        for (o = (a = i.length) < (c = s.length) ? a : c, n = -1; ++n < o; )
          if (i[n] != s[n]) return (i[n] > s[n]) ^ e ? 1 : -1;
        return a == c ? 0 : (a > c) ^ e ? 1 : -1;
      }),
      (Ze.div = function (t) {
        var e = this,
          r = e.constructor,
          i = e.c,
          s = (t = new r(t)).c,
          n = e.s == t.s ? 1 : -1,
          o = r.DP;
        if (o !== ~~o || o < 0 || o > Jo) throw Error(ef);
        if (!s[0]) throw Error(eE);
        if (!i[0]) return (t.s = n), (t.c = [(t.e = 0)]), t;
        var a,
          c,
          l,
          u,
          h,
          d = s.slice(),
          g = (a = s.length),
          p = i.length,
          w = i.slice(0, a),
          f = w.length,
          m = t,
          y = (m.c = []),
          E = 0,
          C = o + (m.e = e.e - t.e) + 1;
        for (m.s = n, n = C < 0 ? 0 : C, d.unshift(0); f++ < a; ) w.push(0);
        do {
          for (l = 0; l < 10; l++) {
            if (a != (f = w.length)) u = a > f ? 1 : -1;
            else
              for (h = -1, u = 0; ++h < a; )
                if (s[h] != w[h]) {
                  u = s[h] > w[h] ? 1 : -1;
                  break;
                }
            if (u < 0) {
              for (c = f == a ? s : d; f; ) {
                if (w[--f] < c[f]) {
                  for (h = f; h && !w[--h]; ) w[h] = 9;
                  --w[h], (w[f] += 10);
                }
                w[f] -= c[f];
              }
              for (; !w[0]; ) w.shift();
            } else break;
          }
          (y[E++] = u ? l : ++l), w[0] && u ? (w[f] = i[g] || 0) : (w = [i[g]]);
        } while ((g++ < p || w[0] !== Ps) && n--);
        return (
          !y[0] && E != 1 && (y.shift(), m.e--, C--),
          E > C && Qo(m, C, r.RM, w[0] !== Ps),
          m
        );
      }),
      (Ze.eq = function (t) {
        return this.cmp(t) === 0;
      }),
      (Ze.gt = function (t) {
        return this.cmp(t) > 0;
      }),
      (Ze.gte = function (t) {
        return this.cmp(t) > -1;
      }),
      (Ze.lt = function (t) {
        return this.cmp(t) < 0;
      }),
      (Ze.lte = function (t) {
        return this.cmp(t) < 1;
      }),
      (Ze.minus = Ze.sub =
        function (t) {
          var e,
            r,
            i,
            s,
            n = this,
            o = n.constructor,
            a = n.s,
            c = (t = new o(t)).s;
          if (a != c) return (t.s = -c), n.plus(t);
          var l = n.c.slice(),
            u = n.e,
            h = t.c,
            d = t.e;
          if (!l[0] || !h[0])
            return h[0] ? (t.s = -c) : l[0] ? (t = new o(n)) : (t.s = 1), t;
          if ((a = u - d)) {
            for (
              (s = a < 0) ? ((a = -a), (i = l)) : ((d = u), (i = h)),
                i.reverse(),
                c = a;
              c--;

            )
              i.push(0);
            i.reverse();
          } else
            for (
              r = ((s = l.length < h.length) ? l : h).length, a = c = 0;
              c < r;
              c++
            )
              if (l[c] != h[c]) {
                s = l[c] < h[c];
                break;
              }
          if (
            (s && ((i = l), (l = h), (h = i), (t.s = -t.s)),
            (c = (r = h.length) - (e = l.length)) > 0)
          )
            for (; c--; ) l[e++] = 0;
          for (c = e; r > a; ) {
            if (l[--r] < h[r]) {
              for (e = r; e && !l[--e]; ) l[e] = 9;
              --l[e], (l[r] += 10);
            }
            l[r] -= h[r];
          }
          for (; l[--c] === 0; ) l.pop();
          for (; l[0] === 0; ) l.shift(), --d;
          return l[0] || ((t.s = 1), (l = [(d = 0)])), (t.c = l), (t.e = d), t;
        }),
      (Ze.mod = function (t) {
        var e,
          r = this,
          i = r.constructor,
          s = r.s,
          n = (t = new i(t)).s;
        if (!t.c[0]) throw Error(eE);
        return (
          (r.s = t.s = 1),
          (e = t.cmp(r) == 1),
          (r.s = s),
          (t.s = n),
          e
            ? new i(r)
            : ((s = i.DP),
              (n = i.RM),
              (i.DP = i.RM = 0),
              (r = r.div(t)),
              (i.DP = s),
              (i.RM = n),
              this.minus(r.times(t)))
        );
      }),
      (Ze.neg = function () {
        var t = new this.constructor(this);
        return (t.s = -t.s), t;
      }),
      (Ze.plus = Ze.add =
        function (t) {
          var e,
            r,
            i,
            s = this,
            n = s.constructor;
          if (((t = new n(t)), s.s != t.s)) return (t.s = -t.s), s.minus(t);
          var o = s.e,
            a = s.c,
            c = t.e,
            l = t.c;
          if (!a[0] || !l[0])
            return l[0] || (a[0] ? (t = new n(s)) : (t.s = s.s)), t;
          if (((a = a.slice()), (e = o - c))) {
            for (
              e > 0 ? ((c = o), (i = l)) : ((e = -e), (i = a)), i.reverse();
              e--;

            )
              i.push(0);
            i.reverse();
          }
          for (
            a.length - l.length < 0 && ((i = l), (l = a), (a = i)),
              e = l.length,
              r = 0;
            e;
            a[e] %= 10
          )
            r = ((a[--e] = a[e] + l[e] + r) / 10) | 0;
          for (r && (a.unshift(r), ++c), e = a.length; a[--e] === 0; ) a.pop();
          return (t.c = a), (t.e = c), t;
        }),
      (Ze.pow = function (t) {
        var e = this,
          r = new e.constructor("1"),
          i = r,
          s = t < 0;
        if (t !== ~~t || t < -Q8 || t > Q8) throw Error(Xo + "exponent");
        for (s && (t = -t); t & 1 && (i = i.times(e)), (t >>= 1), !!t; )
          e = e.times(e);
        return s ? r.div(i) : i;
      }),
      (Ze.prec = function (t, e) {
        if (t !== ~~t || t < 1 || t > Jo) throw Error(Xo + "precision");
        return Qo(new this.constructor(this), t, e);
      }),
      (Ze.round = function (t, e) {
        if (t === Ps) t = 0;
        else if (t !== ~~t || t < -Jo || t > Jo) throw Error(ef);
        return Qo(new this.constructor(this), t + this.e + 1, e);
      }),
      (Ze.sqrt = function () {
        var t,
          e,
          r,
          i = this,
          s = i.constructor,
          n = i.s,
          o = i.e,
          a = new s("0.5");
        if (!i.c[0]) return new s(i);
        if (n < 0) throw Error(Wu + "No square root");
        (n = Math.sqrt(+ea(i, !0, !0))),
          n === 0 || n === 1 / 0
            ? ((e = i.c.join("")),
              (e.length + o) & 1 || (e += "0"),
              (n = Math.sqrt(e)),
              (o = (((o + 1) / 2) | 0) - (o < 0 || o & 1)),
              (t = new s(
                (n == 1 / 0
                  ? "5e"
                  : (n = n.toExponential()).slice(0, n.indexOf("e") + 1)) + o
              )))
            : (t = new s(n + "")),
          (o = t.e + (s.DP += 4));
        do (r = t), (t = a.times(r.plus(i.div(r))));
        while (r.c.slice(0, o).join("") !== t.c.slice(0, o).join(""));
        return Qo(t, (s.DP -= 4) + t.e + 1, s.RM);
      }),
      (Ze.times = Ze.mul =
        function (t) {
          var e,
            r = this,
            i = r.constructor,
            s = r.c,
            n = (t = new i(t)).c,
            o = s.length,
            a = n.length,
            c = r.e,
            l = t.e;
          if (((t.s = r.s == t.s ? 1 : -1), !s[0] || !n[0]))
            return (t.c = [(t.e = 0)]), t;
          for (
            t.e = c + l,
              o < a && ((e = s), (s = n), (n = e), (l = o), (o = a), (a = l)),
              e = new Array((l = o + a));
            l--;

          )
            e[l] = 0;
          for (c = a; c--; ) {
            for (a = 0, l = o + c; l > c; )
              (a = e[l] + n[c] * s[l - c - 1] + a),
                (e[l--] = a % 10),
                (a = (a / 10) | 0);
            e[l] = a;
          }
          for (a ? ++t.e : e.shift(), c = e.length; !e[--c]; ) e.pop();
          return (t.c = e), t;
        }),
      (Ze.toExponential = function (t, e) {
        var r = this,
          i = r.c[0];
        if (t !== Ps) {
          if (t !== ~~t || t < 0 || t > Jo) throw Error(ef);
          for (r = Qo(new r.constructor(r), ++t, e); r.c.length < t; )
            r.c.push(0);
        }
        return ea(r, !0, !!i);
      }),
      (Ze.toFixed = function (t, e) {
        var r = this,
          i = r.c[0];
        if (t !== Ps) {
          if (t !== ~~t || t < 0 || t > Jo) throw Error(ef);
          for (
            r = Qo(new r.constructor(r), t + r.e + 1, e), t = t + r.e + 1;
            r.c.length < t;

          )
            r.c.push(0);
        }
        return ea(r, !1, !!i);
      }),
      (Ze[Symbol.for("nodejs.util.inspect.custom")] =
        Ze.toJSON =
        Ze.toString =
          function () {
            var t = this,
              e = t.constructor;
            return ea(t, t.e <= e.NE || t.e >= e.PE, !!t.c[0]);
          }),
      (Ze.toNumber = function () {
        var t = +ea(this, !0, !0);
        if (this.constructor.strict === !0 && !this.eq(t.toString()))
          throw Error(Wu + "Imprecise conversion");
        return t;
      }),
      (Ze.toPrecision = function (t, e) {
        var r = this,
          i = r.constructor,
          s = r.c[0];
        if (t !== Ps) {
          if (t !== ~~t || t < 1 || t > Jo) throw Error(Xo + "precision");
          for (r = Qo(new i(r), t, e); r.c.length < t; ) r.c.push(0);
        }
        return ea(r, t <= r.e || r.e <= i.NE || r.e >= i.PE, !!s);
      }),
      (Ze.valueOf = function () {
        var t = this,
          e = t.constructor;
        if (e.strict === !0) throw Error(Wu + "valueOf disallowed");
        return ea(t, t.e <= e.NE || t.e >= e.PE, !0);
      });
    var Ku = tE();
    const tf = {
        bigNumber(t) {
          return t ? new Ku(t) : new Ku(0);
        },
        multiply(t, e) {
          if (t === void 0 || e === void 0) return new Ku(0);
          const r = new Ku(t),
            i = new Ku(e);
          return r.times(i);
        },
        formatNumberToLocalString(t, e = 2) {
          return t === void 0
            ? "0.00"
            : typeof t == "number"
            ? t.toLocaleString("en-US", {
                maximumFractionDigits: e,
                minimumFractionDigits: e,
              })
            : parseFloat(t).toLocaleString("en-US", {
                maximumFractionDigits: e,
                minimumFractionDigits: e,
              });
        },
        parseLocalStringToNumber(t) {
          return t === void 0 ? 0 : parseFloat(t.replace(/,/gu, ""));
        },
      },
      zV = [
        {
          type: "function",
          name: "transfer",
          stateMutability: "nonpayable",
          inputs: [
            { name: "_to", type: "address" },
            { name: "_value", type: "uint256" },
          ],
          outputs: [{ name: "", type: "bool" }],
        },
        {
          type: "function",
          name: "transferFrom",
          stateMutability: "nonpayable",
          inputs: [
            { name: "_from", type: "address" },
            { name: "_to", type: "address" },
            { name: "_value", type: "uint256" },
          ],
          outputs: [{ name: "", type: "bool" }],
        },
      ],
      qV = [
        {
          type: "function",
          name: "approve",
          stateMutability: "nonpayable",
          inputs: [
            { name: "spender", type: "address" },
            { name: "amount", type: "uint256" },
          ],
          outputs: [{ type: "bool" }],
        },
      ],
      HV = [
        {
          type: "function",
          name: "transfer",
          stateMutability: "nonpayable",
          inputs: [
            { name: "recipient", type: "address" },
            { name: "amount", type: "uint256" },
          ],
          outputs: [],
        },
        {
          type: "function",
          name: "transferFrom",
          stateMutability: "nonpayable",
          inputs: [
            { name: "sender", type: "address" },
            { name: "recipient", type: "address" },
            { name: "amount", type: "uint256" },
          ],
          outputs: [{ name: "", type: "bool" }],
        },
      ],
      he = {
        WC_NAME_SUFFIX: ".reown.id",
        WC_NAME_SUFFIX_LEGACY: ".wcn.id",
        BLOCKCHAIN_API_RPC_URL: "https://rpc.walletconnect.org",
        PULSE_API_URL: "https://pulse.walletconnect.org",
        W3M_API_URL: "https://api.web3modal.org",
        CONNECTOR_ID: {
          WALLET_CONNECT: "walletConnect",
          INJECTED: "injected",
          WALLET_STANDARD: "announced",
          COINBASE: "coinbaseWallet",
          COINBASE_SDK: "coinbaseWalletSDK",
          SAFE: "safe",
          LEDGER: "ledger",
          OKX: "okx",
          EIP6963: "eip6963",
          AUTH: "ID_AUTH",
        },
        CONNECTOR_NAMES: { AUTH: "Auth" },
        AUTH_CONNECTOR_SUPPORTED_CHAINS: ["eip155", "solana"],
        LIMITS: { PENDING_TRANSACTIONS: 99 },
        CHAIN: {
          EVM: "eip155",
          SOLANA: "solana",
          POLKADOT: "polkadot",
          BITCOIN: "bip122",
        },
        CHAIN_NAME_MAP: {
          eip155: "EVM Networks",
          solana: "Solana",
          polkadot: "Polkadot",
          bip122: "Bitcoin",
        },
        ADAPTER_TYPES: {
          BITCOIN: "bitcoin",
          SOLANA: "solana",
          WAGMI: "wagmi",
          ETHERS: "ethers",
          ETHERS5: "ethers5",
        },
        USDT_CONTRACT_ADDRESSES: [
          "0xdac17f958d2ee523a2206206994597c13d831ec7",
          "0xc2132d05d31c914a87c6611c10748aeb04b58e8f",
          "0x9702230a8ea53601f5cd2dc00fdbc13d4df4a8c7",
          "0x919C1c267BC06a7039e03fcc2eF738525769109c",
          "0x48065fbBE25f71C9282ddf5e1cD6D6A887483D5e",
          "0x55d398326f99059fF775485246999027B3197955",
          "0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9",
        ],
        HTTP_STATUS_CODES: { SERVICE_UNAVAILABLE: 503, FORBIDDEN: 403 },
        UNSUPPORTED_NETWORK_NAME: "Unknown Network",
      },
      VV = {
        getERC20Abi: (t) => (he.USDT_CONTRACT_ADDRESSES.includes(t) ? HV : zV),
        getSwapAbi: () => qV,
      },
      Xn = {
        validateCaipAddress(t) {
          if (t.split(":")?.length !== 3)
            throw new Error("Invalid CAIP Address");
          return t;
        },
        parseCaipAddress(t) {
          const e = t.split(":");
          if (e.length !== 3) throw new Error(`Invalid CAIP-10 address: ${t}`);
          const [r, i, s] = e;
          if (!r || !i || !s) throw new Error(`Invalid CAIP-10 address: ${t}`);
          return { chainNamespace: r, chainId: i, address: s };
        },
        parseCaipNetworkId(t) {
          const e = t.split(":");
          if (e.length !== 2)
            throw new Error(`Invalid CAIP-2 network id: ${t}`);
          const [r, i] = e;
          if (!r || !i) throw new Error(`Invalid CAIP-2 network id: ${t}`);
          return { chainNamespace: r, chainId: i };
        },
      },
      Ae = {
        WALLET_ID: "@appkit/wallet_id",
        WALLET_NAME: "@appkit/wallet_name",
        SOLANA_WALLET: "@appkit/solana_wallet",
        SOLANA_CAIP_CHAIN: "@appkit/solana_caip_chain",
        ACTIVE_CAIP_NETWORK_ID: "@appkit/active_caip_network_id",
        CONNECTED_SOCIAL: "@appkit/connected_social",
        CONNECTED_SOCIAL_USERNAME: "@appkit-wallet/SOCIAL_USERNAME",
        RECENT_WALLETS: "@appkit/recent_wallets",
        DEEPLINK_CHOICE: "WALLETCONNECT_DEEPLINK_CHOICE",
        ACTIVE_NAMESPACE: "@appkit/active_namespace",
        CONNECTED_NAMESPACES: "@appkit/connected_namespaces",
        CONNECTION_STATUS: "@appkit/connection_status",
        SIWX_AUTH_TOKEN: "@appkit/siwx-auth-token",
        SIWX_NONCE_TOKEN: "@appkit/siwx-nonce-token",
        TELEGRAM_SOCIAL_PROVIDER: "@appkit/social_provider",
        NATIVE_BALANCE_CACHE: "@appkit/native_balance_cache",
        PORTFOLIO_CACHE: "@appkit/portfolio_cache",
        ENS_CACHE: "@appkit/ens_cache",
        IDENTITY_CACHE: "@appkit/identity_cache",
        PREFERRED_ACCOUNT_TYPES: "@appkit/preferred_account_types",
      };
    function Bw(t) {
      if (!t)
        throw new Error("Namespace is required for CONNECTED_CONNECTOR_ID");
      return `@appkit/${t}:connected_connector_id`;
    }
    const xe = {
      setItem(t, e) {
        Gu() && e !== void 0 && localStorage.setItem(t, e);
      },
      getItem(t) {
        if (Gu()) return localStorage.getItem(t) || void 0;
      },
      removeItem(t) {
        Gu() && localStorage.removeItem(t);
      },
      clear() {
        Gu() && localStorage.clear();
      },
    };
    function Gu() {
      return typeof window < "u" && typeof localStorage < "u";
    }
    function Qn(t, e) {
      return e === "light"
        ? {
            "--w3m-accent": t?.["--w3m-accent"] || "hsla(231, 100%, 70%, 1)",
            "--w3m-background": "#fff",
          }
        : {
            "--w3m-accent": t?.["--w3m-accent"] || "hsla(230, 100%, 67%, 1)",
            "--w3m-background": "#121313",
          };
    }
    const WV = Symbol(),
      rE = Object.getPrototypeOf,
      Lw = new WeakMap(),
      KV = (t) =>
        t &&
        (Lw.has(t)
          ? Lw.get(t)
          : rE(t) === Object.prototype || rE(t) === Array.prototype),
      GV = (t) => (KV(t) && t[WV]) || null,
      iE = (t, e = !0) => {
        Lw.set(t, e);
      },
      Uw = (t) => typeof t == "object" && t !== null,
      eo = new WeakMap(),
      Zu = new WeakSet(),
      ZV = (
        t = Object.is,
        e = (l, u) => new Proxy(l, u),
        r = (l) =>
          Uw(l) &&
          !Zu.has(l) &&
          (Array.isArray(l) || !(Symbol.iterator in l)) &&
          !(l instanceof WeakMap) &&
          !(l instanceof WeakSet) &&
          !(l instanceof Error) &&
          !(l instanceof Number) &&
          !(l instanceof Date) &&
          !(l instanceof String) &&
          !(l instanceof RegExp) &&
          !(l instanceof ArrayBuffer),
        i = (l) => {
          switch (l.status) {
            case "fulfilled":
              return l.value;
            case "rejected":
              throw l.reason;
            default:
              throw l;
          }
        },
        s = new WeakMap(),
        n = (l, u, h = i) => {
          const d = s.get(l);
          if (d?.[0] === u) return d[1];
          const g = Array.isArray(l)
            ? []
            : Object.create(Object.getPrototypeOf(l));
          return (
            iE(g, !0),
            s.set(l, [u, g]),
            Reflect.ownKeys(l).forEach((p) => {
              if (Object.getOwnPropertyDescriptor(g, p)) return;
              const w = Reflect.get(l, p),
                { enumerable: f } = Reflect.getOwnPropertyDescriptor(l, p),
                m = { value: w, enumerable: f, configurable: !0 };
              if (Zu.has(w)) iE(w, !1);
              else if (w instanceof Promise)
                delete m.value, (m.get = () => h(w));
              else if (eo.has(w)) {
                const [y, E] = eo.get(w);
                m.value = n(y, E(), h);
              }
              Object.defineProperty(g, p, m);
            }),
            Object.preventExtensions(g)
          );
        },
        o = new WeakMap(),
        a = [1, 1],
        c = (l) => {
          if (!Uw(l)) throw new Error("object required");
          const u = o.get(l);
          if (u) return u;
          let h = a[0];
          const d = new Set(),
            g = (N, x = ++a[0]) => {
              h !== x && ((h = x), d.forEach(($) => $(N, x)));
            };
          let p = a[1];
          const w = (N = ++a[1]) => (
              p !== N &&
                !d.size &&
                ((p = N),
                m.forEach(([x]) => {
                  const $ = x[1](N);
                  $ > h && (h = $);
                })),
              h
            ),
            f = (N) => (x, $) => {
              const k = [...x];
              (k[1] = [N, ...k[1]]), g(k, $);
            },
            m = new Map(),
            y = (N, x) => {
              if (m.has(N)) throw new Error("prop listener already exists");
              if (d.size) {
                const $ = x[3](f(N));
                m.set(N, [x, $]);
              } else m.set(N, [x]);
            },
            E = (N) => {
              var x;
              const $ = m.get(N);
              $ && (m.delete(N), (x = $[1]) == null || x.call($));
            },
            C = (N) => (
              d.add(N),
              d.size === 1 &&
                m.forEach(([x, $], k) => {
                  if ($) throw new Error("remove already exists");
                  const F = x[3](f(k));
                  m.set(k, [x, F]);
                }),
              () => {
                d.delete(N),
                  d.size === 0 &&
                    m.forEach(([x, $], k) => {
                      $ && ($(), m.set(k, [x]));
                    });
              }
            ),
            O = Array.isArray(l) ? [] : Object.create(Object.getPrototypeOf(l)),
            A = e(O, {
              deleteProperty(N, x) {
                const $ = Reflect.get(N, x);
                E(x);
                const k = Reflect.deleteProperty(N, x);
                return k && g(["delete", [x], $]), k;
              },
              set(N, x, $, k) {
                const F = Reflect.has(N, x),
                  j = Reflect.get(N, x, k);
                if (F && (t(j, $) || (o.has($) && t(j, o.get($))))) return !0;
                E(x), Uw($) && ($ = GV($) || $);
                let I = $;
                if ($ instanceof Promise)
                  $.then((b) => {
                    ($.status = "fulfilled"),
                      ($.value = b),
                      g(["resolve", [x], b]);
                  }).catch((b) => {
                    ($.status = "rejected"),
                      ($.reason = b),
                      g(["reject", [x], b]);
                  });
                else {
                  !eo.has($) && r($) && (I = c($));
                  const b = !Zu.has(I) && eo.get(I);
                  b && y(x, b);
                }
                return Reflect.set(N, x, I, k), g(["set", [x], $, j]), !0;
              },
            });
          o.set(l, A);
          const P = [O, w, n, C];
          return (
            eo.set(A, P),
            Reflect.ownKeys(l).forEach((N) => {
              const x = Object.getOwnPropertyDescriptor(l, N);
              "value" in x &&
                ((A[N] = l[N]), delete x.value, delete x.writable),
                Object.defineProperty(O, N, x);
            }),
            A
          );
        }
      ) => [c, eo, Zu, t, e, r, i, s, n, o, a],
      [YV] = ZV();
    function ot(t = {}) {
      return YV(t);
    }
    function Sr(t, e, r) {
      const i = eo.get(t);
      i || console.warn("Please use proxy object");
      let s;
      const n = [],
        o = i[3];
      let a = !1;
      const c = o((l) => {
        if ((n.push(l), r)) {
          e(n.splice(0));
          return;
        }
        s ||
          (s = Promise.resolve().then(() => {
            (s = void 0), a && e(n.splice(0));
          }));
      });
      return (
        (a = !0),
        () => {
          (a = !1), c();
        }
      );
    }
    function Yu(t, e) {
      const r = eo.get(t);
      r || console.warn("Please use proxy object");
      const [i, s, n] = r;
      return n(i, s(), e);
    }
    function ta(t) {
      return Zu.add(t), t;
    }
    function Fr(t, e, r, i) {
      let s = t[e];
      return Sr(
        t,
        () => {
          const n = t[e];
          Object.is(s, n) || r((s = n));
        },
        i
      );
    }
    function JV(t) {
      const e = ot({
        data: Array.from(t || []),
        has(r) {
          return this.data.some((i) => i[0] === r);
        },
        set(r, i) {
          const s = this.data.find((n) => n[0] === r);
          return s ? (s[1] = i) : this.data.push([r, i]), this;
        },
        get(r) {
          var i;
          return (i = this.data.find((s) => s[0] === r)) == null
            ? void 0
            : i[1];
        },
        delete(r) {
          const i = this.data.findIndex((s) => s[0] === r);
          return i === -1 ? !1 : (this.data.splice(i, 1), !0);
        },
        clear() {
          this.data.splice(0);
        },
        get size() {
          return this.data.length;
        },
        toJSON() {
          return new Map(this.data);
        },
        forEach(r) {
          this.data.forEach((i) => {
            r(i[1], i[0], this);
          });
        },
        keys() {
          return this.data.map((r) => r[0]).values();
        },
        values() {
          return this.data.map((r) => r[1]).values();
        },
        entries() {
          return new Map(this.data).entries();
        },
        get [Symbol.toStringTag]() {
          return "Map";
        },
        [Symbol.iterator]() {
          return this.entries();
        },
      });
      return (
        Object.defineProperties(e, {
          data: { enumerable: !1 },
          size: { enumerable: !1 },
          toJSON: { enumerable: !1 },
        }),
        Object.seal(e),
        e
      );
    }
    const Dw =
        (typeof ut < "u" && typeof ut.env < "u"
          ? {}.NEXT_PUBLIC_SECURE_SITE_ORIGIN
          : void 0) || "https://secure.walletconnect.org",
      XV = [
        {
          label: "Coinbase",
          name: "coinbase",
          feeRange: "1-2%",
          url: "",
          supportedChains: ["eip155"],
        },
        {
          label: "Meld.io",
          name: "meld",
          feeRange: "1-2%",
          url: "https://meldcrypto.com",
          supportedChains: ["eip155", "solana"],
        },
      ],
      Lt = {
        FOUR_MINUTES_MS: 24e4,
        TEN_SEC_MS: 1e4,
        FIVE_SEC_MS: 5e3,
        THREE_SEC_MS: 3e3,
        ONE_SEC_MS: 1e3,
        SECURE_SITE: Dw,
        SECURE_SITE_DASHBOARD: `${Dw}/dashboard`,
        SECURE_SITE_FAVICON: `${Dw}/images/favicon.png`,
        RESTRICTED_TIMEZONES: [
          "ASIA/SHANGHAI",
          "ASIA/URUMQI",
          "ASIA/CHONGQING",
          "ASIA/HARBIN",
          "ASIA/KASHGAR",
          "ASIA/MACAU",
          "ASIA/HONG_KONG",
          "ASIA/MACAO",
          "ASIA/BEIJING",
          "ASIA/HARBIN",
        ],
        WC_COINBASE_PAY_SDK_CHAINS: [
          "ethereum",
          "arbitrum",
          "polygon",
          "berachain",
          "avalanche-c-chain",
          "optimism",
          "celo",
          "base",
        ],
        WC_COINBASE_PAY_SDK_FALLBACK_CHAIN: "ethereum",
        WC_COINBASE_PAY_SDK_CHAIN_NAME_MAP: {
          Ethereum: "ethereum",
          "Arbitrum One": "arbitrum",
          Polygon: "polygon",
          Berachain: "berachain",
          Avalanche: "avalanche-c-chain",
          "OP Mainnet": "optimism",
          Celo: "celo",
          Base: "base",
        },
        WC_COINBASE_ONRAMP_APP_ID: "bf18c88d-495a-463b-b249-0b9d3656cf5e",
        SWAP_SUGGESTED_TOKENS: [
          "ETH",
          "UNI",
          "1INCH",
          "AAVE",
          "SOL",
          "ADA",
          "AVAX",
          "DOT",
          "LINK",
          "NITRO",
          "GAIA",
          "MILK",
          "TRX",
          "NEAR",
          "GNO",
          "WBTC",
          "DAI",
          "WETH",
          "USDC",
          "USDT",
          "ARB",
          "BAL",
          "BICO",
          "CRV",
          "ENS",
          "MATIC",
          "OP",
        ],
        SWAP_POPULAR_TOKENS: [
          "ETH",
          "UNI",
          "1INCH",
          "AAVE",
          "SOL",
          "ADA",
          "AVAX",
          "DOT",
          "LINK",
          "NITRO",
          "GAIA",
          "MILK",
          "TRX",
          "NEAR",
          "GNO",
          "WBTC",
          "DAI",
          "WETH",
          "USDC",
          "USDT",
          "ARB",
          "BAL",
          "BICO",
          "CRV",
          "ENS",
          "MATIC",
          "OP",
          "METAL",
          "DAI",
          "CHAMP",
          "WOLF",
          "SALE",
          "BAL",
          "BUSD",
          "MUST",
          "BTCpx",
          "ROUTE",
          "HEX",
          "WELT",
          "amDAI",
          "VSQ",
          "VISION",
          "AURUM",
          "pSP",
          "SNX",
          "VC",
          "LINK",
          "CHP",
          "amUSDT",
          "SPHERE",
          "FOX",
          "GIDDY",
          "GFC",
          "OMEN",
          "OX_OLD",
          "DE",
          "WNT",
        ],
        BALANCE_SUPPORTED_CHAINS: ["eip155", "solana"],
        SWAP_SUPPORTED_NETWORKS: [
          "eip155:1",
          "eip155:42161",
          "eip155:10",
          "eip155:324",
          "eip155:8453",
          "eip155:56",
          "eip155:137",
          "eip155:100",
          "eip155:43114",
          "eip155:250",
          "eip155:8217",
          "eip155:1313161554",
        ],
        NAMES_SUPPORTED_CHAIN_NAMESPACES: ["eip155"],
        ONRAMP_SUPPORTED_CHAIN_NAMESPACES: ["eip155", "solana"],
        ACTIVITY_ENABLED_CHAIN_NAMESPACES: ["eip155"],
        NATIVE_TOKEN_ADDRESS: {
          eip155: "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
          solana: "So11111111111111111111111111111111111111111",
          polkadot: "0x",
          bip122: "0x",
        },
        CONVERT_SLIPPAGE_TOLERANCE: 1,
        CONNECT_LABELS: { MOBILE: "Open and continue in a new browser tab" },
        DEFAULT_FEATURES: {
          swaps: !0,
          onramp: !0,
          receive: !0,
          send: !0,
          email: !0,
          emailShowWallets: !0,
          socials: [
            "google",
            "x",
            "discord",
            "farcaster",
            "github",
            "apple",
            "facebook",
          ],
          connectorTypeOrder: [
            "walletConnect",
            "recent",
            "injected",
            "featured",
            "custom",
            "external",
            "recommended",
          ],
          history: !0,
          analytics: !0,
          allWallets: !0,
          legalCheckbox: !1,
          smartSessions: !1,
          collapseWallets: !1,
          walletFeaturesOrder: ["onramp", "swaps", "receive", "send"],
          connectMethodsOrder: void 0,
        },
        DEFAULT_ACCOUNT_TYPES: {
          bip122: "payment",
          eip155: "smartAccount",
          polkadot: "eoa",
          solana: "eoa",
        },
        ADAPTER_TYPES: {
          UNIVERSAL: "universal",
          SOLANA: "solana",
          WAGMI: "wagmi",
          ETHERS: "ethers",
          ETHERS5: "ethers5",
          BITCOIN: "bitcoin",
        },
      },
      de = {
        cacheExpiry: {
          portfolio: 3e4,
          nativeBalance: 3e4,
          ens: 3e5,
          identity: 3e5,
        },
        isCacheExpired(t, e) {
          return Date.now() - t > e;
        },
        getActiveNetworkProps() {
          const t = de.getActiveNamespace(),
            e = de.getActiveCaipNetworkId(),
            r = e ? e.split(":")[1] : void 0,
            i = r ? (isNaN(Number(r)) ? r : Number(r)) : void 0;
          return { namespace: t, caipNetworkId: e, chainId: i };
        },
        setWalletConnectDeepLink({ name: t, href: e }) {
          try {
            xe.setItem(
              Ae.DEEPLINK_CHOICE,
              JSON.stringify({ href: e, name: t })
            );
          } catch {
            console.info("Unable to set WalletConnect deep link");
          }
        },
        getWalletConnectDeepLink() {
          try {
            const t = xe.getItem(Ae.DEEPLINK_CHOICE);
            if (t) return JSON.parse(t);
          } catch {
            console.info("Unable to get WalletConnect deep link");
          }
        },
        deleteWalletConnectDeepLink() {
          try {
            xe.removeItem(Ae.DEEPLINK_CHOICE);
          } catch {
            console.info("Unable to delete WalletConnect deep link");
          }
        },
        setActiveNamespace(t) {
          try {
            xe.setItem(Ae.ACTIVE_NAMESPACE, t);
          } catch {
            console.info("Unable to set active namespace");
          }
        },
        setActiveCaipNetworkId(t) {
          try {
            xe.setItem(Ae.ACTIVE_CAIP_NETWORK_ID, t),
              de.setActiveNamespace(t.split(":")[0]);
          } catch {
            console.info("Unable to set active caip network id");
          }
        },
        getActiveCaipNetworkId() {
          try {
            return xe.getItem(Ae.ACTIVE_CAIP_NETWORK_ID);
          } catch {
            console.info("Unable to get active caip network id");
            return;
          }
        },
        deleteActiveCaipNetworkId() {
          try {
            xe.removeItem(Ae.ACTIVE_CAIP_NETWORK_ID);
          } catch {
            console.info("Unable to delete active caip network id");
          }
        },
        deleteConnectedConnectorId(t) {
          try {
            const e = Bw(t);
            xe.removeItem(e);
          } catch {
            console.info("Unable to delete connected connector id");
          }
        },
        setAppKitRecent(t) {
          try {
            const e = de.getRecentWallets();
            e.find((r) => r.id === t.id) ||
              (e.unshift(t),
              e.length > 2 && e.pop(),
              xe.setItem(Ae.RECENT_WALLETS, JSON.stringify(e)));
          } catch {
            console.info("Unable to set AppKit recent");
          }
        },
        getRecentWallets() {
          try {
            const t = xe.getItem(Ae.RECENT_WALLETS);
            return t ? JSON.parse(t) : [];
          } catch {
            console.info("Unable to get AppKit recent");
          }
          return [];
        },
        setConnectedConnectorId(t, e) {
          try {
            const r = Bw(t);
            xe.setItem(r, e);
          } catch {
            console.info("Unable to set Connected Connector Id");
          }
        },
        getActiveNamespace() {
          try {
            return xe.getItem(Ae.ACTIVE_NAMESPACE);
          } catch {
            console.info("Unable to get active namespace");
          }
        },
        getConnectedConnectorId(t) {
          if (t)
            try {
              const e = Bw(t);
              return xe.getItem(e);
            } catch {
              console.info(
                "Unable to get connected connector id in namespace ",
                t
              );
            }
        },
        setConnectedSocialProvider(t) {
          try {
            xe.setItem(Ae.CONNECTED_SOCIAL, t);
          } catch {
            console.info("Unable to set connected social provider");
          }
        },
        getConnectedSocialProvider() {
          try {
            return xe.getItem(Ae.CONNECTED_SOCIAL);
          } catch {
            console.info("Unable to get connected social provider");
          }
        },
        deleteConnectedSocialProvider() {
          try {
            xe.removeItem(Ae.CONNECTED_SOCIAL);
          } catch {
            console.info("Unable to delete connected social provider");
          }
        },
        getConnectedSocialUsername() {
          try {
            return xe.getItem(Ae.CONNECTED_SOCIAL_USERNAME);
          } catch {
            console.info("Unable to get connected social username");
          }
        },
        getStoredActiveCaipNetworkId() {
          return xe.getItem(Ae.ACTIVE_CAIP_NETWORK_ID)?.split(":")?.[1];
        },
        setConnectionStatus(t) {
          try {
            xe.setItem(Ae.CONNECTION_STATUS, t);
          } catch {
            console.info("Unable to set connection status");
          }
        },
        getConnectionStatus() {
          try {
            return xe.getItem(Ae.CONNECTION_STATUS);
          } catch {
            return;
          }
        },
        getConnectedNamespaces() {
          try {
            const t = xe.getItem(Ae.CONNECTED_NAMESPACES);
            return t?.length ? t.split(",") : [];
          } catch {
            return [];
          }
        },
        setConnectedNamespaces(t) {
          try {
            const e = Array.from(new Set(t));
            xe.setItem(Ae.CONNECTED_NAMESPACES, e.join(","));
          } catch {
            console.info("Unable to set namespaces in storage");
          }
        },
        addConnectedNamespace(t) {
          try {
            const e = de.getConnectedNamespaces();
            e.includes(t) || (e.push(t), de.setConnectedNamespaces(e));
          } catch {
            console.info("Unable to add connected namespace");
          }
        },
        removeConnectedNamespace(t) {
          try {
            const e = de.getConnectedNamespaces(),
              r = e.indexOf(t);
            r > -1 && (e.splice(r, 1), de.setConnectedNamespaces(e));
          } catch {
            console.info("Unable to remove connected namespace");
          }
        },
        getTelegramSocialProvider() {
          try {
            return xe.getItem(Ae.TELEGRAM_SOCIAL_PROVIDER);
          } catch {
            return console.info("Unable to get telegram social provider"), null;
          }
        },
        setTelegramSocialProvider(t) {
          try {
            xe.setItem(Ae.TELEGRAM_SOCIAL_PROVIDER, t);
          } catch {
            console.info("Unable to set telegram social provider");
          }
        },
        removeTelegramSocialProvider() {
          try {
            xe.removeItem(Ae.TELEGRAM_SOCIAL_PROVIDER);
          } catch {
            console.info("Unable to remove telegram social provider");
          }
        },
        getBalanceCache() {
          let t = {};
          try {
            const e = xe.getItem(Ae.PORTFOLIO_CACHE);
            t = e ? JSON.parse(e) : {};
          } catch {
            console.info("Unable to get balance cache");
          }
          return t;
        },
        removeAddressFromBalanceCache(t) {
          try {
            const e = de.getBalanceCache();
            xe.setItem(
              Ae.PORTFOLIO_CACHE,
              JSON.stringify({ ...e, [t]: void 0 })
            );
          } catch {
            console.info("Unable to remove address from balance cache", t);
          }
        },
        getBalanceCacheForCaipAddress(t) {
          try {
            const e = de.getBalanceCache()[t];
            if (
              e &&
              !this.isCacheExpired(e.timestamp, this.cacheExpiry.portfolio)
            )
              return e.balance;
            de.removeAddressFromBalanceCache(t);
          } catch {
            console.info("Unable to get balance cache for address", t);
          }
        },
        updateBalanceCache(t) {
          try {
            const e = de.getBalanceCache();
            (e[t.caipAddress] = t),
              xe.setItem(Ae.PORTFOLIO_CACHE, JSON.stringify(e));
          } catch {
            console.info("Unable to update balance cache", t);
          }
        },
        getNativeBalanceCache() {
          let t = {};
          try {
            const e = xe.getItem(Ae.NATIVE_BALANCE_CACHE);
            t = e ? JSON.parse(e) : {};
          } catch {
            console.info("Unable to get balance cache");
          }
          return t;
        },
        removeAddressFromNativeBalanceCache(t) {
          try {
            const e = de.getBalanceCache();
            xe.setItem(
              Ae.NATIVE_BALANCE_CACHE,
              JSON.stringify({ ...e, [t]: void 0 })
            );
          } catch {
            console.info("Unable to remove address from balance cache", t);
          }
        },
        getNativeBalanceCacheForCaipAddress(t) {
          try {
            const e = de.getNativeBalanceCache()[t];
            if (
              e &&
              !this.isCacheExpired(e.timestamp, this.cacheExpiry.nativeBalance)
            )
              return e;
            console.info("Discarding cache for address", t),
              de.removeAddressFromBalanceCache(t);
          } catch {
            console.info("Unable to get balance cache for address", t);
          }
        },
        updateNativeBalanceCache(t) {
          try {
            const e = de.getNativeBalanceCache();
            (e[t.caipAddress] = t),
              xe.setItem(Ae.NATIVE_BALANCE_CACHE, JSON.stringify(e));
          } catch {
            console.info("Unable to update balance cache", t);
          }
        },
        getEnsCache() {
          let t = {};
          try {
            const e = xe.getItem(Ae.ENS_CACHE);
            t = e ? JSON.parse(e) : {};
          } catch {
            console.info("Unable to get ens name cache");
          }
          return t;
        },
        getEnsFromCacheForAddress(t) {
          try {
            const e = de.getEnsCache()[t];
            if (e && !this.isCacheExpired(e.timestamp, this.cacheExpiry.ens))
              return e.ens;
            de.removeEnsFromCache(t);
          } catch {
            console.info("Unable to get ens name from cache", t);
          }
        },
        updateEnsCache(t) {
          try {
            const e = de.getEnsCache();
            (e[t.address] = t), xe.setItem(Ae.ENS_CACHE, JSON.stringify(e));
          } catch {
            console.info("Unable to update ens name cache", t);
          }
        },
        removeEnsFromCache(t) {
          try {
            const e = de.getEnsCache();
            xe.setItem(Ae.ENS_CACHE, JSON.stringify({ ...e, [t]: void 0 }));
          } catch {
            console.info("Unable to remove ens name from cache", t);
          }
        },
        getIdentityCache() {
          let t = {};
          try {
            const e = xe.getItem(Ae.IDENTITY_CACHE);
            t = e ? JSON.parse(e) : {};
          } catch {
            console.info("Unable to get identity cache");
          }
          return t;
        },
        getIdentityFromCacheForAddress(t) {
          try {
            const e = de.getIdentityCache()[t];
            if (
              e &&
              !this.isCacheExpired(e.timestamp, this.cacheExpiry.identity)
            )
              return e.identity;
            de.removeIdentityFromCache(t);
          } catch {
            console.info("Unable to get identity from cache", t);
          }
        },
        updateIdentityCache(t) {
          try {
            const e = de.getIdentityCache();
            (e[t.address] = { identity: t.identity, timestamp: t.timestamp }),
              xe.setItem(Ae.IDENTITY_CACHE, JSON.stringify(e));
          } catch {
            console.info("Unable to update identity cache", t);
          }
        },
        removeIdentityFromCache(t) {
          try {
            const e = de.getIdentityCache();
            xe.setItem(
              Ae.IDENTITY_CACHE,
              JSON.stringify({ ...e, [t]: void 0 })
            );
          } catch {
            console.info("Unable to remove identity from cache", t);
          }
        },
        clearAddressCache() {
          try {
            xe.removeItem(Ae.PORTFOLIO_CACHE),
              xe.removeItem(Ae.NATIVE_BALANCE_CACHE),
              xe.removeItem(Ae.ENS_CACHE),
              xe.removeItem(Ae.IDENTITY_CACHE);
          } catch {
            console.info("Unable to clear address cache");
          }
        },
        setPreferredAccountTypes(t) {
          try {
            xe.setItem(Ae.PREFERRED_ACCOUNT_TYPES, JSON.stringify(t));
          } catch {
            console.info("Unable to set preferred account types", t);
          }
        },
        getPreferredAccountTypes() {
          try {
            const t = xe.getItem(Ae.PREFERRED_ACCOUNT_TYPES);
            return JSON.parse(t);
          } catch {
            console.info("Unable to get preferred account types");
          }
        },
      },
      X = {
        isMobile() {
          return this.isClient()
            ? !!(
                window?.matchMedia("(pointer:coarse)")?.matches ||
                /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(
                  navigator.userAgent
                )
              )
            : !1;
        },
        checkCaipNetwork(t, e = "") {
          return t?.caipNetworkId.toLocaleLowerCase().includes(e.toLowerCase());
        },
        isAndroid() {
          if (!this.isMobile()) return !1;
          const t = window?.navigator.userAgent.toLowerCase();
          return X.isMobile() && t.includes("android");
        },
        isIos() {
          if (!this.isMobile()) return !1;
          const t = window?.navigator.userAgent.toLowerCase();
          return t.includes("iphone") || t.includes("ipad");
        },
        isSafari() {
          return this.isClient()
            ? window?.navigator.userAgent.toLowerCase().includes("safari")
            : !1;
        },
        isClient() {
          return typeof window < "u";
        },
        isPairingExpired(t) {
          return t ? t - Date.now() <= Lt.TEN_SEC_MS : !0;
        },
        isAllowedRetry(t, e = Lt.ONE_SEC_MS) {
          return Date.now() - t >= e;
        },
        copyToClopboard(t) {
          navigator.clipboard.writeText(t);
        },
        isIframe() {
          try {
            return window?.self !== window?.top;
          } catch {
            return !1;
          }
        },
        getPairingExpiry() {
          return Date.now() + Lt.FOUR_MINUTES_MS;
        },
        getNetworkId(t) {
          return t?.split(":")[1];
        },
        getPlainAddress(t) {
          return t?.split(":")[2];
        },
        async wait(t) {
          return new Promise((e) => {
            setTimeout(e, t);
          });
        },
        debounce(t, e = 500) {
          let r;
          return (...i) => {
            function s() {
              t(...i);
            }
            r && clearTimeout(r), (r = setTimeout(s, e));
          };
        },
        isHttpUrl(t) {
          return t.startsWith("http://") || t.startsWith("https://");
        },
        formatNativeUrl(t, e) {
          if (X.isHttpUrl(t)) return this.formatUniversalUrl(t, e);
          let r = t;
          r.includes("://") ||
            ((r = t.replaceAll("/", "").replaceAll(":", "")), (r = `${r}://`)),
            r.endsWith("/") || (r = `${r}/`),
            this.isTelegram() &&
              this.isAndroid() &&
              (e = encodeURIComponent(e));
          const i = encodeURIComponent(e);
          return { redirect: `${r}wc?uri=${i}`, href: r };
        },
        formatUniversalUrl(t, e) {
          if (!X.isHttpUrl(t)) return this.formatNativeUrl(t, e);
          let r = t;
          r.endsWith("/") || (r = `${r}/`);
          const i = encodeURIComponent(e);
          return { redirect: `${r}wc?uri=${i}`, href: r };
        },
        getOpenTargetForPlatform(t) {
          return t === "popupWindow"
            ? t
            : this.isTelegram()
            ? de.getTelegramSocialProvider()
              ? "_top"
              : "_blank"
            : t;
        },
        openHref(t, e, r) {
          window?.open(
            t,
            this.getOpenTargetForPlatform(e),
            r || "noreferrer noopener"
          );
        },
        returnOpenHref(t, e, r) {
          return window?.open(
            t,
            this.getOpenTargetForPlatform(e),
            r || "noreferrer noopener"
          );
        },
        isTelegram() {
          return (
            typeof window < "u" &&
            (!!window.TelegramWebviewProxy ||
              !!window.Telegram ||
              !!window.TelegramWebviewProxyProto)
          );
        },
        async preloadImage(t) {
          const e = new Promise((r, i) => {
            const s = new Image();
            (s.onload = r),
              (s.onerror = i),
              (s.crossOrigin = "anonymous"),
              (s.src = t);
          });
          return Promise.race([e, X.wait(2e3)]);
        },
        formatBalance(t, e) {
          let r = "0.000";
          if (typeof t == "string") {
            const i = Number(t);
            if (i) {
              const s = Math.floor(i * 1e3) / 1e3;
              s && (r = s.toString());
            }
          }
          return `${r}${e ? ` ${e}` : ""}`;
        },
        formatBalance2(t, e) {
          let r;
          if (t === "0") r = "0";
          else if (typeof t == "string") {
            const i = Number(t);
            i && (r = i.toString().match(/^-?\d+(?:\.\d{0,3})?/u)?.[0]);
          }
          return { value: r ?? "0", rest: r === "0" ? "000" : "", symbol: e };
        },
        getApiUrl() {
          return he.W3M_API_URL;
        },
        getBlockchainApiUrl() {
          return he.BLOCKCHAIN_API_RPC_URL;
        },
        getAnalyticsUrl() {
          return he.PULSE_API_URL;
        },
        getUUID() {
          return crypto?.randomUUID
            ? crypto.randomUUID()
            : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (t) => {
                const e = (Math.random() * 16) | 0;
                return (t === "x" ? e : (e & 3) | 8).toString(16);
              });
        },
        parseError(t) {
          return typeof t == "string"
            ? t
            : typeof t?.issues?.[0]?.message == "string"
            ? t.issues[0].message
            : t instanceof Error
            ? t.message
            : "Unknown error";
        },
        sortRequestedNetworks(t, e = []) {
          const r = {};
          return (
            e &&
              t &&
              (t.forEach((i, s) => {
                r[i] = s;
              }),
              e.sort((i, s) => {
                const n = r[i.id],
                  o = r[s.id];
                return n !== void 0 && o !== void 0
                  ? n - o
                  : n !== void 0
                  ? -1
                  : o !== void 0
                  ? 1
                  : 0;
              })),
            e
          );
        },
        calculateBalance(t) {
          let e = 0;
          for (const r of t) e += r.value ?? 0;
          return e;
        },
        formatTokenBalance(t) {
          const e = t.toFixed(2),
            [r, i] = e.split(".");
          return { dollars: r, pennies: i };
        },
        isAddress(t, e = "eip155") {
          switch (e) {
            case "eip155":
              if (/^(?:0x)?[0-9a-f]{40}$/iu.test(t)) {
                if (
                  /^(?:0x)?[0-9a-f]{40}$/iu.test(t) ||
                  /^(?:0x)?[0-9A-F]{40}$/iu.test(t)
                )
                  return !0;
              } else return !1;
              return !1;
            case "solana":
              return /[1-9A-HJ-NP-Za-km-z]{32,44}$/iu.test(t);
            default:
              return !1;
          }
        },
        uniqueBy(t, e) {
          const r = new Set();
          return t.filter((i) => {
            const s = i[e];
            return r.has(s) ? !1 : (r.add(s), !0);
          });
        },
        generateSdkVersion(t, e, r) {
          const i =
            t.length === 0
              ? Lt.ADAPTER_TYPES.UNIVERSAL
              : t.map((s) => s.adapterType).join(",");
          return `${e}-${i}-${r}`;
        },
        createAccount(t, e, r, i, s) {
          return { namespace: t, address: e, type: r, publicKey: i, path: s };
        },
        isCaipAddress(t) {
          if (typeof t != "string") return !1;
          const e = t.split(":"),
            r = e[0];
          return e.filter(Boolean).length === 3 && r in he.CHAIN_NAME_MAP;
        },
        isMac() {
          const t = window?.navigator.userAgent.toLowerCase();
          return t.includes("macintosh") && !t.includes("safari");
        },
        formatTelegramSocialLoginUrl(t) {
          const e = `--${encodeURIComponent(window?.location.href)}`,
            r = "state=";
          if (new URL(t).host === "auth.magic.link") {
            const i = "provider_authorization_url=",
              s = t.substring(t.indexOf(i) + i.length),
              n = this.injectIntoUrl(decodeURIComponent(s), r, e);
            return t.replace(s, encodeURIComponent(n));
          }
          return this.injectIntoUrl(t, r, e);
        },
        injectIntoUrl(t, e, r) {
          const i = t.indexOf(e);
          if (i === -1)
            throw new Error(`${e} parameter not found in the URL: ${t}`);
          const s = t.indexOf("&", i),
            n = e.length,
            o = s !== -1 ? s : t.length,
            a = t.substring(0, i + n),
            c = t.substring(i + n, o),
            l = t.substring(s),
            u = c + r;
          return a + u + l;
        },
      };
    async function Ju(...t) {
      const e = await fetch(...t);
      if (!e.ok) throw new Error(`HTTP status code: ${e.status}`, { cause: e });
      return e;
    }
    class rf {
      constructor({ baseUrl: e, clientId: r }) {
        (this.baseUrl = e), (this.clientId = r);
      }
      async get({ headers: e, signal: r, cache: i, ...s }) {
        const n = this.createUrl(s);
        return (
          await Ju(n, { method: "GET", headers: e, signal: r, cache: i })
        ).json();
      }
      async getBlob({ headers: e, signal: r, ...i }) {
        const s = this.createUrl(i);
        return (await Ju(s, { method: "GET", headers: e, signal: r })).blob();
      }
      async post({ body: e, headers: r, signal: i, ...s }) {
        const n = this.createUrl(s);
        return (
          await Ju(n, {
            method: "POST",
            headers: r,
            body: e ? JSON.stringify(e) : void 0,
            signal: i,
          })
        ).json();
      }
      async put({ body: e, headers: r, signal: i, ...s }) {
        const n = this.createUrl(s);
        return (
          await Ju(n, {
            method: "PUT",
            headers: r,
            body: e ? JSON.stringify(e) : void 0,
            signal: i,
          })
        ).json();
      }
      async delete({ body: e, headers: r, signal: i, ...s }) {
        const n = this.createUrl(s);
        return (
          await Ju(n, {
            method: "DELETE",
            headers: r,
            body: e ? JSON.stringify(e) : void 0,
            signal: i,
          })
        ).json();
      }
      createUrl({ path: e, params: r }) {
        const i = new URL(e, this.baseUrl);
        return (
          r &&
            Object.entries(r).forEach(([s, n]) => {
              n && i.searchParams.append(s, n);
            }),
          this.clientId && i.searchParams.append("clientId", this.clientId),
          i
        );
      }
    }
    const QV = {
        handleSolanaDeeplinkRedirect(t) {
          if (B.state.activeChain === he.CHAIN.SOLANA) {
            const e = window.location.href,
              r = encodeURIComponent(e);
            if (t === "Phantom" && !("phantom" in window)) {
              const i = e.startsWith("https") ? "https" : "http",
                s = e.split("/")[2],
                n = encodeURIComponent(`${i}://${s}`);
              window.location.href = `https://phantom.app/ul/browse/${r}?ref=${n}`;
            }
            t === "Coinbase Wallet" &&
              !("coinbaseSolana" in window) &&
              (window.location.href = `https://go.cb-w.com/dapp?cb_url=${r}`);
          }
        },
      },
      gi = ot({
        walletImages: {},
        networkImages: {},
        chainImages: {},
        connectorImages: {},
        tokenImages: {},
        currencyImages: {},
      }),
      Gr = {
        state: gi,
        subscribeNetworkImages(t) {
          return Sr(gi.networkImages, () => t(gi.networkImages));
        },
        subscribeKey(t, e) {
          return Fr(gi, t, e);
        },
        subscribe(t) {
          return Sr(gi, () => t(gi));
        },
        setWalletImage(t, e) {
          gi.walletImages[t] = e;
        },
        setNetworkImage(t, e) {
          gi.networkImages[t] = e;
        },
        setChainImage(t, e) {
          gi.chainImages[t] = e;
        },
        setConnectorImage(t, e) {
          gi.connectorImages = { ...gi.connectorImages, [t]: e };
        },
        setTokenImage(t, e) {
          gi.tokenImages[t] = e;
        },
        setCurrencyImage(t, e) {
          gi.currencyImages[t] = e;
        },
      },
      eW = {
        eip155: "ba0ba0cd-17c6-4806-ad93-f9d174f17900",
        solana: "a1b58899-f671-4276-6a5e-56ca5bd59700",
        polkadot: "",
        bip122: "0b4838db-0161-4ffe-022d-532bf03dba00",
      },
      jw = ot({ networkImagePromises: {} }),
      Ut = {
        async fetchWalletImage(t) {
          if (t)
            return await ne._fetchWalletImage(t), this.getWalletImageById(t);
        },
        async fetchNetworkImage(t) {
          return t
            ? this.getNetworkImageById(t) ||
                (jw.networkImagePromises[t] ||
                  (jw.networkImagePromises[t] = ne._fetchNetworkImage(t)),
                await jw.networkImagePromises[t],
                this.getNetworkImageById(t))
            : void 0;
        },
        getWalletImageById(t) {
          if (t) return Gr.state.walletImages[t];
        },
        getWalletImage(t) {
          if (t?.image_url) return t?.image_url;
          if (t?.image_id) return Gr.state.walletImages[t.image_id];
        },
        getNetworkImage(t) {
          if (t?.assets?.imageUrl) return t?.assets?.imageUrl;
          if (t?.assets?.imageId)
            return Gr.state.networkImages[t.assets.imageId];
        },
        getNetworkImageById(t) {
          if (t) return Gr.state.networkImages[t];
        },
        getConnectorImage(t) {
          if (t?.imageUrl) return t.imageUrl;
          if (t?.imageId) return Gr.state.connectorImages[t.imageId];
        },
        getChainImage(t) {
          return Gr.state.networkImages[eW[t]];
        },
      },
      tW = {
        getFeatureValue(t, e) {
          const r = e?.[t];
          return r === void 0 ? Lt.DEFAULT_FEATURES[t] : r;
        },
        filterSocialsByPlatform(t) {
          if (!t || !t.length) return t;
          if (X.isTelegram()) {
            if (X.isIos()) return t.filter((e) => e !== "google");
            if (X.isMac()) return t.filter((e) => e !== "x");
            if (X.isAndroid())
              return t.filter((e) => !["facebook", "x"].includes(e));
          }
          return t;
        },
      },
      me = ot({
        features: Lt.DEFAULT_FEATURES,
        projectId: "",
        sdkType: "appkit",
        sdkVersion: "html-wagmi-undefined",
        defaultAccountTypes: {
          solana: "eoa",
          bip122: "payment",
          polkadot: "eoa",
          eip155: "smartAccount",
        },
        enableNetworkSwitch: !0,
      }),
      G = {
        state: me,
        subscribeKey(t, e) {
          return Fr(me, t, e);
        },
        setOptions(t) {
          Object.assign(me, t);
        },
        setFeatures(t) {
          if (!t) return;
          me.features || (me.features = Lt.DEFAULT_FEATURES);
          const e = { ...me.features, ...t };
          (me.features = e),
            me.features.socials &&
              (me.features.socials = tW.filterSocialsByPlatform(
                me.features.socials
              ));
        },
        setProjectId(t) {
          me.projectId = t;
        },
        setCustomRpcUrls(t) {
          me.customRpcUrls = t;
        },
        setAllWallets(t) {
          me.allWallets = t;
        },
        setIncludeWalletIds(t) {
          me.includeWalletIds = t;
        },
        setExcludeWalletIds(t) {
          me.excludeWalletIds = t;
        },
        setFeaturedWalletIds(t) {
          me.featuredWalletIds = t;
        },
        setTokens(t) {
          me.tokens = t;
        },
        setTermsConditionsUrl(t) {
          me.termsConditionsUrl = t;
        },
        setPrivacyPolicyUrl(t) {
          me.privacyPolicyUrl = t;
        },
        setCustomWallets(t) {
          me.customWallets = t;
        },
        setIsSiweEnabled(t) {
          me.isSiweEnabled = t;
        },
        setIsUniversalProvider(t) {
          me.isUniversalProvider = t;
        },
        setSdkVersion(t) {
          me.sdkVersion = t;
        },
        setMetadata(t) {
          me.metadata = t;
        },
        setDisableAppend(t) {
          me.disableAppend = t;
        },
        setEIP6963Enabled(t) {
          me.enableEIP6963 = t;
        },
        setDebug(t) {
          me.debug = t;
        },
        setEnableWalletConnect(t) {
          me.enableWalletConnect = t;
        },
        setEnableWalletGuide(t) {
          me.enableWalletGuide = t;
        },
        setEnableAuthLogger(t) {
          me.enableAuthLogger = t;
        },
        setEnableWallets(t) {
          me.enableWallets = t;
        },
        setHasMultipleAddresses(t) {
          me.hasMultipleAddresses = t;
        },
        setSIWX(t) {
          me.siwx = t;
        },
        setConnectMethodsOrder(t) {
          me.features = { ...me.features, connectMethodsOrder: t };
        },
        setWalletFeaturesOrder(t) {
          me.features = { ...me.features, walletFeaturesOrder: t };
        },
        setSocialsOrder(t) {
          me.features = { ...me.features, socials: t };
        },
        setCollapseWallets(t) {
          me.features = { ...me.features, collapseWallets: t };
        },
        setEnableEmbedded(t) {
          me.enableEmbedded = t;
        },
        setAllowUnsupportedChain(t) {
          me.allowUnsupportedChain = t;
        },
        setManualWCControl(t) {
          me.manualWCControl = t;
        },
        setEnableNetworkSwitch(t) {
          me.enableNetworkSwitch = t;
        },
        setDefaultAccountTypes(t = {}) {
          Object.entries(t).forEach(([e, r]) => {
            r && (me.defaultAccountTypes[e] = r);
          });
        },
        setUniversalProviderConfigOverride(t) {
          me.universalProviderConfigOverride = t;
        },
        getUniversalProviderConfigOverride() {
          return me.universalProviderConfigOverride;
        },
        getSnapshot() {
          return Yu(me);
        },
      },
      to = ot({ message: "", variant: "info", open: !1 }),
      ro = {
        state: to,
        subscribeKey(t, e) {
          return Fr(to, t, e);
        },
        open(t, e) {
          const { debug: r } = G.state,
            { shortMessage: i, longMessage: s } = t;
          r && ((to.message = i), (to.variant = e), (to.open = !0)),
            s && console.error(typeof s == "function" ? s() : s);
        },
        close() {
          (to.open = !1), (to.message = ""), (to.variant = "info");
        },
      },
      rW = X.getAnalyticsUrl(),
      iW = new rf({ baseUrl: rW, clientId: null }),
      sW = ["MODAL_CREATED"],
      on = ot({
        timestamp: Date.now(),
        reportedErrors: {},
        data: { type: "track", event: "MODAL_CREATED" },
      }),
      Se = {
        state: on,
        subscribe(t) {
          return Sr(on, () => t(on));
        },
        getSdkProperties() {
          const { projectId: t, sdkType: e, sdkVersion: r } = G.state;
          return { projectId: t, st: e, sv: r || "html-wagmi-4.2.2" };
        },
        async _sendAnalyticsEvent(t) {
          try {
            const e = fe.state.address;
            if (sW.includes(t.data.event) || typeof window > "u") return;
            await iW.post({
              path: "/e",
              params: Se.getSdkProperties(),
              body: {
                eventId: X.getUUID(),
                url: window.location.href,
                domain: window.location.hostname,
                timestamp: t.timestamp,
                props: { ...t.data, address: e },
              },
            }),
              (on.reportedErrors.FORBIDDEN = !1);
          } catch (e) {
            e instanceof Error &&
              e.cause instanceof Response &&
              e.cause.status === he.HTTP_STATUS_CODES.FORBIDDEN &&
              !on.reportedErrors.FORBIDDEN &&
              (ro.open(
                {
                  shortMessage: "Invalid App Configuration",
                  longMessage: `Origin ${
                    Gu() ? window.origin : "uknown"
                  } not found on Allowlist - update configuration on cloud.reown.com`,
                },
                "error"
              ),
              (on.reportedErrors.FORBIDDEN = !0));
          }
        },
        sendEvent(t) {
          (on.timestamp = Date.now()),
            (on.data = t),
            G.state.features?.analytics && Se._sendAnalyticsEvent(on);
        },
      },
      nW = [
        "1ca0bdd4747578705b1939af023d120677c64fe6ca76add81fda36e350605e79",
        "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
        "a797aa35c0fadbfc1a53e7f675162ed5226968b44a19ee3d24385c64d1d3c393",
      ],
      oW = X.getApiUrl(),
      Bi = new rf({ baseUrl: oW, clientId: null }),
      aW = 40,
      sE = 4,
      cW = 20,
      Ye = ot({
        promises: {},
        page: 1,
        count: 0,
        featured: [],
        allFeatured: [],
        recommended: [],
        allRecommended: [],
        wallets: [],
        search: [],
        isAnalyticsEnabled: !1,
        excludedWallets: [],
        isFetchingRecommendedWallets: !1,
      }),
      ne = {
        state: Ye,
        subscribeKey(t, e) {
          return Fr(Ye, t, e);
        },
        _getSdkProperties() {
          const { projectId: t, sdkType: e, sdkVersion: r } = G.state;
          return {
            projectId: t,
            st: e || "appkit",
            sv: r || "html-wagmi-4.2.2",
          };
        },
        _filterOutExtensions(t) {
          return G.state.isUniversalProvider
            ? t.filter(
                (e) => !!(e.mobile_link || e.desktop_link || e.webapp_link)
              )
            : t;
        },
        async _fetchWalletImage(t) {
          const e = `${Bi.baseUrl}/getWalletImage/${t}`,
            r = await Bi.getBlob({ path: e, params: ne._getSdkProperties() });
          Gr.setWalletImage(t, URL.createObjectURL(r));
        },
        async _fetchNetworkImage(t) {
          const e = `${Bi.baseUrl}/public/getAssetImage/${t}`,
            r = await Bi.getBlob({ path: e, params: ne._getSdkProperties() });
          Gr.setNetworkImage(t, URL.createObjectURL(r));
        },
        async _fetchConnectorImage(t) {
          const e = `${Bi.baseUrl}/public/getAssetImage/${t}`,
            r = await Bi.getBlob({ path: e, params: ne._getSdkProperties() });
          Gr.setConnectorImage(t, URL.createObjectURL(r));
        },
        async _fetchCurrencyImage(t) {
          const e = `${Bi.baseUrl}/public/getCurrencyImage/${t}`,
            r = await Bi.getBlob({ path: e, params: ne._getSdkProperties() });
          Gr.setCurrencyImage(t, URL.createObjectURL(r));
        },
        async _fetchTokenImage(t) {
          const e = `${Bi.baseUrl}/public/getTokenImage/${t}`,
            r = await Bi.getBlob({ path: e, params: ne._getSdkProperties() });
          Gr.setTokenImage(t, URL.createObjectURL(r));
        },
        async fetchNetworkImages() {
          const t = B.getAllRequestedCaipNetworks()
            ?.map(({ assets: e }) => e?.imageId)
            .filter(Boolean)
            .filter((e) => !Ut.getNetworkImageById(e));
          t &&
            (await Promise.allSettled(t.map((e) => ne._fetchNetworkImage(e))));
        },
        async fetchConnectorImages() {
          const { connectors: t } = oe.state,
            e = t.map(({ imageId: r }) => r).filter(Boolean);
          await Promise.allSettled(e.map((r) => ne._fetchConnectorImage(r)));
        },
        async fetchCurrencyImages(t = []) {
          await Promise.allSettled(t.map((e) => ne._fetchCurrencyImage(e)));
        },
        async fetchTokenImages(t = []) {
          await Promise.allSettled(t.map((e) => ne._fetchTokenImage(e)));
        },
        async fetchWallets(t) {
          const e = t.exclude ?? [];
          return (
            ne._getSdkProperties().sv.startsWith("html-core-") && e.push(...nW),
            await Bi.get({
              path: "/getWallets",
              params: {
                ...ne._getSdkProperties(),
                ...t,
                page: String(t.page),
                entries: String(t.entries),
                include: t.include?.join(","),
                exclude: t.exclude?.join(","),
              },
            })
          );
        },
        async fetchFeaturedWallets() {
          const { featuredWalletIds: t } = G.state;
          if (t?.length) {
            const e = {
                ...ne._getSdkProperties(),
                page: 1,
                entries: t?.length ?? sE,
                include: t,
              },
              { data: r } = await ne.fetchWallets(e);
            r.sort((s, n) => t.indexOf(s.id) - t.indexOf(n.id));
            const i = r.map((s) => s.image_id).filter(Boolean);
            await Promise.allSettled(i.map((s) => ne._fetchWalletImage(s))),
              (Ye.featured = r),
              (Ye.allFeatured = r);
          }
        },
        async fetchRecommendedWallets() {
          try {
            Ye.isFetchingRecommendedWallets = !0;
            const {
                includeWalletIds: t,
                excludeWalletIds: e,
                featuredWalletIds: r,
              } = G.state,
              i = [...(e ?? []), ...(r ?? [])].filter(Boolean),
              s = B.getRequestedCaipNetworkIds().join(","),
              n = { page: 1, entries: sE, include: t, exclude: i, chains: s },
              { data: o, count: a } = await ne.fetchWallets(n),
              c = de.getRecentWallets(),
              l = o.map((h) => h.image_id).filter(Boolean),
              u = c.map((h) => h.image_id).filter(Boolean);
            await Promise.allSettled(
              [...l, ...u].map((h) => ne._fetchWalletImage(h))
            ),
              (Ye.recommended = o),
              (Ye.allRecommended = o),
              (Ye.count = a ?? 0);
          } catch {
          } finally {
            Ye.isFetchingRecommendedWallets = !1;
          }
        },
        async fetchWalletsByPage({ page: t }) {
          const {
              includeWalletIds: e,
              excludeWalletIds: r,
              featuredWalletIds: i,
            } = G.state,
            s = B.getRequestedCaipNetworkIds().join(","),
            n = [
              ...Ye.recommended.map(({ id: u }) => u),
              ...(r ?? []),
              ...(i ?? []),
            ].filter(Boolean),
            o = { page: t, entries: aW, include: e, exclude: n, chains: s },
            { data: a, count: c } = await ne.fetchWallets(o),
            l = a
              .slice(0, cW)
              .map((u) => u.image_id)
              .filter(Boolean);
          await Promise.allSettled(l.map((u) => ne._fetchWalletImage(u))),
            (Ye.wallets = X.uniqueBy(
              [...Ye.wallets, ...ne._filterOutExtensions(a)],
              "id"
            )),
            (Ye.count = c > Ye.count ? c : Ye.count),
            (Ye.page = t);
        },
        async initializeExcludedWallets({ ids: t }) {
          const e = B.getRequestedCaipNetworkIds().join(","),
            r = { page: 1, entries: t.length, include: t, chains: e },
            { data: i } = await ne.fetchWallets(r);
          i &&
            i.forEach((s) => {
              Ye.excludedWallets.push({ rdns: s.rdns, name: s.name });
            });
        },
        async searchWallet({ search: t, badge: e }) {
          const { includeWalletIds: r, excludeWalletIds: i } = G.state,
            s = B.getRequestedCaipNetworkIds().join(",");
          Ye.search = [];
          const n = {
              page: 1,
              entries: 100,
              search: t?.trim(),
              badge_type: e,
              include: r,
              exclude: i,
              chains: s,
            },
            { data: o } = await ne.fetchWallets(n);
          Se.sendEvent({
            type: "track",
            event: "SEARCH_WALLET",
            properties: { badge: e ?? "", search: t ?? "" },
          });
          const a = o.map((c) => c.image_id).filter(Boolean);
          await Promise.allSettled([
            ...a.map((c) => ne._fetchWalletImage(c)),
            X.wait(300),
          ]),
            (Ye.search = ne._filterOutExtensions(o));
        },
        initPromise(t, e) {
          return Ye.promises[t] || (Ye.promises[t] = e());
        },
        prefetch({
          fetchConnectorImages: t = !0,
          fetchFeaturedWallets: e = !0,
          fetchRecommendedWallets: r = !0,
          fetchNetworkImages: i = !0,
        } = {}) {
          const s = [
            t && ne.initPromise("connectorImages", ne.fetchConnectorImages),
            e && ne.initPromise("featuredWallets", ne.fetchFeaturedWallets),
            r &&
              ne.initPromise("recommendedWallets", ne.fetchRecommendedWallets),
            i && ne.initPromise("networkImages", ne.fetchNetworkImages),
          ].filter(Boolean);
          return Promise.allSettled(s);
        },
        prefetchAnalyticsConfig() {
          G.state.features?.analytics && ne.fetchAnalyticsConfig();
        },
        async fetchAnalyticsConfig() {
          try {
            const { isAnalyticsEnabled: t } = await Bi.get({
              path: "/getAnalyticsConfig",
              params: ne._getSdkProperties(),
            });
            G.setFeatures({ analytics: t });
          } catch {
            G.setFeatures({ analytics: !1 });
          }
        },
        setFilterByNamespace(t) {
          if (!t) {
            (Ye.featured = Ye.allFeatured),
              (Ye.recommended = Ye.allRecommended);
            return;
          }
          const e = B.getRequestedCaipNetworkIds().join(",");
          (Ye.featured = Ye.allFeatured.filter((r) =>
            r.chains?.some((i) => e.includes(i))
          )),
            (Ye.recommended = Ye.allRecommended.filter((r) =>
              r.chains?.some((i) => e.includes(i))
            ));
        },
      },
      We = ot({ view: "Connect", history: ["Connect"], transactionStack: [] }),
      ie = {
        state: We,
        subscribeKey(t, e) {
          return Fr(We, t, e);
        },
        pushTransactionStack(t) {
          We.transactionStack.push(t);
        },
        popTransactionStack(t) {
          const e = We.transactionStack.pop();
          if (e)
            if (t) this.goBack(), e?.onCancel?.();
            else {
              if (e.goBack) this.goBack();
              else if (e.replace) {
                const r = We.history.indexOf("ConnectingSiwe");
                r > 0
                  ? this.goBackToIndex(r - 1)
                  : ($e.close(), (We.history = []));
              } else e.view && this.reset(e.view);
              e?.onSuccess?.();
            }
        },
        push(t, e) {
          t !== We.view && ((We.view = t), We.history.push(t), (We.data = e));
        },
        reset(t, e) {
          (We.view = t), (We.history = [t]), (We.data = e);
        },
        replace(t, e) {
          We.history.at(-1) === t ||
            ((We.view = t),
            (We.history[We.history.length - 1] = t),
            (We.data = e));
        },
        goBack() {
          const t =
            !B.state.activeCaipAddress &&
            this.state.view === "ConnectingFarcaster";
          if (
            We.history.length > 1 &&
            !We.history.includes("UnsupportedChain")
          ) {
            We.history.pop();
            const [e] = We.history.slice(-1);
            e && (We.view = e);
          } else $e.close();
          We.data?.wallet && (We.data.wallet = void 0),
            setTimeout(() => {
              if (t) {
                fe.setFarcasterUrl(void 0, B.state.activeChain);
                const e = oe.getAuthConnector();
                e?.provider?.reload();
                const r = Yu(G.state);
                e?.provider?.syncDappData?.({
                  metadata: r.metadata,
                  sdkVersion: r.sdkVersion,
                  projectId: r.projectId,
                  sdkType: r.sdkType,
                });
              }
            }, 100);
        },
        goBackToIndex(t) {
          if (We.history.length > 1) {
            We.history = We.history.slice(0, t + 1);
            const [e] = We.history.slice(-1);
            e && (We.view = e);
          }
        },
      },
      an = ot({
        themeMode: "dark",
        themeVariables: {},
        w3mThemeVariables: void 0,
      }),
      Dt = {
        state: an,
        subscribe(t) {
          return Sr(an, () => t(an));
        },
        setThemeMode(t) {
          an.themeMode = t;
          try {
            const e = oe.getAuthConnector();
            if (e) {
              const r = Dt.getSnapshot().themeVariables;
              e.provider.syncTheme({
                themeMode: t,
                themeVariables: r,
                w3mThemeVariables: Qn(r, t),
              });
            }
          } catch {
            console.info("Unable to sync theme to auth connector");
          }
        },
        setThemeVariables(t) {
          an.themeVariables = { ...an.themeVariables, ...t };
          try {
            const e = oe.getAuthConnector();
            if (e) {
              const r = Dt.getSnapshot().themeVariables;
              e.provider.syncTheme({
                themeVariables: r,
                w3mThemeVariables: Qn(an.themeVariables, an.themeMode),
              });
            }
          } catch {
            console.info("Unable to sync theme to auth connector");
          }
        },
        getSnapshot() {
          return Yu(an);
        },
      },
      nE = { eip155: void 0, solana: void 0, polkadot: void 0, bip122: void 0 },
      Je = ot({
        allConnectors: [],
        connectors: [],
        activeConnector: void 0,
        filterByNamespace: void 0,
        activeConnectorIds: { ...nE },
      }),
      oe = {
        state: Je,
        subscribe(t) {
          return Sr(Je, () => {
            t(Je);
          });
        },
        subscribeKey(t, e) {
          return Fr(Je, t, e);
        },
        initialize(t) {
          t.forEach((e) => {
            const r = de.getConnectedConnectorId(e);
            r && this.setConnectorId(r, e);
          });
        },
        setActiveConnector(t) {
          t && (Je.activeConnector = ta(t));
        },
        setConnectors(t) {
          t
            .filter(
              (e) =>
                !Je.allConnectors.some(
                  (r) =>
                    r.id === e.id &&
                    this.getConnectorName(r.name) ===
                      this.getConnectorName(e.name) &&
                    r.chain === e.chain
                )
            )
            .forEach((e) => {
              e.type !== "MULTI_CHAIN" && Je.allConnectors.push(ta(e));
            }),
            (Je.connectors = this.mergeMultiChainConnectors(Je.allConnectors));
        },
        removeAdapter(t) {
          (Je.allConnectors = Je.allConnectors.filter((e) => e.chain !== t)),
            (Je.connectors = this.mergeMultiChainConnectors(Je.allConnectors));
        },
        mergeMultiChainConnectors(t) {
          const e = this.generateConnectorMapByName(t),
            r = [];
          return (
            e.forEach((i) => {
              const s = i[0],
                n = s?.id === he.CONNECTOR_ID.AUTH;
              i.length > 1 && s
                ? r.push({
                    name: s.name,
                    imageUrl: s.imageUrl,
                    imageId: s.imageId,
                    connectors: [...i],
                    type: n ? "AUTH" : "MULTI_CHAIN",
                    chain: "eip155",
                    id: s?.id || "",
                  })
                : s && r.push(s);
            }),
            r
          );
        },
        generateConnectorMapByName(t) {
          const e = new Map();
          return (
            t.forEach((r) => {
              const { name: i } = r,
                s = this.getConnectorName(i);
              if (!s) return;
              const n = e.get(s) || [];
              n.find((o) => o.chain === r.chain) || n.push(r), e.set(s, n);
            }),
            e
          );
        },
        getConnectorName(t) {
          return t && ({ "Trust Wallet": "Trust" }[t] || t);
        },
        getUniqueConnectorsByName(t) {
          const e = [];
          return (
            t.forEach((r) => {
              e.find((i) => i.chain === r.chain) || e.push(r);
            }),
            e
          );
        },
        addConnector(t) {
          if (t.id === he.CONNECTOR_ID.AUTH) {
            const e = t,
              r = Yu(G.state),
              i = Dt.getSnapshot().themeMode,
              s = Dt.getSnapshot().themeVariables;
            e?.provider?.syncDappData?.({
              metadata: r.metadata,
              sdkVersion: r.sdkVersion,
              projectId: r.projectId,
              sdkType: r.sdkType,
            }),
              e?.provider?.syncTheme({
                themeMode: i,
                themeVariables: s,
                w3mThemeVariables: Qn(s, i),
              }),
              this.setConnectors([t]);
          } else this.setConnectors([t]);
        },
        getAuthConnector(t) {
          const e = t || B.state.activeChain,
            r = Je.connectors.find((i) => i.id === he.CONNECTOR_ID.AUTH);
          if (r)
            return r?.connectors?.length
              ? r.connectors.find((i) => i.chain === e)
              : r;
        },
        getAnnouncedConnectorRdns() {
          return Je.connectors
            .filter((t) => t.type === "ANNOUNCED")
            .map((t) => t.info?.rdns);
        },
        getConnectorById(t) {
          return Je.allConnectors.find((e) => e.id === t);
        },
        getConnector(t, e) {
          return Je.allConnectors
            .filter((r) => r.chain === B.state.activeChain)
            .find((r) => r.explorerId === t || r.info?.rdns === e);
        },
        syncIfAuthConnector(t) {
          if (t.id !== "ID_AUTH") return;
          const e = t,
            r = Yu(G.state),
            i = Dt.getSnapshot().themeMode,
            s = Dt.getSnapshot().themeVariables;
          e?.provider?.syncDappData?.({
            metadata: r.metadata,
            sdkVersion: r.sdkVersion,
            sdkType: r.sdkType,
            projectId: r.projectId,
          }),
            e.provider.syncTheme({
              themeMode: i,
              themeVariables: s,
              w3mThemeVariables: Qn(s, i),
            });
        },
        getConnectorsByNamespace(t) {
          const e = Je.allConnectors.filter((r) => r.chain === t);
          return this.mergeMultiChainConnectors(e);
        },
        selectWalletConnector(t) {
          const e = oe.getConnector(t.id, t.rdns);
          B.state.activeChain === he.CHAIN.SOLANA &&
            QV.handleSolanaDeeplinkRedirect(e?.name || t.name || ""),
            e
              ? ie.push("ConnectingExternal", { connector: e })
              : ie.push("ConnectingWalletConnect", { wallet: t });
        },
        getConnectors(t) {
          return t
            ? this.getConnectorsByNamespace(t)
            : this.mergeMultiChainConnectors(Je.allConnectors);
        },
        setFilterByNamespace(t) {
          (Je.filterByNamespace = t),
            (Je.connectors = this.getConnectors(t)),
            ne.setFilterByNamespace(t);
        },
        setConnectorId(t, e) {
          t &&
            ((Je.activeConnectorIds = { ...Je.activeConnectorIds, [e]: t }),
            de.setConnectedConnectorId(e, t));
        },
        removeConnectorId(t) {
          (Je.activeConnectorIds = { ...Je.activeConnectorIds, [t]: void 0 }),
            de.deleteConnectedConnectorId(t);
        },
        getConnectorId(t) {
          if (t) return Je.activeConnectorIds[t];
        },
        isConnected(t) {
          return t
            ? !!Je.activeConnectorIds[t]
            : Object.values(Je.activeConnectorIds).some((e) => !!e);
        },
        resetConnectorIds() {
          Je.activeConnectorIds = { ...nE };
        },
      };
    function sf(t, e) {
      return oe.getConnectorId(t) === e;
    }
    function lW(t) {
      const e = Array.from(B.state.chains.keys());
      let r = [];
      return (
        t
          ? (r.push([t, B.state.chains.get(t)]),
            sf(t, he.CONNECTOR_ID.WALLET_CONNECT)
              ? e.forEach((i) => {
                  i !== t &&
                    sf(i, he.CONNECTOR_ID.WALLET_CONNECT) &&
                    r.push([i, B.state.chains.get(i)]);
                })
              : sf(t, he.CONNECTOR_ID.AUTH) &&
                e.forEach((i) => {
                  i !== t &&
                    sf(i, he.CONNECTOR_ID.AUTH) &&
                    r.push([i, B.state.chains.get(i)]);
                }))
          : (r = Array.from(B.state.chains.entries())),
        r
      );
    }
    class uW extends Map {
      constructor(e) {
        super(),
          Object.defineProperty(this, "maxSize", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          (this.maxSize = e);
      }
      get(e) {
        const r = super.get(e);
        return (
          super.has(e) && r !== void 0 && (this.delete(e), super.set(e, r)), r
        );
      }
      set(e, r) {
        if ((super.set(e, r), this.maxSize && this.size > this.maxSize)) {
          const i = this.keys().next().value;
          i && this.delete(i);
        }
        return this;
      }
    }
    new uW(128);
    const hW = "0.1.1";
    function dW() {
      return hW;
    }
    class Br extends Error {
      constructor(e, r = {}) {
        const i = (() => {
            if (r.cause instanceof Br) {
              if (r.cause.details) return r.cause.details;
              if (r.cause.shortMessage) return r.cause.shortMessage;
            }
            return r.cause?.message ? r.cause.message : r.details;
          })(),
          s = (r.cause instanceof Br && r.cause.docsPath) || r.docsPath,
          n = `https://oxlib.sh${s ?? ""}`,
          o = [
            e || "An error occurred.",
            ...(r.metaMessages ? ["", ...r.metaMessages] : []),
            ...(i || s
              ? ["", i ? `Details: ${i}` : void 0, s ? `See: ${n}` : void 0]
              : []),
          ].filter((a) => typeof a == "string").join(`
`);
        super(o, r.cause ? { cause: r.cause } : void 0),
          Object.defineProperty(this, "details", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "docs", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "docsPath", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "shortMessage", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "cause", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "BaseError",
          }),
          Object.defineProperty(this, "version", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: `ox@${dW()}`,
          }),
          (this.cause = r.cause),
          (this.details = i),
          (this.docs = n),
          (this.docsPath = s),
          (this.shortMessage = e);
      }
      walk(e) {
        return oE(this, e);
      }
    }
    function oE(t, e) {
      return e?.(t)
        ? t
        : t && typeof t == "object" && "cause" in t && t.cause
        ? oE(t.cause, e)
        : e
        ? null
        : t;
    }
    function pW(t, e) {
      if (lE(t) > e) throw new EW({ givenSize: lE(t), maxSize: e });
    }
    const cn = { zero: 48, nine: 57, A: 65, F: 70, a: 97, f: 102 };
    function aE(t) {
      if (t >= cn.zero && t <= cn.nine) return t - cn.zero;
      if (t >= cn.A && t <= cn.F) return t - (cn.A - 10);
      if (t >= cn.a && t <= cn.f) return t - (cn.a - 10);
    }
    function fW(t, e = {}) {
      const { dir: r, size: i = 32 } = e;
      if (i === 0) return t;
      if (t.length > i)
        throw new CW({ size: t.length, targetSize: i, type: "Bytes" });
      const s = new Uint8Array(i);
      for (let n = 0; n < i; n++) {
        const o = r === "right";
        s[o ? n : i - n - 1] = t[o ? n : t.length - n - 1];
      }
      return s;
    }
    function Mw(t, e) {
      if (qw(t) > e) throw new OW({ givenSize: qw(t), maxSize: e });
    }
    function cE(t, e = {}) {
      const { dir: r, size: i = 32 } = e;
      if (i === 0) return t;
      const s = t.replace("0x", "");
      if (s.length > i * 2)
        throw new NW({
          size: Math.ceil(s.length / 2),
          targetSize: i,
          type: "Hex",
        });
      return `0x${s[r === "right" ? "padEnd" : "padStart"](i * 2, "0")}`;
    }
    const gW = new TextEncoder();
    function wW(t) {
      return t instanceof Uint8Array ? t : typeof t == "string" ? yW(t) : mW(t);
    }
    function mW(t) {
      return t instanceof Uint8Array ? t : new Uint8Array(t);
    }
    function yW(t, e = {}) {
      const { size: r } = e;
      let i = t;
      r && (Mw(t, r), (i = zw(t, r)));
      let s = i.slice(2);
      s.length % 2 && (s = `0${s}`);
      const n = s.length / 2,
        o = new Uint8Array(n);
      for (let a = 0, c = 0; a < n; a++) {
        const l = aE(s.charCodeAt(c++)),
          u = aE(s.charCodeAt(c++));
        if (l === void 0 || u === void 0)
          throw new Br(
            `Invalid byte sequence ("${s[c - 2]}${s[c - 1]}" in "${s}").`
          );
        o[a] = l * 16 + u;
      }
      return o;
    }
    function bW(t, e = {}) {
      const { size: r } = e,
        i = gW.encode(t);
      return typeof r == "number" ? (pW(i, r), vW(i, r)) : i;
    }
    function vW(t, e) {
      return fW(t, { dir: "right", size: e });
    }
    function lE(t) {
      return t.length;
    }
    class EW extends Br {
      constructor({ givenSize: e, maxSize: r }) {
        super(`Size cannot exceed \`${r}\` bytes. Given size: \`${e}\` bytes.`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Bytes.SizeOverflowError",
          });
      }
    }
    class CW extends Br {
      constructor({ size: e, targetSize: r, type: i }) {
        super(
          `${i.charAt(0).toUpperCase()}${i
            .slice(1)
            .toLowerCase()} size (\`${e}\`) exceeds padding size (\`${r}\`).`
        ),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Bytes.SizeExceedsPaddingSizeError",
          });
      }
    }
    const xW = new TextEncoder(),
      IW = Array.from({ length: 256 }, (t, e) =>
        e.toString(16).padStart(2, "0")
      );
    function uE(...t) {
      return `0x${t.reduce((e, r) => e + r.replace("0x", ""), "")}`;
    }
    function _W(t, e = {}) {
      const r = `0x${Number(t)}`;
      return typeof e.size == "number" ? (Mw(r, e.size), nf(r, e.size)) : r;
    }
    function hE(t, e = {}) {
      let r = "";
      for (let s = 0; s < t.length; s++) r += IW[t[s]];
      const i = `0x${r}`;
      return typeof e.size == "number" ? (Mw(i, e.size), zw(i, e.size)) : i;
    }
    function AW(t, e = {}) {
      const { signed: r, size: i } = e,
        s = BigInt(t);
      let n;
      i
        ? r
          ? (n = (1n << (BigInt(i) * 8n - 1n)) - 1n)
          : (n = 2n ** (BigInt(i) * 8n) - 1n)
        : typeof t == "number" && (n = BigInt(Number.MAX_SAFE_INTEGER));
      const o = typeof n == "bigint" && r ? -n - 1n : 0;
      if ((n && s > n) || s < o) {
        const c = typeof t == "bigint" ? "n" : "";
        throw new PW({
          max: n ? `${n}${c}` : void 0,
          min: `${o}${c}`,
          signed: r,
          size: i,
          value: `${t}${c}`,
        });
      }
      const a = `0x${(r && s < 0
        ? (1n << BigInt(i * 8)) + BigInt(s)
        : s
      ).toString(16)}`;
      return i ? nf(a, i) : a;
    }
    function SW(t, e = {}) {
      return hE(xW.encode(t), e);
    }
    function nf(t, e) {
      return cE(t, { dir: "left", size: e });
    }
    function zw(t, e) {
      return cE(t, { dir: "right", size: e });
    }
    function qw(t) {
      return Math.ceil((t.length - 2) / 2);
    }
    class PW extends Br {
      constructor({ max: e, min: r, signed: i, size: s, value: n }) {
        super(
          `Number \`${n}\` is not in safe${s ? ` ${s * 8}-bit` : ""}${
            i ? " signed" : " unsigned"
          } integer range ${e ? `(\`${r}\` to \`${e}\`)` : `(above \`${r}\`)`}`
        ),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Hex.IntegerOutOfRangeError",
          });
      }
    }
    class OW extends Br {
      constructor({ givenSize: e, maxSize: r }) {
        super(`Size cannot exceed \`${r}\` bytes. Given size: \`${e}\` bytes.`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Hex.SizeOverflowError",
          });
      }
    }
    class NW extends Br {
      constructor({ size: e, targetSize: r, type: i }) {
        super(
          `${i.charAt(0).toUpperCase()}${i
            .slice(1)
            .toLowerCase()} size (\`${e}\`) exceeds padding size (\`${r}\`).`
        ),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Hex.SizeExceedsPaddingSizeError",
          });
      }
    }
    function TW(t, e = {}) {
      const { as: r = typeof t == "string" ? "Hex" : "Bytes" } = e,
        i = To(wW(t));
      return r === "Bytes" ? i : hE(i);
    }
    class kW extends Map {
      constructor(e) {
        super(),
          Object.defineProperty(this, "maxSize", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          (this.maxSize = e);
      }
      get(e) {
        const r = super.get(e);
        return (
          super.has(e) && r !== void 0 && (this.delete(e), super.set(e, r)), r
        );
      }
      set(e, r) {
        if ((super.set(e, r), this.maxSize && this.size > this.maxSize)) {
          const i = this.keys().next().value;
          i && this.delete(i);
        }
        return this;
      }
    }
    const Hw = { checksum: new kW(8192) }.checksum,
      RW = /^0x[a-fA-F0-9]{40}$/;
    function dE(t, e = {}) {
      const { strict: r = !0 } = e;
      if (!RW.test(t)) throw new pE({ address: t, cause: new FW() });
      if (r) {
        if (t.toLowerCase() === t) return;
        if ($W(t) !== t) throw new pE({ address: t, cause: new BW() });
      }
    }
    function $W(t) {
      if (Hw.has(t)) return Hw.get(t);
      dE(t, { strict: !1 });
      const e = t.substring(2).toLowerCase(),
        r = TW(bW(e), { as: "Bytes" }),
        i = e.split("");
      for (let n = 0; n < 40; n += 2)
        r[n >> 1] >> 4 >= 8 && i[n] && (i[n] = i[n].toUpperCase()),
          (r[n >> 1] & 15) >= 8 &&
            i[n + 1] &&
            (i[n + 1] = i[n + 1].toUpperCase());
      const s = `0x${i.join("")}`;
      return Hw.set(t, s), s;
    }
    class pE extends Br {
      constructor({ address: e, cause: r }) {
        super(`Address "${e}" is invalid.`, { cause: r }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Address.InvalidAddressError",
          });
      }
    }
    class FW extends Br {
      constructor() {
        super("Address is not a 20 byte (40 hexadecimal character) value."),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Address.InvalidInputError",
          });
      }
    }
    class BW extends Br {
      constructor() {
        super("Address does not match its checksum counterpart."),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Address.InvalidChecksumError",
          });
      }
    }
    const LW = /^(.*)\[([0-9]*)\]$/,
      UW = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,
      DW =
        /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
    function Vw(t, e) {
      if (t.length !== e.length)
        throw new MW({ expectedLength: t.length, givenLength: e.length });
      const r = [];
      for (let i = 0; i < t.length; i++) {
        const s = t[i],
          n = e[i];
        r.push(Vw.encode(s, n));
      }
      return uE(...r);
    }
    (function (t) {
      function e(r, i, s = !1) {
        if (r === "address") {
          const c = i;
          return dE(c), nf(c.toLowerCase(), s ? 32 : 0);
        }
        if (r === "string") return SW(i);
        if (r === "bytes") return i;
        if (r === "bool") return nf(_W(i), s ? 32 : 1);
        const n = r.match(DW);
        if (n) {
          const [c, l, u = "256"] = n,
            h = Number.parseInt(u) / 8;
          return AW(i, { size: s ? 32 : h, signed: l === "int" });
        }
        const o = r.match(UW);
        if (o) {
          const [c, l] = o;
          if (Number.parseInt(l) !== (i.length - 2) / 2)
            throw new jW({ expectedSize: Number.parseInt(l), value: i });
          return zw(i, s ? 32 : 0);
        }
        const a = r.match(LW);
        if (a && Array.isArray(i)) {
          const [c, l] = a,
            u = [];
          for (let h = 0; h < i.length; h++) u.push(e(l, i[h], !0));
          return u.length === 0 ? "0x" : uE(...u);
        }
        throw new zW(r);
      }
      t.encode = e;
    })(Vw || (Vw = {}));
    class jW extends Br {
      constructor({ expectedSize: e, value: r }) {
        super(
          `Size of bytes "${r}" (bytes${qw(
            r
          )}) does not match expected size (bytes${e}).`
        ),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiParameters.BytesSizeMismatchError",
          });
      }
    }
    class MW extends Br {
      constructor({ expectedLength: e, givenLength: r }) {
        super(
          [
            "ABI encoding parameters/values length mismatch.",
            `Expected length (parameters): ${e}`,
            `Given length (values): ${r}`,
          ].join(`
`)
        ),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiParameters.LengthMismatchError",
          });
      }
    }
    class zW extends Br {
      constructor(e) {
        super(`Type \`${e}\` is not a valid ABI Type.`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiParameters.InvalidTypeError",
          });
      }
    }
    function of(t) {
      if (!Number.isSafeInteger(t) || t < 0)
        throw new Error("positive integer expected, got " + t);
    }
    function qW(t) {
      return (
        t instanceof Uint8Array ||
        (ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array")
      );
    }
    function Xu(t, ...e) {
      if (!qW(t)) throw new Error("Uint8Array expected");
      if (e.length > 0 && !e.includes(t.length))
        throw new Error(
          "Uint8Array expected of length " + e + ", got length=" + t.length
        );
    }
    function HW(t) {
      if (typeof t != "function" || typeof t.create != "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      of(t.outputLen), of(t.blockLen);
    }
    function Mc(t, e = !0) {
      if (t.destroyed) throw new Error("Hash instance has been destroyed");
      if (e && t.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function fE(t, e) {
      Xu(t);
      const r = e.outputLen;
      if (t.length < r)
        throw new Error(
          "digestInto() expects output buffer of length at least " + r
        );
    }
    const af = BigInt(2 ** 32 - 1),
      gE = BigInt(32);
    function VW(t, e = !1) {
      return e
        ? { h: Number(t & af), l: Number((t >> gE) & af) }
        : { h: Number((t >> gE) & af) | 0, l: Number(t & af) | 0 };
    }
    function WW(t, e = !1) {
      let r = new Uint32Array(t.length),
        i = new Uint32Array(t.length);
      for (let s = 0; s < t.length; s++) {
        const { h: n, l: o } = VW(t[s], e);
        [r[s], i[s]] = [n, o];
      }
      return [r, i];
    }
    const KW = (t, e, r) => (t << r) | (e >>> (32 - r)),
      GW = (t, e, r) => (e << r) | (t >>> (32 - r)),
      ZW = (t, e, r) => (e << (r - 32)) | (t >>> (64 - r)),
      YW = (t, e, r) => (t << (r - 32)) | (e >>> (64 - r)),
      zc =
        typeof globalThis == "object" && "crypto" in globalThis
          ? globalThis.crypto
          : void 0;
    function JW(t) {
      return new Uint32Array(
        t.buffer,
        t.byteOffset,
        Math.floor(t.byteLength / 4)
      );
    }
    function Ww(t) {
      return new DataView(t.buffer, t.byteOffset, t.byteLength);
    }
    function Os(t, e) {
      return (t << (32 - e)) | (t >>> e);
    }
    const wE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    function XW(t) {
      return (
        ((t << 24) & 4278190080) |
        ((t << 8) & 16711680) |
        ((t >>> 8) & 65280) |
        ((t >>> 24) & 255)
      );
    }
    function mE(t) {
      for (let e = 0; e < t.length; e++) t[e] = XW(t[e]);
    }
    function QW(t) {
      if (typeof t != "string")
        throw new Error("utf8ToBytes expected string, got " + typeof t);
      return new Uint8Array(new TextEncoder().encode(t));
    }
    function cf(t) {
      return typeof t == "string" && (t = QW(t)), Xu(t), t;
    }
    function eK(...t) {
      let e = 0;
      for (let i = 0; i < t.length; i++) {
        const s = t[i];
        Xu(s), (e += s.length);
      }
      const r = new Uint8Array(e);
      for (let i = 0, s = 0; i < t.length; i++) {
        const n = t[i];
        r.set(n, s), (s += n.length);
      }
      return r;
    }
    class Kw {
      clone() {
        return this._cloneInto();
      }
    }
    function yE(t) {
      const e = (i) => t().update(cf(i)).digest(),
        r = t();
      return (
        (e.outputLen = r.outputLen),
        (e.blockLen = r.blockLen),
        (e.create = () => t()),
        e
      );
    }
    function bE(t = 32) {
      if (zc && typeof zc.getRandomValues == "function")
        return zc.getRandomValues(new Uint8Array(t));
      if (zc && typeof zc.randomBytes == "function") return zc.randomBytes(t);
      throw new Error("crypto.getRandomValues must be defined");
    }
    const vE = [],
      EE = [],
      CE = [],
      tK = BigInt(0),
      Qu = BigInt(1),
      rK = BigInt(2),
      iK = BigInt(7),
      sK = BigInt(256),
      nK = BigInt(113);
    for (let t = 0, e = Qu, r = 1, i = 0; t < 24; t++) {
      ([r, i] = [i, (2 * r + 3 * i) % 5]),
        vE.push(2 * (5 * i + r)),
        EE.push((((t + 1) * (t + 2)) / 2) % 64);
      let s = tK;
      for (let n = 0; n < 7; n++)
        (e = ((e << Qu) ^ ((e >> iK) * nK)) % sK),
          e & rK && (s ^= Qu << ((Qu << BigInt(n)) - Qu));
      CE.push(s);
    }
    const [oK, aK] = WW(CE, !0),
      xE = (t, e, r) => (r > 32 ? ZW(t, e, r) : KW(t, e, r)),
      IE = (t, e, r) => (r > 32 ? YW(t, e, r) : GW(t, e, r));
    function cK(t, e = 24) {
      const r = new Uint32Array(10);
      for (let i = 24 - e; i < 24; i++) {
        for (let o = 0; o < 10; o++)
          r[o] = t[o] ^ t[o + 10] ^ t[o + 20] ^ t[o + 30] ^ t[o + 40];
        for (let o = 0; o < 10; o += 2) {
          const a = (o + 8) % 10,
            c = (o + 2) % 10,
            l = r[c],
            u = r[c + 1],
            h = xE(l, u, 1) ^ r[a],
            d = IE(l, u, 1) ^ r[a + 1];
          for (let g = 0; g < 50; g += 10) (t[o + g] ^= h), (t[o + g + 1] ^= d);
        }
        let s = t[2],
          n = t[3];
        for (let o = 0; o < 24; o++) {
          const a = EE[o],
            c = xE(s, n, a),
            l = IE(s, n, a),
            u = vE[o];
          (s = t[u]), (n = t[u + 1]), (t[u] = c), (t[u + 1] = l);
        }
        for (let o = 0; o < 50; o += 10) {
          for (let a = 0; a < 10; a++) r[a] = t[o + a];
          for (let a = 0; a < 10; a++)
            t[o + a] ^= ~r[(a + 2) % 10] & r[(a + 4) % 10];
        }
        (t[0] ^= oK[i]), (t[1] ^= aK[i]);
      }
      r.fill(0);
    }
    class Gw extends Kw {
      constructor(e, r, i, s = !1, n = 24) {
        if (
          (super(),
          (this.blockLen = e),
          (this.suffix = r),
          (this.outputLen = i),
          (this.enableXOF = s),
          (this.rounds = n),
          (this.pos = 0),
          (this.posOut = 0),
          (this.finished = !1),
          (this.destroyed = !1),
          of(i),
          0 >= this.blockLen || this.blockLen >= 200)
        )
          throw new Error("Sha3 supports only keccak-f1600 function");
        (this.state = new Uint8Array(200)), (this.state32 = JW(this.state));
      }
      keccak() {
        wE || mE(this.state32),
          cK(this.state32, this.rounds),
          wE || mE(this.state32),
          (this.posOut = 0),
          (this.pos = 0);
      }
      update(e) {
        Mc(this);
        const { blockLen: r, state: i } = this;
        e = cf(e);
        const s = e.length;
        for (let n = 0; n < s; ) {
          const o = Math.min(r - this.pos, s - n);
          for (let a = 0; a < o; a++) i[this.pos++] ^= e[n++];
          this.pos === r && this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished) return;
        this.finished = !0;
        const { state: e, suffix: r, pos: i, blockLen: s } = this;
        (e[i] ^= r),
          (r & 128) !== 0 && i === s - 1 && this.keccak(),
          (e[s - 1] ^= 128),
          this.keccak();
      }
      writeInto(e) {
        Mc(this, !1), Xu(e), this.finish();
        const r = this.state,
          { blockLen: i } = this;
        for (let s = 0, n = e.length; s < n; ) {
          this.posOut >= i && this.keccak();
          const o = Math.min(i - this.posOut, n - s);
          e.set(r.subarray(this.posOut, this.posOut + o), s),
            (this.posOut += o),
            (s += o);
        }
        return e;
      }
      xofInto(e) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(e);
      }
      xof(e) {
        return of(e), this.xofInto(new Uint8Array(e));
      }
      digestInto(e) {
        if ((fE(e, this), this.finished))
          throw new Error("digest() was already called");
        return this.writeInto(e), this.destroy(), e;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        (this.destroyed = !0), this.state.fill(0);
      }
      _cloneInto(e) {
        const {
          blockLen: r,
          suffix: i,
          outputLen: s,
          rounds: n,
          enableXOF: o,
        } = this;
        return (
          e || (e = new Gw(r, i, s, o, n)),
          e.state32.set(this.state32),
          (e.pos = this.pos),
          (e.posOut = this.posOut),
          (e.finished = this.finished),
          (e.rounds = n),
          (e.suffix = i),
          (e.outputLen = s),
          (e.enableXOF = o),
          (e.destroyed = this.destroyed),
          e
        );
      }
    }
    ((t, e, r) => yE(() => new Gw(e, t, r)))(1, 136, 256 / 8);
    function Zw(t) {
      if (!Number.isSafeInteger(t) || t < 0)
        throw new Error("positive integer expected, got " + t);
    }
    function _E(t) {
      return (
        t instanceof Uint8Array ||
        (ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array")
      );
    }
    function wi(t, ...e) {
      if (!_E(t)) throw new Error("Uint8Array expected");
      if (e.length > 0 && !e.includes(t.length))
        throw new Error(
          "Uint8Array expected of length " + e + ", got length=" + t.length
        );
    }
    function AE(t, e = !0) {
      if (t.destroyed) throw new Error("Hash instance has been destroyed");
      if (e && t.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function lK(t, e) {
      wi(t);
      const r = e.outputLen;
      if (t.length < r)
        throw new Error(
          "digestInto() expects output buffer of length at least " + r
        );
    }
    function SE(t) {
      if (typeof t != "boolean") throw new Error(`boolean expected, not ${t}`);
    }
    const io = (t) =>
        new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4)),
      uK = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength);
    if (new Uint8Array(new Uint32Array([287454020]).buffer)[0] !== 68)
      throw new Error("Non little-endian hardware is not supported");
    function hK(t) {
      if (typeof t != "string") throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(t));
    }
    function Yw(t) {
      if (typeof t == "string") t = hK(t);
      else if (_E(t)) t = Jw(t);
      else throw new Error("Uint8Array expected, got " + typeof t);
      return t;
    }
    function dK(t, e) {
      if (e == null || typeof e != "object")
        throw new Error("options must be defined");
      return Object.assign(t, e);
    }
    function pK(t, e) {
      if (t.length !== e.length) return !1;
      let r = 0;
      for (let i = 0; i < t.length; i++) r |= t[i] ^ e[i];
      return r === 0;
    }
    const fK = (t, e) => {
      function r(i, ...s) {
        if ((wi(i), t.nonceLength !== void 0)) {
          const l = s[0];
          if (!l) throw new Error("nonce / iv required");
          t.varSizeNonce ? wi(l) : wi(l, t.nonceLength);
        }
        const n = t.tagLength;
        n && s[1] !== void 0 && wi(s[1]);
        const o = e(i, ...s),
          a = (l, u) => {
            if (u !== void 0) {
              if (l !== 2) throw new Error("cipher output not supported");
              wi(u);
            }
          };
        let c = !1;
        return {
          encrypt(l, u) {
            if (c)
              throw new Error("cannot encrypt() twice with same key + nonce");
            return (c = !0), wi(l), a(o.encrypt.length, u), o.encrypt(l, u);
          },
          decrypt(l, u) {
            if ((wi(l), n && l.length < n))
              throw new Error(
                "invalid ciphertext length: smaller than tagLength=" + n
              );
            return a(o.decrypt.length, u), o.decrypt(l, u);
          },
        };
      }
      return Object.assign(r, t), r;
    };
    function PE(t, e, r = !0) {
      if (e === void 0) return new Uint8Array(t);
      if (e.length !== t)
        throw new Error(
          "invalid output length, expected " + t + ", got: " + e.length
        );
      if (r && !gK(e)) throw new Error("invalid output, must be aligned");
      return e;
    }
    function OE(t, e, r, i) {
      if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, r, i);
      const s = BigInt(32),
        n = BigInt(4294967295),
        o = Number((r >> s) & n),
        a = Number(r & n),
        c = i ? 4 : 0,
        l = i ? 0 : 4;
      t.setUint32(e + c, o, i), t.setUint32(e + l, a, i);
    }
    function gK(t) {
      return t.byteOffset % 4 === 0;
    }
    function Jw(t) {
      return Uint8Array.from(t);
    }
    function qc(...t) {
      for (let e = 0; e < t.length; e++) t[e].fill(0);
    }
    const NE = (t) => Uint8Array.from(t.split("").map((e) => e.charCodeAt(0))),
      wK = NE("expand 16-byte k"),
      mK = NE("expand 32-byte k"),
      yK = io(wK),
      bK = io(mK);
    function De(t, e) {
      return (t << e) | (t >>> (32 - e));
    }
    function Xw(t) {
      return t.byteOffset % 4 === 0;
    }
    const lf = 64,
      vK = 16,
      TE = 2 ** 32 - 1,
      kE = new Uint32Array();
    function EK(t, e, r, i, s, n, o, a) {
      const c = s.length,
        l = new Uint8Array(lf),
        u = io(l),
        h = Xw(s) && Xw(n),
        d = h ? io(s) : kE,
        g = h ? io(n) : kE;
      for (let p = 0; p < c; o++) {
        if ((t(e, r, i, u, o, a), o >= TE))
          throw new Error("arx: counter overflow");
        const w = Math.min(lf, c - p);
        if (h && w === lf) {
          const f = p / 4;
          if (p % 4 !== 0) throw new Error("arx: invalid block position");
          for (let m = 0, y; m < vK; m++) (y = f + m), (g[y] = d[y] ^ u[m]);
          p += lf;
          continue;
        }
        for (let f = 0, m; f < w; f++) (m = p + f), (n[m] = s[m] ^ l[f]);
        p += w;
      }
    }
    function CK(t, e) {
      const {
        allowShortKeys: r,
        extendNonceFn: i,
        counterLength: s,
        counterRight: n,
        rounds: o,
      } = dK(
        { allowShortKeys: !1, counterLength: 8, counterRight: !1, rounds: 20 },
        e
      );
      if (typeof t != "function") throw new Error("core must be a function");
      return (
        Zw(s),
        Zw(o),
        SE(n),
        SE(r),
        (a, c, l, u, h = 0) => {
          wi(a), wi(c), wi(l);
          const d = l.length;
          if (
            (u === void 0 && (u = new Uint8Array(d)),
            wi(u),
            Zw(h),
            h < 0 || h >= TE)
          )
            throw new Error("arx: counter overflow");
          if (u.length < d)
            throw new Error(
              `arx: output (${u.length}) is shorter than data (${d})`
            );
          const g = [];
          let p = a.length,
            w,
            f;
          if (p === 32) g.push((w = Jw(a))), (f = bK);
          else if (p === 16 && r)
            (w = new Uint8Array(32)),
              w.set(a),
              w.set(a, 16),
              (f = yK),
              g.push(w);
          else throw new Error(`arx: invalid 32-byte key, got length=${p}`);
          Xw(c) || g.push((c = Jw(c)));
          const m = io(w);
          if (i) {
            if (c.length !== 24)
              throw new Error("arx: extended nonce must be 24 bytes");
            i(f, m, io(c.subarray(0, 16)), m), (c = c.subarray(16));
          }
          const y = 16 - s;
          if (y !== c.length)
            throw new Error(`arx: nonce must be ${y} or 16 bytes`);
          if (y !== 12) {
            const C = new Uint8Array(12);
            C.set(c, n ? 0 : 12 - c.length), (c = C), g.push(c);
          }
          const E = io(c);
          return EK(t, f, m, E, l, u, h, o), qc(...g), u;
        }
      );
    }
    const gr = (t, e) => (t[e++] & 255) | ((t[e++] & 255) << 8);
    class xK {
      constructor(e) {
        (this.blockLen = 16),
          (this.outputLen = 16),
          (this.buffer = new Uint8Array(16)),
          (this.r = new Uint16Array(10)),
          (this.h = new Uint16Array(10)),
          (this.pad = new Uint16Array(8)),
          (this.pos = 0),
          (this.finished = !1),
          (e = Yw(e)),
          wi(e, 32);
        const r = gr(e, 0),
          i = gr(e, 2),
          s = gr(e, 4),
          n = gr(e, 6),
          o = gr(e, 8),
          a = gr(e, 10),
          c = gr(e, 12),
          l = gr(e, 14);
        (this.r[0] = r & 8191),
          (this.r[1] = ((r >>> 13) | (i << 3)) & 8191),
          (this.r[2] = ((i >>> 10) | (s << 6)) & 7939),
          (this.r[3] = ((s >>> 7) | (n << 9)) & 8191),
          (this.r[4] = ((n >>> 4) | (o << 12)) & 255),
          (this.r[5] = (o >>> 1) & 8190),
          (this.r[6] = ((o >>> 14) | (a << 2)) & 8191),
          (this.r[7] = ((a >>> 11) | (c << 5)) & 8065),
          (this.r[8] = ((c >>> 8) | (l << 8)) & 8191),
          (this.r[9] = (l >>> 5) & 127);
        for (let u = 0; u < 8; u++) this.pad[u] = gr(e, 16 + 2 * u);
      }
      process(e, r, i = !1) {
        const s = i ? 0 : 2048,
          { h: n, r: o } = this,
          a = o[0],
          c = o[1],
          l = o[2],
          u = o[3],
          h = o[4],
          d = o[5],
          g = o[6],
          p = o[7],
          w = o[8],
          f = o[9],
          m = gr(e, r + 0),
          y = gr(e, r + 2),
          E = gr(e, r + 4),
          C = gr(e, r + 6),
          O = gr(e, r + 8),
          A = gr(e, r + 10),
          P = gr(e, r + 12),
          N = gr(e, r + 14);
        let x = n[0] + (m & 8191),
          $ = n[1] + (((m >>> 13) | (y << 3)) & 8191),
          k = n[2] + (((y >>> 10) | (E << 6)) & 8191),
          F = n[3] + (((E >>> 7) | (C << 9)) & 8191),
          j = n[4] + (((C >>> 4) | (O << 12)) & 8191),
          I = n[5] + ((O >>> 1) & 8191),
          b = n[6] + (((O >>> 14) | (A << 2)) & 8191),
          v = n[7] + (((A >>> 11) | (P << 5)) & 8191),
          S = n[8] + (((P >>> 8) | (N << 8)) & 8191),
          T = n[9] + ((N >>> 5) | s),
          _ = 0,
          R = _ + x * a + $ * (5 * f) + k * (5 * w) + F * (5 * p) + j * (5 * g);
        (_ = R >>> 13),
          (R &= 8191),
          (R +=
            I * (5 * d) +
            b * (5 * h) +
            v * (5 * u) +
            S * (5 * l) +
            T * (5 * c)),
          (_ += R >>> 13),
          (R &= 8191);
        let U = _ + x * c + $ * a + k * (5 * f) + F * (5 * w) + j * (5 * p);
        (_ = U >>> 13),
          (U &= 8191),
          (U +=
            I * (5 * g) +
            b * (5 * d) +
            v * (5 * h) +
            S * (5 * u) +
            T * (5 * l)),
          (_ += U >>> 13),
          (U &= 8191);
        let D = _ + x * l + $ * c + k * a + F * (5 * f) + j * (5 * w);
        (_ = D >>> 13),
          (D &= 8191),
          (D +=
            I * (5 * p) +
            b * (5 * g) +
            v * (5 * d) +
            S * (5 * h) +
            T * (5 * u)),
          (_ += D >>> 13),
          (D &= 8191);
        let H = _ + x * u + $ * l + k * c + F * a + j * (5 * f);
        (_ = H >>> 13),
          (H &= 8191),
          (H +=
            I * (5 * w) +
            b * (5 * p) +
            v * (5 * g) +
            S * (5 * d) +
            T * (5 * h)),
          (_ += H >>> 13),
          (H &= 8191);
        let q = _ + x * h + $ * u + k * l + F * c + j * a;
        (_ = q >>> 13),
          (q &= 8191),
          (q +=
            I * (5 * f) +
            b * (5 * w) +
            v * (5 * p) +
            S * (5 * g) +
            T * (5 * d)),
          (_ += q >>> 13),
          (q &= 8191);
        let V = _ + x * d + $ * h + k * u + F * l + j * c;
        (_ = V >>> 13),
          (V &= 8191),
          (V += I * a + b * (5 * f) + v * (5 * w) + S * (5 * p) + T * (5 * g)),
          (_ += V >>> 13),
          (V &= 8191);
        let Y = _ + x * g + $ * d + k * h + F * u + j * l;
        (_ = Y >>> 13),
          (Y &= 8191),
          (Y += I * c + b * a + v * (5 * f) + S * (5 * w) + T * (5 * p)),
          (_ += Y >>> 13),
          (Y &= 8191);
        let ae = _ + x * p + $ * g + k * d + F * h + j * u;
        (_ = ae >>> 13),
          (ae &= 8191),
          (ae += I * l + b * c + v * a + S * (5 * f) + T * (5 * w)),
          (_ += ae >>> 13),
          (ae &= 8191);
        let re = _ + x * w + $ * p + k * g + F * d + j * h;
        (_ = re >>> 13),
          (re &= 8191),
          (re += I * u + b * l + v * c + S * a + T * (5 * f)),
          (_ += re >>> 13),
          (re &= 8191);
        let te = _ + x * f + $ * w + k * p + F * g + j * d;
        (_ = te >>> 13),
          (te &= 8191),
          (te += I * h + b * u + v * l + S * c + T * a),
          (_ += te >>> 13),
          (te &= 8191),
          (_ = ((_ << 2) + _) | 0),
          (_ = (_ + R) | 0),
          (R = _ & 8191),
          (_ = _ >>> 13),
          (U += _),
          (n[0] = R),
          (n[1] = U),
          (n[2] = D),
          (n[3] = H),
          (n[4] = q),
          (n[5] = V),
          (n[6] = Y),
          (n[7] = ae),
          (n[8] = re),
          (n[9] = te);
      }
      finalize() {
        const { h: e, pad: r } = this,
          i = new Uint16Array(10);
        let s = e[1] >>> 13;
        e[1] &= 8191;
        for (let a = 2; a < 10; a++)
          (e[a] += s), (s = e[a] >>> 13), (e[a] &= 8191);
        (e[0] += s * 5),
          (s = e[0] >>> 13),
          (e[0] &= 8191),
          (e[1] += s),
          (s = e[1] >>> 13),
          (e[1] &= 8191),
          (e[2] += s),
          (i[0] = e[0] + 5),
          (s = i[0] >>> 13),
          (i[0] &= 8191);
        for (let a = 1; a < 10; a++)
          (i[a] = e[a] + s), (s = i[a] >>> 13), (i[a] &= 8191);
        i[9] -= 8192;
        let n = (s ^ 1) - 1;
        for (let a = 0; a < 10; a++) i[a] &= n;
        n = ~n;
        for (let a = 0; a < 10; a++) e[a] = (e[a] & n) | i[a];
        (e[0] = (e[0] | (e[1] << 13)) & 65535),
          (e[1] = ((e[1] >>> 3) | (e[2] << 10)) & 65535),
          (e[2] = ((e[2] >>> 6) | (e[3] << 7)) & 65535),
          (e[3] = ((e[3] >>> 9) | (e[4] << 4)) & 65535),
          (e[4] = ((e[4] >>> 12) | (e[5] << 1) | (e[6] << 14)) & 65535),
          (e[5] = ((e[6] >>> 2) | (e[7] << 11)) & 65535),
          (e[6] = ((e[7] >>> 5) | (e[8] << 8)) & 65535),
          (e[7] = ((e[8] >>> 8) | (e[9] << 5)) & 65535);
        let o = e[0] + r[0];
        e[0] = o & 65535;
        for (let a = 1; a < 8; a++)
          (o = (((e[a] + r[a]) | 0) + (o >>> 16)) | 0), (e[a] = o & 65535);
        qc(i);
      }
      update(e) {
        AE(this);
        const { buffer: r, blockLen: i } = this;
        e = Yw(e);
        const s = e.length;
        for (let n = 0; n < s; ) {
          const o = Math.min(i - this.pos, s - n);
          if (o === i) {
            for (; i <= s - n; n += i) this.process(e, n);
            continue;
          }
          r.set(e.subarray(n, n + o), this.pos),
            (this.pos += o),
            (n += o),
            this.pos === i && (this.process(r, 0, !1), (this.pos = 0));
        }
        return this;
      }
      destroy() {
        qc(this.h, this.r, this.buffer, this.pad);
      }
      digestInto(e) {
        AE(this), lK(e, this), (this.finished = !0);
        const { buffer: r, h: i } = this;
        let { pos: s } = this;
        if (s) {
          for (r[s++] = 1; s < 16; s++) r[s] = 0;
          this.process(r, 0, !0);
        }
        this.finalize();
        let n = 0;
        for (let o = 0; o < 8; o++)
          (e[n++] = i[o] >>> 0), (e[n++] = i[o] >>> 8);
        return e;
      }
      digest() {
        const { buffer: e, outputLen: r } = this;
        this.digestInto(e);
        const i = e.slice(0, r);
        return this.destroy(), i;
      }
    }
    function IK(t) {
      const e = (i, s) => t(s).update(Yw(i)).digest(),
        r = t(new Uint8Array(32));
      return (
        (e.outputLen = r.outputLen),
        (e.blockLen = r.blockLen),
        (e.create = (i) => t(i)),
        e
      );
    }
    const _K = IK((t) => new xK(t));
    function AK(t, e, r, i, s, n = 20) {
      let o = t[0],
        a = t[1],
        c = t[2],
        l = t[3],
        u = e[0],
        h = e[1],
        d = e[2],
        g = e[3],
        p = e[4],
        w = e[5],
        f = e[6],
        m = e[7],
        y = s,
        E = r[0],
        C = r[1],
        O = r[2],
        A = o,
        P = a,
        N = c,
        x = l,
        $ = u,
        k = h,
        F = d,
        j = g,
        I = p,
        b = w,
        v = f,
        S = m,
        T = y,
        _ = E,
        R = C,
        U = O;
      for (let H = 0; H < n; H += 2)
        (A = (A + $) | 0),
          (T = De(T ^ A, 16)),
          (I = (I + T) | 0),
          ($ = De($ ^ I, 12)),
          (A = (A + $) | 0),
          (T = De(T ^ A, 8)),
          (I = (I + T) | 0),
          ($ = De($ ^ I, 7)),
          (P = (P + k) | 0),
          (_ = De(_ ^ P, 16)),
          (b = (b + _) | 0),
          (k = De(k ^ b, 12)),
          (P = (P + k) | 0),
          (_ = De(_ ^ P, 8)),
          (b = (b + _) | 0),
          (k = De(k ^ b, 7)),
          (N = (N + F) | 0),
          (R = De(R ^ N, 16)),
          (v = (v + R) | 0),
          (F = De(F ^ v, 12)),
          (N = (N + F) | 0),
          (R = De(R ^ N, 8)),
          (v = (v + R) | 0),
          (F = De(F ^ v, 7)),
          (x = (x + j) | 0),
          (U = De(U ^ x, 16)),
          (S = (S + U) | 0),
          (j = De(j ^ S, 12)),
          (x = (x + j) | 0),
          (U = De(U ^ x, 8)),
          (S = (S + U) | 0),
          (j = De(j ^ S, 7)),
          (A = (A + k) | 0),
          (U = De(U ^ A, 16)),
          (v = (v + U) | 0),
          (k = De(k ^ v, 12)),
          (A = (A + k) | 0),
          (U = De(U ^ A, 8)),
          (v = (v + U) | 0),
          (k = De(k ^ v, 7)),
          (P = (P + F) | 0),
          (T = De(T ^ P, 16)),
          (S = (S + T) | 0),
          (F = De(F ^ S, 12)),
          (P = (P + F) | 0),
          (T = De(T ^ P, 8)),
          (S = (S + T) | 0),
          (F = De(F ^ S, 7)),
          (N = (N + j) | 0),
          (_ = De(_ ^ N, 16)),
          (I = (I + _) | 0),
          (j = De(j ^ I, 12)),
          (N = (N + j) | 0),
          (_ = De(_ ^ N, 8)),
          (I = (I + _) | 0),
          (j = De(j ^ I, 7)),
          (x = (x + $) | 0),
          (R = De(R ^ x, 16)),
          (b = (b + R) | 0),
          ($ = De($ ^ b, 12)),
          (x = (x + $) | 0),
          (R = De(R ^ x, 8)),
          (b = (b + R) | 0),
          ($ = De($ ^ b, 7));
      let D = 0;
      (i[D++] = (o + A) | 0),
        (i[D++] = (a + P) | 0),
        (i[D++] = (c + N) | 0),
        (i[D++] = (l + x) | 0),
        (i[D++] = (u + $) | 0),
        (i[D++] = (h + k) | 0),
        (i[D++] = (d + F) | 0),
        (i[D++] = (g + j) | 0),
        (i[D++] = (p + I) | 0),
        (i[D++] = (w + b) | 0),
        (i[D++] = (f + v) | 0),
        (i[D++] = (m + S) | 0),
        (i[D++] = (y + T) | 0),
        (i[D++] = (E + _) | 0),
        (i[D++] = (C + R) | 0),
        (i[D++] = (O + U) | 0);
    }
    const SK = CK(AK, {
        counterRight: !1,
        counterLength: 4,
        allowShortKeys: !1,
      }),
      PK = new Uint8Array(16),
      RE = (t, e) => {
        t.update(e);
        const r = e.length % 16;
        r && t.update(PK.subarray(r));
      },
      OK = new Uint8Array(32);
    function $E(t, e, r, i, s) {
      const n = t(e, r, OK),
        o = _K.create(n);
      s && RE(o, s), RE(o, i);
      const a = new Uint8Array(16),
        c = uK(a);
      OE(c, 0, BigInt(s ? s.length : 0), !0),
        OE(c, 8, BigInt(i.length), !0),
        o.update(a);
      const l = o.digest();
      return qc(n, a), l;
    }
    fK(
      { blockSize: 64, nonceLength: 12, tagLength: 16 },
      ((t) => (e, r, i) => ({
        encrypt(s, n) {
          const o = s.length;
          (n = PE(o + 16, n, !1)), n.set(s);
          const a = n.subarray(0, -16);
          t(e, r, a, a, 1);
          const c = $E(t, e, r, a, i);
          return n.set(c, o), qc(c), n;
        },
        decrypt(s, n) {
          n = PE(s.length - 16, n, !1);
          const o = s.subarray(0, -16),
            a = s.subarray(-16),
            c = $E(t, e, r, o, i);
          if (!pK(a, c)) throw new Error("invalid tag");
          return n.set(s.subarray(0, -16)), t(e, r, n, n, 1), qc(c), n;
        },
      }))(SK)
    );
    class FE extends Kw {
      constructor(e, r) {
        super(), (this.finished = !1), (this.destroyed = !1), HW(e);
        const i = cf(r);
        if (((this.iHash = e.create()), typeof this.iHash.update != "function"))
          throw new Error(
            "Expected instance of class which extends utils.Hash"
          );
        (this.blockLen = this.iHash.blockLen),
          (this.outputLen = this.iHash.outputLen);
        const s = this.blockLen,
          n = new Uint8Array(s);
        n.set(i.length > s ? e.create().update(i).digest() : i);
        for (let o = 0; o < n.length; o++) n[o] ^= 54;
        this.iHash.update(n), (this.oHash = e.create());
        for (let o = 0; o < n.length; o++) n[o] ^= 106;
        this.oHash.update(n), n.fill(0);
      }
      update(e) {
        return Mc(this), this.iHash.update(e), this;
      }
      digestInto(e) {
        Mc(this),
          Xu(e, this.outputLen),
          (this.finished = !0),
          this.iHash.digestInto(e),
          this.oHash.update(e),
          this.oHash.digestInto(e),
          this.destroy();
      }
      digest() {
        const e = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(e), e;
      }
      _cloneInto(e) {
        e || (e = Object.create(Object.getPrototypeOf(this), {}));
        const {
          oHash: r,
          iHash: i,
          finished: s,
          destroyed: n,
          blockLen: o,
          outputLen: a,
        } = this;
        return (
          (e = e),
          (e.finished = s),
          (e.destroyed = n),
          (e.blockLen = o),
          (e.outputLen = a),
          (e.oHash = r._cloneInto(e.oHash)),
          (e.iHash = i._cloneInto(e.iHash)),
          e
        );
      }
      destroy() {
        (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
      }
    }
    const BE = (t, e, r) => new FE(t, e).update(r).digest();
    BE.create = (t, e) => new FE(t, e);
    function NK(t, e, r, i) {
      if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, r, i);
      const s = BigInt(32),
        n = BigInt(4294967295),
        o = Number((r >> s) & n),
        a = Number(r & n),
        c = i ? 4 : 0,
        l = i ? 0 : 4;
      t.setUint32(e + c, o, i), t.setUint32(e + l, a, i);
    }
    function TK(t, e, r) {
      return (t & e) ^ (~t & r);
    }
    function kK(t, e, r) {
      return (t & e) ^ (t & r) ^ (e & r);
    }
    class RK extends Kw {
      constructor(e, r, i, s) {
        super(),
          (this.blockLen = e),
          (this.outputLen = r),
          (this.padOffset = i),
          (this.isLE = s),
          (this.finished = !1),
          (this.length = 0),
          (this.pos = 0),
          (this.destroyed = !1),
          (this.buffer = new Uint8Array(e)),
          (this.view = Ww(this.buffer));
      }
      update(e) {
        Mc(this);
        const { view: r, buffer: i, blockLen: s } = this;
        e = cf(e);
        const n = e.length;
        for (let o = 0; o < n; ) {
          const a = Math.min(s - this.pos, n - o);
          if (a === s) {
            const c = Ww(e);
            for (; s <= n - o; o += s) this.process(c, o);
            continue;
          }
          i.set(e.subarray(o, o + a), this.pos),
            (this.pos += a),
            (o += a),
            this.pos === s && (this.process(r, 0), (this.pos = 0));
        }
        return (this.length += e.length), this.roundClean(), this;
      }
      digestInto(e) {
        Mc(this), fE(e, this), (this.finished = !0);
        const { buffer: r, view: i, blockLen: s, isLE: n } = this;
        let { pos: o } = this;
        (r[o++] = 128),
          this.buffer.subarray(o).fill(0),
          this.padOffset > s - o && (this.process(i, 0), (o = 0));
        for (let h = o; h < s; h++) r[h] = 0;
        NK(i, s - 8, BigInt(this.length * 8), n), this.process(i, 0);
        const a = Ww(e),
          c = this.outputLen;
        if (c % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const l = c / 4,
          u = this.get();
        if (l > u.length) throw new Error("_sha2: outputLen bigger than state");
        for (let h = 0; h < l; h++) a.setUint32(4 * h, u[h], n);
      }
      digest() {
        const { buffer: e, outputLen: r } = this;
        this.digestInto(e);
        const i = e.slice(0, r);
        return this.destroy(), i;
      }
      _cloneInto(e) {
        e || (e = new this.constructor()), e.set(...this.get());
        const {
          blockLen: r,
          buffer: i,
          length: s,
          finished: n,
          destroyed: o,
          pos: a,
        } = this;
        return (
          (e.length = s),
          (e.pos = a),
          (e.finished = n),
          (e.destroyed = o),
          s % r && e.buffer.set(i),
          e
        );
      }
    }
    const $K = new Uint32Array([
        1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
        2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
        1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
        264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
        2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
        113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
        1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
        3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
        430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
        1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
        2428436474, 2756734187, 3204031479, 3329325298,
      ]),
      so = new Uint32Array([
        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924,
        528734635, 1541459225,
      ]),
      no = new Uint32Array(64);
    class FK extends RK {
      constructor() {
        super(64, 32, 8, !1),
          (this.A = so[0] | 0),
          (this.B = so[1] | 0),
          (this.C = so[2] | 0),
          (this.D = so[3] | 0),
          (this.E = so[4] | 0),
          (this.F = so[5] | 0),
          (this.G = so[6] | 0),
          (this.H = so[7] | 0);
      }
      get() {
        const { A: e, B: r, C: i, D: s, E: n, F: o, G: a, H: c } = this;
        return [e, r, i, s, n, o, a, c];
      }
      set(e, r, i, s, n, o, a, c) {
        (this.A = e | 0),
          (this.B = r | 0),
          (this.C = i | 0),
          (this.D = s | 0),
          (this.E = n | 0),
          (this.F = o | 0),
          (this.G = a | 0),
          (this.H = c | 0);
      }
      process(e, r) {
        for (let h = 0; h < 16; h++, r += 4) no[h] = e.getUint32(r, !1);
        for (let h = 16; h < 64; h++) {
          const d = no[h - 15],
            g = no[h - 2],
            p = Os(d, 7) ^ Os(d, 18) ^ (d >>> 3),
            w = Os(g, 17) ^ Os(g, 19) ^ (g >>> 10);
          no[h] = (w + no[h - 7] + p + no[h - 16]) | 0;
        }
        let { A: i, B: s, C: n, D: o, E: a, F: c, G: l, H: u } = this;
        for (let h = 0; h < 64; h++) {
          const d = Os(a, 6) ^ Os(a, 11) ^ Os(a, 25),
            g = (u + d + TK(a, c, l) + $K[h] + no[h]) | 0,
            p = ((Os(i, 2) ^ Os(i, 13) ^ Os(i, 22)) + kK(i, s, n)) | 0;
          (u = l),
            (l = c),
            (c = a),
            (a = (o + g) | 0),
            (o = n),
            (n = s),
            (s = i),
            (i = (g + p) | 0);
        }
        (i = (i + this.A) | 0),
          (s = (s + this.B) | 0),
          (n = (n + this.C) | 0),
          (o = (o + this.D) | 0),
          (a = (a + this.E) | 0),
          (c = (c + this.F) | 0),
          (l = (l + this.G) | 0),
          (u = (u + this.H) | 0),
          this.set(i, s, n, o, a, c, l, u);
      }
      roundClean() {
        no.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
      }
    }
    const BK = yE(() => new FK());
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const uf =
        BigInt(0),
      hf = BigInt(1),
      LK = BigInt(2);
    function ra(t) {
      return (
        t instanceof Uint8Array ||
        (ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array")
      );
    }
    function eh(t) {
      if (!ra(t)) throw new Error("Uint8Array expected");
    }
    function Hc(t, e) {
      if (typeof e != "boolean")
        throw new Error(t + " boolean expected, got " + e);
    }
    const UK = Array.from({ length: 256 }, (t, e) =>
      e.toString(16).padStart(2, "0")
    );
    function Vc(t) {
      eh(t);
      let e = "";
      for (let r = 0; r < t.length; r++) e += UK[t[r]];
      return e;
    }
    function Wc(t) {
      const e = t.toString(16);
      return e.length & 1 ? "0" + e : e;
    }
    function Qw(t) {
      if (typeof t != "string")
        throw new Error("hex string expected, got " + typeof t);
      return t === "" ? uf : BigInt("0x" + t);
    }
    const ln = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function LE(t) {
      if (t >= ln._0 && t <= ln._9) return t - ln._0;
      if (t >= ln.A && t <= ln.F) return t - (ln.A - 10);
      if (t >= ln.a && t <= ln.f) return t - (ln.a - 10);
    }
    function Kc(t) {
      if (typeof t != "string")
        throw new Error("hex string expected, got " + typeof t);
      const e = t.length,
        r = e / 2;
      if (e % 2)
        throw new Error("hex string expected, got unpadded hex of length " + e);
      const i = new Uint8Array(r);
      for (let s = 0, n = 0; s < r; s++, n += 2) {
        const o = LE(t.charCodeAt(n)),
          a = LE(t.charCodeAt(n + 1));
        if (o === void 0 || a === void 0) {
          const c = t[n] + t[n + 1];
          throw new Error(
            'hex string expected, got non-hex character "' +
              c +
              '" at index ' +
              n
          );
        }
        i[s] = o * 16 + a;
      }
      return i;
    }
    function ia(t) {
      return Qw(Vc(t));
    }
    function th(t) {
      return eh(t), Qw(Vc(Uint8Array.from(t).reverse()));
    }
    function Gc(t, e) {
      return Kc(t.toString(16).padStart(e * 2, "0"));
    }
    function df(t, e) {
      return Gc(t, e).reverse();
    }
    function DK(t) {
      return Kc(Wc(t));
    }
    function mi(t, e, r) {
      let i;
      if (typeof e == "string")
        try {
          i = Kc(e);
        } catch (n) {
          throw new Error(t + " must be hex string or Uint8Array, cause: " + n);
        }
      else if (ra(e)) i = Uint8Array.from(e);
      else throw new Error(t + " must be hex string or Uint8Array");
      const s = i.length;
      if (typeof r == "number" && s !== r)
        throw new Error(t + " of length " + r + " expected, got " + s);
      return i;
    }
    function rh(...t) {
      let e = 0;
      for (let i = 0; i < t.length; i++) {
        const s = t[i];
        eh(s), (e += s.length);
      }
      const r = new Uint8Array(e);
      for (let i = 0, s = 0; i < t.length; i++) {
        const n = t[i];
        r.set(n, s), (s += n.length);
      }
      return r;
    }
    function jK(t, e) {
      if (t.length !== e.length) return !1;
      let r = 0;
      for (let i = 0; i < t.length; i++) r |= t[i] ^ e[i];
      return r === 0;
    }
    function MK(t) {
      if (typeof t != "string") throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(t));
    }
    const em = (t) => typeof t == "bigint" && uf <= t;
    function pf(t, e, r) {
      return em(t) && em(e) && em(r) && e <= t && t < r;
    }
    function un(t, e, r, i) {
      if (!pf(e, r, i))
        throw new Error(
          "expected valid " + t + ": " + r + " <= n < " + i + ", got " + e
        );
    }
    function UE(t) {
      let e;
      for (e = 0; t > uf; t >>= hf, e += 1);
      return e;
    }
    function zK(t, e) {
      return (t >> BigInt(e)) & hf;
    }
    function qK(t, e, r) {
      return t | ((r ? hf : uf) << BigInt(e));
    }
    const tm = (t) => (LK << BigInt(t - 1)) - hf,
      rm = (t) => new Uint8Array(t),
      DE = (t) => Uint8Array.from(t);
    function jE(t, e, r) {
      if (typeof t != "number" || t < 2)
        throw new Error("hashLen must be a number");
      if (typeof e != "number" || e < 2)
        throw new Error("qByteLen must be a number");
      if (typeof r != "function") throw new Error("hmacFn must be a function");
      let i = rm(t),
        s = rm(t),
        n = 0;
      const o = () => {
          i.fill(1), s.fill(0), (n = 0);
        },
        a = (...u) => r(s, i, ...u),
        c = (u = rm()) => {
          (s = a(DE([0]), u)),
            (i = a()),
            u.length !== 0 && ((s = a(DE([1]), u)), (i = a()));
        },
        l = () => {
          if (n++ >= 1e3) throw new Error("drbg: tried 1000 values");
          let u = 0;
          const h = [];
          for (; u < e; ) {
            i = a();
            const d = i.slice();
            h.push(d), (u += i.length);
          }
          return rh(...h);
        };
      return (u, h) => {
        o(), c(u);
        let d;
        for (; !(d = h(l())); ) c();
        return o(), d;
      };
    }
    const HK = {
      bigint: (t) => typeof t == "bigint",
      function: (t) => typeof t == "function",
      boolean: (t) => typeof t == "boolean",
      string: (t) => typeof t == "string",
      stringOrUint8Array: (t) => typeof t == "string" || ra(t),
      isSafeInteger: (t) => Number.isSafeInteger(t),
      array: (t) => Array.isArray(t),
      field: (t, e) => e.Fp.isValid(t),
      hash: (t) => typeof t == "function" && Number.isSafeInteger(t.outputLen),
    };
    function Zc(t, e, r = {}) {
      const i = (s, n, o) => {
        const a = HK[n];
        if (typeof a != "function")
          throw new Error("invalid validator function");
        const c = t[s];
        if (!(o && c === void 0) && !a(c, t))
          throw new Error(
            "param " + String(s) + " is invalid. Expected " + n + ", got " + c
          );
      };
      for (const [s, n] of Object.entries(e)) i(s, n, !1);
      for (const [s, n] of Object.entries(r)) i(s, n, !0);
      return t;
    }
    const VK = () => {
      throw new Error("not implemented");
    };
    function im(t) {
      const e = new WeakMap();
      return (r, ...i) => {
        const s = e.get(r);
        if (s !== void 0) return s;
        const n = t(r, ...i);
        return e.set(r, n), n;
      };
    }
    var WK = Object.freeze({
      __proto__: null,
      isBytes: ra,
      abytes: eh,
      abool: Hc,
      bytesToHex: Vc,
      numberToHexUnpadded: Wc,
      hexToNumber: Qw,
      hexToBytes: Kc,
      bytesToNumberBE: ia,
      bytesToNumberLE: th,
      numberToBytesBE: Gc,
      numberToBytesLE: df,
      numberToVarBytesBE: DK,
      ensureBytes: mi,
      concatBytes: rh,
      equalBytes: jK,
      utf8ToBytes: MK,
      inRange: pf,
      aInRange: un,
      bitLen: UE,
      bitGet: zK,
      bitSet: qK,
      bitMask: tm,
      createHmacDrbg: jE,
      validateObject: Zc,
      notImplemented: VK,
      memoized: im,
    });
    const er = BigInt(0),
      St = BigInt(1),
      sa = BigInt(2),
      KK = BigInt(3),
      sm = BigInt(4),
      ME = BigInt(5),
      zE = BigInt(8);
    function Zr(t, e) {
      const r = t % e;
      return r >= er ? r : e + r;
    }
    function qE(t, e, r) {
      if (e < er) throw new Error("invalid exponent, negatives unsupported");
      if (r <= er) throw new Error("invalid modulus");
      if (r === St) return er;
      let i = St;
      for (; e > er; )
        e & St && (i = (i * t) % r), (t = (t * t) % r), (e >>= St);
      return i;
    }
    function is(t, e, r) {
      let i = t;
      for (; e-- > er; ) (i *= i), (i %= r);
      return i;
    }
    function nm(t, e) {
      if (t === er) throw new Error("invert: expected non-zero number");
      if (e <= er)
        throw new Error("invert: expected positive modulus, got " + e);
      let r = Zr(t, e),
        i = e,
        s = er,
        n = St;
      for (; r !== er; ) {
        const o = i / r,
          a = i % r,
          c = s - n * o;
        (i = r), (r = a), (s = n), (n = c);
      }
      if (i !== St) throw new Error("invert: does not exist");
      return Zr(s, e);
    }
    function GK(t) {
      const e = (t - St) / sa;
      let r, i, s;
      for (r = t - St, i = 0; r % sa === er; r /= sa, i++);
      for (s = sa; s < t && qE(s, e, t) !== t - St; s++)
        if (s > 1e3)
          throw new Error("Cannot find square root: likely non-prime P");
      if (i === 1) {
        const o = (t + St) / sm;
        return function (a, c) {
          const l = a.pow(c, o);
          if (!a.eql(a.sqr(l), c)) throw new Error("Cannot find square root");
          return l;
        };
      }
      const n = (r + St) / sa;
      return function (o, a) {
        if (o.pow(a, e) === o.neg(o.ONE))
          throw new Error("Cannot find square root");
        let c = i,
          l = o.pow(o.mul(o.ONE, s), r),
          u = o.pow(a, n),
          h = o.pow(a, r);
        for (; !o.eql(h, o.ONE); ) {
          if (o.eql(h, o.ZERO)) return o.ZERO;
          let d = 1;
          for (let p = o.sqr(h); d < c && !o.eql(p, o.ONE); d++) p = o.sqr(p);
          const g = o.pow(l, St << BigInt(c - d - 1));
          (l = o.sqr(g)), (u = o.mul(u, g)), (h = o.mul(h, l)), (c = d);
        }
        return u;
      };
    }
    function ZK(t) {
      if (t % sm === KK) {
        const e = (t + St) / sm;
        return function (r, i) {
          const s = r.pow(i, e);
          if (!r.eql(r.sqr(s), i)) throw new Error("Cannot find square root");
          return s;
        };
      }
      if (t % zE === ME) {
        const e = (t - ME) / zE;
        return function (r, i) {
          const s = r.mul(i, sa),
            n = r.pow(s, e),
            o = r.mul(i, n),
            a = r.mul(r.mul(o, sa), n),
            c = r.mul(o, r.sub(a, r.ONE));
          if (!r.eql(r.sqr(c), i)) throw new Error("Cannot find square root");
          return c;
        };
      }
      return GK(t);
    }
    const YK = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN",
    ];
    function JK(t) {
      const e = {
          ORDER: "bigint",
          MASK: "bigint",
          BYTES: "isSafeInteger",
          BITS: "isSafeInteger",
        },
        r = YK.reduce((i, s) => ((i[s] = "function"), i), e);
      return Zc(t, r);
    }
    function XK(t, e, r) {
      if (r < er) throw new Error("invalid exponent, negatives unsupported");
      if (r === er) return t.ONE;
      if (r === St) return e;
      let i = t.ONE,
        s = e;
      for (; r > er; ) r & St && (i = t.mul(i, s)), (s = t.sqr(s)), (r >>= St);
      return i;
    }
    function QK(t, e) {
      const r = new Array(e.length),
        i = e.reduce(
          (n, o, a) => (t.is0(o) ? n : ((r[a] = n), t.mul(n, o))),
          t.ONE
        ),
        s = t.inv(i);
      return (
        e.reduceRight(
          (n, o, a) => (t.is0(o) ? n : ((r[a] = t.mul(n, r[a])), t.mul(n, o))),
          s
        ),
        r
      );
    }
    function HE(t, e) {
      const r = e !== void 0 ? e : t.toString(2).length,
        i = Math.ceil(r / 8);
      return { nBitLength: r, nByteLength: i };
    }
    function VE(t, e, r = !1, i = {}) {
      if (t <= er)
        throw new Error("invalid field: expected ORDER > 0, got " + t);
      const { nBitLength: s, nByteLength: n } = HE(t, e);
      if (n > 2048)
        throw new Error("invalid field: expected ORDER of <= 2048 bytes");
      let o;
      const a = Object.freeze({
        ORDER: t,
        isLE: r,
        BITS: s,
        BYTES: n,
        MASK: tm(s),
        ZERO: er,
        ONE: St,
        create: (c) => Zr(c, t),
        isValid: (c) => {
          if (typeof c != "bigint")
            throw new Error(
              "invalid field element: expected bigint, got " + typeof c
            );
          return er <= c && c < t;
        },
        is0: (c) => c === er,
        isOdd: (c) => (c & St) === St,
        neg: (c) => Zr(-c, t),
        eql: (c, l) => c === l,
        sqr: (c) => Zr(c * c, t),
        add: (c, l) => Zr(c + l, t),
        sub: (c, l) => Zr(c - l, t),
        mul: (c, l) => Zr(c * l, t),
        pow: (c, l) => XK(a, c, l),
        div: (c, l) => Zr(c * nm(l, t), t),
        sqrN: (c) => c * c,
        addN: (c, l) => c + l,
        subN: (c, l) => c - l,
        mulN: (c, l) => c * l,
        inv: (c) => nm(c, t),
        sqrt: i.sqrt || ((c) => (o || (o = ZK(t)), o(a, c))),
        invertBatch: (c) => QK(a, c),
        cmov: (c, l, u) => (u ? l : c),
        toBytes: (c) => (r ? df(c, n) : Gc(c, n)),
        fromBytes: (c) => {
          if (c.length !== n)
            throw new Error(
              "Field.fromBytes: expected " + n + " bytes, got " + c.length
            );
          return r ? th(c) : ia(c);
        },
      });
      return Object.freeze(a);
    }
    function WE(t) {
      if (typeof t != "bigint") throw new Error("field order must be bigint");
      const e = t.toString(2).length;
      return Math.ceil(e / 8);
    }
    function KE(t) {
      const e = WE(t);
      return e + Math.ceil(e / 2);
    }
    function eG(t, e, r = !1) {
      const i = t.length,
        s = WE(e),
        n = KE(e);
      if (i < 16 || i < n || i > 1024)
        throw new Error("expected " + n + "-1024 bytes of input, got " + i);
      const o = r ? th(t) : ia(t),
        a = Zr(o, e - St) + St;
      return r ? df(a, s) : Gc(a, s);
    }
    const GE = BigInt(0),
      ff = BigInt(1);
    function om(t, e) {
      const r = e.negate();
      return t ? r : e;
    }
    function ZE(t, e) {
      if (!Number.isSafeInteger(t) || t <= 0 || t > e)
        throw new Error(
          "invalid window size, expected [1.." + e + "], got W=" + t
        );
    }
    function am(t, e) {
      ZE(t, e);
      const r = Math.ceil(e / t) + 1,
        i = 2 ** (t - 1);
      return { windows: r, windowSize: i };
    }
    function tG(t, e) {
      if (!Array.isArray(t)) throw new Error("array expected");
      t.forEach((r, i) => {
        if (!(r instanceof e)) throw new Error("invalid point at index " + i);
      });
    }
    function rG(t, e) {
      if (!Array.isArray(t)) throw new Error("array of scalars expected");
      t.forEach((r, i) => {
        if (!e.isValid(r)) throw new Error("invalid scalar at index " + i);
      });
    }
    const cm = new WeakMap(),
      YE = new WeakMap();
    function lm(t) {
      return YE.get(t) || 1;
    }
    function iG(t, e) {
      return {
        constTimeNegate: om,
        hasPrecomputes(r) {
          return lm(r) !== 1;
        },
        unsafeLadder(r, i, s = t.ZERO) {
          let n = r;
          for (; i > GE; )
            i & ff && (s = s.add(n)), (n = n.double()), (i >>= ff);
          return s;
        },
        precomputeWindow(r, i) {
          const { windows: s, windowSize: n } = am(i, e),
            o = [];
          let a = r,
            c = a;
          for (let l = 0; l < s; l++) {
            (c = a), o.push(c);
            for (let u = 1; u < n; u++) (c = c.add(a)), o.push(c);
            a = c.double();
          }
          return o;
        },
        wNAF(r, i, s) {
          const { windows: n, windowSize: o } = am(r, e);
          let a = t.ZERO,
            c = t.BASE;
          const l = BigInt(2 ** r - 1),
            u = 2 ** r,
            h = BigInt(r);
          for (let d = 0; d < n; d++) {
            const g = d * o;
            let p = Number(s & l);
            (s >>= h), p > o && ((p -= u), (s += ff));
            const w = g,
              f = g + Math.abs(p) - 1,
              m = d % 2 !== 0,
              y = p < 0;
            p === 0 ? (c = c.add(om(m, i[w]))) : (a = a.add(om(y, i[f])));
          }
          return { p: a, f: c };
        },
        wNAFUnsafe(r, i, s, n = t.ZERO) {
          const { windows: o, windowSize: a } = am(r, e),
            c = BigInt(2 ** r - 1),
            l = 2 ** r,
            u = BigInt(r);
          for (let h = 0; h < o; h++) {
            const d = h * a;
            if (s === GE) break;
            let g = Number(s & c);
            if (((s >>= u), g > a && ((g -= l), (s += ff)), g === 0)) continue;
            let p = i[d + Math.abs(g) - 1];
            g < 0 && (p = p.negate()), (n = n.add(p));
          }
          return n;
        },
        getPrecomputes(r, i, s) {
          let n = cm.get(i);
          return (
            n ||
              ((n = this.precomputeWindow(i, r)), r !== 1 && cm.set(i, s(n))),
            n
          );
        },
        wNAFCached(r, i, s) {
          const n = lm(r);
          return this.wNAF(n, this.getPrecomputes(n, r, s), i);
        },
        wNAFCachedUnsafe(r, i, s, n) {
          const o = lm(r);
          return o === 1
            ? this.unsafeLadder(r, i, n)
            : this.wNAFUnsafe(o, this.getPrecomputes(o, r, s), i, n);
        },
        setWindowSize(r, i) {
          ZE(i, e), YE.set(r, i), cm.delete(r);
        },
      };
    }
    function sG(t, e, r, i) {
      if ((tG(r, t), rG(i, e), r.length !== i.length))
        throw new Error("arrays of points and scalars must have equal length");
      const s = t.ZERO,
        n = UE(BigInt(r.length)),
        o = n > 12 ? n - 3 : n > 4 ? n - 2 : n ? 2 : 1,
        a = (1 << o) - 1,
        c = new Array(a + 1).fill(s),
        l = Math.floor((e.BITS - 1) / o) * o;
      let u = s;
      for (let h = l; h >= 0; h -= o) {
        c.fill(s);
        for (let g = 0; g < i.length; g++) {
          const p = i[g],
            w = Number((p >> BigInt(h)) & BigInt(a));
          c[w] = c[w].add(r[g]);
        }
        let d = s;
        for (let g = c.length - 1, p = s; g > 0; g--)
          (p = p.add(c[g])), (d = d.add(p));
        if (((u = u.add(d)), h !== 0))
          for (let g = 0; g < o; g++) u = u.double();
      }
      return u;
    }
    function JE(t) {
      return (
        JK(t.Fp),
        Zc(
          t,
          { n: "bigint", h: "bigint", Gx: "field", Gy: "field" },
          { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }
        ),
        Object.freeze({ ...HE(t.n, t.nBitLength), ...t, p: t.Fp.ORDER })
      );
    }
    BigInt(0), BigInt(1), BigInt(2), BigInt(8);
    const Yc = BigInt(0),
      um = BigInt(1);
    function nG(t) {
      return (
        Zc(
          t,
          { a: "bigint" },
          {
            montgomeryBits: "isSafeInteger",
            nByteLength: "isSafeInteger",
            adjustScalarBytes: "function",
            domain: "function",
            powPminus2: "function",
            Gu: "bigint",
          }
        ),
        Object.freeze({ ...t })
      );
    }
    function oG(t) {
      const e = nG(t),
        { P: r } = e,
        i = (y) => Zr(y, r),
        s = e.montgomeryBits,
        n = Math.ceil(s / 8),
        o = e.nByteLength,
        a = e.adjustScalarBytes || ((y) => y),
        c = e.powPminus2 || ((y) => qE(y, r - BigInt(2), r));
      function l(y, E, C) {
        const O = i(y * (E - C));
        return (E = i(E - O)), (C = i(C + O)), [E, C];
      }
      const u = (e.a - BigInt(2)) / BigInt(4);
      function h(y, E) {
        un("u", y, Yc, r), un("scalar", E, Yc, r);
        const C = E,
          O = y;
        let A = um,
          P = Yc,
          N = y,
          x = um,
          $ = Yc,
          k;
        for (let j = BigInt(s - 1); j >= Yc; j--) {
          const I = (C >> j) & um;
          ($ ^= I),
            (k = l($, A, N)),
            (A = k[0]),
            (N = k[1]),
            (k = l($, P, x)),
            (P = k[0]),
            (x = k[1]),
            ($ = I);
          const b = A + P,
            v = i(b * b),
            S = A - P,
            T = i(S * S),
            _ = v - T,
            R = N + x,
            U = N - x,
            D = i(U * b),
            H = i(R * S),
            q = D + H,
            V = D - H;
          (N = i(q * q)),
            (x = i(O * i(V * V))),
            (A = i(v * T)),
            (P = i(_ * (v + i(u * _))));
        }
        (k = l($, A, N)),
          (A = k[0]),
          (N = k[1]),
          (k = l($, P, x)),
          (P = k[0]),
          (x = k[1]);
        const F = c(P);
        return i(A * F);
      }
      function d(y) {
        return df(i(y), n);
      }
      function g(y) {
        const E = mi("u coordinate", y, n);
        return o === 32 && (E[31] &= 127), th(E);
      }
      function p(y) {
        const E = mi("scalar", y),
          C = E.length;
        if (C !== n && C !== o) {
          let O = "" + n + " or " + o;
          throw new Error("invalid scalar, expected " + O + " bytes, got " + C);
        }
        return th(a(E));
      }
      function w(y, E) {
        const C = g(E),
          O = p(y),
          A = h(C, O);
        if (A === Yc) throw new Error("invalid private or public key received");
        return d(A);
      }
      const f = d(e.Gu);
      function m(y) {
        return w(y, f);
      }
      return {
        scalarMult: w,
        scalarMultBase: m,
        getSharedSecret: (y, E) => w(y, E),
        getPublicKey: (y) => m(y),
        utils: { randomPrivateKey: () => e.randomBytes(e.nByteLength) },
        GuBytes: f,
      };
    }
    const hm = BigInt(
      "57896044618658097711785492504343953926634992332820282019728792003956564819949"
    );
    BigInt(0);
    const aG = BigInt(1),
      XE = BigInt(2),
      cG = BigInt(3),
      lG = BigInt(5);
    BigInt(8);
    function uG(t) {
      const e = BigInt(10),
        r = BigInt(20),
        i = BigInt(40),
        s = BigInt(80),
        n = hm,
        o = (((t * t) % n) * t) % n,
        a = (is(o, XE, n) * o) % n,
        c = (is(a, aG, n) * t) % n,
        l = (is(c, lG, n) * c) % n,
        u = (is(l, e, n) * l) % n,
        h = (is(u, r, n) * u) % n,
        d = (is(h, i, n) * h) % n,
        g = (is(d, s, n) * d) % n,
        p = (is(g, s, n) * d) % n,
        w = (is(p, e, n) * l) % n;
      return { pow_p_5_8: (is(w, XE, n) * t) % n, b2: o };
    }
    function hG(t) {
      return (t[0] &= 248), (t[31] &= 127), (t[31] |= 64), t;
    }
    oG({
      P: hm,
      a: BigInt(486662),
      montgomeryBits: 255,
      nByteLength: 32,
      Gu: BigInt(9),
      powPminus2: (t) => {
        const e = hm,
          { pow_p_5_8: r, b2: i } = uG(t);
        return Zr(is(r, cG, e) * i, e);
      },
      adjustScalarBytes: hG,
      randomBytes: bE,
    });
    function QE(t) {
      t.lowS !== void 0 && Hc("lowS", t.lowS),
        t.prehash !== void 0 && Hc("prehash", t.prehash);
    }
    function dG(t) {
      const e = JE(t);
      Zc(
        e,
        { a: "field", b: "field" },
        {
          allowedPrivateKeyLengths: "array",
          wrapPrivateKey: "boolean",
          isTorsionFree: "function",
          clearCofactor: "function",
          allowInfinityPoint: "boolean",
          fromBytes: "function",
          toBytes: "function",
        }
      );
      const { endo: r, Fp: i, a: s } = e;
      if (r) {
        if (!i.eql(s, i.ZERO))
          throw new Error(
            "invalid endomorphism, can only be defined for Koblitz curves that have a=0"
          );
        if (
          typeof r != "object" ||
          typeof r.beta != "bigint" ||
          typeof r.splitScalar != "function"
        )
          throw new Error(
            "invalid endomorphism, expected beta: bigint and splitScalar: function"
          );
      }
      return Object.freeze({ ...e });
    }
    const { bytesToNumberBE: pG, hexToBytes: fG } = WK;
    class gG extends Error {
      constructor(e = "") {
        super(e);
      }
    }
    const hn = {
        Err: gG,
        _tlv: {
          encode: (t, e) => {
            const { Err: r } = hn;
            if (t < 0 || t > 256) throw new r("tlv.encode: wrong tag");
            if (e.length & 1) throw new r("tlv.encode: unpadded data");
            const i = e.length / 2,
              s = Wc(i);
            if ((s.length / 2) & 128)
              throw new r("tlv.encode: long form length too big");
            const n = i > 127 ? Wc((s.length / 2) | 128) : "";
            return Wc(t) + n + s + e;
          },
          decode(t, e) {
            const { Err: r } = hn;
            let i = 0;
            if (t < 0 || t > 256) throw new r("tlv.encode: wrong tag");
            if (e.length < 2 || e[i++] !== t)
              throw new r("tlv.decode: wrong tlv");
            const s = e[i++],
              n = !!(s & 128);
            let o = 0;
            if (!n) o = s;
            else {
              const c = s & 127;
              if (!c)
                throw new r(
                  "tlv.decode(long): indefinite length not supported"
                );
              if (c > 4)
                throw new r("tlv.decode(long): byte length is too big");
              const l = e.subarray(i, i + c);
              if (l.length !== c)
                throw new r("tlv.decode: length bytes not complete");
              if (l[0] === 0)
                throw new r("tlv.decode(long): zero leftmost byte");
              for (const u of l) o = (o << 8) | u;
              if (((i += c), o < 128))
                throw new r("tlv.decode(long): not minimal encoding");
            }
            const a = e.subarray(i, i + o);
            if (a.length !== o) throw new r("tlv.decode: wrong value length");
            return { v: a, l: e.subarray(i + o) };
          },
        },
        _int: {
          encode(t) {
            const { Err: e } = hn;
            if (t < dn)
              throw new e("integer: negative integers are not allowed");
            let r = Wc(t);
            if ((Number.parseInt(r[0], 16) & 8 && (r = "00" + r), r.length & 1))
              throw new e("unexpected DER parsing assertion: unpadded hex");
            return r;
          },
          decode(t) {
            const { Err: e } = hn;
            if (t[0] & 128) throw new e("invalid signature integer: negative");
            if (t[0] === 0 && !(t[1] & 128))
              throw new e(
                "invalid signature integer: unnecessary leading zero"
              );
            return pG(t);
          },
        },
        toSig(t) {
          const { Err: e, _int: r, _tlv: i } = hn,
            s = typeof t == "string" ? fG(t) : t;
          eh(s);
          const { v: n, l: o } = i.decode(48, s);
          if (o.length)
            throw new e("invalid signature: left bytes after parsing");
          const { v: a, l: c } = i.decode(2, n),
            { v: l, l: u } = i.decode(2, c);
          if (u.length)
            throw new e("invalid signature: left bytes after parsing");
          return { r: r.decode(a), s: r.decode(l) };
        },
        hexFromSig(t) {
          const { _tlv: e, _int: r } = hn,
            i = e.encode(2, r.encode(t.r)),
            s = e.encode(2, r.encode(t.s)),
            n = i + s;
          return e.encode(48, n);
        },
      },
      dn = BigInt(0),
      tr = BigInt(1);
    BigInt(2);
    const e9 = BigInt(3);
    BigInt(4);
    function wG(t) {
      const e = dG(t),
        { Fp: r } = e,
        i = VE(e.n, e.nBitLength),
        s =
          e.toBytes ||
          ((w, f, m) => {
            const y = f.toAffine();
            return rh(Uint8Array.from([4]), r.toBytes(y.x), r.toBytes(y.y));
          }),
        n =
          e.fromBytes ||
          ((w) => {
            const f = w.subarray(1),
              m = r.fromBytes(f.subarray(0, r.BYTES)),
              y = r.fromBytes(f.subarray(r.BYTES, 2 * r.BYTES));
            return { x: m, y };
          });
      function o(w) {
        const { a: f, b: m } = e,
          y = r.sqr(w),
          E = r.mul(y, w);
        return r.add(r.add(E, r.mul(w, f)), m);
      }
      if (!r.eql(r.sqr(e.Gy), o(e.Gx)))
        throw new Error("bad generator point: equation left != right");
      function a(w) {
        return pf(w, tr, e.n);
      }
      function c(w) {
        const {
          allowedPrivateKeyLengths: f,
          nByteLength: m,
          wrapPrivateKey: y,
          n: E,
        } = e;
        if (f && typeof w != "bigint") {
          if (
            (ra(w) && (w = Vc(w)),
            typeof w != "string" || !f.includes(w.length))
          )
            throw new Error("invalid private key");
          w = w.padStart(m * 2, "0");
        }
        let C;
        try {
          C = typeof w == "bigint" ? w : ia(mi("private key", w, m));
        } catch {
          throw new Error(
            "invalid private key, expected hex or " +
              m +
              " bytes, got " +
              typeof w
          );
        }
        return y && (C = Zr(C, E)), un("private key", C, tr, E), C;
      }
      function l(w) {
        if (!(w instanceof d)) throw new Error("ProjectivePoint expected");
      }
      const u = im((w, f) => {
          const { px: m, py: y, pz: E } = w;
          if (r.eql(E, r.ONE)) return { x: m, y };
          const C = w.is0();
          f == null && (f = C ? r.ONE : r.inv(E));
          const O = r.mul(m, f),
            A = r.mul(y, f),
            P = r.mul(E, f);
          if (C) return { x: r.ZERO, y: r.ZERO };
          if (!r.eql(P, r.ONE)) throw new Error("invZ was invalid");
          return { x: O, y: A };
        }),
        h = im((w) => {
          if (w.is0()) {
            if (e.allowInfinityPoint && !r.is0(w.py)) return;
            throw new Error("bad point: ZERO");
          }
          const { x: f, y: m } = w.toAffine();
          if (!r.isValid(f) || !r.isValid(m))
            throw new Error("bad point: x or y not FE");
          const y = r.sqr(m),
            E = o(f);
          if (!r.eql(y, E))
            throw new Error("bad point: equation left != right");
          if (!w.isTorsionFree())
            throw new Error("bad point: not in prime-order subgroup");
          return !0;
        });
      class d {
        constructor(f, m, y) {
          if (
            ((this.px = f),
            (this.py = m),
            (this.pz = y),
            f == null || !r.isValid(f))
          )
            throw new Error("x required");
          if (m == null || !r.isValid(m)) throw new Error("y required");
          if (y == null || !r.isValid(y)) throw new Error("z required");
          Object.freeze(this);
        }
        static fromAffine(f) {
          const { x: m, y } = f || {};
          if (!f || !r.isValid(m) || !r.isValid(y))
            throw new Error("invalid affine point");
          if (f instanceof d) throw new Error("projective point not allowed");
          const E = (C) => r.eql(C, r.ZERO);
          return E(m) && E(y) ? d.ZERO : new d(m, y, r.ONE);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        static normalizeZ(f) {
          const m = r.invertBatch(f.map((y) => y.pz));
          return f.map((y, E) => y.toAffine(m[E])).map(d.fromAffine);
        }
        static fromHex(f) {
          const m = d.fromAffine(n(mi("pointHex", f)));
          return m.assertValidity(), m;
        }
        static fromPrivateKey(f) {
          return d.BASE.multiply(c(f));
        }
        static msm(f, m) {
          return sG(d, i, f, m);
        }
        _setWindowSize(f) {
          p.setWindowSize(this, f);
        }
        assertValidity() {
          h(this);
        }
        hasEvenY() {
          const { y: f } = this.toAffine();
          if (r.isOdd) return !r.isOdd(f);
          throw new Error("Field doesn't support isOdd");
        }
        equals(f) {
          l(f);
          const { px: m, py: y, pz: E } = this,
            { px: C, py: O, pz: A } = f,
            P = r.eql(r.mul(m, A), r.mul(C, E)),
            N = r.eql(r.mul(y, A), r.mul(O, E));
          return P && N;
        }
        negate() {
          return new d(this.px, r.neg(this.py), this.pz);
        }
        double() {
          const { a: f, b: m } = e,
            y = r.mul(m, e9),
            { px: E, py: C, pz: O } = this;
          let A = r.ZERO,
            P = r.ZERO,
            N = r.ZERO,
            x = r.mul(E, E),
            $ = r.mul(C, C),
            k = r.mul(O, O),
            F = r.mul(E, C);
          return (
            (F = r.add(F, F)),
            (N = r.mul(E, O)),
            (N = r.add(N, N)),
            (A = r.mul(f, N)),
            (P = r.mul(y, k)),
            (P = r.add(A, P)),
            (A = r.sub($, P)),
            (P = r.add($, P)),
            (P = r.mul(A, P)),
            (A = r.mul(F, A)),
            (N = r.mul(y, N)),
            (k = r.mul(f, k)),
            (F = r.sub(x, k)),
            (F = r.mul(f, F)),
            (F = r.add(F, N)),
            (N = r.add(x, x)),
            (x = r.add(N, x)),
            (x = r.add(x, k)),
            (x = r.mul(x, F)),
            (P = r.add(P, x)),
            (k = r.mul(C, O)),
            (k = r.add(k, k)),
            (x = r.mul(k, F)),
            (A = r.sub(A, x)),
            (N = r.mul(k, $)),
            (N = r.add(N, N)),
            (N = r.add(N, N)),
            new d(A, P, N)
          );
        }
        add(f) {
          l(f);
          const { px: m, py: y, pz: E } = this,
            { px: C, py: O, pz: A } = f;
          let P = r.ZERO,
            N = r.ZERO,
            x = r.ZERO;
          const $ = e.a,
            k = r.mul(e.b, e9);
          let F = r.mul(m, C),
            j = r.mul(y, O),
            I = r.mul(E, A),
            b = r.add(m, y),
            v = r.add(C, O);
          (b = r.mul(b, v)),
            (v = r.add(F, j)),
            (b = r.sub(b, v)),
            (v = r.add(m, E));
          let S = r.add(C, A);
          return (
            (v = r.mul(v, S)),
            (S = r.add(F, I)),
            (v = r.sub(v, S)),
            (S = r.add(y, E)),
            (P = r.add(O, A)),
            (S = r.mul(S, P)),
            (P = r.add(j, I)),
            (S = r.sub(S, P)),
            (x = r.mul($, v)),
            (P = r.mul(k, I)),
            (x = r.add(P, x)),
            (P = r.sub(j, x)),
            (x = r.add(j, x)),
            (N = r.mul(P, x)),
            (j = r.add(F, F)),
            (j = r.add(j, F)),
            (I = r.mul($, I)),
            (v = r.mul(k, v)),
            (j = r.add(j, I)),
            (I = r.sub(F, I)),
            (I = r.mul($, I)),
            (v = r.add(v, I)),
            (F = r.mul(j, v)),
            (N = r.add(N, F)),
            (F = r.mul(S, v)),
            (P = r.mul(b, P)),
            (P = r.sub(P, F)),
            (F = r.mul(b, j)),
            (x = r.mul(S, x)),
            (x = r.add(x, F)),
            new d(P, N, x)
          );
        }
        subtract(f) {
          return this.add(f.negate());
        }
        is0() {
          return this.equals(d.ZERO);
        }
        wNAF(f) {
          return p.wNAFCached(this, f, d.normalizeZ);
        }
        multiplyUnsafe(f) {
          const { endo: m, n: y } = e;
          un("scalar", f, dn, y);
          const E = d.ZERO;
          if (f === dn) return E;
          if (this.is0() || f === tr) return this;
          if (!m || p.hasPrecomputes(this))
            return p.wNAFCachedUnsafe(this, f, d.normalizeZ);
          let { k1neg: C, k1: O, k2neg: A, k2: P } = m.splitScalar(f),
            N = E,
            x = E,
            $ = this;
          for (; O > dn || P > dn; )
            O & tr && (N = N.add($)),
              P & tr && (x = x.add($)),
              ($ = $.double()),
              (O >>= tr),
              (P >>= tr);
          return (
            C && (N = N.negate()),
            A && (x = x.negate()),
            (x = new d(r.mul(x.px, m.beta), x.py, x.pz)),
            N.add(x)
          );
        }
        multiply(f) {
          const { endo: m, n: y } = e;
          un("scalar", f, tr, y);
          let E, C;
          if (m) {
            const { k1neg: O, k1: A, k2neg: P, k2: N } = m.splitScalar(f);
            let { p: x, f: $ } = this.wNAF(A),
              { p: k, f: F } = this.wNAF(N);
            (x = p.constTimeNegate(O, x)),
              (k = p.constTimeNegate(P, k)),
              (k = new d(r.mul(k.px, m.beta), k.py, k.pz)),
              (E = x.add(k)),
              (C = $.add(F));
          } else {
            const { p: O, f: A } = this.wNAF(f);
            (E = O), (C = A);
          }
          return d.normalizeZ([E, C])[0];
        }
        multiplyAndAddUnsafe(f, m, y) {
          const E = d.BASE,
            C = (A, P) =>
              P === dn || P === tr || !A.equals(E)
                ? A.multiplyUnsafe(P)
                : A.multiply(P),
            O = C(this, m).add(C(f, y));
          return O.is0() ? void 0 : O;
        }
        toAffine(f) {
          return u(this, f);
        }
        isTorsionFree() {
          const { h: f, isTorsionFree: m } = e;
          if (f === tr) return !0;
          if (m) return m(d, this);
          throw new Error(
            "isTorsionFree() has not been declared for the elliptic curve"
          );
        }
        clearCofactor() {
          const { h: f, clearCofactor: m } = e;
          return f === tr ? this : m ? m(d, this) : this.multiplyUnsafe(e.h);
        }
        toRawBytes(f = !0) {
          return Hc("isCompressed", f), this.assertValidity(), s(d, this, f);
        }
        toHex(f = !0) {
          return Hc("isCompressed", f), Vc(this.toRawBytes(f));
        }
      }
      (d.BASE = new d(e.Gx, e.Gy, r.ONE)),
        (d.ZERO = new d(r.ZERO, r.ONE, r.ZERO));
      const g = e.nBitLength,
        p = iG(d, e.endo ? Math.ceil(g / 2) : g);
      return {
        CURVE: e,
        ProjectivePoint: d,
        normPrivateKeyToScalar: c,
        weierstrassEquation: o,
        isWithinCurveOrder: a,
      };
    }
    function mG(t) {
      const e = JE(t);
      return (
        Zc(
          e,
          { hash: "hash", hmac: "function", randomBytes: "function" },
          { bits2int: "function", bits2int_modN: "function", lowS: "boolean" }
        ),
        Object.freeze({ lowS: !0, ...e })
      );
    }
    function yG(t) {
      const e = mG(t),
        { Fp: r, n: i } = e,
        s = r.BYTES + 1,
        n = 2 * r.BYTES + 1;
      function o(I) {
        return Zr(I, i);
      }
      function a(I) {
        return nm(I, i);
      }
      const {
          ProjectivePoint: c,
          normPrivateKeyToScalar: l,
          weierstrassEquation: u,
          isWithinCurveOrder: h,
        } = wG({
          ...e,
          toBytes(I, b, v) {
            const S = b.toAffine(),
              T = r.toBytes(S.x),
              _ = rh;
            return (
              Hc("isCompressed", v),
              v
                ? _(Uint8Array.from([b.hasEvenY() ? 2 : 3]), T)
                : _(Uint8Array.from([4]), T, r.toBytes(S.y))
            );
          },
          fromBytes(I) {
            const b = I.length,
              v = I[0],
              S = I.subarray(1);
            if (b === s && (v === 2 || v === 3)) {
              const T = ia(S);
              if (!pf(T, tr, r.ORDER)) throw new Error("Point is not on curve");
              const _ = u(T);
              let R;
              try {
                R = r.sqrt(_);
              } catch (D) {
                const H = D instanceof Error ? ": " + D.message : "";
                throw new Error("Point is not on curve" + H);
              }
              const U = (R & tr) === tr;
              return ((v & 1) === 1) !== U && (R = r.neg(R)), { x: T, y: R };
            } else if (b === n && v === 4) {
              const T = r.fromBytes(S.subarray(0, r.BYTES)),
                _ = r.fromBytes(S.subarray(r.BYTES, 2 * r.BYTES));
              return { x: T, y: _ };
            } else {
              const T = s,
                _ = n;
              throw new Error(
                "invalid Point, expected length of " +
                  T +
                  ", or uncompressed " +
                  _ +
                  ", got " +
                  b
              );
            }
          },
        }),
        d = (I) => Vc(Gc(I, e.nByteLength));
      function g(I) {
        const b = i >> tr;
        return I > b;
      }
      function p(I) {
        return g(I) ? o(-I) : I;
      }
      const w = (I, b, v) => ia(I.slice(b, v));
      class f {
        constructor(b, v, S) {
          (this.r = b),
            (this.s = v),
            (this.recovery = S),
            this.assertValidity();
        }
        static fromCompact(b) {
          const v = e.nByteLength;
          return (
            (b = mi("compactSignature", b, v * 2)),
            new f(w(b, 0, v), w(b, v, 2 * v))
          );
        }
        static fromDER(b) {
          const { r: v, s: S } = hn.toSig(mi("DER", b));
          return new f(v, S);
        }
        assertValidity() {
          un("r", this.r, tr, i), un("s", this.s, tr, i);
        }
        addRecoveryBit(b) {
          return new f(this.r, this.s, b);
        }
        recoverPublicKey(b) {
          const { r: v, s: S, recovery: T } = this,
            _ = A(mi("msgHash", b));
          if (T == null || ![0, 1, 2, 3].includes(T))
            throw new Error("recovery id invalid");
          const R = T === 2 || T === 3 ? v + e.n : v;
          if (R >= r.ORDER) throw new Error("recovery id 2 or 3 invalid");
          const U = (T & 1) === 0 ? "02" : "03",
            D = c.fromHex(U + d(R)),
            H = a(R),
            q = o(-_ * H),
            V = o(S * H),
            Y = c.BASE.multiplyAndAddUnsafe(D, q, V);
          if (!Y) throw new Error("point at infinify");
          return Y.assertValidity(), Y;
        }
        hasHighS() {
          return g(this.s);
        }
        normalizeS() {
          return this.hasHighS()
            ? new f(this.r, o(-this.s), this.recovery)
            : this;
        }
        toDERRawBytes() {
          return Kc(this.toDERHex());
        }
        toDERHex() {
          return hn.hexFromSig({ r: this.r, s: this.s });
        }
        toCompactRawBytes() {
          return Kc(this.toCompactHex());
        }
        toCompactHex() {
          return d(this.r) + d(this.s);
        }
      }
      const m = {
        isValidPrivateKey(I) {
          try {
            return l(I), !0;
          } catch {
            return !1;
          }
        },
        normPrivateKeyToScalar: l,
        randomPrivateKey: () => {
          const I = KE(e.n);
          return eG(e.randomBytes(I), e.n);
        },
        precompute(I = 8, b = c.BASE) {
          return b._setWindowSize(I), b.multiply(BigInt(3)), b;
        },
      };
      function y(I, b = !0) {
        return c.fromPrivateKey(I).toRawBytes(b);
      }
      function E(I) {
        const b = ra(I),
          v = typeof I == "string",
          S = (b || v) && I.length;
        return b
          ? S === s || S === n
          : v
          ? S === 2 * s || S === 2 * n
          : I instanceof c;
      }
      function C(I, b, v = !0) {
        if (E(I)) throw new Error("first arg must be private key");
        if (!E(b)) throw new Error("second arg must be public key");
        return c.fromHex(b).multiply(l(I)).toRawBytes(v);
      }
      const O =
          e.bits2int ||
          function (I) {
            if (I.length > 8192) throw new Error("input is too large");
            const b = ia(I),
              v = I.length * 8 - e.nBitLength;
            return v > 0 ? b >> BigInt(v) : b;
          },
        A =
          e.bits2int_modN ||
          function (I) {
            return o(O(I));
          },
        P = tm(e.nBitLength);
      function N(I) {
        return un("num < 2^" + e.nBitLength, I, dn, P), Gc(I, e.nByteLength);
      }
      function x(I, b, v = $) {
        if (["recovered", "canonical"].some((re) => re in v))
          throw new Error("sign() legacy options not supported");
        const { hash: S, randomBytes: T } = e;
        let { lowS: _, prehash: R, extraEntropy: U } = v;
        _ == null && (_ = !0),
          (I = mi("msgHash", I)),
          QE(v),
          R && (I = mi("prehashed msgHash", S(I)));
        const D = A(I),
          H = l(b),
          q = [N(H), N(D)];
        if (U != null && U !== !1) {
          const re = U === !0 ? T(r.BYTES) : U;
          q.push(mi("extraEntropy", re));
        }
        const V = rh(...q),
          Y = D;
        function ae(re) {
          const te = O(re);
          if (!h(te)) return;
          const ve = a(te),
            Ee = c.BASE.multiply(te).toAffine(),
            Ce = o(Ee.x);
          if (Ce === dn) return;
          const Ie = o(ve * o(Y + Ce * H));
          if (Ie === dn) return;
          let mt = (Ee.x === Ce ? 0 : 2) | Number(Ee.y & tr),
            Ir = Ie;
          return _ && g(Ie) && ((Ir = p(Ie)), (mt ^= 1)), new f(Ce, Ir, mt);
        }
        return { seed: V, k2sig: ae };
      }
      const $ = { lowS: e.lowS, prehash: !1 },
        k = { lowS: e.lowS, prehash: !1 };
      function F(I, b, v = $) {
        const { seed: S, k2sig: T } = x(I, b, v),
          _ = e;
        return jE(_.hash.outputLen, _.nByteLength, _.hmac)(S, T);
      }
      c.BASE._setWindowSize(8);
      function j(I, b, v, S = k) {
        const T = I;
        (b = mi("msgHash", b)), (v = mi("publicKey", v));
        const { lowS: _, prehash: R, format: U } = S;
        if ((QE(S), "strict" in S))
          throw new Error("options.strict was renamed to lowS");
        if (U !== void 0 && U !== "compact" && U !== "der")
          throw new Error("format must be compact or der");
        const D = typeof T == "string" || ra(T),
          H =
            !D &&
            !U &&
            typeof T == "object" &&
            T !== null &&
            typeof T.r == "bigint" &&
            typeof T.s == "bigint";
        if (!D && !H)
          throw new Error(
            "invalid signature, expected Uint8Array, hex string or Signature instance"
          );
        let q, V;
        try {
          if ((H && (q = new f(T.r, T.s)), D)) {
            try {
              U !== "compact" && (q = f.fromDER(T));
            } catch (Ie) {
              if (!(Ie instanceof hn.Err)) throw Ie;
            }
            !q && U !== "der" && (q = f.fromCompact(T));
          }
          V = c.fromHex(v);
        } catch {
          return !1;
        }
        if (!q || (_ && q.hasHighS())) return !1;
        R && (b = e.hash(b));
        const { r: Y, s: ae } = q,
          re = A(b),
          te = a(ae),
          ve = o(re * te),
          Ee = o(Y * te),
          Ce = c.BASE.multiplyAndAddUnsafe(V, ve, Ee)?.toAffine();
        return Ce ? o(Ce.x) === Y : !1;
      }
      return {
        CURVE: e,
        getPublicKey: y,
        getSharedSecret: C,
        sign: F,
        verify: j,
        ProjectivePoint: c,
        Signature: f,
        utils: m,
      };
    }
    function bG(t) {
      return {
        hash: t,
        hmac: (e, ...r) => BE(t, e, eK(...r)),
        randomBytes: bE,
      };
    }
    function vG(t, e) {
      const r = (i) => yG({ ...t, ...bG(i) });
      return { ...r(e), create: r };
    }
    const t9 = VE(
        BigInt(
          "0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"
        )
      ),
      EG = t9.create(BigInt("-3")),
      CG = BigInt(
        "0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"
      );
    vG(
      {
        a: EG,
        b: CG,
        Fp: t9,
        n: BigInt(
          "0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"
        ),
        Gx: BigInt(
          "0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"
        ),
        Gy: BigInt(
          "0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"
        ),
        h: BigInt(1),
        lowS: !1,
      },
      BK
    );
    function xG(t, e) {
      if (t.length >= 255) throw new TypeError("Alphabet too long");
      for (var r = new Uint8Array(256), i = 0; i < r.length; i++) r[i] = 255;
      for (var s = 0; s < t.length; s++) {
        var n = t.charAt(s),
          o = n.charCodeAt(0);
        if (r[o] !== 255) throw new TypeError(n + " is ambiguous");
        r[o] = s;
      }
      var a = t.length,
        c = t.charAt(0),
        l = Math.log(a) / Math.log(256),
        u = Math.log(256) / Math.log(a);
      function h(p) {
        if (
          (p instanceof Uint8Array ||
            (ArrayBuffer.isView(p)
              ? (p = new Uint8Array(p.buffer, p.byteOffset, p.byteLength))
              : Array.isArray(p) && (p = Uint8Array.from(p))),
          !(p instanceof Uint8Array))
        )
          throw new TypeError("Expected Uint8Array");
        if (p.length === 0) return "";
        for (var w = 0, f = 0, m = 0, y = p.length; m !== y && p[m] === 0; )
          m++, w++;
        for (
          var E = ((y - m) * u + 1) >>> 0, C = new Uint8Array(E);
          m !== y;

        ) {
          for (
            var O = p[m], A = 0, P = E - 1;
            (O !== 0 || A < f) && P !== -1;
            P--, A++
          )
            (O += (256 * C[P]) >>> 0),
              (C[P] = O % a >>> 0),
              (O = (O / a) >>> 0);
          if (O !== 0) throw new Error("Non-zero carry");
          (f = A), m++;
        }
        for (var N = E - f; N !== E && C[N] === 0; ) N++;
        for (var x = c.repeat(w); N < E; ++N) x += t.charAt(C[N]);
        return x;
      }
      function d(p) {
        if (typeof p != "string") throw new TypeError("Expected String");
        if (p.length === 0) return new Uint8Array();
        var w = 0;
        if (p[w] !== " ") {
          for (var f = 0, m = 0; p[w] === c; ) f++, w++;
          for (
            var y = ((p.length - w) * l + 1) >>> 0, E = new Uint8Array(y);
            p[w];

          ) {
            var C = r[p.charCodeAt(w)];
            if (C === 255) return;
            for (var O = 0, A = y - 1; (C !== 0 || O < m) && A !== -1; A--, O++)
              (C += (a * E[A]) >>> 0),
                (E[A] = C % 256 >>> 0),
                (C = (C / 256) >>> 0);
            if (C !== 0) throw new Error("Non-zero carry");
            (m = O), w++;
          }
          if (p[w] !== " ") {
            for (var P = y - m; P !== y && E[P] === 0; ) P++;
            for (var N = new Uint8Array(f + (y - P)), x = f; P !== y; )
              N[x++] = E[P++];
            return N;
          }
        }
      }
      function g(p) {
        var w = d(p);
        if (w) return w;
        throw new Error(`Non-${e} character`);
      }
      return { encode: h, decodeUnsafe: d, decode: g };
    }
    var IG = xG,
      _G = IG;
    const r9 = (t) => {
        if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
          return t;
        if (t instanceof ArrayBuffer) return new Uint8Array(t);
        if (ArrayBuffer.isView(t))
          return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
        throw new Error("Unknown type, must be binary type");
      },
      AG = (t) => new TextEncoder().encode(t),
      SG = (t) => new TextDecoder().decode(t);
    class PG {
      constructor(e, r, i) {
        (this.name = e), (this.prefix = r), (this.baseEncode = i);
      }
      encode(e) {
        if (e instanceof Uint8Array)
          return `${this.prefix}${this.baseEncode(e)}`;
        throw Error("Unknown type, must be binary type");
      }
    }
    class OG {
      constructor(e, r, i) {
        if (((this.name = e), (this.prefix = r), r.codePointAt(0) === void 0))
          throw new Error("Invalid prefix character");
        (this.prefixCodePoint = r.codePointAt(0)), (this.baseDecode = i);
      }
      decode(e) {
        if (typeof e == "string") {
          if (e.codePointAt(0) !== this.prefixCodePoint)
            throw Error(
              `Unable to decode multibase string ${JSON.stringify(e)}, ${
                this.name
              } decoder only supports inputs prefixed with ${this.prefix}`
            );
          return this.baseDecode(e.slice(this.prefix.length));
        } else throw Error("Can only multibase decode strings");
      }
      or(e) {
        return i9(this, e);
      }
    }
    class NG {
      constructor(e) {
        this.decoders = e;
      }
      or(e) {
        return i9(this, e);
      }
      decode(e) {
        const r = e[0],
          i = this.decoders[r];
        if (i) return i.decode(e);
        throw RangeError(
          `Unable to decode multibase string ${JSON.stringify(
            e
          )}, only inputs prefixed with ${Object.keys(
            this.decoders
          )} are supported`
        );
      }
    }
    const i9 = (t, e) =>
      new NG({
        ...(t.decoders || { [t.prefix]: t }),
        ...(e.decoders || { [e.prefix]: e }),
      });
    class TG {
      constructor(e, r, i, s) {
        (this.name = e),
          (this.prefix = r),
          (this.baseEncode = i),
          (this.baseDecode = s),
          (this.encoder = new PG(e, r, i)),
          (this.decoder = new OG(e, r, s));
      }
      encode(e) {
        return this.encoder.encode(e);
      }
      decode(e) {
        return this.decoder.decode(e);
      }
    }
    const gf = ({ name: t, prefix: e, encode: r, decode: i }) =>
        new TG(t, e, r, i),
      ih = ({ prefix: t, name: e, alphabet: r }) => {
        const { encode: i, decode: s } = _G(r, e);
        return gf({ prefix: t, name: e, encode: i, decode: (n) => r9(s(n)) });
      },
      kG = (t, e, r, i) => {
        const s = {};
        for (let u = 0; u < e.length; ++u) s[e[u]] = u;
        let n = t.length;
        for (; t[n - 1] === "="; ) --n;
        const o = new Uint8Array(((n * r) / 8) | 0);
        let a = 0,
          c = 0,
          l = 0;
        for (let u = 0; u < n; ++u) {
          const h = s[t[u]];
          if (h === void 0) throw new SyntaxError(`Non-${i} character`);
          (c = (c << r) | h),
            (a += r),
            a >= 8 && ((a -= 8), (o[l++] = 255 & (c >> a)));
        }
        if (a >= r || 255 & (c << (8 - a)))
          throw new SyntaxError("Unexpected end of data");
        return o;
      },
      RG = (t, e, r) => {
        const i = e[e.length - 1] === "=",
          s = (1 << r) - 1;
        let n = "",
          o = 0,
          a = 0;
        for (let c = 0; c < t.length; ++c)
          for (a = (a << 8) | t[c], o += 8; o > r; )
            (o -= r), (n += e[s & (a >> o)]);
        if ((o && (n += e[s & (a << (r - o))]), i))
          for (; (n.length * r) & 7; ) n += "=";
        return n;
      },
      wr = ({ name: t, prefix: e, bitsPerChar: r, alphabet: i }) =>
        gf({
          prefix: e,
          name: t,
          encode(s) {
            return RG(s, i, r);
          },
          decode(s) {
            return kG(s, i, r, t);
          },
        }),
      $G = gf({
        prefix: "\0",
        name: "identity",
        encode: (t) => SG(t),
        decode: (t) => AG(t),
      });
    var FG = Object.freeze({ __proto__: null, identity: $G });
    const BG = wr({
      prefix: "0",
      name: "base2",
      alphabet: "01",
      bitsPerChar: 1,
    });
    var LG = Object.freeze({ __proto__: null, base2: BG });
    const UG = wr({
      prefix: "7",
      name: "base8",
      alphabet: "01234567",
      bitsPerChar: 3,
    });
    var DG = Object.freeze({ __proto__: null, base8: UG });
    const jG = ih({ prefix: "9", name: "base10", alphabet: "0123456789" });
    var MG = Object.freeze({ __proto__: null, base10: jG });
    const zG = wr({
        prefix: "f",
        name: "base16",
        alphabet: "0123456789abcdef",
        bitsPerChar: 4,
      }),
      qG = wr({
        prefix: "F",
        name: "base16upper",
        alphabet: "0123456789ABCDEF",
        bitsPerChar: 4,
      });
    var HG = Object.freeze({ __proto__: null, base16: zG, base16upper: qG });
    const VG = wr({
        prefix: "b",
        name: "base32",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567",
        bitsPerChar: 5,
      }),
      WG = wr({
        prefix: "B",
        name: "base32upper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
        bitsPerChar: 5,
      }),
      KG = wr({
        prefix: "c",
        name: "base32pad",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
        bitsPerChar: 5,
      }),
      GG = wr({
        prefix: "C",
        name: "base32padupper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
        bitsPerChar: 5,
      }),
      ZG = wr({
        prefix: "v",
        name: "base32hex",
        alphabet: "0123456789abcdefghijklmnopqrstuv",
        bitsPerChar: 5,
      }),
      YG = wr({
        prefix: "V",
        name: "base32hexupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
        bitsPerChar: 5,
      }),
      JG = wr({
        prefix: "t",
        name: "base32hexpad",
        alphabet: "0123456789abcdefghijklmnopqrstuv=",
        bitsPerChar: 5,
      }),
      XG = wr({
        prefix: "T",
        name: "base32hexpadupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
        bitsPerChar: 5,
      }),
      QG = wr({
        prefix: "h",
        name: "base32z",
        alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
        bitsPerChar: 5,
      });
    var eZ = Object.freeze({
      __proto__: null,
      base32: VG,
      base32upper: WG,
      base32pad: KG,
      base32padupper: GG,
      base32hex: ZG,
      base32hexupper: YG,
      base32hexpad: JG,
      base32hexpadupper: XG,
      base32z: QG,
    });
    const tZ = ih({
        prefix: "k",
        name: "base36",
        alphabet: "0123456789abcdefghijklmnopqrstuvwxyz",
      }),
      rZ = ih({
        prefix: "K",
        name: "base36upper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
      });
    var iZ = Object.freeze({ __proto__: null, base36: tZ, base36upper: rZ });
    const sZ = ih({
        name: "base58btc",
        prefix: "z",
        alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
      }),
      nZ = ih({
        name: "base58flickr",
        prefix: "Z",
        alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
      });
    var oZ = Object.freeze({
      __proto__: null,
      base58btc: sZ,
      base58flickr: nZ,
    });
    const aZ = wr({
        prefix: "m",
        name: "base64",
        alphabet:
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        bitsPerChar: 6,
      }),
      cZ = wr({
        prefix: "M",
        name: "base64pad",
        alphabet:
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        bitsPerChar: 6,
      }),
      lZ = wr({
        prefix: "u",
        name: "base64url",
        alphabet:
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
        bitsPerChar: 6,
      }),
      uZ = wr({
        prefix: "U",
        name: "base64urlpad",
        alphabet:
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
        bitsPerChar: 6,
      });
    var hZ = Object.freeze({
      __proto__: null,
      base64: aZ,
      base64pad: cZ,
      base64url: lZ,
      base64urlpad: uZ,
    });
    const s9 = Array.from(
        "\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"
      ),
      dZ = s9.reduce((t, e, r) => ((t[r] = e), t), []),
      pZ = s9.reduce((t, e, r) => ((t[e.codePointAt(0)] = r), t), []);
    function fZ(t) {
      return t.reduce((e, r) => ((e += dZ[r]), e), "");
    }
    function gZ(t) {
      const e = [];
      for (const r of t) {
        const i = pZ[r.codePointAt(0)];
        if (i === void 0) throw new Error(`Non-base256emoji character: ${r}`);
        e.push(i);
      }
      return new Uint8Array(e);
    }
    const wZ = gf({
      prefix: "\u{1F680}",
      name: "base256emoji",
      encode: fZ,
      decode: gZ,
    });
    var mZ = Object.freeze({ __proto__: null, base256emoji: wZ }),
      yZ = o9,
      n9 = 128,
      bZ = 127,
      vZ = ~bZ,
      EZ = Math.pow(2, 31);
    function o9(t, e, r) {
      (e = e || []), (r = r || 0);
      for (var i = r; t >= EZ; ) (e[r++] = (t & 255) | n9), (t /= 128);
      for (; t & vZ; ) (e[r++] = (t & 255) | n9), (t >>>= 7);
      return (e[r] = t | 0), (o9.bytes = r - i + 1), e;
    }
    var CZ = dm,
      xZ = 128,
      a9 = 127;
    function dm(t, i) {
      var r = 0,
        i = i || 0,
        s = 0,
        n = i,
        o,
        a = t.length;
      do {
        if (n >= a)
          throw ((dm.bytes = 0), new RangeError("Could not decode varint"));
        (o = t[n++]),
          (r += s < 28 ? (o & a9) << s : (o & a9) * Math.pow(2, s)),
          (s += 7);
      } while (o >= xZ);
      return (dm.bytes = n - i), r;
    }
    var IZ = Math.pow(2, 7),
      _Z = Math.pow(2, 14),
      AZ = Math.pow(2, 21),
      SZ = Math.pow(2, 28),
      PZ = Math.pow(2, 35),
      OZ = Math.pow(2, 42),
      NZ = Math.pow(2, 49),
      TZ = Math.pow(2, 56),
      kZ = Math.pow(2, 63),
      RZ = function (t) {
        return t < IZ
          ? 1
          : t < _Z
          ? 2
          : t < AZ
          ? 3
          : t < SZ
          ? 4
          : t < PZ
          ? 5
          : t < OZ
          ? 6
          : t < NZ
          ? 7
          : t < TZ
          ? 8
          : t < kZ
          ? 9
          : 10;
      },
      $Z = { encode: yZ, decode: CZ, encodingLength: RZ },
      c9 = $Z;
    const l9 = (t, e, r = 0) => (c9.encode(t, e, r), e),
      u9 = (t) => c9.encodingLength(t),
      pm = (t, e) => {
        const r = e.byteLength,
          i = u9(t),
          s = i + u9(r),
          n = new Uint8Array(s + r);
        return l9(t, n, 0), l9(r, n, i), n.set(e, s), new FZ(t, r, e, n);
      };
    class FZ {
      constructor(e, r, i, s) {
        (this.code = e), (this.size = r), (this.digest = i), (this.bytes = s);
      }
    }
    const h9 = ({ name: t, code: e, encode: r }) => new BZ(t, e, r);
    class BZ {
      constructor(e, r, i) {
        (this.name = e), (this.code = r), (this.encode = i);
      }
      digest(e) {
        if (e instanceof Uint8Array) {
          const r = this.encode(e);
          return r instanceof Uint8Array
            ? pm(this.code, r)
            : r.then((i) => pm(this.code, i));
        } else throw Error("Unknown type, must be binary type");
      }
    }
    const d9 = (t) => async (e) =>
        new Uint8Array(await crypto.subtle.digest(t, e)),
      LZ = h9({ name: "sha2-256", code: 18, encode: d9("SHA-256") }),
      UZ = h9({ name: "sha2-512", code: 19, encode: d9("SHA-512") });
    var DZ = Object.freeze({ __proto__: null, sha256: LZ, sha512: UZ });
    const p9 = 0,
      jZ = "identity",
      f9 = r9;
    var MZ = Object.freeze({
      __proto__: null,
      identity: {
        code: p9,
        name: jZ,
        encode: f9,
        digest: (t) => pm(p9, f9(t)),
      },
    });
    new TextEncoder(),
      new TextDecoder(),
      { ...FG, ...LG, ...DG, ...MG, ...HG, ...eZ, ...iZ, ...oZ, ...hZ, ...mZ },
      { ...DZ, ...MZ },
      typeof ut < "u" &&
        typeof ut.env < "u" &&
        {}.NEXT_PUBLIC_SECURE_SITE_SDK_URL,
      typeof ut < "u" &&
        typeof ut.env < "u" &&
        {}.NEXT_PUBLIC_DEFAULT_LOG_LEVEL,
      typeof ut < "u" &&
        typeof ut.env < "u" &&
        {}.NEXT_PUBLIC_SECURE_SITE_SDK_VERSION;
    const oo = {
        SAFE_RPC_METHODS: [
          "eth_accounts",
          "eth_blockNumber",
          "eth_call",
          "eth_chainId",
          "eth_estimateGas",
          "eth_feeHistory",
          "eth_gasPrice",
          "eth_getAccount",
          "eth_getBalance",
          "eth_getBlockByHash",
          "eth_getBlockByNumber",
          "eth_getBlockReceipts",
          "eth_getBlockTransactionCountByHash",
          "eth_getBlockTransactionCountByNumber",
          "eth_getCode",
          "eth_getFilterChanges",
          "eth_getFilterLogs",
          "eth_getLogs",
          "eth_getProof",
          "eth_getStorageAt",
          "eth_getTransactionByBlockHashAndIndex",
          "eth_getTransactionByBlockNumberAndIndex",
          "eth_getTransactionByHash",
          "eth_getTransactionCount",
          "eth_getTransactionReceipt",
          "eth_getUncleCountByBlockHash",
          "eth_getUncleCountByBlockNumber",
          "eth_maxPriorityFeePerGas",
          "eth_newBlockFilter",
          "eth_newFilter",
          "eth_newPendingTransactionFilter",
          "eth_sendRawTransaction",
          "eth_syncing",
          "eth_uninstallFilter",
          "wallet_getCapabilities",
          "wallet_getCallsStatus",
          "eth_getUserOperationReceipt",
          "eth_estimateUserOperationGas",
          "eth_getUserOperationByHash",
          "eth_supportedEntryPoints",
          "wallet_getAssets",
        ],
        NOT_SAFE_RPC_METHODS: [
          "personal_sign",
          "eth_signTypedData_v4",
          "eth_sendTransaction",
          "solana_signMessage",
          "solana_signTransaction",
          "solana_signAllTransactions",
          "solana_signAndSendTransaction",
          "wallet_sendCalls",
          "wallet_grantPermissions",
          "wallet_revokePermissions",
          "eth_sendUserOperation",
        ],
        GET_CHAIN_ID: "eth_chainId",
        RPC_METHOD_NOT_ALLOWED_MESSAGE: "Requested RPC call is not allowed",
        RPC_METHOD_NOT_ALLOWED_UI_MESSAGE: "Action not allowed",
        ACCOUNT_TYPES: { EOA: "eoa", SMART_ACCOUNT: "smartAccount" },
      },
      na = Object.freeze({
        message: "",
        variant: "success",
        svg: void 0,
        open: !1,
        autoClose: !0,
      }),
      jt = ot({ ...na }),
      at = {
        state: jt,
        subscribeKey(t, e) {
          return Fr(jt, t, e);
        },
        showLoading(t, e = {}) {
          this._showMessage({ message: t, variant: "loading", ...e });
        },
        showSuccess(t) {
          this._showMessage({ message: t, variant: "success" });
        },
        showSvg(t, e) {
          this._showMessage({ message: t, svg: e });
        },
        showError(t) {
          const e = X.parseError(t);
          this._showMessage({ message: e, variant: "error" });
        },
        hide() {
          (jt.message = na.message),
            (jt.variant = na.variant),
            (jt.svg = na.svg),
            (jt.open = na.open),
            (jt.autoClose = na.autoClose);
        },
        _showMessage({
          message: t,
          svg: e,
          variant: r = "success",
          autoClose: i = na.autoClose,
        }) {
          jt.open
            ? ((jt.open = !1),
              setTimeout(() => {
                (jt.message = t),
                  (jt.variant = r),
                  (jt.svg = e),
                  (jt.open = !0),
                  (jt.autoClose = i);
              }, 150))
            : ((jt.message = t),
              (jt.variant = r),
              (jt.svg = e),
              (jt.open = !0),
              (jt.autoClose = i));
        },
      },
      ao = {
        getSIWX() {
          return G.state.siwx;
        },
        async initializeIfEnabled() {
          const t = G.state.siwx,
            e = B.getActiveCaipAddress();
          if (!(t && e)) return;
          const [r, i, s] = e.split(":");
          if (B.checkIfSupportedNetwork(r))
            try {
              if ((await t.getSessions(`${r}:${i}`, s)).length) return;
              await $e.open({ view: "SIWXSignMessage" });
            } catch (n) {
              console.error("SIWXUtil:initializeIfEnabled", n),
                Se.sendEvent({
                  type: "track",
                  event: "SIWX_AUTH_ERROR",
                  properties: this.getSIWXEventProperties(),
                }),
                await pe._getClient()?.disconnect().catch(console.error),
                ie.reset("Connect"),
                at.showError(
                  "A problem occurred while trying initialize authentication"
                );
            }
        },
        async requestSignMessage() {
          const t = G.state.siwx,
            e = X.getPlainAddress(B.getActiveCaipAddress()),
            r = B.getActiveCaipNetwork(),
            i = pe._getClient();
          if (!t) throw new Error("SIWX is not enabled");
          if (!e) throw new Error("No ActiveCaipAddress found");
          if (!r) throw new Error("No ActiveCaipNetwork or client found");
          if (!i) throw new Error("No ConnectionController client found");
          try {
            const s = await t.createMessage({
                chainId: r.caipNetworkId,
                accountAddress: e,
              }),
              n = s.toString();
            oe.getConnectorId(r.chainNamespace) === he.CONNECTOR_ID.AUTH &&
              ie.pushTransactionStack({ view: null, goBack: !1, replace: !0 });
            const o = await i.signMessage(n);
            await t.addSession({ data: s, message: n, signature: o }),
              $e.close(),
              Se.sendEvent({
                type: "track",
                event: "SIWX_AUTH_SUCCESS",
                properties: this.getSIWXEventProperties(),
              });
          } catch (s) {
            const n = this.getSIWXEventProperties();
            (!$e.state.open || ie.state.view === "ApproveTransaction") &&
              (await $e.open({ view: "SIWXSignMessage" })),
              n.isSmartAccount
                ? at.showError(
                    "This application might not support Smart Accounts"
                  )
                : at.showError("Signature declined"),
              Se.sendEvent({
                type: "track",
                event: "SIWX_AUTH_ERROR",
                properties: n,
              }),
              console.error("SWIXUtil:requestSignMessage", s);
          }
        },
        async cancelSignMessage() {
          try {
            this.getSIWX()?.getRequired?.()
              ? await pe.disconnect()
              : $e.close(),
              ie.reset("Connect"),
              Se.sendEvent({
                event: "CLICK_CANCEL_SIWX",
                type: "track",
                properties: this.getSIWXEventProperties(),
              });
          } catch (t) {
            console.error("SIWXUtil:cancelSignMessage", t);
          }
        },
        async getSessions() {
          const t = G.state.siwx,
            e = X.getPlainAddress(B.getActiveCaipAddress()),
            r = B.getActiveCaipNetwork();
          return t && e && r ? t.getSessions(r.caipNetworkId, e) : [];
        },
        async isSIWXCloseDisabled() {
          const t = this.getSIWX();
          if (t) {
            const e = ie.state.view === "ApproveTransaction",
              r = ie.state.view === "SIWXSignMessage";
            if (e || r)
              return (
                t.getRequired?.() && (await this.getSessions()).length === 0
              );
          }
          return !1;
        },
        async universalProviderAuthenticate({
          universalProvider: t,
          chains: e,
          methods: r,
        }) {
          const i = ao.getSIWX(),
            s = new Set(e.map((a) => a.split(":")[0]));
          if (!i || s.size !== 1 || !s.has("eip155")) return !1;
          const n = await i.createMessage({
              chainId: B.getActiveCaipNetwork()?.caipNetworkId || "",
              accountAddress: "",
            }),
            o = await t.authenticate({
              nonce: n.nonce,
              domain: n.domain,
              uri: n.uri,
              exp: n.expirationTime,
              iat: n.issuedAt,
              nbf: n.notBefore,
              requestId: n.requestId,
              version: n.version,
              resources: n.resources,
              statement: n.statement,
              chainId: n.chainId,
              methods: r,
              chains: [n.chainId, ...e.filter((a) => a !== n.chainId)],
            });
          if (
            (at.showLoading("Authenticating...", { autoClose: !1 }),
            fe.setConnectedWalletInfo(
              {
                ...o.session.peer.metadata,
                name: o.session.peer.metadata.name,
                icon: o.session.peer.metadata.icons?.[0],
                type: "WALLET_CONNECT",
              },
              Array.from(s)[0]
            ),
            o?.auths?.length)
          ) {
            const a = o.auths.map((c) => {
              const l = t.client.formatAuthMessage({
                request: c.p,
                iss: c.p.iss,
              });
              return {
                data: {
                  ...c.p,
                  accountAddress: c.p.iss.split(":").slice(-1).join(""),
                  chainId: c.p.iss.split(":").slice(2, 4).join(":"),
                  uri: c.p.aud,
                  version: c.p.version || n.version,
                  expirationTime: c.p.exp,
                  issuedAt: c.p.iat,
                  notBefore: c.p.nbf,
                },
                message: l,
                signature: c.s.s,
                cacao: c,
              };
            });
            try {
              await i.setSessions(a),
                Se.sendEvent({
                  type: "track",
                  event: "SIWX_AUTH_SUCCESS",
                  properties: ao.getSIWXEventProperties(),
                });
            } catch (c) {
              throw (
                (console.error(
                  "SIWX:universalProviderAuth - failed to set sessions",
                  c
                ),
                Se.sendEvent({
                  type: "track",
                  event: "SIWX_AUTH_ERROR",
                  properties: ao.getSIWXEventProperties(),
                }),
                await t.disconnect().catch(console.error),
                c)
              );
            } finally {
              at.hide();
            }
          }
          return !0;
        },
        getSIWXEventProperties() {
          const t = B.state.activeChain;
          return {
            network: B.state.activeCaipNetwork?.caipNetworkId || "",
            isSmartAccount:
              fe.state.preferredAccountTypes?.[t] ===
              oo.ACCOUNT_TYPES.SMART_ACCOUNT,
          };
        },
        async clearSessions() {
          const t = this.getSIWX();
          t && (await t.setSessions([]));
        },
      },
      pt = ot({
        transactions: [],
        coinbaseTransactions: {},
        transactionsByYear: {},
        lastNetworkInView: void 0,
        loading: !1,
        empty: !1,
        next: void 0,
      }),
      zZ = {
        state: pt,
        subscribe(t) {
          return Sr(pt, () => t(pt));
        },
        setLastNetworkInView(t) {
          pt.lastNetworkInView = t;
        },
        async fetchTransactions(t, e) {
          if (!t)
            throw new Error(
              "Transactions can't be fetched without an accountAddress"
            );
          pt.loading = !0;
          try {
            const r = await be.fetchTransactions({
                account: t,
                cursor: pt.next,
                onramp: e,
                cache: e === "coinbase" ? "no-cache" : void 0,
                chainId: B.state.activeCaipNetwork?.caipNetworkId,
              }),
              i = this.filterSpamTransactions(r.data),
              s = this.filterByConnectedChain(i),
              n = [...pt.transactions, ...s];
            (pt.loading = !1),
              e === "coinbase"
                ? (pt.coinbaseTransactions =
                    this.groupTransactionsByYearAndMonth(
                      pt.coinbaseTransactions,
                      r.data
                    ))
                : ((pt.transactions = n),
                  (pt.transactionsByYear = this.groupTransactionsByYearAndMonth(
                    pt.transactionsByYear,
                    s
                  ))),
              (pt.empty = n.length === 0),
              (pt.next = r.next ? r.next : void 0);
          } catch {
            const r = B.state.activeChain;
            Se.sendEvent({
              type: "track",
              event: "ERROR_FETCH_TRANSACTIONS",
              properties: {
                address: t,
                projectId: G.state.projectId,
                cursor: pt.next,
                isSmartAccount:
                  fe.state.preferredAccountTypes?.[r] ===
                  oo.ACCOUNT_TYPES.SMART_ACCOUNT,
              },
            }),
              at.showError("Failed to fetch transactions"),
              (pt.loading = !1),
              (pt.empty = !0),
              (pt.next = void 0);
          }
        },
        groupTransactionsByYearAndMonth(t = {}, e = []) {
          const r = t;
          return (
            e.forEach((i) => {
              const s = new Date(i.metadata.minedAt).getFullYear(),
                n = new Date(i.metadata.minedAt).getMonth(),
                o = r[s] ?? {},
                a = (o[n] ?? []).filter((c) => c.id !== i.id);
              r[s] = {
                ...o,
                [n]: [...a, i].sort(
                  (c, l) =>
                    new Date(l.metadata.minedAt).getTime() -
                    new Date(c.metadata.minedAt).getTime()
                ),
              };
            }),
            r
          );
        },
        filterSpamTransactions(t) {
          return t.filter(
            (e) => !e.transfers.every((r) => r.nft_info?.flags.is_spam === !0)
          );
        },
        filterByConnectedChain(t) {
          const e = B.state.activeCaipNetwork?.caipNetworkId;
          return t.filter((r) => r.metadata.chain === e);
        },
        clearCursor() {
          pt.next = void 0;
        },
        resetTransactions() {
          (pt.transactions = []),
            (pt.transactionsByYear = {}),
            (pt.lastNetworkInView = void 0),
            (pt.loading = !1),
            (pt.empty = !1),
            (pt.next = void 0);
        },
      },
      vt = ot({ wcError: !1, buffering: !1, status: "disconnected" });
    let Jc;
    const pe = {
        state: vt,
        subscribeKey(t, e) {
          return Fr(vt, t, e);
        },
        _getClient() {
          return vt._client;
        },
        setClient(t) {
          vt._client = ta(t);
        },
        async connectWalletConnect() {
          if (X.isTelegram() || (X.isSafari() && X.isIos())) {
            if (Jc) {
              await Jc, (Jc = void 0);
              return;
            }
            if (!X.isPairingExpired(vt?.wcPairingExpiry)) {
              const t = vt.wcUri;
              vt.wcUri = t;
              return;
            }
            (Jc = this._getClient()
              ?.connectWalletConnect?.()
              .catch(() => {})),
              (this.state.status = "connecting"),
              await Jc,
              (Jc = void 0),
              (vt.wcPairingExpiry = void 0),
              (this.state.status = "connected");
          } else await this._getClient()?.connectWalletConnect?.();
        },
        async connectExternal(t, e, r = !0) {
          await this._getClient()?.connectExternal?.(t),
            r && B.setActiveNamespace(e);
        },
        async reconnectExternal(t) {
          await this._getClient()?.reconnectExternal?.(t);
          const e = t.chain || B.state.activeChain;
          e && oe.setConnectorId(t.id, e);
        },
        async setPreferredAccountType(t, e) {
          $e.setLoading(!0, B.state.activeChain);
          const r = oe.getAuthConnector();
          r &&
            (fe.setPreferredAccountType(t, e),
            await r.provider.setPreferredAccount(t),
            de.setPreferredAccountTypes(
              fe.state.preferredAccountTypes ?? { [e]: t }
            ),
            await this.reconnectExternal(r),
            $e.setLoading(!1, B.state.activeChain),
            Se.sendEvent({
              type: "track",
              event: "SET_PREFERRED_ACCOUNT_TYPE",
              properties: {
                accountType: t,
                network: B.state.activeCaipNetwork?.caipNetworkId || "",
              },
            }));
        },
        async signMessage(t) {
          return this._getClient()?.signMessage(t);
        },
        parseUnits(t, e) {
          return this._getClient()?.parseUnits(t, e);
        },
        formatUnits(t, e) {
          return this._getClient()?.formatUnits(t, e);
        },
        async sendTransaction(t) {
          return this._getClient()?.sendTransaction(t);
        },
        async getCapabilities(t) {
          return this._getClient()?.getCapabilities(t);
        },
        async grantPermissions(t) {
          return this._getClient()?.grantPermissions(t);
        },
        async walletGetAssets(t) {
          return this._getClient()?.walletGetAssets(t) ?? {};
        },
        async estimateGas(t) {
          return this._getClient()?.estimateGas(t);
        },
        async writeContract(t) {
          return this._getClient()?.writeContract(t);
        },
        async getEnsAddress(t) {
          return this._getClient()?.getEnsAddress(t);
        },
        async getEnsAvatar(t) {
          return this._getClient()?.getEnsAvatar(t);
        },
        checkInstalled(t) {
          return this._getClient()?.checkInstalled?.(t) || !1;
        },
        resetWcConnection() {
          (vt.wcUri = void 0),
            (vt.wcPairingExpiry = void 0),
            (vt.wcLinking = void 0),
            (vt.recentWallet = void 0),
            (vt.status = "disconnected"),
            zZ.resetTransactions(),
            de.deleteWalletConnectDeepLink();
        },
        resetUri() {
          (vt.wcUri = void 0), (vt.wcPairingExpiry = void 0);
        },
        finalizeWcConnection() {
          const { wcLinking: t, recentWallet: e } = pe.state;
          t && de.setWalletConnectDeepLink(t),
            e && de.setAppKitRecent(e),
            Se.sendEvent({
              type: "track",
              event: "CONNECT_SUCCESS",
              properties: {
                method: t ? "mobile" : "qrcode",
                name: ie.state.data?.wallet?.name || "Unknown",
              },
            });
        },
        setWcBasic(t) {
          vt.wcBasic = t;
        },
        setUri(t) {
          (vt.wcUri = t), (vt.wcPairingExpiry = X.getPairingExpiry());
        },
        setWcLinking(t) {
          vt.wcLinking = t;
        },
        setWcError(t) {
          (vt.wcError = t), (vt.buffering = !1);
        },
        setRecentWallet(t) {
          vt.recentWallet = t;
        },
        setBuffering(t) {
          vt.buffering = t;
        },
        setStatus(t) {
          vt.status = t;
        },
        async disconnect(t) {
          try {
            $e.setLoading(!0, t),
              await ao.clearSessions(),
              await B.disconnect(t),
              $e.setLoading(!1, t),
              oe.setFilterByNamespace(void 0);
          } catch {
            throw new Error("Failed to disconnect");
          }
        },
      },
      Xc = ot({
        loading: !1,
        open: !1,
        selectedNetworkId: void 0,
        activeChain: void 0,
        initialized: !1,
      }),
      pn = {
        state: Xc,
        subscribe(t) {
          return Sr(Xc, () => t(Xc));
        },
        subscribeOpen(t) {
          return Fr(Xc, "open", t);
        },
        set(t) {
          Object.assign(Xc, { ...Xc, ...t });
        },
      };
    function sh(t, { strict: e = !0 } = {}) {
      return !t || typeof t != "string"
        ? !1
        : e
        ? /^0x[0-9a-fA-F]*$/.test(t)
        : t.startsWith("0x");
    }
    function co(t) {
      return sh(t, { strict: !1 }) ? Math.ceil((t.length - 2) / 2) : t.length;
    }
    const g9 = "2.27.0";
    let fm = {
      getDocsUrl: ({ docsBaseUrl: t, docsPath: e = "", docsSlug: r }) =>
        e ? `${t ?? "https://viem.sh"}${e}${r ? `#${r}` : ""}` : void 0,
      version: `viem@${g9}`,
    };
    class Ne extends Error {
      constructor(e, r = {}) {
        const i =
            r.cause instanceof Ne
              ? r.cause.details
              : r.cause?.message
              ? r.cause.message
              : r.details,
          s = (r.cause instanceof Ne && r.cause.docsPath) || r.docsPath,
          n = fm.getDocsUrl?.({ ...r, docsPath: s }),
          o = [
            e || "An error occurred.",
            "",
            ...(r.metaMessages ? [...r.metaMessages, ""] : []),
            ...(n ? [`Docs: ${n}`] : []),
            ...(i ? [`Details: ${i}`] : []),
            ...(fm.version ? [`Version: ${fm.version}`] : []),
          ].join(`
`);
        super(o, r.cause ? { cause: r.cause } : void 0),
          Object.defineProperty(this, "details", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "docsPath", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "metaMessages", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "shortMessage", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "version", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "BaseError",
          }),
          (this.details = i),
          (this.docsPath = s),
          (this.metaMessages = r.metaMessages),
          (this.name = r.name ?? this.name),
          (this.shortMessage = e),
          (this.version = g9);
      }
      walk(e) {
        return w9(this, e);
      }
    }
    function w9(t, e) {
      return e?.(t)
        ? t
        : t && typeof t == "object" && "cause" in t && t.cause !== void 0
        ? w9(t.cause, e)
        : e
        ? null
        : t;
    }
    class m9 extends Ne {
      constructor({ offset: e, position: r, size: i }) {
        super(
          `Slice ${
            r === "start" ? "starting" : "ending"
          } at offset "${e}" is out-of-bounds (size: ${i}).`,
          { name: "SliceOffsetOutOfBoundsError" }
        );
      }
    }
    class y9 extends Ne {
      constructor({ size: e, targetSize: r, type: i }) {
        super(
          `${i.charAt(0).toUpperCase()}${i
            .slice(1)
            .toLowerCase()} size (${e}) exceeds padding size (${r}).`,
          { name: "SizeExceedsPaddingSizeError" }
        );
      }
    }
    function Qc(t, { dir: e, size: r = 32 } = {}) {
      return typeof t == "string"
        ? qZ(t, { dir: e, size: r })
        : HZ(t, { dir: e, size: r });
    }
    function qZ(t, { dir: e, size: r = 32 } = {}) {
      if (r === null) return t;
      const i = t.replace("0x", "");
      if (i.length > r * 2)
        throw new y9({
          size: Math.ceil(i.length / 2),
          targetSize: r,
          type: "hex",
        });
      return `0x${i[e === "right" ? "padEnd" : "padStart"](r * 2, "0")}`;
    }
    function HZ(t, { dir: e, size: r = 32 } = {}) {
      if (r === null) return t;
      if (t.length > r)
        throw new y9({ size: t.length, targetSize: r, type: "bytes" });
      const i = new Uint8Array(r);
      for (let s = 0; s < r; s++) {
        const n = e === "right";
        i[n ? s : r - s - 1] = t[n ? s : t.length - s - 1];
      }
      return i;
    }
    class VZ extends Ne {
      constructor({ max: e, min: r, signed: i, size: s, value: n }) {
        super(
          `Number "${n}" is not in safe ${
            s ? `${s * 8}-bit ${i ? "signed" : "unsigned"} ` : ""
          }integer range ${e ? `(${r} to ${e})` : `(above ${r})`}`,
          { name: "IntegerOutOfRangeError" }
        );
      }
    }
    class WZ extends Ne {
      constructor({ givenSize: e, maxSize: r }) {
        super(`Size cannot exceed ${r} bytes. Given size: ${e} bytes.`, {
          name: "SizeOverflowError",
        });
      }
    }
    function el(t, { dir: e = "left" } = {}) {
      let r = typeof t == "string" ? t.replace("0x", "") : t,
        i = 0;
      for (
        let s = 0;
        s < r.length - 1 &&
        r[e === "left" ? s : r.length - s - 1].toString() === "0";
        s++
      )
        i++;
      return (
        (r = e === "left" ? r.slice(i) : r.slice(0, r.length - i)),
        typeof t == "string"
          ? (r.length === 1 && e === "right" && (r = `${r}0`),
            `0x${r.length % 2 === 1 ? `0${r}` : r}`)
          : r
      );
    }
    function tl(t, { size: e }) {
      if (co(t) > e) throw new WZ({ givenSize: co(t), maxSize: e });
    }
    function fn(t, e = {}) {
      const { signed: r } = e;
      e.size && tl(t, { size: e.size });
      const i = BigInt(t);
      if (!r) return i;
      const s = (t.length - 2) / 2,
        n = (1n << (BigInt(s) * 8n - 1n)) - 1n;
      return i <= n ? i : i - BigInt(`0x${"f".padStart(s * 2, "f")}`) - 1n;
    }
    function wf(t, e = {}) {
      return Number(fn(t, e));
    }
    const KZ = Array.from({ length: 256 }, (t, e) =>
      e.toString(16).padStart(2, "0")
    );
    function ye(t, e = {}) {
      return typeof t == "number" || typeof t == "bigint"
        ? Lr(t, e)
        : typeof t == "string"
        ? b9(t, e)
        : typeof t == "boolean"
        ? GZ(t, e)
        : gn(t, e);
    }
    function GZ(t, e = {}) {
      const r = `0x${Number(t)}`;
      return typeof e.size == "number"
        ? (tl(r, { size: e.size }), Qc(r, { size: e.size }))
        : r;
    }
    function gn(t, e = {}) {
      let r = "";
      for (let s = 0; s < t.length; s++) r += KZ[t[s]];
      const i = `0x${r}`;
      return typeof e.size == "number"
        ? (tl(i, { size: e.size }), Qc(i, { dir: "right", size: e.size }))
        : i;
    }
    function Lr(t, e = {}) {
      const { signed: r, size: i } = e,
        s = BigInt(t);
      let n;
      i
        ? r
          ? (n = (1n << (BigInt(i) * 8n - 1n)) - 1n)
          : (n = 2n ** (BigInt(i) * 8n) - 1n)
        : typeof t == "number" && (n = BigInt(Number.MAX_SAFE_INTEGER));
      const o = typeof n == "bigint" && r ? -n - 1n : 0;
      if ((n && s > n) || s < o) {
        const c = typeof t == "bigint" ? "n" : "";
        throw new VZ({
          max: n ? `${n}${c}` : void 0,
          min: `${o}${c}`,
          signed: r,
          size: i,
          value: `${t}${c}`,
        });
      }
      const a = `0x${(r && s < 0
        ? (1n << BigInt(i * 8)) + BigInt(s)
        : s
      ).toString(16)}`;
      return i ? Qc(a, { size: i }) : a;
    }
    const ZZ = new TextEncoder();
    function b9(t, e = {}) {
      const r = ZZ.encode(t);
      return gn(r, e);
    }
    const YZ = new TextEncoder();
    function v9(t, e = {}) {
      return typeof t == "number" || typeof t == "bigint"
        ? XZ(t, e)
        : typeof t == "boolean"
        ? JZ(t, e)
        : sh(t)
        ? oa(t, e)
        : C9(t, e);
    }
    function JZ(t, e = {}) {
      const r = new Uint8Array(1);
      return (
        (r[0] = Number(t)),
        typeof e.size == "number"
          ? (tl(r, { size: e.size }), Qc(r, { size: e.size }))
          : r
      );
    }
    const wn = { zero: 48, nine: 57, A: 65, F: 70, a: 97, f: 102 };
    function E9(t) {
      if (t >= wn.zero && t <= wn.nine) return t - wn.zero;
      if (t >= wn.A && t <= wn.F) return t - (wn.A - 10);
      if (t >= wn.a && t <= wn.f) return t - (wn.a - 10);
    }
    function oa(t, e = {}) {
      let r = t;
      e.size &&
        (tl(r, { size: e.size }), (r = Qc(r, { dir: "right", size: e.size })));
      let i = r.slice(2);
      i.length % 2 && (i = `0${i}`);
      const s = i.length / 2,
        n = new Uint8Array(s);
      for (let o = 0, a = 0; o < s; o++) {
        const c = E9(i.charCodeAt(a++)),
          l = E9(i.charCodeAt(a++));
        if (c === void 0 || l === void 0)
          throw new Ne(
            `Invalid byte sequence ("${i[a - 2]}${i[a - 1]}" in "${i}").`
          );
        n[o] = c * 16 + l;
      }
      return n;
    }
    function XZ(t, e) {
      const r = Lr(t, e);
      return oa(r);
    }
    function C9(t, e = {}) {
      const r = YZ.encode(t);
      return typeof e.size == "number"
        ? (tl(r, { size: e.size }), Qc(r, { dir: "right", size: e.size }))
        : r;
    }
    function QZ(t, e) {
      const r = e || "hex",
        i = To(sh(t, { strict: !1 }) ? v9(t) : t);
      return r === "bytes" ? i : ye(i);
    }
    class lo extends Ne {
      constructor({ address: e }) {
        super(`Address "${e}" is invalid.`, {
          metaMessages: [
            "- Address must be a hex value of 20 bytes (40 hex characters).",
            "- Address must match its checksum counterpart.",
          ],
          name: "InvalidAddressError",
        });
      }
    }
    class mf extends Map {
      constructor(e) {
        super(),
          Object.defineProperty(this, "maxSize", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          (this.maxSize = e);
      }
      get(e) {
        const r = super.get(e);
        return (
          super.has(e) && r !== void 0 && (this.delete(e), super.set(e, r)), r
        );
      }
      set(e, r) {
        if ((super.set(e, r), this.maxSize && this.size > this.maxSize)) {
          const i = this.keys().next().value;
          i && this.delete(i);
        }
        return this;
      }
    }
    const gm = new mf(8192);
    function eY(t, e) {
      if (gm.has(`${t}.${e}`)) return gm.get(`${t}.${e}`);
      const r = e ? `${e}${t.toLowerCase()}` : t.substring(2).toLowerCase(),
        i = QZ(C9(r), "bytes"),
        s = (e ? r.substring(`${e}0x`.length) : r).split("");
      for (let o = 0; o < 40; o += 2)
        i[o >> 1] >> 4 >= 8 && s[o] && (s[o] = s[o].toUpperCase()),
          (i[o >> 1] & 15) >= 8 &&
            s[o + 1] &&
            (s[o + 1] = s[o + 1].toUpperCase());
      const n = `0x${s.join("")}`;
      return gm.set(`${t}.${e}`, n), n;
    }
    const tY = /^0x[a-fA-F0-9]{40}$/,
      wm = new mf(8192);
    function mn(t, e) {
      const { strict: r = !0 } = e ?? {},
        i = `${t}.${r}`;
      if (wm.has(i)) return wm.get(i);
      const s = tY.test(t)
        ? t.toLowerCase() === t
          ? !0
          : r
          ? eY(t) === t
          : !0
        : !1;
      return wm.set(i, s), s;
    }
    function rl(t) {
      return `0x${t.reduce((e, r) => e + r.replace("0x", ""), "")}`;
    }
    function rY(t, e, r, { strict: i } = {}) {
      return sh(t, { strict: !1 })
        ? sY(t, e, r, { strict: i })
        : iY(t, e, r, { strict: i });
    }
    function x9(t, e) {
      if (typeof e == "number" && e > 0 && e > co(t) - 1)
        throw new m9({ offset: e, position: "start", size: co(t) });
    }
    function I9(t, e, r) {
      if (typeof e == "number" && typeof r == "number" && co(t) !== r - e)
        throw new m9({ offset: r, position: "end", size: co(t) });
    }
    function iY(t, e, r, { strict: i } = {}) {
      x9(t, e);
      const s = t.slice(e, r);
      return i && I9(s, e, r), s;
    }
    function sY(t, e, r, { strict: i } = {}) {
      x9(t, e);
      const s = `0x${t
        .replace("0x", "")
        .slice((e ?? 0) * 2, (r ?? t.length) * 2)}`;
      return i && I9(s, e, r), s;
    }
    class _9 extends Ne {
      constructor({ offset: e }) {
        super(`Offset \`${e}\` cannot be negative.`, {
          name: "NegativeOffsetError",
        });
      }
    }
    class nY extends Ne {
      constructor({ length: e, position: r }) {
        super(`Position \`${r}\` is out of bounds (\`0 < position < ${e}\`).`, {
          name: "PositionOutOfBoundsError",
        });
      }
    }
    class oY extends Ne {
      constructor({ count: e, limit: r }) {
        super(
          `Recursive read limit of \`${r}\` exceeded (recursive read count: \`${e}\`).`,
          { name: "RecursiveReadLimitExceededError" }
        );
      }
    }
    const aY = {
      bytes: new Uint8Array(),
      dataView: new DataView(new ArrayBuffer(0)),
      position: 0,
      positionReadCount: new Map(),
      recursiveReadCount: 0,
      recursiveReadLimit: Number.POSITIVE_INFINITY,
      assertReadLimit() {
        if (this.recursiveReadCount >= this.recursiveReadLimit)
          throw new oY({
            count: this.recursiveReadCount + 1,
            limit: this.recursiveReadLimit,
          });
      },
      assertPosition(t) {
        if (t < 0 || t > this.bytes.length - 1)
          throw new nY({ length: this.bytes.length, position: t });
      },
      decrementPosition(t) {
        if (t < 0) throw new _9({ offset: t });
        const e = this.position - t;
        this.assertPosition(e), (this.position = e);
      },
      getReadCount(t) {
        return this.positionReadCount.get(t || this.position) || 0;
      },
      incrementPosition(t) {
        if (t < 0) throw new _9({ offset: t });
        const e = this.position + t;
        this.assertPosition(e), (this.position = e);
      },
      inspectByte(t) {
        const e = t ?? this.position;
        return this.assertPosition(e), this.bytes[e];
      },
      inspectBytes(t, e) {
        const r = e ?? this.position;
        return this.assertPosition(r + t - 1), this.bytes.subarray(r, r + t);
      },
      inspectUint8(t) {
        const e = t ?? this.position;
        return this.assertPosition(e), this.bytes[e];
      },
      inspectUint16(t) {
        const e = t ?? this.position;
        return this.assertPosition(e + 1), this.dataView.getUint16(e);
      },
      inspectUint24(t) {
        const e = t ?? this.position;
        return (
          this.assertPosition(e + 2),
          (this.dataView.getUint16(e) << 8) + this.dataView.getUint8(e + 2)
        );
      },
      inspectUint32(t) {
        const e = t ?? this.position;
        return this.assertPosition(e + 3), this.dataView.getUint32(e);
      },
      pushByte(t) {
        this.assertPosition(this.position),
          (this.bytes[this.position] = t),
          this.position++;
      },
      pushBytes(t) {
        this.assertPosition(this.position + t.length - 1),
          this.bytes.set(t, this.position),
          (this.position += t.length);
      },
      pushUint8(t) {
        this.assertPosition(this.position),
          (this.bytes[this.position] = t),
          this.position++;
      },
      pushUint16(t) {
        this.assertPosition(this.position + 1),
          this.dataView.setUint16(this.position, t),
          (this.position += 2);
      },
      pushUint24(t) {
        this.assertPosition(this.position + 2),
          this.dataView.setUint16(this.position, t >> 8),
          this.dataView.setUint8(this.position + 2, t & 255),
          (this.position += 3);
      },
      pushUint32(t) {
        this.assertPosition(this.position + 3),
          this.dataView.setUint32(this.position, t),
          (this.position += 4);
      },
      readByte() {
        this.assertReadLimit(), this._touch();
        const t = this.inspectByte();
        return this.position++, t;
      },
      readBytes(t, e) {
        this.assertReadLimit(), this._touch();
        const r = this.inspectBytes(t);
        return (this.position += e ?? t), r;
      },
      readUint8() {
        this.assertReadLimit(), this._touch();
        const t = this.inspectUint8();
        return (this.position += 1), t;
      },
      readUint16() {
        this.assertReadLimit(), this._touch();
        const t = this.inspectUint16();
        return (this.position += 2), t;
      },
      readUint24() {
        this.assertReadLimit(), this._touch();
        const t = this.inspectUint24();
        return (this.position += 3), t;
      },
      readUint32() {
        this.assertReadLimit(), this._touch();
        const t = this.inspectUint32();
        return (this.position += 4), t;
      },
      get remaining() {
        return this.bytes.length - this.position;
      },
      setPosition(t) {
        const e = this.position;
        return (
          this.assertPosition(t), (this.position = t), () => (this.position = e)
        );
      },
      _touch() {
        if (this.recursiveReadLimit === Number.POSITIVE_INFINITY) return;
        const t = this.getReadCount();
        this.positionReadCount.set(this.position, t + 1),
          t > 0 && this.recursiveReadCount++;
      },
    };
    function A9(t, { recursiveReadLimit: e = 8192 } = {}) {
      const r = Object.create(aY);
      return (
        (r.bytes = t),
        (r.dataView = new DataView(t.buffer, t.byteOffset, t.byteLength)),
        (r.positionReadCount = new Map()),
        (r.recursiveReadLimit = e),
        r
      );
    }
    const aa = (t, e, r) =>
        JSON.stringify(
          t,
          (i, s) => {
            const n = typeof s == "bigint" ? s.toString() : s;
            return typeof e == "function" ? e(i, n) : n;
          },
          r
        ),
      cY = { ether: -9, wei: 9 };
    function S9(t, e) {
      let r = t.toString();
      const i = r.startsWith("-");
      i && (r = r.slice(1)), (r = r.padStart(e, "0"));
      let [s, n] = [r.slice(0, r.length - e), r.slice(r.length - e)];
      return (
        (n = n.replace(/(0+)$/, "")),
        `${i ? "-" : ""}${s || "0"}${n ? `.${n}` : ""}`
      );
    }
    function mm(t, e = "wei") {
      return S9(t, cY[e]);
    }
    function lY(t) {
      const e = Object.entries(t)
          .map(([i, s]) => (s === void 0 || s === !1 ? null : [i, s]))
          .filter(Boolean),
        r = e.reduce((i, [s]) => Math.max(i, s.length), 0);
      return e.map(([i, s]) => `  ${`${i}:`.padEnd(r + 1)}  ${s}`).join(`
`);
    }
    class uY extends Ne {
      constructor({ v: e }) {
        super(`Invalid \`v\` value "${e}". Expected 27 or 28.`, {
          name: "InvalidLegacyVError",
        });
      }
    }
    class hY extends Ne {
      constructor({ transaction: e }) {
        super("Cannot infer a transaction type from provided transaction.", {
          metaMessages: [
            "Provided Transaction:",
            "{",
            lY(e),
            "}",
            "",
            "To infer the type, either provide:",
            "- a `type` to the Transaction, or",
            "- an EIP-1559 Transaction with `maxFeePerGas`, or",
            "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
            "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
            "- an EIP-7702 Transaction with `authorizationList`, or",
            "- a Legacy Transaction with `gasPrice`",
          ],
          name: "InvalidSerializableTransactionError",
        });
      }
    }
    class dY extends Ne {
      constructor({ storageKey: e }) {
        super(
          `Size for storage key "${e}" is invalid. Expected 32 bytes. Got ${Math.floor(
            (e.length - 2) / 2
          )} bytes.`,
          { name: "InvalidStorageKeySizeError" }
        );
      }
    }
    const ym = (t) => t;
    class nh extends Ne {
      constructor({
        body: e,
        cause: r,
        details: i,
        headers: s,
        status: n,
        url: o,
      }) {
        super("HTTP request failed.", {
          cause: r,
          details: i,
          metaMessages: [
            n && `Status: ${n}`,
            `URL: ${ym(o)}`,
            e && `Request body: ${aa(e)}`,
          ].filter(Boolean),
          name: "HttpRequestError",
        }),
          Object.defineProperty(this, "body", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "headers", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "status", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "url", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          (this.body = e),
          (this.headers = s),
          (this.status = n),
          (this.url = o);
      }
    }
    class P9 extends Ne {
      constructor({ body: e, error: r, url: i }) {
        super("RPC Request failed.", {
          cause: r,
          details: r.message,
          metaMessages: [`URL: ${ym(i)}`, `Request body: ${aa(e)}`],
          name: "RpcRequestError",
        }),
          Object.defineProperty(this, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "data", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          (this.code = r.code),
          (this.data = r.data);
      }
    }
    class O9 extends Ne {
      constructor({ body: e, url: r }) {
        super("The request took too long to respond.", {
          details: "The request timed out.",
          metaMessages: [`URL: ${ym(r)}`, `Request body: ${aa(e)}`],
          name: "TimeoutError",
        });
      }
    }
    const pY = -1;
    class Yr extends Ne {
      constructor(
        e,
        { code: r, docsPath: i, metaMessages: s, name: n, shortMessage: o }
      ) {
        super(o, {
          cause: e,
          docsPath: i,
          metaMessages: s || e?.metaMessages,
          name: n || "RpcError",
        }),
          Object.defineProperty(this, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          (this.name = n || e.name),
          (this.code = e instanceof P9 ? e.code : r ?? pY);
      }
    }
    class yi extends Yr {
      constructor(e, r) {
        super(e, r),
          Object.defineProperty(this, "data", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          (this.data = r.data);
      }
    }
    class oh extends Yr {
      constructor(e) {
        super(e, {
          code: oh.code,
          name: "ParseRpcError",
          shortMessage:
            "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.",
        });
      }
    }
    Object.defineProperty(oh, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: -32700,
    });
    class ah extends Yr {
      constructor(e) {
        super(e, {
          code: ah.code,
          name: "InvalidRequestRpcError",
          shortMessage: "JSON is not a valid request object.",
        });
      }
    }
    Object.defineProperty(ah, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: -32600,
    });
    class ch extends Yr {
      constructor(e, { method: r } = {}) {
        super(e, {
          code: ch.code,
          name: "MethodNotFoundRpcError",
          shortMessage: `The method${
            r ? ` "${r}"` : ""
          } does not exist / is not available.`,
        });
      }
    }
    Object.defineProperty(ch, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: -32601,
    });
    class lh extends Yr {
      constructor(e) {
        super(e, {
          code: lh.code,
          name: "InvalidParamsRpcError",
          shortMessage: [
            "Invalid parameters were provided to the RPC method.",
            "Double check you have provided the correct parameters.",
          ].join(`
`),
        });
      }
    }
    Object.defineProperty(lh, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: -32602,
    });
    class il extends Yr {
      constructor(e) {
        super(e, {
          code: il.code,
          name: "InternalRpcError",
          shortMessage: "An internal error was received.",
        });
      }
    }
    Object.defineProperty(il, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: -32603,
    });
    class uh extends Yr {
      constructor(e) {
        super(e, {
          code: uh.code,
          name: "InvalidInputRpcError",
          shortMessage: [
            "Missing or invalid parameters.",
            "Double check you have provided the correct parameters.",
          ].join(`
`),
        });
      }
    }
    Object.defineProperty(uh, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: -32e3,
    });
    class hh extends Yr {
      constructor(e) {
        super(e, {
          code: hh.code,
          name: "ResourceNotFoundRpcError",
          shortMessage: "Requested resource not found.",
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ResourceNotFoundRpcError",
          });
      }
    }
    Object.defineProperty(hh, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: -32001,
    });
    class dh extends Yr {
      constructor(e) {
        super(e, {
          code: dh.code,
          name: "ResourceUnavailableRpcError",
          shortMessage: "Requested resource not available.",
        });
      }
    }
    Object.defineProperty(dh, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: -32002,
    });
    class sl extends Yr {
      constructor(e) {
        super(e, {
          code: sl.code,
          name: "TransactionRejectedRpcError",
          shortMessage: "Transaction creation failed.",
        });
      }
    }
    Object.defineProperty(sl, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: -32003,
    });
    class ca extends Yr {
      constructor(e, { method: r } = {}) {
        super(e, {
          code: ca.code,
          name: "MethodNotSupportedRpcError",
          shortMessage: `Method${r ? ` "${r}"` : ""} is not supported.`,
        });
      }
    }
    Object.defineProperty(ca, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: -32004,
    });
    class nl extends Yr {
      constructor(e) {
        super(e, {
          code: nl.code,
          name: "LimitExceededRpcError",
          shortMessage: "Request exceeds defined limit.",
        });
      }
    }
    Object.defineProperty(nl, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: -32005,
    });
    class ph extends Yr {
      constructor(e) {
        super(e, {
          code: ph.code,
          name: "JsonRpcVersionUnsupportedError",
          shortMessage: "Version of JSON-RPC protocol is not supported.",
        });
      }
    }
    Object.defineProperty(ph, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: -32006,
    });
    class la extends yi {
      constructor(e) {
        super(e, {
          code: la.code,
          name: "UserRejectedRequestError",
          shortMessage: "User rejected the request.",
        });
      }
    }
    Object.defineProperty(la, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 4001,
    });
    class fh extends yi {
      constructor(e) {
        super(e, {
          code: fh.code,
          name: "UnauthorizedProviderError",
          shortMessage:
            "The requested method and/or account has not been authorized by the user.",
        });
      }
    }
    Object.defineProperty(fh, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 4100,
    });
    class gh extends yi {
      constructor(e, { method: r } = {}) {
        super(e, {
          code: gh.code,
          name: "UnsupportedProviderMethodError",
          shortMessage: `The Provider does not support the requested method${
            r ? ` " ${r}"` : ""
          }.`,
        });
      }
    }
    Object.defineProperty(gh, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 4200,
    });
    class wh extends yi {
      constructor(e) {
        super(e, {
          code: wh.code,
          name: "ProviderDisconnectedError",
          shortMessage: "The Provider is disconnected from all chains.",
        });
      }
    }
    Object.defineProperty(wh, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 4900,
    });
    class mh extends yi {
      constructor(e) {
        super(e, {
          code: mh.code,
          name: "ChainDisconnectedError",
          shortMessage: "The Provider is not connected to the requested chain.",
        });
      }
    }
    Object.defineProperty(mh, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 4901,
    });
    class yh extends yi {
      constructor(e) {
        super(e, {
          code: yh.code,
          name: "SwitchChainError",
          shortMessage: "An error occurred when attempting to switch chain.",
        });
      }
    }
    Object.defineProperty(yh, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 4902,
    });
    class bh extends yi {
      constructor(e) {
        super(e, {
          code: bh.code,
          name: "UnsupportedNonOptionalCapabilityError",
          shortMessage:
            "This Wallet does not support a capability that was not marked as optional.",
        });
      }
    }
    Object.defineProperty(bh, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 5700,
    });
    class vh extends yi {
      constructor(e) {
        super(e, {
          code: vh.code,
          name: "UnsupportedChainIdError",
          shortMessage: "This Wallet does not support the requested chain ID.",
        });
      }
    }
    Object.defineProperty(vh, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 5710,
    });
    class Eh extends yi {
      constructor(e) {
        super(e, {
          code: Eh.code,
          name: "DuplicateIdError",
          shortMessage: "There is already a bundle submitted with this ID.",
        });
      }
    }
    Object.defineProperty(Eh, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 5720,
    });
    class Ch extends yi {
      constructor(e) {
        super(e, {
          code: Ch.code,
          name: "UnknownBundleIdError",
          shortMessage: "This bundle id is unknown / has not been submitted",
        });
      }
    }
    Object.defineProperty(Ch, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 5730,
    });
    class xh extends yi {
      constructor(e) {
        super(e, {
          code: xh.code,
          name: "BundleTooLargeError",
          shortMessage:
            "The call bundle is too large for the Wallet to process.",
        });
      }
    }
    Object.defineProperty(xh, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 5740,
    });
    class Ih extends yi {
      constructor(e) {
        super(e, {
          code: Ih.code,
          name: "AtomicReadyWalletRejectedUpgradeError",
          shortMessage:
            "The Wallet can support atomicity after an upgrade, but the user rejected the upgrade.",
        });
      }
    }
    Object.defineProperty(Ih, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 5750,
    });
    class _h extends yi {
      constructor(e) {
        super(e, {
          code: _h.code,
          name: "AtomicityNotSupportedError",
          shortMessage:
            "The wallet does not support atomic execution but the request requires it.",
        });
      }
    }
    Object.defineProperty(_h, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 5760,
    });
    class fY extends Yr {
      constructor(e) {
        super(e, {
          name: "UnknownRpcError",
          shortMessage: "An unknown RPC error occurred.",
        });
      }
    }
    function ua(t, e = "hex") {
      const r = N9(t),
        i = A9(new Uint8Array(r.length));
      return r.encode(i), e === "hex" ? gn(i.bytes) : i.bytes;
    }
    function N9(t) {
      return Array.isArray(t) ? gY(t.map((e) => N9(e))) : wY(t);
    }
    function gY(t) {
      const e = t.reduce((i, s) => i + s.length, 0),
        r = T9(e);
      return {
        length: e <= 55 ? 1 + e : 1 + r + e,
        encode(i) {
          e <= 55
            ? i.pushByte(192 + e)
            : (i.pushByte(247 + r),
              r === 1
                ? i.pushUint8(e)
                : r === 2
                ? i.pushUint16(e)
                : r === 3
                ? i.pushUint24(e)
                : i.pushUint32(e));
          for (const { encode: s } of t) s(i);
        },
      };
    }
    function wY(t) {
      const e = typeof t == "string" ? oa(t) : t,
        r = T9(e.length);
      return {
        length:
          e.length === 1 && e[0] < 128
            ? 1
            : e.length <= 55
            ? 1 + e.length
            : 1 + r + e.length,
        encode(i) {
          e.length === 1 && e[0] < 128
            ? i.pushBytes(e)
            : e.length <= 55
            ? (i.pushByte(128 + e.length), i.pushBytes(e))
            : (i.pushByte(183 + r),
              r === 1
                ? i.pushUint8(e.length)
                : r === 2
                ? i.pushUint16(e.length)
                : r === 3
                ? i.pushUint24(e.length)
                : i.pushUint32(e.length),
              i.pushBytes(e));
        },
      };
    }
    function T9(t) {
      if (t < 2 ** 8) return 1;
      if (t < 2 ** 16) return 2;
      if (t < 2 ** 24) return 3;
      if (t < 2 ** 32) return 4;
      throw new Ne("Length is too large.");
    }
    class bm extends Ne {
      constructor({ cause: e, message: r } = {}) {
        const i = r
          ?.replace("execution reverted: ", "")
          ?.replace("execution reverted", "");
        super(
          `Execution reverted ${
            i ? `with reason: ${i}` : "for an unknown reason"
          }.`,
          { cause: e, name: "ExecutionRevertedError" }
        );
      }
    }
    Object.defineProperty(bm, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 3,
    }),
      Object.defineProperty(bm, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /execution reverted/,
      });
    class Ah extends Ne {
      constructor({ cause: e, maxFeePerGas: r } = {}) {
        super(
          `The fee cap (\`maxFeePerGas\`${
            r ? ` = ${mm(r)} gwei` : ""
          }) cannot be higher than the maximum allowed value (2^256-1).`,
          { cause: e, name: "FeeCapTooHighError" }
        );
      }
    }
    Object.defineProperty(Ah, "nodeMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value:
        /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/,
    });
    class vm extends Ne {
      constructor({ cause: e, maxPriorityFeePerGas: r, maxFeePerGas: i } = {}) {
        super(
          [
            `The provided tip (\`maxPriorityFeePerGas\`${
              r ? ` = ${mm(r)} gwei` : ""
            }) cannot be higher than the fee cap (\`maxFeePerGas\`${
              i ? ` = ${mm(i)} gwei` : ""
            }).`,
          ].join(`
`),
          { cause: e, name: "TipAboveFeeCapError" }
        );
      }
    }
    Object.defineProperty(vm, "nodeMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value:
        /max priority fee per gas higher than max fee per gas|tip higher than fee cap/,
    });
    function yf(t, e) {
      return ({ exclude: r, format: i }) => ({
        exclude: r,
        format: (s) => {
          const n = e(s);
          if (r) for (const o of r) delete n[o];
          return { ...n, ...i(s) };
        },
        type: t,
      });
    }
    const mY = {
      legacy: "0x0",
      eip2930: "0x1",
      eip1559: "0x2",
      eip4844: "0x3",
      eip7702: "0x4",
    };
    function yY(t) {
      const e = {};
      return (
        typeof t.authorizationList < "u" &&
          (e.authorizationList = vY(t.authorizationList)),
        typeof t.accessList < "u" && (e.accessList = t.accessList),
        typeof t.blobVersionedHashes < "u" &&
          (e.blobVersionedHashes = t.blobVersionedHashes),
        typeof t.blobs < "u" &&
          (typeof t.blobs[0] != "string"
            ? (e.blobs = t.blobs.map((r) => gn(r)))
            : (e.blobs = t.blobs)),
        typeof t.data < "u" && (e.data = t.data),
        typeof t.from < "u" && (e.from = t.from),
        typeof t.gas < "u" && (e.gas = Lr(t.gas)),
        typeof t.gasPrice < "u" && (e.gasPrice = Lr(t.gasPrice)),
        typeof t.maxFeePerBlobGas < "u" &&
          (e.maxFeePerBlobGas = Lr(t.maxFeePerBlobGas)),
        typeof t.maxFeePerGas < "u" && (e.maxFeePerGas = Lr(t.maxFeePerGas)),
        typeof t.maxPriorityFeePerGas < "u" &&
          (e.maxPriorityFeePerGas = Lr(t.maxPriorityFeePerGas)),
        typeof t.nonce < "u" && (e.nonce = Lr(t.nonce)),
        typeof t.to < "u" && (e.to = t.to),
        typeof t.type < "u" && (e.type = mY[t.type]),
        typeof t.value < "u" && (e.value = Lr(t.value)),
        e
      );
    }
    const bY = yf("transactionRequest", yY);
    function vY(t) {
      return t.map((e) => ({
        address: e.address,
        r: e.r ? Lr(BigInt(e.r)) : e.r,
        s: e.s ? Lr(BigInt(e.s)) : e.s,
        chainId: Lr(e.chainId),
        nonce: Lr(e.nonce),
        ...(typeof e.yParity < "u" ? { yParity: Lr(e.yParity) } : {}),
        ...(typeof e.v < "u" && typeof e.yParity > "u" ? { v: Lr(e.v) } : {}),
      }));
    }
    const bf = 2n ** 256n - 1n,
      k9 = {
        "0x0": "legacy",
        "0x1": "eip2930",
        "0x2": "eip1559",
        "0x3": "eip4844",
        "0x4": "eip7702",
      };
    function vf(t) {
      const e = {
        ...t,
        blockHash: t.blockHash ? t.blockHash : null,
        blockNumber: t.blockNumber ? BigInt(t.blockNumber) : null,
        chainId: t.chainId ? wf(t.chainId) : void 0,
        gas: t.gas ? BigInt(t.gas) : void 0,
        gasPrice: t.gasPrice ? BigInt(t.gasPrice) : void 0,
        maxFeePerBlobGas: t.maxFeePerBlobGas
          ? BigInt(t.maxFeePerBlobGas)
          : void 0,
        maxFeePerGas: t.maxFeePerGas ? BigInt(t.maxFeePerGas) : void 0,
        maxPriorityFeePerGas: t.maxPriorityFeePerGas
          ? BigInt(t.maxPriorityFeePerGas)
          : void 0,
        nonce: t.nonce ? wf(t.nonce) : void 0,
        to: t.to ? t.to : null,
        transactionIndex: t.transactionIndex
          ? Number(t.transactionIndex)
          : null,
        type: t.type ? k9[t.type] : void 0,
        typeHex: t.type ? t.type : void 0,
        value: t.value ? BigInt(t.value) : void 0,
        v: t.v ? BigInt(t.v) : void 0,
      };
      return (
        t.authorizationList && (e.authorizationList = EY(t.authorizationList)),
        (e.yParity = (() => {
          if (t.yParity) return Number(t.yParity);
          if (typeof e.v == "bigint") {
            if (e.v === 0n || e.v === 27n) return 0;
            if (e.v === 1n || e.v === 28n) return 1;
            if (e.v >= 35n) return e.v % 2n === 0n ? 1 : 0;
          }
        })()),
        e.type === "legacy" &&
          (delete e.accessList,
          delete e.maxFeePerBlobGas,
          delete e.maxFeePerGas,
          delete e.maxPriorityFeePerGas,
          delete e.yParity),
        e.type === "eip2930" &&
          (delete e.maxFeePerBlobGas,
          delete e.maxFeePerGas,
          delete e.maxPriorityFeePerGas),
        e.type === "eip1559" && delete e.maxFeePerBlobGas,
        e
      );
    }
    const R9 = yf("transaction", vf);
    function EY(t) {
      return t.map((e) => ({
        address: e.address,
        chainId: Number(e.chainId),
        nonce: Number(e.nonce),
        r: e.r,
        s: e.s,
        yParity: Number(e.yParity),
      }));
    }
    function CY(t) {
      const e = (t.transactions ?? []).map((r) =>
        typeof r == "string" ? r : vf(r)
      );
      return {
        ...t,
        baseFeePerGas: t.baseFeePerGas ? BigInt(t.baseFeePerGas) : null,
        blobGasUsed: t.blobGasUsed ? BigInt(t.blobGasUsed) : void 0,
        difficulty: t.difficulty ? BigInt(t.difficulty) : void 0,
        excessBlobGas: t.excessBlobGas ? BigInt(t.excessBlobGas) : void 0,
        gasLimit: t.gasLimit ? BigInt(t.gasLimit) : void 0,
        gasUsed: t.gasUsed ? BigInt(t.gasUsed) : void 0,
        hash: t.hash ? t.hash : null,
        logsBloom: t.logsBloom ? t.logsBloom : null,
        nonce: t.nonce ? t.nonce : null,
        number: t.number ? BigInt(t.number) : null,
        size: t.size ? BigInt(t.size) : void 0,
        timestamp: t.timestamp ? BigInt(t.timestamp) : void 0,
        transactions: e,
        totalDifficulty: t.totalDifficulty ? BigInt(t.totalDifficulty) : null,
      };
    }
    const $9 = yf("block", CY);
    function F9(t) {
      const { kzg: e } = t,
        r = t.to ?? (typeof t.blobs[0] == "string" ? "hex" : "bytes"),
        i = typeof t.blobs[0] == "string" ? t.blobs.map((n) => oa(n)) : t.blobs,
        s = [];
      for (const n of i) s.push(Uint8Array.from(e.blobToKzgCommitment(n)));
      return r === "bytes" ? s : s.map((n) => gn(n));
    }
    function B9(t) {
      const { kzg: e } = t,
        r = t.to ?? (typeof t.blobs[0] == "string" ? "hex" : "bytes"),
        i = typeof t.blobs[0] == "string" ? t.blobs.map((o) => oa(o)) : t.blobs,
        s =
          typeof t.commitments[0] == "string"
            ? t.commitments.map((o) => oa(o))
            : t.commitments,
        n = [];
      for (let o = 0; o < i.length; o++) {
        const a = i[o],
          c = s[o];
        n.push(Uint8Array.from(e.computeBlobKzgProof(a, c)));
      }
      return r === "bytes" ? n : n.map((o) => gn(o));
    }
    function xY(t, e) {
      const r = e || "hex",
        i = nu(sh(t, { strict: !1 }) ? v9(t) : t);
      return r === "bytes" ? i : ye(i);
    }
    function IY(t) {
      const { commitment: e, version: r = 1 } = t,
        i = t.to ?? (typeof e == "string" ? "hex" : "bytes"),
        s = xY(e, "bytes");
      return s.set([r], 0), i === "bytes" ? s : gn(s);
    }
    function _Y(t) {
      const { commitments: e, version: r } = t,
        i = t.to ?? (typeof e[0] == "string" ? "hex" : "bytes"),
        s = [];
      for (const n of e) s.push(IY({ commitment: n, to: i, version: r }));
      return s;
    }
    const L9 = 6,
      U9 = 32,
      Em = 4096,
      D9 = U9 * Em,
      j9 = D9 * L9 - 1 - 1 * Em * L9,
      M9 = 1;
    class AY extends Ne {
      constructor({ maxSize: e, size: r }) {
        super("Blob size is too large.", {
          metaMessages: [`Max: ${e} bytes`, `Given: ${r} bytes`],
          name: "BlobSizeTooLargeError",
        });
      }
    }
    class z9 extends Ne {
      constructor() {
        super("Blob data must not be empty.", { name: "EmptyBlobError" });
      }
    }
    class SY extends Ne {
      constructor({ hash: e, size: r }) {
        super(`Versioned hash "${e}" size is invalid.`, {
          metaMessages: ["Expected: 32", `Received: ${r}`],
          name: "InvalidVersionedHashSizeError",
        });
      }
    }
    class PY extends Ne {
      constructor({ hash: e, version: r }) {
        super(`Versioned hash "${e}" version is invalid.`, {
          metaMessages: [`Expected: ${M9}`, `Received: ${r}`],
          name: "InvalidVersionedHashVersionError",
        });
      }
    }
    function OY(t) {
      const e = t.to ?? (typeof t.data == "string" ? "hex" : "bytes"),
        r = typeof t.data == "string" ? oa(t.data) : t.data,
        i = co(r);
      if (!i) throw new z9();
      if (i > j9) throw new AY({ maxSize: j9, size: i });
      const s = [];
      let n = !0,
        o = 0;
      for (; n; ) {
        const a = A9(new Uint8Array(D9));
        let c = 0;
        for (; c < Em; ) {
          const l = r.slice(o, o + (U9 - 1));
          if ((a.pushByte(0), a.pushBytes(l), l.length < 31)) {
            a.pushByte(128), (n = !1);
            break;
          }
          c++, (o += 31);
        }
        s.push(a);
      }
      return e === "bytes" ? s.map((a) => a.bytes) : s.map((a) => gn(a.bytes));
    }
    function NY(t) {
      const { data: e, kzg: r, to: i } = t,
        s = t.blobs ?? OY({ data: e, to: i }),
        n = t.commitments ?? F9({ blobs: s, kzg: r, to: i }),
        o = t.proofs ?? B9({ blobs: s, commitments: n, kzg: r, to: i }),
        a = [];
      for (let c = 0; c < s.length; c++)
        a.push({ blob: s[c], commitment: n[c], proof: o[c] });
      return a;
    }
    function TY(t) {
      if (t.type) return t.type;
      if (typeof t.authorizationList < "u") return "eip7702";
      if (
        typeof t.blobs < "u" ||
        typeof t.blobVersionedHashes < "u" ||
        typeof t.maxFeePerBlobGas < "u" ||
        typeof t.sidecars < "u"
      )
        return "eip4844";
      if (typeof t.maxFeePerGas < "u" || typeof t.maxPriorityFeePerGas < "u")
        return "eip1559";
      if (typeof t.gasPrice < "u")
        return typeof t.accessList < "u" ? "eip2930" : "legacy";
      throw new hY({ transaction: t });
    }
    function kY(t, { args: e, eventName: r } = {}) {
      return {
        ...t,
        blockHash: t.blockHash ? t.blockHash : null,
        blockNumber: t.blockNumber ? BigInt(t.blockNumber) : null,
        logIndex: t.logIndex ? Number(t.logIndex) : null,
        transactionHash: t.transactionHash ? t.transactionHash : null,
        transactionIndex: t.transactionIndex
          ? Number(t.transactionIndex)
          : null,
        ...(r ? { args: e, eventName: r } : {}),
      };
    }
    class Sh extends Ne {
      constructor({ chainId: e }) {
        super(
          typeof e == "number"
            ? `Chain ID "${e}" is invalid.`
            : "Chain ID is invalid.",
          { name: "InvalidChainIdError" }
        );
      }
    }
    function RY() {
      let t = () => {},
        e = () => {};
      return {
        promise: new Promise((r, i) => {
          (t = r), (e = i);
        }),
        resolve: t,
        reject: e,
      };
    }
    const Cm = new Map();
    function $Y({ fn: t, id: e, shouldSplitBatch: r, wait: i = 0, sort: s }) {
      const n = async () => {
          const u = c();
          o();
          const h = u.map(({ args: d }) => d);
          h.length !== 0 &&
            t(h)
              .then((d) => {
                s && Array.isArray(d) && d.sort(s);
                for (let g = 0; g < u.length; g++) {
                  const { resolve: p } = u[g];
                  p?.([d[g], d]);
                }
              })
              .catch((d) => {
                for (let g = 0; g < u.length; g++) {
                  const { reject: p } = u[g];
                  p?.(d);
                }
              });
        },
        o = () => Cm.delete(e),
        a = () => c().map(({ args: u }) => u),
        c = () => Cm.get(e) || [],
        l = (u) => Cm.set(e, [...c(), u]);
      return {
        flush: o,
        async schedule(u) {
          const { promise: h, resolve: d, reject: g } = RY();
          return (
            r?.([...a(), u]) && n(),
            c().length > 0
              ? (l({ args: u, resolve: d, reject: g }), h)
              : (l({ args: u, resolve: d, reject: g }), setTimeout(n, i), h)
          );
        },
      };
    }
    async function q9(t) {
      return new Promise((e) => setTimeout(e, t));
    }
    new mf(128);
    const xm = 256;
    let Ef = xm,
      Cf;
    function FY(t = 11) {
      if (!Cf || Ef + t > xm * 2) {
        (Cf = ""), (Ef = 0);
        for (let e = 0; e < xm; e++)
          Cf += ((256 + Math.random() * 256) | 0).toString(16).substring(1);
      }
      return Cf.substring(Ef, Ef++ + t);
    }
    const xf = new mf(8192);
    function BY(t, { enabled: e = !0, id: r }) {
      if (!e || !r) return t();
      if (xf.get(r)) return xf.get(r);
      const i = t().finally(() => xf.delete(r));
      return xf.set(r, i), i;
    }
    function LY(
      t,
      { delay: e = 100, retryCount: r = 2, shouldRetry: i = () => !0 } = {}
    ) {
      return new Promise((s, n) => {
        const o = async ({ count: a = 0 } = {}) => {
          const c = async ({ error: l }) => {
            const u = typeof e == "function" ? e({ count: a, error: l }) : e;
            u && (await q9(u)), o({ count: a + 1 });
          };
          try {
            const l = await t();
            s(l);
          } catch (l) {
            if (a < r && (await i({ count: a, error: l })))
              return c({ error: l });
            n(l);
          }
        };
        o();
      });
    }
    function UY(t, e = {}) {
      return async (r, i = {}) => {
        const {
            dedupe: s = !1,
            methods: n,
            retryDelay: o = 150,
            retryCount: a = 3,
            uid: c,
          } = { ...e, ...i },
          { method: l } = r;
        if (n?.exclude?.includes(l))
          throw new ca(new Error("method not supported"), { method: l });
        if (n?.include && !n.include.includes(l))
          throw new ca(new Error("method not supported"), { method: l });
        const u = s ? b9(`${c}.${aa(r)}`) : void 0;
        return BY(
          () =>
            LY(
              async () => {
                try {
                  return await t(r);
                } catch (h) {
                  const d = h;
                  switch (d.code) {
                    case oh.code:
                      throw new oh(d);
                    case ah.code:
                      throw new ah(d);
                    case ch.code:
                      throw new ch(d, { method: r.method });
                    case lh.code:
                      throw new lh(d);
                    case il.code:
                      throw new il(d);
                    case uh.code:
                      throw new uh(d);
                    case hh.code:
                      throw new hh(d);
                    case dh.code:
                      throw new dh(d);
                    case sl.code:
                      throw new sl(d);
                    case ca.code:
                      throw new ca(d, { method: r.method });
                    case nl.code:
                      throw new nl(d);
                    case ph.code:
                      throw new ph(d);
                    case la.code:
                      throw new la(d);
                    case fh.code:
                      throw new fh(d);
                    case gh.code:
                      throw new gh(d);
                    case wh.code:
                      throw new wh(d);
                    case mh.code:
                      throw new mh(d);
                    case yh.code:
                      throw new yh(d);
                    case bh.code:
                      throw new bh(d);
                    case vh.code:
                      throw new vh(d);
                    case Eh.code:
                      throw new Eh(d);
                    case Ch.code:
                      throw new Ch(d);
                    case xh.code:
                      throw new xh(d);
                    case Ih.code:
                      throw new Ih(d);
                    case _h.code:
                      throw new _h(d);
                    case 5e3:
                      throw new la(d);
                    default:
                      throw h instanceof Ne ? h : new fY(d);
                  }
                }
              },
              {
                delay: ({ count: h, error: d }) => {
                  if (d && d instanceof nh) {
                    const g = d?.headers?.get("Retry-After");
                    if (g?.match(/\d/)) return Number.parseInt(g) * 1e3;
                  }
                  return ~~(1 << h) * o;
                },
                retryCount: a,
                shouldRetry: ({ error: h }) => DY(h),
              }
            ),
          { enabled: s, id: u }
        );
      };
    }
    function DY(t) {
      return "code" in t && typeof t.code == "number"
        ? t.code === -1 || t.code === nl.code || t.code === il.code
        : t instanceof nh && t.status
        ? t.status === 403 ||
          t.status === 408 ||
          t.status === 413 ||
          t.status === 429 ||
          t.status === 500 ||
          t.status === 502 ||
          t.status === 503 ||
          t.status === 504
        : !0;
    }
    function H9(
      {
        key: t,
        methods: e,
        name: r,
        request: i,
        retryCount: s = 3,
        retryDelay: n = 150,
        timeout: o,
        type: a,
      },
      c
    ) {
      const l = FY();
      return {
        config: {
          key: t,
          methods: e,
          name: r,
          request: i,
          retryCount: s,
          retryDelay: n,
          timeout: o,
          type: a,
        },
        request: UY(i, { methods: e, retryCount: s, retryDelay: n, uid: l }),
        value: c,
      };
    }
    function V9(t, e = {}) {
      const {
        key: r = "fallback",
        name: i = "Fallback",
        rank: s = !1,
        shouldThrow: n = jY,
        retryCount: o,
        retryDelay: a,
      } = e;
      return ({ chain: c, pollingInterval: l = 4e3, timeout: u, ...h }) => {
        let d = t,
          g = () => {};
        const p = H9(
          {
            key: r,
            name: i,
            async request({ method: w, params: f }) {
              let m;
              const y = async (E = 0) => {
                const C = d[E]({ ...h, chain: c, retryCount: 0, timeout: u });
                try {
                  const O = await C.request({ method: w, params: f });
                  return (
                    g({
                      method: w,
                      params: f,
                      response: O,
                      transport: C,
                      status: "success",
                    }),
                    O
                  );
                } catch (O) {
                  if (
                    (g({
                      error: O,
                      method: w,
                      params: f,
                      transport: C,
                      status: "error",
                    }),
                    n(O) ||
                      E === d.length - 1 ||
                      (m ??
                        (m = d.slice(E + 1).some((A) => {
                          const { include: P, exclude: N } =
                            A({ chain: c }).config.methods || {};
                          return P ? P.includes(w) : N ? !N.includes(w) : !0;
                        })),
                      !m))
                  )
                    throw O;
                  return y(E + 1);
                }
              };
              return y();
            },
            retryCount: o,
            retryDelay: a,
            type: "fallback",
          },
          {
            onResponse: (w) => (g = w),
            transports: d.map((w) => w({ chain: c, retryCount: 0 })),
          }
        );
        if (s) {
          const w = typeof s == "object" ? s : {};
          MY({
            chain: c,
            interval: w.interval ?? l,
            onTransports: (f) => (d = f),
            ping: w.ping,
            sampleCount: w.sampleCount,
            timeout: w.timeout,
            transports: d,
            weights: w.weights,
          });
        }
        return p;
      };
    }
    function jY(t) {
      return !!(
        "code" in t &&
        typeof t.code == "number" &&
        (t.code === sl.code ||
          t.code === la.code ||
          bm.nodeMessage.test(t.message) ||
          t.code === 5e3)
      );
    }
    function MY({
      chain: t,
      interval: e = 4e3,
      onTransports: r,
      ping: i,
      sampleCount: s = 10,
      timeout: n = 1e3,
      transports: o,
      weights: a = {},
    }) {
      const { stability: c = 0.7, latency: l = 0.3 } = a,
        u = [],
        h = async () => {
          const d = await Promise.all(
            o.map(async (w) => {
              const f = w({ chain: t, retryCount: 0, timeout: n }),
                m = Date.now();
              let y, E;
              try {
                await (i
                  ? i({ transport: f })
                  : f.request({ method: "net_listening" })),
                  (E = 1);
              } catch {
                E = 0;
              } finally {
                y = Date.now();
              }
              return { latency: y - m, success: E };
            })
          );
          u.push(d), u.length > s && u.shift();
          const g = Math.max(
              ...u.map((w) => Math.max(...w.map(({ latency: f }) => f)))
            ),
            p = o
              .map((w, f) => {
                const m = u.map((O) => O[f].latency),
                  y = 1 - m.reduce((O, A) => O + A, 0) / m.length / g,
                  E = u.map((O) => O[f].success),
                  C = E.reduce((O, A) => O + A, 0) / E.length;
                return C === 0 ? [0, f] : [l * y + c * C, f];
              })
              .sort((w, f) => f[0] - w[0]);
          r(p.map(([, w]) => o[w])), await q9(e), h();
        };
      h();
    }
    class zY extends Ne {
      constructor() {
        super(
          "No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.",
          { docsPath: "/docs/clients/intro", name: "UrlRequiredError" }
        );
      }
    }
    function qY(
      t,
      { errorInstance: e = new Error("timed out"), timeout: r, signal: i }
    ) {
      return new Promise((s, n) => {
        (async () => {
          let o;
          try {
            const a = new AbortController();
            r > 0 &&
              (o = setTimeout(() => {
                i ? a.abort() : n(e);
              }, r)),
              s(await t({ signal: a?.signal || null }));
          } catch (a) {
            a?.name === "AbortError" && n(e), n(a);
          } finally {
            clearTimeout(o);
          }
        })();
      });
    }
    function HY() {
      return {
        current: 0,
        take() {
          return this.current++;
        },
        reset() {
          this.current = 0;
        },
      };
    }
    const W9 = HY();
    function VY(t, e = {}) {
      return {
        async request(r) {
          const {
              body: i,
              onRequest: s = e.onRequest,
              onResponse: n = e.onResponse,
              timeout: o = e.timeout ?? 1e4,
            } = r,
            a = { ...(e.fetchOptions ?? {}), ...(r.fetchOptions ?? {}) },
            { headers: c, method: l, signal: u } = a;
          try {
            const h = await qY(
              async ({ signal: g }) => {
                const p = {
                    ...a,
                    body: Array.isArray(i)
                      ? aa(
                          i.map((m) => ({
                            jsonrpc: "2.0",
                            id: m.id ?? W9.take(),
                            ...m,
                          }))
                        )
                      : aa({ jsonrpc: "2.0", id: i.id ?? W9.take(), ...i }),
                    headers: { "Content-Type": "application/json", ...c },
                    method: l || "POST",
                    signal: u || (o > 0 ? g : null),
                  },
                  w = new Request(t, p),
                  f = (await s?.(w, p)) ?? { ...p, url: t };
                return await fetch(f.url ?? t, f);
              },
              {
                errorInstance: new O9({ body: i, url: t }),
                timeout: o,
                signal: !0,
              }
            );
            n && (await n(h));
            let d;
            if (h.headers.get("Content-Type")?.startsWith("application/json"))
              d = await h.json();
            else {
              d = await h.text();
              try {
                d = JSON.parse(d || "{}");
              } catch (g) {
                if (h.ok) throw g;
                d = { error: d };
              }
            }
            if (!h.ok)
              throw new nh({
                body: i,
                details: aa(d.error) || h.statusText,
                headers: h.headers,
                status: h.status,
                url: t,
              });
            return d;
          } catch (h) {
            throw h instanceof nh || h instanceof O9
              ? h
              : new nh({ body: i, cause: h, url: t });
          }
        },
      };
    }
    function If(t, e = {}) {
      const {
        batch: r,
        fetchOptions: i,
        key: s = "http",
        methods: n,
        name: o = "HTTP JSON-RPC",
        onFetchRequest: a,
        onFetchResponse: c,
        retryDelay: l,
        raw: u,
      } = e;
      return ({ chain: h, retryCount: d, timeout: g }) => {
        const { batchSize: p = 1e3, wait: w = 0 } =
            typeof r == "object" ? r : {},
          f = e.retryCount ?? d,
          m = g ?? e.timeout ?? 1e4,
          y = t || h?.rpcUrls.default.http[0];
        if (!y) throw new zY();
        const E = VY(y, {
          fetchOptions: i,
          onRequest: a,
          onResponse: c,
          timeout: m,
        });
        return H9(
          {
            key: s,
            methods: n,
            name: o,
            async request({ method: C, params: O }) {
              const A = { method: C, params: O },
                { schedule: P } = $Y({
                  id: y,
                  wait: w,
                  shouldSplitBatch(k) {
                    return k.length > p;
                  },
                  fn: (k) => E.request({ body: k }),
                  sort: (k, F) => k.id - F.id,
                }),
                N = async (k) => (r ? P(k) : [await E.request({ body: k })]),
                [{ error: x, result: $ }] = await N(A);
              if (u) return { error: x, result: $ };
              if (x) throw new P9({ body: A, error: x, url: y });
              return $;
            },
            retryCount: f,
            retryDelay: l,
            timeout: m,
            type: "http",
          },
          { fetchOptions: i, url: y }
        );
      };
    }
    function ss(t) {
      return { formatters: void 0, fees: void 0, serializers: void 0, ...t };
    }
    function WY(t) {
      const { authorizationList: e } = t;
      if (e)
        for (const r of e) {
          const { chainId: i } = r,
            s = r.address;
          if (!mn(s)) throw new lo({ address: s });
          if (i < 0) throw new Sh({ chainId: i });
        }
      Im(t);
    }
    function KY(t) {
      const { blobVersionedHashes: e } = t;
      if (e) {
        if (e.length === 0) throw new z9();
        for (const r of e) {
          const i = co(r),
            s = wf(rY(r, 0, 1));
          if (i !== 32) throw new SY({ hash: r, size: i });
          if (s !== M9) throw new PY({ hash: r, version: s });
        }
      }
      Im(t);
    }
    function Im(t) {
      const { chainId: e, maxPriorityFeePerGas: r, maxFeePerGas: i, to: s } = t;
      if (e <= 0) throw new Sh({ chainId: e });
      if (s && !mn(s)) throw new lo({ address: s });
      if (i && i > bf) throw new Ah({ maxFeePerGas: i });
      if (r && i && r > i)
        throw new vm({ maxFeePerGas: i, maxPriorityFeePerGas: r });
    }
    function GY(t) {
      const {
        chainId: e,
        maxPriorityFeePerGas: r,
        gasPrice: i,
        maxFeePerGas: s,
        to: n,
      } = t;
      if (e <= 0) throw new Sh({ chainId: e });
      if (n && !mn(n)) throw new lo({ address: n });
      if (r || s)
        throw new Ne(
          "`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute."
        );
      if (i && i > bf) throw new Ah({ maxFeePerGas: i });
    }
    function ZY(t) {
      const {
        chainId: e,
        maxPriorityFeePerGas: r,
        gasPrice: i,
        maxFeePerGas: s,
        to: n,
      } = t;
      if (n && !mn(n)) throw new lo({ address: n });
      if (typeof e < "u" && e <= 0) throw new Sh({ chainId: e });
      if (r || s)
        throw new Ne(
          "`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute."
        );
      if (i && i > bf) throw new Ah({ maxFeePerGas: i });
    }
    function Ph(t) {
      if (!t || t.length === 0) return [];
      const e = [];
      for (let r = 0; r < t.length; r++) {
        const { address: i, storageKeys: s } = t[r];
        for (let n = 0; n < s.length; n++)
          if (s[n].length - 2 !== 64) throw new dY({ storageKey: s[n] });
        if (!mn(i, { strict: !1 })) throw new lo({ address: i });
        e.push([i, s]);
      }
      return e;
    }
    function YY(t, e) {
      const r = TY(t);
      return r === "eip1559"
        ? QY(t, e)
        : r === "eip2930"
        ? eJ(t, e)
        : r === "eip4844"
        ? XY(t, e)
        : r === "eip7702"
        ? JY(t, e)
        : tJ(t, e);
    }
    function JY(t, e) {
      const {
        authorizationList: r,
        chainId: i,
        gas: s,
        nonce: n,
        to: o,
        value: a,
        maxFeePerGas: c,
        maxPriorityFeePerGas: l,
        accessList: u,
        data: h,
      } = t;
      WY(t);
      const d = Ph(u),
        g = rJ(r);
      return rl([
        "0x04",
        ua([
          ye(i),
          n ? ye(n) : "0x",
          l ? ye(l) : "0x",
          c ? ye(c) : "0x",
          s ? ye(s) : "0x",
          o ?? "0x",
          a ? ye(a) : "0x",
          h ?? "0x",
          d,
          g,
          ...ol(t, e),
        ]),
      ]);
    }
    function XY(t, e) {
      const {
        chainId: r,
        gas: i,
        nonce: s,
        to: n,
        value: o,
        maxFeePerBlobGas: a,
        maxFeePerGas: c,
        maxPriorityFeePerGas: l,
        accessList: u,
        data: h,
      } = t;
      KY(t);
      let d = t.blobVersionedHashes,
        g = t.sidecars;
      if (t.blobs && (typeof d > "u" || typeof g > "u")) {
        const E =
            typeof t.blobs[0] == "string" ? t.blobs : t.blobs.map((A) => gn(A)),
          C = t.kzg,
          O = F9({ blobs: E, kzg: C });
        if ((typeof d > "u" && (d = _Y({ commitments: O })), typeof g > "u")) {
          const A = B9({ blobs: E, commitments: O, kzg: C });
          g = NY({ blobs: E, commitments: O, proofs: A });
        }
      }
      const p = Ph(u),
        w = [
          ye(r),
          s ? ye(s) : "0x",
          l ? ye(l) : "0x",
          c ? ye(c) : "0x",
          i ? ye(i) : "0x",
          n ?? "0x",
          o ? ye(o) : "0x",
          h ?? "0x",
          p,
          a ? ye(a) : "0x",
          d ?? [],
          ...ol(t, e),
        ],
        f = [],
        m = [],
        y = [];
      if (g)
        for (let E = 0; E < g.length; E++) {
          const { blob: C, commitment: O, proof: A } = g[E];
          f.push(C), m.push(O), y.push(A);
        }
      return rl(["0x03", ua(g ? [w, f, m, y] : w)]);
    }
    function QY(t, e) {
      const {
        chainId: r,
        gas: i,
        nonce: s,
        to: n,
        value: o,
        maxFeePerGas: a,
        maxPriorityFeePerGas: c,
        accessList: l,
        data: u,
      } = t;
      Im(t);
      const h = Ph(l),
        d = [
          ye(r),
          s ? ye(s) : "0x",
          c ? ye(c) : "0x",
          a ? ye(a) : "0x",
          i ? ye(i) : "0x",
          n ?? "0x",
          o ? ye(o) : "0x",
          u ?? "0x",
          h,
          ...ol(t, e),
        ];
      return rl(["0x02", ua(d)]);
    }
    function eJ(t, e) {
      const {
        chainId: r,
        gas: i,
        data: s,
        nonce: n,
        to: o,
        value: a,
        accessList: c,
        gasPrice: l,
      } = t;
      GY(t);
      const u = Ph(c),
        h = [
          ye(r),
          n ? ye(n) : "0x",
          l ? ye(l) : "0x",
          i ? ye(i) : "0x",
          o ?? "0x",
          a ? ye(a) : "0x",
          s ?? "0x",
          u,
          ...ol(t, e),
        ];
      return rl(["0x01", ua(h)]);
    }
    function tJ(t, e) {
      const {
        chainId: r = 0,
        gas: i,
        data: s,
        nonce: n,
        to: o,
        value: a,
        gasPrice: c,
      } = t;
      ZY(t);
      let l = [
        n ? ye(n) : "0x",
        c ? ye(c) : "0x",
        i ? ye(i) : "0x",
        o ?? "0x",
        a ? ye(a) : "0x",
        s ?? "0x",
      ];
      if (e) {
        const u = (() => {
            if (e.v >= 35n)
              return (e.v - 35n) / 2n > 0 ? e.v : 27n + (e.v === 35n ? 0n : 1n);
            if (r > 0) return BigInt(r * 2) + BigInt(35n + e.v - 27n);
            const g = 27n + (e.v === 27n ? 0n : 1n);
            if (e.v !== g) throw new uY({ v: e.v });
            return g;
          })(),
          h = el(e.r),
          d = el(e.s);
        l = [...l, ye(u), h === "0x00" ? "0x" : h, d === "0x00" ? "0x" : d];
      } else r > 0 && (l = [...l, ye(r), "0x", "0x"]);
      return ua(l);
    }
    function ol(t, e) {
      const r = e ?? t,
        { v: i, yParity: s } = r;
      if (typeof r.r > "u") return [];
      if (typeof r.s > "u") return [];
      if (typeof i > "u" && typeof s > "u") return [];
      const n = el(r.r),
        o = el(r.s);
      return [
        typeof s == "number"
          ? s
            ? ye(1)
            : "0x"
          : i === 0n
          ? "0x"
          : i === 1n
          ? ye(1)
          : i === 27n
          ? "0x"
          : ye(1),
        n === "0x00" ? "0x" : n,
        o === "0x00" ? "0x" : o,
      ];
    }
    function rJ(t) {
      if (!t || t.length === 0) return [];
      const e = [];
      for (const r of t) {
        const { chainId: i, nonce: s, ...n } = r,
          o = r.address;
        e.push([i ? ye(i) : "0x", o, s ? ye(s) : "0x", ...ol({}, n)]);
      }
      return e;
    }
    const iJ = { "0x0": "reverted", "0x1": "success" };
    function sJ(t) {
      const e = {
        ...t,
        blockNumber: t.blockNumber ? BigInt(t.blockNumber) : null,
        contractAddress: t.contractAddress ? t.contractAddress : null,
        cumulativeGasUsed: t.cumulativeGasUsed
          ? BigInt(t.cumulativeGasUsed)
          : null,
        effectiveGasPrice: t.effectiveGasPrice
          ? BigInt(t.effectiveGasPrice)
          : null,
        gasUsed: t.gasUsed ? BigInt(t.gasUsed) : null,
        logs: t.logs ? t.logs.map((r) => kY(r)) : null,
        to: t.to ? t.to : null,
        transactionIndex: t.transactionIndex ? wf(t.transactionIndex) : null,
        status: t.status ? iJ[t.status] : null,
        type: t.type ? k9[t.type] || t.type : null,
      };
      return (
        t.blobGasPrice && (e.blobGasPrice = BigInt(t.blobGasPrice)),
        t.blobGasUsed && (e.blobGasUsed = BigInt(t.blobGasUsed)),
        e
      );
    }
    const nJ = yf("transactionReceipt", sJ),
      oJ = "0.1.1";
    function aJ() {
      return oJ;
    }
    class Ur extends Error {
      constructor(e, r = {}) {
        const i = (() => {
            if (r.cause instanceof Ur) {
              if (r.cause.details) return r.cause.details;
              if (r.cause.shortMessage) return r.cause.shortMessage;
            }
            return r.cause?.message ? r.cause.message : r.details;
          })(),
          s = (r.cause instanceof Ur && r.cause.docsPath) || r.docsPath,
          n = `https://oxlib.sh${s ?? ""}`,
          o = [
            e || "An error occurred.",
            ...(r.metaMessages ? ["", ...r.metaMessages] : []),
            ...(i || s
              ? ["", i ? `Details: ${i}` : void 0, s ? `See: ${n}` : void 0]
              : []),
          ].filter((a) => typeof a == "string").join(`
`);
        super(o, r.cause ? { cause: r.cause } : void 0),
          Object.defineProperty(this, "details", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "docs", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "docsPath", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "shortMessage", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "cause", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "BaseError",
          }),
          Object.defineProperty(this, "version", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: `ox@${aJ()}`,
          }),
          (this.cause = r.cause),
          (this.details = i),
          (this.docs = n),
          (this.docsPath = s),
          (this.shortMessage = e);
      }
      walk(e) {
        return K9(this, e);
      }
    }
    function K9(t, e) {
      return e?.(t)
        ? t
        : t && typeof t == "object" && "cause" in t && t.cause
        ? K9(t.cause, e)
        : e
        ? null
        : t;
    }
    function cJ(t, e) {
      if (Y9(t) > e) throw new wJ({ givenSize: Y9(t), maxSize: e });
    }
    const yn = { zero: 48, nine: 57, A: 65, F: 70, a: 97, f: 102 };
    function G9(t) {
      if (t >= yn.zero && t <= yn.nine) return t - yn.zero;
      if (t >= yn.A && t <= yn.F) return t - (yn.A - 10);
      if (t >= yn.a && t <= yn.f) return t - (yn.a - 10);
    }
    function lJ(t, e = {}) {
      const { dir: r, size: i = 32 } = e;
      if (i === 0) return t;
      if (t.length > i)
        throw new mJ({ size: t.length, targetSize: i, type: "Bytes" });
      const s = new Uint8Array(i);
      for (let n = 0; n < i; n++) {
        const o = r === "right";
        s[o ? n : i - n - 1] = t[o ? n : t.length - n - 1];
      }
      return s;
    }
    function _m(t, e) {
      if (Sm(t) > e) throw new IJ({ givenSize: Sm(t), maxSize: e });
    }
    function Z9(t, e = {}) {
      const { dir: r, size: i = 32 } = e;
      if (i === 0) return t;
      const s = t.replace("0x", "");
      if (s.length > i * 2)
        throw new _J({
          size: Math.ceil(s.length / 2),
          targetSize: i,
          type: "Hex",
        });
      return `0x${s[r === "right" ? "padEnd" : "padStart"](i * 2, "0")}`;
    }
    const uJ = new TextEncoder();
    function hJ(t) {
      return t instanceof Uint8Array ? t : typeof t == "string" ? pJ(t) : dJ(t);
    }
    function dJ(t) {
      return t instanceof Uint8Array ? t : new Uint8Array(t);
    }
    function pJ(t, e = {}) {
      const { size: r } = e;
      let i = t;
      r && (_m(t, r), (i = Am(t, r)));
      let s = i.slice(2);
      s.length % 2 && (s = `0${s}`);
      const n = s.length / 2,
        o = new Uint8Array(n);
      for (let a = 0, c = 0; a < n; a++) {
        const l = G9(s.charCodeAt(c++)),
          u = G9(s.charCodeAt(c++));
        if (l === void 0 || u === void 0)
          throw new Ur(
            `Invalid byte sequence ("${s[c - 2]}${s[c - 1]}" in "${s}").`
          );
        o[a] = l * 16 + u;
      }
      return o;
    }
    function fJ(t, e = {}) {
      const { size: r } = e,
        i = uJ.encode(t);
      return typeof r == "number" ? (cJ(i, r), gJ(i, r)) : i;
    }
    function gJ(t, e) {
      return lJ(t, { dir: "right", size: e });
    }
    function Y9(t) {
      return t.length;
    }
    class wJ extends Ur {
      constructor({ givenSize: e, maxSize: r }) {
        super(`Size cannot exceed \`${r}\` bytes. Given size: \`${e}\` bytes.`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Bytes.SizeOverflowError",
          });
      }
    }
    class mJ extends Ur {
      constructor({ size: e, targetSize: r, type: i }) {
        super(
          `${i.charAt(0).toUpperCase()}${i
            .slice(1)
            .toLowerCase()} size (\`${e}\`) exceeds padding size (\`${r}\`).`
        ),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Bytes.SizeExceedsPaddingSizeError",
          });
      }
    }
    const yJ = new TextEncoder(),
      bJ = Array.from({ length: 256 }, (t, e) =>
        e.toString(16).padStart(2, "0")
      );
    function J9(...t) {
      return `0x${t.reduce((e, r) => e + r.replace("0x", ""), "")}`;
    }
    function vJ(t, e = {}) {
      const r = `0x${Number(t)}`;
      return typeof e.size == "number" ? (_m(r, e.size), _f(r, e.size)) : r;
    }
    function X9(t, e = {}) {
      let r = "";
      for (let s = 0; s < t.length; s++) r += bJ[t[s]];
      const i = `0x${r}`;
      return typeof e.size == "number" ? (_m(i, e.size), Am(i, e.size)) : i;
    }
    function EJ(t, e = {}) {
      const { signed: r, size: i } = e,
        s = BigInt(t);
      let n;
      i
        ? r
          ? (n = (1n << (BigInt(i) * 8n - 1n)) - 1n)
          : (n = 2n ** (BigInt(i) * 8n) - 1n)
        : typeof t == "number" && (n = BigInt(Number.MAX_SAFE_INTEGER));
      const o = typeof n == "bigint" && r ? -n - 1n : 0;
      if ((n && s > n) || s < o) {
        const c = typeof t == "bigint" ? "n" : "";
        throw new xJ({
          max: n ? `${n}${c}` : void 0,
          min: `${o}${c}`,
          signed: r,
          size: i,
          value: `${t}${c}`,
        });
      }
      const a = `0x${(r && s < 0
        ? (1n << BigInt(i * 8)) + BigInt(s)
        : s
      ).toString(16)}`;
      return i ? _f(a, i) : a;
    }
    function CJ(t, e = {}) {
      return X9(yJ.encode(t), e);
    }
    function _f(t, e) {
      return Z9(t, { dir: "left", size: e });
    }
    function Am(t, e) {
      return Z9(t, { dir: "right", size: e });
    }
    function Sm(t) {
      return Math.ceil((t.length - 2) / 2);
    }
    class xJ extends Ur {
      constructor({ max: e, min: r, signed: i, size: s, value: n }) {
        super(
          `Number \`${n}\` is not in safe${s ? ` ${s * 8}-bit` : ""}${
            i ? " signed" : " unsigned"
          } integer range ${e ? `(\`${r}\` to \`${e}\`)` : `(above \`${r}\`)`}`
        ),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Hex.IntegerOutOfRangeError",
          });
      }
    }
    class IJ extends Ur {
      constructor({ givenSize: e, maxSize: r }) {
        super(`Size cannot exceed \`${r}\` bytes. Given size: \`${e}\` bytes.`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Hex.SizeOverflowError",
          });
      }
    }
    class _J extends Ur {
      constructor({ size: e, targetSize: r, type: i }) {
        super(
          `${i.charAt(0).toUpperCase()}${i
            .slice(1)
            .toLowerCase()} size (\`${e}\`) exceeds padding size (\`${r}\`).`
        ),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Hex.SizeExceedsPaddingSizeError",
          });
      }
    }
    function AJ(t, e = {}) {
      const { as: r = typeof t == "string" ? "Hex" : "Bytes" } = e,
        i = To(hJ(t));
      return r === "Bytes" ? i : X9(i);
    }
    class SJ extends Map {
      constructor(e) {
        super(),
          Object.defineProperty(this, "maxSize", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          (this.maxSize = e);
      }
      get(e) {
        const r = super.get(e);
        return (
          super.has(e) && r !== void 0 && (this.delete(e), super.set(e, r)), r
        );
      }
      set(e, r) {
        if ((super.set(e, r), this.maxSize && this.size > this.maxSize)) {
          const i = this.keys().next().value;
          i && this.delete(i);
        }
        return this;
      }
    }
    const Pm = { checksum: new SJ(8192) }.checksum,
      PJ = /^0x[a-fA-F0-9]{40}$/;
    function Q9(t, e = {}) {
      const { strict: r = !0 } = e;
      if (!PJ.test(t)) throw new eC({ address: t, cause: new NJ() });
      if (r) {
        if (t.toLowerCase() === t) return;
        if (OJ(t) !== t) throw new eC({ address: t, cause: new TJ() });
      }
    }
    function OJ(t) {
      if (Pm.has(t)) return Pm.get(t);
      Q9(t, { strict: !1 });
      const e = t.substring(2).toLowerCase(),
        r = AJ(fJ(e), { as: "Bytes" }),
        i = e.split("");
      for (let n = 0; n < 40; n += 2)
        r[n >> 1] >> 4 >= 8 && i[n] && (i[n] = i[n].toUpperCase()),
          (r[n >> 1] & 15) >= 8 &&
            i[n + 1] &&
            (i[n + 1] = i[n + 1].toUpperCase());
      const s = `0x${i.join("")}`;
      return Pm.set(t, s), s;
    }
    class eC extends Ur {
      constructor({ address: e, cause: r }) {
        super(`Address "${e}" is invalid.`, { cause: r }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Address.InvalidAddressError",
          });
      }
    }
    class NJ extends Ur {
      constructor() {
        super("Address is not a 20 byte (40 hexadecimal character) value."),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Address.InvalidInputError",
          });
      }
    }
    class TJ extends Ur {
      constructor() {
        super("Address does not match its checksum counterpart."),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Address.InvalidChecksumError",
          });
      }
    }
    const kJ = /^(.*)\[([0-9]*)\]$/,
      RJ = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,
      $J =
        /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
    function Om(t, e) {
      if (t.length !== e.length)
        throw new BJ({ expectedLength: t.length, givenLength: e.length });
      const r = [];
      for (let i = 0; i < t.length; i++) {
        const s = t[i],
          n = e[i];
        r.push(Om.encode(s, n));
      }
      return J9(...r);
    }
    (function (t) {
      function e(r, i, s = !1) {
        if (r === "address") {
          const c = i;
          return Q9(c), _f(c.toLowerCase(), s ? 32 : 0);
        }
        if (r === "string") return CJ(i);
        if (r === "bytes") return i;
        if (r === "bool") return _f(vJ(i), s ? 32 : 1);
        const n = r.match($J);
        if (n) {
          const [c, l, u = "256"] = n,
            h = Number.parseInt(u) / 8;
          return EJ(i, { size: s ? 32 : h, signed: l === "int" });
        }
        const o = r.match(RJ);
        if (o) {
          const [c, l] = o;
          if (Number.parseInt(l) !== (i.length - 2) / 2)
            throw new FJ({ expectedSize: Number.parseInt(l), value: i });
          return Am(i, s ? 32 : 0);
        }
        const a = r.match(kJ);
        if (a && Array.isArray(i)) {
          const [c, l] = a,
            u = [];
          for (let h = 0; h < i.length; h++) u.push(e(l, i[h], !0));
          return u.length === 0 ? "0x" : J9(...u);
        }
        throw new LJ(r);
      }
      t.encode = e;
    })(Om || (Om = {}));
    class FJ extends Ur {
      constructor({ expectedSize: e, value: r }) {
        super(
          `Size of bytes "${r}" (bytes${Sm(
            r
          )}) does not match expected size (bytes${e}).`
        ),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiParameters.BytesSizeMismatchError",
          });
      }
    }
    class BJ extends Ur {
      constructor({ expectedLength: e, givenLength: r }) {
        super(
          [
            "ABI encoding parameters/values length mismatch.",
            `Expected length (parameters): ${e}`,
            `Given length (values): ${r}`,
          ].join(`
`)
        ),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiParameters.LengthMismatchError",
          });
      }
    }
    class LJ extends Ur {
      constructor(e) {
        super(`Type \`${e}\` is not a valid ABI Type.`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiParameters.InvalidTypeError",
          });
      }
    }
    const Nm = {
        createBalance(t, e) {
          const r = {
            name: t.metadata.name || "",
            symbol: t.metadata.symbol || "",
            decimals: t.metadata.decimals || 0,
            value: t.metadata.value || 0,
            price: t.metadata.price || 0,
            iconUrl: t.metadata.iconUrl || "",
          };
          return {
            name: r.name,
            symbol: r.symbol,
            chainId: e,
            address:
              t.address === "native"
                ? void 0
                : this.convertAddressToCAIP10Address(t.address, e),
            value: r.value,
            price: r.price,
            quantity: {
              decimals: r.decimals.toString(),
              numeric: this.convertHexToBalance({
                hex: t.balance,
                decimals: r.decimals,
              }),
            },
            iconUrl: r.iconUrl,
          };
        },
        convertHexToBalance({ hex: t, decimals: e }) {
          return S9(BigInt(t), e);
        },
        convertAddressToCAIP10Address(t, e) {
          return `${e}:${t}`;
        },
        createCAIP2ChainId(t, e) {
          return `${e}:${parseInt(t, 16)}`;
        },
        getChainIdHexFromCAIP2ChainId(t) {
          const e = t.split(":");
          if (e.length < 2 || !e[1]) return "0x0";
          const r = e[1],
            i = parseInt(r, 10);
          return isNaN(i) ? "0x0" : `0x${i.toString(16)}`;
        },
        isWalletGetAssetsResponse(t) {
          return typeof t != "object" || t === null
            ? !1
            : Object.values(t).every(
                (e) => Array.isArray(e) && e.every((r) => this.isValidAsset(r))
              );
        },
        isValidAsset(t) {
          return (
            typeof t == "object" &&
            t !== null &&
            typeof t.address == "string" &&
            typeof t.balance == "string" &&
            (t.type === "ERC20" || t.type === "NATIVE") &&
            typeof t.metadata == "object" &&
            t.metadata !== null &&
            typeof t.metadata.name == "string" &&
            typeof t.metadata.symbol == "string" &&
            typeof t.metadata.decimals == "number" &&
            typeof t.metadata.price == "number" &&
            typeof t.metadata.iconUrl == "string"
          );
        },
      },
      tC = {
        async getMyTokensWithBalance(t) {
          const e = fe.state.address,
            r = B.state.activeCaipNetwork;
          if (!e || !r) return [];
          if (r.chainNamespace === "eip155") {
            const s = await this.getEIP155Balances(e, r);
            if (s) return this.filterLowQualityTokens(s);
          }
          const i = await be.getBalance(e, r.caipNetworkId, t);
          return this.filterLowQualityTokens(i.balances);
        },
        async getEIP155Balances(t, e) {
          try {
            const r = Nm.getChainIdHexFromCAIP2ChainId(e.caipNetworkId);
            if (!(await pe.getCapabilities(t))?.[r]?.assetDiscovery?.supported)
              return null;
            const i = await pe.walletGetAssets({
              account: t,
              chainFilter: [r],
            });
            return Nm.isWalletGetAssetsResponse(i)
              ? (i[r] || []).map((s) => Nm.createBalance(s, e.caipNetworkId))
              : null;
          } catch {
            return null;
          }
        },
        filterLowQualityTokens(t) {
          return t.filter((e) => e.quantity.decimals !== "0");
        },
        mapBalancesToSwapTokens(t) {
          return (
            t?.map((e) => ({
              ...e,
              address: e?.address
                ? e.address
                : B.getActiveNetworkTokenAddress(),
              decimals: parseInt(e.quantity.decimals, 10),
              logoUri: e.iconUrl,
              eip2612: !1,
            })) || []
          );
        },
      },
      Re = ot({ tokenBalances: [], loading: !1 }),
      rC = {
        state: Re,
        subscribe(t) {
          return Sr(Re, () => t(Re));
        },
        subscribeKey(t, e) {
          return Fr(Re, t, e);
        },
        setToken(t) {
          t && (Re.token = ta(t));
        },
        setTokenAmount(t) {
          Re.sendTokenAmount = t;
        },
        setReceiverAddress(t) {
          Re.receiverAddress = t;
        },
        setReceiverProfileImageUrl(t) {
          Re.receiverProfileImageUrl = t;
        },
        setReceiverProfileName(t) {
          Re.receiverProfileName = t;
        },
        setGasPrice(t) {
          Re.gasPrice = t;
        },
        setGasPriceInUsd(t) {
          Re.gasPriceInUSD = t;
        },
        setNetworkBalanceInUsd(t) {
          Re.networkBalanceInUSD = t;
        },
        setLoading(t) {
          Re.loading = t;
        },
        sendToken() {
          switch (B.state.activeCaipNetwork?.chainNamespace) {
            case "eip155":
              this.sendEvmToken();
              return;
            case "solana":
              this.sendSolanaToken();
              return;
            default:
              throw new Error("Unsupported chain");
          }
        },
        sendEvmToken() {
          const t = B.state.activeChain,
            e = fe.state.preferredAccountTypes?.[t];
          this.state.token?.address &&
          this.state.sendTokenAmount &&
          this.state.receiverAddress
            ? (Se.sendEvent({
                type: "track",
                event: "SEND_INITIATED",
                properties: {
                  isSmartAccount: e === oo.ACCOUNT_TYPES.SMART_ACCOUNT,
                  token: this.state.token.address,
                  amount: this.state.sendTokenAmount,
                  network: B.state.activeCaipNetwork?.caipNetworkId || "",
                },
              }),
              this.sendERC20Token({
                receiverAddress: this.state.receiverAddress,
                tokenAddress: this.state.token.address,
                sendTokenAmount: this.state.sendTokenAmount,
                decimals: this.state.token.quantity.decimals,
              }))
            : this.state.receiverAddress &&
              this.state.sendTokenAmount &&
              this.state.gasPrice &&
              this.state.token?.quantity.decimals &&
              (Se.sendEvent({
                type: "track",
                event: "SEND_INITIATED",
                properties: {
                  isSmartAccount: e === oo.ACCOUNT_TYPES.SMART_ACCOUNT,
                  token: this.state.token?.symbol,
                  amount: this.state.sendTokenAmount,
                  network: B.state.activeCaipNetwork?.caipNetworkId || "",
                },
              }),
              this.sendNativeToken({
                receiverAddress: this.state.receiverAddress,
                sendTokenAmount: this.state.sendTokenAmount,
                gasPrice: this.state.gasPrice,
                decimals: this.state.token.quantity.decimals,
              }));
        },
        async fetchTokenBalance(t) {
          Re.loading = !0;
          const e = B.state.activeCaipNetwork?.caipNetworkId,
            r = B.state.activeCaipNetwork?.chainNamespace,
            i = B.state.activeCaipAddress,
            s = i ? X.getPlainAddress(i) : void 0;
          if (
            Re.lastRetry &&
            !X.isAllowedRetry(Re.lastRetry, 30 * Lt.ONE_SEC_MS)
          )
            return (Re.loading = !1), [];
          try {
            if (s && e && r) {
              const n = await tC.getMyTokensWithBalance();
              return (Re.tokenBalances = n), (Re.lastRetry = void 0), n;
            }
          } catch (n) {
            (Re.lastRetry = Date.now()),
              t?.(n),
              at.showError("Token Balance Unavailable");
          } finally {
            Re.loading = !1;
          }
          return [];
        },
        fetchNetworkBalance() {
          if (Re.tokenBalances.length === 0) return;
          const t = tC.mapBalancesToSwapTokens(Re.tokenBalances);
          if (!t) return;
          const e = t.find(
            (r) => r.address === B.getActiveNetworkTokenAddress()
          );
          e &&
            (Re.networkBalanceInUSD = e
              ? tf.multiply(e.quantity.numeric, e.price).toString()
              : "0");
        },
        isInsufficientNetworkTokenForGas(t, e) {
          const r = e || "0";
          return tf.bigNumber(t).eq(0)
            ? !0
            : tf.bigNumber(tf.bigNumber(r)).gt(t);
        },
        hasInsufficientGasFunds() {
          const t = B.state.activeChain;
          let e = !0;
          return (
            fe.state.preferredAccountTypes?.[t] ===
            oo.ACCOUNT_TYPES.SMART_ACCOUNT
              ? (e = !1)
              : Re.networkBalanceInUSD &&
                (e = this.isInsufficientNetworkTokenForGas(
                  Re.networkBalanceInUSD,
                  Re.gasPriceInUSD
                )),
            e
          );
        },
        async sendNativeToken(t) {
          const e = B.state.activeChain;
          ie.pushTransactionStack({ view: "Account", goBack: !1 });
          const r = t.receiverAddress,
            i = fe.state.address,
            s = pe.parseUnits(t.sendTokenAmount.toString(), Number(t.decimals)),
            n = "0x";
          try {
            await pe.sendTransaction({
              chainNamespace: "eip155",
              to: r,
              address: i,
              data: n,
              value: s ?? BigInt(0),
              gasPrice: t.gasPrice,
            }),
              at.showSuccess("Transaction started"),
              Se.sendEvent({
                type: "track",
                event: "SEND_SUCCESS",
                properties: {
                  isSmartAccount:
                    fe.state.preferredAccountTypes?.[e] ===
                    oo.ACCOUNT_TYPES.SMART_ACCOUNT,
                  token: this.state.token?.symbol || "",
                  amount: t.sendTokenAmount,
                  network: B.state.activeCaipNetwork?.caipNetworkId || "",
                },
              }),
              this.resetSend();
          } catch (o) {
            console.error(
              "SendController:sendERC20Token - failed to send native token",
              o
            );
            const a = o instanceof Error ? o.message : "Unknown error";
            Se.sendEvent({
              type: "track",
              event: "SEND_ERROR",
              properties: {
                message: a,
                isSmartAccount:
                  fe.state.preferredAccountTypes?.[e] ===
                  oo.ACCOUNT_TYPES.SMART_ACCOUNT,
                token: this.state.token?.symbol || "",
                amount: t.sendTokenAmount,
                network: B.state.activeCaipNetwork?.caipNetworkId || "",
              },
            }),
              at.showError("Something went wrong");
          }
        },
        async sendERC20Token(t) {
          ie.pushTransactionStack({ view: "Account", goBack: !1 });
          const e = pe.parseUnits(
            t.sendTokenAmount.toString(),
            Number(t.decimals)
          );
          try {
            if (
              fe.state.address &&
              t.sendTokenAmount &&
              t.receiverAddress &&
              t.tokenAddress
            ) {
              const r = X.getPlainAddress(t.tokenAddress);
              await pe.writeContract({
                fromAddress: fe.state.address,
                tokenAddress: r,
                args: [t.receiverAddress, e ?? BigInt(0)],
                method: "transfer",
                abi: VV.getERC20Abi(r),
                chainNamespace: "eip155",
              }),
                at.showSuccess("Transaction started"),
                this.resetSend();
            }
          } catch (r) {
            console.error(
              "SendController:sendERC20Token - failed to send erc20 token",
              r
            );
            const i = r instanceof Error ? r.message : "Unknown error";
            Se.sendEvent({
              type: "track",
              event: "SEND_ERROR",
              properties: {
                message: i,
                isSmartAccount:
                  fe.state.preferredAccountTypes?.eip155 ===
                  oo.ACCOUNT_TYPES.SMART_ACCOUNT,
                token: this.state.token?.symbol || "",
                amount: t.sendTokenAmount,
                network: B.state.activeCaipNetwork?.caipNetworkId || "",
              },
            }),
              at.showError("Something went wrong");
          }
        },
        sendSolanaToken() {
          if (!this.state.sendTokenAmount || !this.state.receiverAddress) {
            at.showError("Please enter a valid amount and receiver address");
            return;
          }
          ie.pushTransactionStack({ view: "Account", goBack: !1 }),
            pe
              .sendTransaction({
                chainNamespace: "solana",
                to: this.state.receiverAddress,
                value: this.state.sendTokenAmount,
              })
              .then(() => {
                this.resetSend(), fe.fetchTokenBalance();
              })
              .catch((t) => {
                at.showError("Failed to send transaction. Please try again."),
                  console.error(
                    "SendController:sendToken - failed to send solana transaction",
                    t
                  );
              });
        },
        resetSend() {
          (Re.token = void 0),
            (Re.sendTokenAmount = void 0),
            (Re.receiverAddress = void 0),
            (Re.receiverProfileImageUrl = void 0),
            (Re.receiverProfileName = void 0),
            (Re.loading = !1),
            (Re.tokenBalances = []);
        },
      },
      Tm = {
        currentTab: 0,
        tokenBalance: [],
        smartAccountDeployed: !1,
        addressLabels: new Map(),
        allAccounts: [],
        user: void 0,
      },
      Af = {
        caipNetwork: void 0,
        supportsAllNetworks: !0,
        smartAccountEnabledNetworks: [],
      },
      se = ot({
        chains: JV(),
        activeCaipAddress: void 0,
        activeChain: void 0,
        activeCaipNetwork: void 0,
        noAdapters: !1,
        universalAdapter: {
          networkControllerClient: void 0,
          connectionControllerClient: void 0,
        },
        isSwitchingNamespace: !1,
      }),
      B = {
        state: se,
        subscribe(t) {
          return Sr(se, () => {
            t(se);
          });
        },
        subscribeKey(t, e) {
          return Fr(se, t, e);
        },
        subscribeChainProp(t, e, r) {
          let i;
          return Sr(se.chains, () => {
            const s = r || se.activeChain;
            if (s) {
              const n = se.chains.get(s)?.[t];
              i !== n && ((i = n), e(n));
            }
          });
        },
        initialize(t, e, r) {
          const { chainId: i, namespace: s } = de.getActiveNetworkProps(),
            n = e?.find((c) => c.id.toString() === i?.toString()),
            o = t.find((c) => c?.namespace === s) || t?.[0],
            a = new Set([...(e?.map((c) => c.chainNamespace) ?? [])]);
          (t?.length === 0 || !o) && (se.noAdapters = !0),
            se.noAdapters ||
              ((se.activeChain = o?.namespace),
              (se.activeCaipNetwork = n),
              this.setChainNetworkData(o?.namespace, { caipNetwork: n }),
              se.activeChain && pn.set({ activeChain: o?.namespace })),
            a.forEach((c) => {
              const l = e?.filter((u) => u.chainNamespace === c);
              B.state.chains.set(c, {
                namespace: c,
                networkState: ot({ ...Af, caipNetwork: l?.[0] }),
                accountState: ot(Tm),
                caipNetworks: l ?? [],
                ...r,
              }),
                this.setRequestedCaipNetworks(l ?? [], c);
            });
        },
        removeAdapter(t) {
          if (se.activeChain === t) {
            const e = Array.from(se.chains.entries()).find(([r]) => r !== t);
            if (e) {
              const r = e[1]?.caipNetworks?.[0];
              r && this.setActiveCaipNetwork(r);
            }
          }
          se.chains.delete(t);
        },
        addAdapter(
          t,
          { networkControllerClient: e, connectionControllerClient: r },
          i
        ) {
          se.chains.set(t.namespace, {
            namespace: t.namespace,
            networkState: { ...Af, caipNetwork: i[0] },
            accountState: Tm,
            caipNetworks: i,
            connectionControllerClient: r,
            networkControllerClient: e,
          }),
            this.setRequestedCaipNetworks(
              i?.filter((s) => s.chainNamespace === t.namespace) ?? [],
              t.namespace
            );
        },
        addNetwork(t) {
          const e = se.chains.get(t.chainNamespace);
          if (e) {
            const r = [...(e.caipNetworks || [])];
            e.caipNetworks?.find((i) => i.id === t.id) || r.push(t),
              se.chains.set(t.chainNamespace, { ...e, caipNetworks: r }),
              this.setRequestedCaipNetworks(r, t.chainNamespace);
          }
        },
        removeNetwork(t, e) {
          const r = se.chains.get(t);
          if (r) {
            const i = se.activeCaipNetwork?.id === e,
              s = [...(r.caipNetworks?.filter((n) => n.id !== e) || [])];
            i &&
              r?.caipNetworks?.[0] &&
              this.setActiveCaipNetwork(r.caipNetworks[0]),
              se.chains.set(t, { ...r, caipNetworks: s }),
              this.setRequestedCaipNetworks(s || [], t);
          }
        },
        setAdapterNetworkState(t, e) {
          const r = se.chains.get(t);
          r &&
            ((r.networkState = { ...(r.networkState || Af), ...e }),
            se.chains.set(t, r));
        },
        setChainAccountData(t, e, r = !0) {
          if (!t)
            throw new Error("Chain is required to update chain account data");
          const i = se.chains.get(t);
          if (i) {
            const s = { ...(i.accountState || Tm), ...e };
            se.chains.set(t, { ...i, accountState: s }),
              (se.chains.size === 1 || se.activeChain === t) &&
                (e.caipAddress && (se.activeCaipAddress = e.caipAddress),
                fe.replaceState(s));
          }
        },
        setChainNetworkData(t, e) {
          if (!t) return;
          const r = se.chains.get(t);
          if (r) {
            const i = { ...(r.networkState || Af), ...e };
            se.chains.set(t, { ...r, networkState: i });
          }
        },
        setAccountProp(t, e, r, i = !0) {
          this.setChainAccountData(r, { [t]: e }, i),
            t === "status" &&
              e === "disconnected" &&
              r &&
              oe.removeConnectorId(r);
        },
        setActiveNamespace(t) {
          se.activeChain = t;
          const e = t ? se.chains.get(t) : void 0,
            r = e?.networkState?.caipNetwork;
          r?.id &&
            t &&
            ((se.activeCaipAddress = e?.accountState?.caipAddress),
            (se.activeCaipNetwork = r),
            this.setChainNetworkData(t, { caipNetwork: r }),
            de.setActiveCaipNetworkId(r?.caipNetworkId),
            pn.set({ activeChain: t, selectedNetworkId: r?.caipNetworkId }));
        },
        setActiveCaipNetwork(t) {
          if (!t) return;
          se.activeChain !== t.chainNamespace &&
            this.setIsSwitchingNamespace(!0);
          const e = se.chains.get(t.chainNamespace);
          (se.activeChain = t.chainNamespace),
            (se.activeCaipNetwork = t),
            this.setChainNetworkData(t.chainNamespace, { caipNetwork: t }),
            e?.accountState?.address
              ? (se.activeCaipAddress = `${t.chainNamespace}:${t.id}:${e?.accountState?.address}`)
              : (se.activeCaipAddress = void 0),
            this.setAccountProp(
              "caipAddress",
              se.activeCaipAddress,
              t.chainNamespace
            ),
            e && fe.replaceState(e.accountState),
            rC.resetSend(),
            pn.set({
              activeChain: se.activeChain,
              selectedNetworkId: se.activeCaipNetwork?.caipNetworkId,
            }),
            de.setActiveCaipNetworkId(t.caipNetworkId),
            !this.checkIfSupportedNetwork(t.chainNamespace) &&
              G.state.enableNetworkSwitch &&
              !G.state.allowUnsupportedChain &&
              !pe.state.wcBasic &&
              this.showUnsupportedChainUI();
        },
        addCaipNetwork(t) {
          if (!t) return;
          const e = se.chains.get(t.chainNamespace);
          e && e?.caipNetworks?.push(t);
        },
        async switchActiveNamespace(t) {
          if (!t) return;
          const e = t !== B.state.activeChain,
            r = B.getNetworkData(t)?.caipNetwork,
            i = B.getCaipNetworkByNamespace(t, r?.id);
          e && i && (await B.switchActiveNetwork(i));
        },
        async switchActiveNetwork(t) {
          !B.state.chains
            .get(B.state.activeChain)
            ?.caipNetworks?.some((r) => r.id === se.activeCaipNetwork?.id) &&
            ie.goBack();
          const e = this.getNetworkControllerClient(t.chainNamespace);
          e &&
            (await e.switchCaipNetwork(t),
            Se.sendEvent({
              type: "track",
              event: "SWITCH_NETWORK",
              properties: { network: t.caipNetworkId },
            }));
        },
        getNetworkControllerClient(t) {
          const e = t || se.activeChain,
            r = se.chains.get(e);
          if (!r) throw new Error("Chain adapter not found");
          if (!r.networkControllerClient)
            throw new Error("NetworkController client not set");
          return r.networkControllerClient;
        },
        getConnectionControllerClient(t) {
          const e = t || se.activeChain;
          if (!e)
            throw new Error(
              "Chain is required to get connection controller client"
            );
          const r = se.chains.get(e);
          if (!r?.connectionControllerClient)
            throw new Error("ConnectionController client not set");
          return r.connectionControllerClient;
        },
        getAccountProp(t, e) {
          let r = se.activeChain;
          if ((e && (r = e), !r)) return;
          const i = se.chains.get(r)?.accountState;
          if (i) return i[t];
        },
        getNetworkProp(t, e) {
          const r = se.chains.get(e)?.networkState;
          if (r) return r[t];
        },
        getRequestedCaipNetworks(t) {
          const e = se.chains.get(t),
            { approvedCaipNetworkIds: r = [], requestedCaipNetworks: i = [] } =
              e?.networkState || {};
          return X.sortRequestedNetworks(r, i);
        },
        getAllRequestedCaipNetworks() {
          const t = [];
          return (
            se.chains.forEach((e) => {
              const r = this.getRequestedCaipNetworks(e.namespace);
              t.push(...r);
            }),
            t
          );
        },
        setRequestedCaipNetworks(t, e) {
          this.setAdapterNetworkState(e, { requestedCaipNetworks: t });
        },
        getAllApprovedCaipNetworkIds() {
          const t = [];
          return (
            se.chains.forEach((e) => {
              const r = this.getApprovedCaipNetworkIds(e.namespace);
              t.push(...r);
            }),
            t
          );
        },
        getActiveCaipNetwork() {
          return se.activeCaipNetwork;
        },
        getActiveCaipAddress() {
          return se.activeCaipAddress;
        },
        getApprovedCaipNetworkIds(t) {
          return se.chains.get(t)?.networkState?.approvedCaipNetworkIds || [];
        },
        async setApprovedCaipNetworksData(t) {
          const e =
            await this.getNetworkControllerClient()?.getApprovedCaipNetworksData();
          this.setAdapterNetworkState(t, {
            approvedCaipNetworkIds: e?.approvedCaipNetworkIds,
            supportsAllNetworks: e?.supportsAllNetworks,
          });
        },
        checkIfSupportedNetwork(t, e) {
          const r = e || se.activeCaipNetwork,
            i = this.getRequestedCaipNetworks(t);
          return i.length ? i?.some((s) => s.id === r?.id) : !0;
        },
        checkIfSupportedChainId(t) {
          return se.activeChain
            ? this.getRequestedCaipNetworks(se.activeChain)?.some(
                (e) => e.id === t
              )
            : !0;
        },
        setSmartAccountEnabledNetworks(t, e) {
          this.setAdapterNetworkState(e, { smartAccountEnabledNetworks: t });
        },
        checkIfSmartAccountEnabled() {
          const t = X8.caipNetworkIdToNumber(
              se.activeCaipNetwork?.caipNetworkId
            ),
            e = se.activeChain;
          return !e || !t
            ? !1
            : !!this.getNetworkProp("smartAccountEnabledNetworks", e)?.includes(
                Number(t)
              );
        },
        getActiveNetworkTokenAddress() {
          const t = se.activeCaipNetwork?.chainNamespace || "eip155",
            e = se.activeCaipNetwork?.id || 1,
            r = Lt.NATIVE_TOKEN_ADDRESS[t];
          return `${t}:${e}:${r}`;
        },
        showUnsupportedChainUI() {
          $e.open({ view: "UnsupportedChain" });
        },
        checkIfNamesSupported() {
          const t = se.activeCaipNetwork;
          return !!(
            t?.chainNamespace &&
            Lt.NAMES_SUPPORTED_CHAIN_NAMESPACES.includes(t.chainNamespace)
          );
        },
        resetNetwork(t) {
          this.setAdapterNetworkState(t, {
            approvedCaipNetworkIds: void 0,
            supportsAllNetworks: !0,
            smartAccountEnabledNetworks: [],
          });
        },
        resetAccount(t) {
          const e = t;
          if (!e) throw new Error("Chain is required to set account prop");
          (se.activeCaipAddress = void 0),
            this.setChainAccountData(e, {
              smartAccountDeployed: !1,
              currentTab: 0,
              caipAddress: void 0,
              address: void 0,
              balance: void 0,
              balanceSymbol: void 0,
              profileName: void 0,
              profileImage: void 0,
              addressExplorerUrl: void 0,
              tokenBalance: [],
              connectedWalletInfo: void 0,
              preferredAccountTypes: void 0,
              socialProvider: void 0,
              socialWindow: void 0,
              farcasterUrl: void 0,
              allAccounts: [],
              user: void 0,
              status: "disconnected",
            }),
            oe.removeConnectorId(e);
        },
        async disconnect(t) {
          const e = lW(t);
          try {
            rC.resetSend();
            const r = await Promise.allSettled(
              e.map(async ([s, n]) => {
                try {
                  const { caipAddress: o } = this.getAccountData(s) || {};
                  o &&
                    n.connectionControllerClient?.disconnect &&
                    (await n.connectionControllerClient.disconnect(s)),
                    this.resetAccount(s),
                    this.resetNetwork(s);
                } catch (o) {
                  throw new Error(
                    `Failed to disconnect chain ${s}: ${o.message}`
                  );
                }
              })
            );
            pe.resetWcConnection();
            const i = r.filter((s) => s.status === "rejected");
            if (i.length > 0)
              throw new Error(i.map((s) => s.reason.message).join(", "));
            de.deleteConnectedSocialProvider(),
              t ? oe.removeConnectorId(t) : oe.resetConnectorIds(),
              Se.sendEvent({
                type: "track",
                event: "DISCONNECT_SUCCESS",
                properties: { namespace: t || "all" },
              });
          } catch (r) {
            console.error(r.message || "Failed to disconnect chains"),
              Se.sendEvent({
                type: "track",
                event: "DISCONNECT_ERROR",
                properties: {
                  message: r.message || "Failed to disconnect chains",
                },
              });
          }
        },
        setIsSwitchingNamespace(t) {
          se.isSwitchingNamespace = t;
        },
        getFirstCaipNetworkSupportsAuthConnector() {
          const t = [];
          let e;
          if (
            (se.chains.forEach((r) => {
              he.AUTH_CONNECTOR_SUPPORTED_CHAINS.find(
                (i) => i === r.namespace
              ) &&
                r.namespace &&
                t.push(r.namespace);
            }),
            t.length > 0)
          ) {
            const r = t[0];
            return (e = r ? se.chains.get(r)?.caipNetworks?.[0] : void 0), e;
          }
        },
        getAccountData(t) {
          return t ? B.state.chains.get(t)?.accountState : fe.state;
        },
        getNetworkData(t) {
          const e = t || se.activeChain;
          if (e) return B.state.chains.get(e)?.networkState;
        },
        getCaipNetworkByNamespace(t, e) {
          if (!t) return;
          const r = B.state.chains.get(t);
          return (
            r?.caipNetworks?.find((s) => s.id === e) ||
            r?.networkState?.caipNetwork ||
            r?.caipNetworks?.[0]
          );
        },
        getRequestedCaipNetworkIds() {
          const t = oe.state.filterByNamespace;
          return (t ? [se.chains.get(t)] : Array.from(se.chains.values()))
            .flatMap((e) => e?.caipNetworks || [])
            .map((e) => e.caipNetworkId);
        },
        getCaipNetworks(t) {
          return t
            ? B.getRequestedCaipNetworks(t)
            : B.getAllRequestedCaipNetworks();
        },
      },
      UJ = {
        purchaseCurrencies: [
          {
            id: "2b92315d-eab7-5bef-84fa-089a131333f5",
            name: "USD Coin",
            symbol: "USDC",
            networks: [
              {
                name: "ethereum-mainnet",
                display_name: "Ethereum",
                chain_id: "1",
                contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
              },
              {
                name: "polygon-mainnet",
                display_name: "Polygon",
                chain_id: "137",
                contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
              },
            ],
          },
          {
            id: "2b92315d-eab7-5bef-84fa-089a131333f5",
            name: "Ether",
            symbol: "ETH",
            networks: [
              {
                name: "ethereum-mainnet",
                display_name: "Ethereum",
                chain_id: "1",
                contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
              },
              {
                name: "polygon-mainnet",
                display_name: "Polygon",
                chain_id: "137",
                contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
              },
            ],
          },
        ],
        paymentCurrencies: [
          {
            id: "USD",
            payment_method_limits: [
              { id: "card", min: "10.00", max: "7500.00" },
              { id: "ach_bank_account", min: "10.00", max: "25000.00" },
            ],
          },
          {
            id: "EUR",
            payment_method_limits: [
              { id: "card", min: "10.00", max: "7500.00" },
              { id: "ach_bank_account", min: "10.00", max: "25000.00" },
            ],
          },
        ],
      },
      iC = X.getBlockchainApiUrl(),
      bi = ot({
        clientId: null,
        api: new rf({ baseUrl: iC, clientId: null }),
        supportedChains: { http: [], ws: [] },
      }),
      be = {
        state: bi,
        async get(t) {
          const { st: e, sv: r } = be.getSdkProperties(),
            i = G.state.projectId,
            s = { ...(t.params || {}), st: e, sv: r, projectId: i };
          return bi.api.get({ ...t, params: s });
        },
        getSdkProperties() {
          const { sdkType: t, sdkVersion: e } = G.state;
          return { st: t || "unknown", sv: e || "unknown" };
        },
        async isNetworkSupported(t) {
          if (!t) return !1;
          try {
            bi.supportedChains.http.length || (await be.getSupportedNetworks());
          } catch {
            return !1;
          }
          return bi.supportedChains.http.includes(t);
        },
        async getSupportedNetworks() {
          const t = await be.get({ path: "v1/supported-chains" });
          return (bi.supportedChains = t), t;
        },
        async fetchIdentity({ address: t, caipNetworkId: e }) {
          if (!(await be.isNetworkSupported(e)))
            return { avatar: "", name: "" };
          const r = de.getIdentityFromCacheForAddress(t);
          if (r) return r;
          const i = await be.get({
            path: `/v1/identity/${t}`,
            params: {
              sender: B.state.activeCaipAddress
                ? X.getPlainAddress(B.state.activeCaipAddress)
                : void 0,
            },
          });
          return (
            de.updateIdentityCache({
              address: t,
              identity: i,
              timestamp: Date.now(),
            }),
            i
          );
        },
        async fetchTransactions({
          account: t,
          cursor: e,
          onramp: r,
          signal: i,
          cache: s,
          chainId: n,
        }) {
          return (await be.isNetworkSupported(
            B.state.activeCaipNetwork?.caipNetworkId
          ))
            ? be.get({
                path: `/v1/account/${t}/history`,
                params: { cursor: e, onramp: r, chainId: n },
                signal: i,
                cache: s,
              })
            : { data: [], next: void 0 };
        },
        async fetchSwapQuote({
          amount: t,
          userAddress: e,
          from: r,
          to: i,
          gasPrice: s,
        }) {
          return (await be.isNetworkSupported(
            B.state.activeCaipNetwork?.caipNetworkId
          ))
            ? be.get({
                path: "/v1/convert/quotes",
                headers: { "Content-Type": "application/json" },
                params: {
                  amount: t,
                  userAddress: e,
                  from: r,
                  to: i,
                  gasPrice: s,
                },
              })
            : { quotes: [] };
        },
        async fetchSwapTokens({ chainId: t }) {
          return (await be.isNetworkSupported(
            B.state.activeCaipNetwork?.caipNetworkId
          ))
            ? be.get({ path: "/v1/convert/tokens", params: { chainId: t } })
            : { tokens: [] };
        },
        async fetchTokenPrice({ addresses: t }) {
          return (await be.isNetworkSupported(
            B.state.activeCaipNetwork?.caipNetworkId
          ))
            ? bi.api.post({
                path: "/v1/fungible/price",
                body: {
                  currency: "usd",
                  addresses: t,
                  projectId: G.state.projectId,
                },
                headers: { "Content-Type": "application/json" },
              })
            : { fungibles: [] };
        },
        async fetchSwapAllowance({ tokenAddress: t, userAddress: e }) {
          return (await be.isNetworkSupported(
            B.state.activeCaipNetwork?.caipNetworkId
          ))
            ? be.get({
                path: "/v1/convert/allowance",
                params: { tokenAddress: t, userAddress: e },
                headers: { "Content-Type": "application/json" },
              })
            : { allowance: "0" };
        },
        async fetchGasPrice({ chainId: t }) {
          const { st: e, sv: r } = be.getSdkProperties();
          if (
            !(await be.isNetworkSupported(
              B.state.activeCaipNetwork?.caipNetworkId
            ))
          )
            throw new Error("Network not supported for Gas Price");
          return be.get({
            path: "/v1/convert/gas-price",
            headers: { "Content-Type": "application/json" },
            params: { chainId: t, st: e, sv: r },
          });
        },
        async generateSwapCalldata({
          amount: t,
          from: e,
          to: r,
          userAddress: i,
          disableEstimate: s,
        }) {
          if (
            !(await be.isNetworkSupported(
              B.state.activeCaipNetwork?.caipNetworkId
            ))
          )
            throw new Error("Network not supported for Swaps");
          return bi.api.post({
            path: "/v1/convert/build-transaction",
            headers: { "Content-Type": "application/json" },
            body: {
              amount: t,
              eip155: { slippage: Lt.CONVERT_SLIPPAGE_TOLERANCE },
              projectId: G.state.projectId,
              from: e,
              to: r,
              userAddress: i,
              disableEstimate: s,
            },
          });
        },
        async generateApproveCalldata({ from: t, to: e, userAddress: r }) {
          const { st: i, sv: s } = be.getSdkProperties();
          if (
            !(await be.isNetworkSupported(
              B.state.activeCaipNetwork?.caipNetworkId
            ))
          )
            throw new Error("Network not supported for Swaps");
          return be.get({
            path: "/v1/convert/build-approve",
            headers: { "Content-Type": "application/json" },
            params: { userAddress: r, from: t, to: e, st: i, sv: s },
          });
        },
        async getBalance(t, e, r) {
          const { st: i, sv: s } = be.getSdkProperties();
          if (
            !(await be.isNetworkSupported(
              B.state.activeCaipNetwork?.caipNetworkId
            ))
          )
            return at.showError("Token Balance Unavailable"), { balances: [] };
          const n = `${e}:${t}`,
            o = de.getBalanceCacheForCaipAddress(n);
          if (o) return o;
          const a = await be.get({
            path: `/v1/account/${t}/balance`,
            params: {
              currency: "usd",
              chainId: e,
              forceUpdate: r,
              st: i,
              sv: s,
            },
          });
          return (
            de.updateBalanceCache({
              caipAddress: n,
              balance: a,
              timestamp: Date.now(),
            }),
            a
          );
        },
        async lookupEnsName(t) {
          return (await be.isNetworkSupported(
            B.state.activeCaipNetwork?.caipNetworkId
          ))
            ? be.get({
                path: `/v1/profile/account/${t}`,
                params: { apiVersion: "2" },
              })
            : { addresses: {}, attributes: [] };
        },
        async reverseLookupEnsName({ address: t }) {
          return (await be.isNetworkSupported(
            B.state.activeCaipNetwork?.caipNetworkId
          ))
            ? be.get({
                path: `/v1/profile/reverse/${t}`,
                params: { sender: fe.state.address, apiVersion: "2" },
              })
            : [];
        },
        async getEnsNameSuggestions(t) {
          return (await be.isNetworkSupported(
            B.state.activeCaipNetwork?.caipNetworkId
          ))
            ? be.get({
                path: `/v1/profile/suggestions/${t}`,
                params: { zone: "reown.id" },
              })
            : { suggestions: [] };
        },
        async registerEnsName({
          coinType: t,
          address: e,
          message: r,
          signature: i,
        }) {
          return (await be.isNetworkSupported(
            B.state.activeCaipNetwork?.caipNetworkId
          ))
            ? bi.api.post({
                path: "/v1/profile/account",
                body: { coin_type: t, address: e, message: r, signature: i },
                headers: { "Content-Type": "application/json" },
              })
            : { success: !1 };
        },
        async generateOnRampURL({
          destinationWallets: t,
          partnerUserId: e,
          defaultNetwork: r,
          purchaseAmount: i,
          paymentAmount: s,
        }) {
          return (await be.isNetworkSupported(
            B.state.activeCaipNetwork?.caipNetworkId
          ))
            ? (
                await bi.api.post({
                  path: "/v1/generators/onrampurl",
                  params: { projectId: G.state.projectId },
                  body: {
                    destinationWallets: t,
                    defaultNetwork: r,
                    partnerUserId: e,
                    defaultExperience: "buy",
                    presetCryptoAmount: i,
                    presetFiatAmount: s,
                  },
                })
              ).url
            : "";
        },
        async getOnrampOptions() {
          if (
            !(await be.isNetworkSupported(
              B.state.activeCaipNetwork?.caipNetworkId
            ))
          )
            return { paymentCurrencies: [], purchaseCurrencies: [] };
          try {
            return await be.get({ path: "/v1/onramp/options" });
          } catch {
            return UJ;
          }
        },
        async getOnrampQuote({
          purchaseCurrency: t,
          paymentCurrency: e,
          amount: r,
          network: i,
        }) {
          try {
            return (await be.isNetworkSupported(
              B.state.activeCaipNetwork?.caipNetworkId
            ))
              ? await bi.api.post({
                  path: "/v1/onramp/quote",
                  params: { projectId: G.state.projectId },
                  body: {
                    purchaseCurrency: t,
                    paymentCurrency: e,
                    amount: r,
                    network: i,
                  },
                })
              : null;
          } catch {
            return {
              coinbaseFee: { amount: r, currency: e.id },
              networkFee: { amount: r, currency: e.id },
              paymentSubtotal: { amount: r, currency: e.id },
              paymentTotal: { amount: r, currency: e.id },
              purchaseAmount: { amount: r, currency: e.id },
              quoteId: "mocked-quote-id",
            };
          }
        },
        async getSmartSessions(t) {
          return (await be.isNetworkSupported(
            B.state.activeCaipNetwork?.caipNetworkId
          ))
            ? be.get({ path: `/v1/sessions/${t}` })
            : [];
        },
        async revokeSmartSession(t, e, r) {
          return (await be.isNetworkSupported(
            B.state.activeCaipNetwork?.caipNetworkId
          ))
            ? bi.api.post({
                path: `/v1/sessions/${t}/revoke`,
                params: { projectId: G.state.projectId },
                body: { pci: e, signature: r },
              })
            : { success: !1 };
        },
        setClientId(t) {
          (bi.clientId = t), (bi.api = new rf({ baseUrl: iC, clientId: t }));
        },
      },
      Li = ot({
        currentTab: 0,
        tokenBalance: [],
        smartAccountDeployed: !1,
        addressLabels: new Map(),
        allAccounts: [],
      }),
      fe = {
        state: Li,
        replaceState(t) {
          t && Object.assign(Li, ta(t));
        },
        subscribe(t) {
          return B.subscribeChainProp("accountState", (e) => {
            if (e) return t(e);
          });
        },
        subscribeKey(t, e, r) {
          let i;
          return B.subscribeChainProp(
            "accountState",
            (s) => {
              if (s) {
                const n = s[t];
                i !== n && ((i = n), e(n));
              }
            },
            r
          );
        },
        setStatus(t, e) {
          B.setAccountProp("status", t, e);
        },
        getCaipAddress(t) {
          return B.getAccountProp("caipAddress", t);
        },
        setCaipAddress(t, e) {
          const r = t ? X.getPlainAddress(t) : void 0;
          e === B.state.activeChain && (B.state.activeCaipAddress = t),
            B.setAccountProp("caipAddress", t, e),
            B.setAccountProp("address", r, e);
        },
        setBalance(t, e, r) {
          B.setAccountProp("balance", t, r),
            B.setAccountProp("balanceSymbol", e, r);
        },
        setProfileName(t, e) {
          B.setAccountProp("profileName", t, e);
        },
        setProfileImage(t, e) {
          B.setAccountProp("profileImage", t, e);
        },
        setUser(t, e) {
          B.setAccountProp("user", t, e);
        },
        setAddressExplorerUrl(t, e) {
          B.setAccountProp("addressExplorerUrl", t, e);
        },
        setSmartAccountDeployed(t, e) {
          B.setAccountProp("smartAccountDeployed", t, e);
        },
        setCurrentTab(t) {
          B.setAccountProp("currentTab", t, B.state.activeChain);
        },
        setTokenBalance(t, e) {
          t && B.setAccountProp("tokenBalance", t, e);
        },
        setShouldUpdateToAddress(t, e) {
          B.setAccountProp("shouldUpdateToAddress", t, e);
        },
        setAllAccounts(t, e) {
          B.setAccountProp("allAccounts", t, e);
        },
        addAddressLabel(t, e, r) {
          const i = B.getAccountProp("addressLabels", r) || new Map();
          i.set(t, e), B.setAccountProp("addressLabels", i, r);
        },
        removeAddressLabel(t, e) {
          const r = B.getAccountProp("addressLabels", e) || new Map();
          r.delete(t), B.setAccountProp("addressLabels", r, e);
        },
        setConnectedWalletInfo(t, e) {
          B.setAccountProp("connectedWalletInfo", t, e, !1);
        },
        setPreferredAccountType(t, e) {
          B.setAccountProp(
            "preferredAccountTypes",
            { ...Li.preferredAccountTypes, [e]: t },
            e
          );
        },
        setPreferredAccountTypes(t) {
          Li.preferredAccountTypes = t;
        },
        setSocialProvider(t, e) {
          t && B.setAccountProp("socialProvider", t, e);
        },
        setSocialWindow(t, e) {
          B.setAccountProp("socialWindow", t ? ta(t) : void 0, e);
        },
        setFarcasterUrl(t, e) {
          B.setAccountProp("farcasterUrl", t, e);
        },
        async fetchTokenBalance(t) {
          Li.balanceLoading = !0;
          const e = B.state.activeCaipNetwork?.caipNetworkId,
            r = B.state.activeCaipNetwork?.chainNamespace,
            i = B.state.activeCaipAddress,
            s = i ? X.getPlainAddress(i) : void 0;
          if (
            Li.lastRetry &&
            !X.isAllowedRetry(Li.lastRetry, 30 * Lt.ONE_SEC_MS)
          )
            return (Li.balanceLoading = !1), [];
          try {
            if (s && e && r) {
              const n = (await be.getBalance(s, e)).balances.filter(
                (o) => o.quantity.decimals !== "0"
              );
              return (
                this.setTokenBalance(n, r),
                (Li.lastRetry = void 0),
                (Li.balanceLoading = !1),
                n
              );
            }
          } catch (n) {
            (Li.lastRetry = Date.now()),
              t?.(n),
              at.showError("Token Balance Unavailable");
          } finally {
            Li.balanceLoading = !1;
          }
          return [];
        },
        resetAccount(t) {
          B.resetAccount(t);
        },
      },
      Jr = ot({
        loading: !1,
        loadingNamespaceMap: new Map(),
        open: !1,
        shake: !1,
        namespace: void 0,
      }),
      $e = {
        state: Jr,
        subscribe(t) {
          return Sr(Jr, () => t(Jr));
        },
        subscribeKey(t, e) {
          return Fr(Jr, t, e);
        },
        async open(t) {
          const e = fe.state.status === "connected";
          pe.state.wcBasic
            ? ne.prefetch({ fetchNetworkImages: !1, fetchConnectorImages: !1 })
            : await ne.prefetch({
                fetchConnectorImages: !e,
                fetchFeaturedWallets: !e,
                fetchRecommendedWallets: !e,
              }),
            t?.namespace
              ? (await B.switchActiveNamespace(t.namespace),
                $e.setLoading(!0, t.namespace))
              : $e.setLoading(!0),
            oe.setFilterByNamespace(t?.namespace);
          const r = B.getAccountData(t?.namespace)?.caipAddress;
          B.state.noAdapters && !r
            ? X.isMobile()
              ? ie.reset("AllWallets")
              : ie.reset("ConnectingWalletConnectBasic")
            : t?.view
            ? ie.reset(t.view, t.data)
            : r
            ? ie.reset("Account")
            : ie.reset("Connect"),
            (Jr.open = !0),
            pn.set({ open: !0 }),
            Se.sendEvent({
              type: "track",
              event: "MODAL_OPEN",
              properties: { connected: !!r },
            });
        },
        close() {
          const t = G.state.enableEmbedded,
            e = !!B.state.activeCaipAddress;
          Jr.open &&
            Se.sendEvent({
              type: "track",
              event: "MODAL_CLOSE",
              properties: { connected: e },
            }),
            (Jr.open = !1),
            $e.clearLoading(),
            t
              ? e
                ? ie.replace("Account")
                : ie.push("Connect")
              : pn.set({ open: !1 }),
            pe.resetUri();
        },
        setLoading(t, e) {
          e && Jr.loadingNamespaceMap.set(e, t),
            (Jr.loading = t),
            pn.set({ loading: t });
        },
        clearLoading() {
          Jr.loadingNamespaceMap.clear(), (Jr.loading = !1);
        },
        shake() {
          Jr.shake ||
            ((Jr.shake = !0),
            setTimeout(() => {
              Jr.shake = !1;
            }, 500));
        },
      },
      sC = {
        id: "2b92315d-eab7-5bef-84fa-089a131333f5",
        name: "USD Coin",
        symbol: "USDC",
        networks: [
          {
            name: "ethereum-mainnet",
            display_name: "Ethereum",
            chain_id: "1",
            contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
          },
          {
            name: "polygon-mainnet",
            display_name: "Polygon",
            chain_id: "137",
            contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
          },
        ],
      };
    ot({
      providers: XV,
      selectedProvider: null,
      error: null,
      purchaseCurrency: sC,
      paymentCurrency: {
        id: "USD",
        payment_method_limits: [
          { id: "card", min: "10.00", max: "7500.00" },
          { id: "ach_bank_account", min: "10.00", max: "25000.00" },
        ],
      },
      purchaseCurrencies: [sC],
      paymentCurrencies: [],
      quotesLoading: !1,
    });
    const DJ = {
      initializing: !1,
      initialized: !1,
      loadingPrices: !1,
      loadingQuote: !1,
      loadingApprovalTransaction: !1,
      loadingBuildTransaction: !1,
      loadingTransaction: !1,
      fetchError: !1,
      approvalTransaction: void 0,
      swapTransaction: void 0,
      transactionError: void 0,
      sourceToken: void 0,
      sourceTokenAmount: "",
      sourceTokenPriceInUSD: 0,
      toToken: void 0,
      toTokenAmount: "",
      toTokenPriceInUSD: 0,
      networkPrice: "0",
      networkBalanceInUSD: "0",
      networkTokenSymbol: "",
      inputError: void 0,
      slippage: Lt.CONVERT_SLIPPAGE_TOLERANCE,
      tokens: void 0,
      popularTokens: void 0,
      suggestedTokens: void 0,
      foundTokens: void 0,
      myTokensWithBalance: void 0,
      tokensPriceMap: {},
      gasFee: "0",
      gasPriceInUSD: 0,
      priceImpact: void 0,
      maxSlippage: void 0,
      providerFee: void 0,
    };
    ot(DJ);
    const ns = ot({
        message: "",
        open: !1,
        triggerRect: { width: 0, height: 0, top: 0, left: 0 },
        variant: "shade",
      }),
      al = {
        state: ns,
        subscribe(t) {
          return Sr(ns, () => t(ns));
        },
        subscribeKey(t, e) {
          return Fr(ns, t, e);
        },
        showTooltip({ message: t, triggerRect: e, variant: r }) {
          (ns.open = !0),
            (ns.message = t),
            (ns.triggerRect = e),
            (ns.variant = r);
        },
        hide() {
          (ns.open = !1),
            (ns.message = ""),
            (ns.triggerRect = { width: 0, height: 0, top: 0, left: 0 });
        },
      },
      nC = 2147483648,
      jJ = {
        convertEVMChainIdToCoinType(t) {
          if (t >= nC) throw new Error("Invalid chainId");
          return (nC | t) >>> 0;
        },
      },
      Ui = ot({ suggestions: [], loading: !1 }),
      oC = {
        state: Ui,
        subscribe(t) {
          return Sr(Ui, () => t(Ui));
        },
        subscribeKey(t, e) {
          return Fr(Ui, t, e);
        },
        async resolveName(t) {
          try {
            return await be.lookupEnsName(t);
          } catch (e) {
            const r = e;
            throw new Error(
              r?.reasons?.[0]?.description || "Error resolving name"
            );
          }
        },
        async isNameRegistered(t) {
          try {
            return await be.lookupEnsName(t), !0;
          } catch {
            return !1;
          }
        },
        async getSuggestions(t) {
          try {
            (Ui.loading = !0), (Ui.suggestions = []);
            const e = await be.getEnsNameSuggestions(t);
            return (
              (Ui.suggestions =
                e.suggestions.map((r) => ({ ...r, name: r.name })) || []),
              Ui.suggestions
            );
          } catch (e) {
            const r = this.parseEnsApiError(
              e,
              "Error fetching name suggestions"
            );
            throw new Error(r);
          } finally {
            Ui.loading = !1;
          }
        },
        async getNamesForAddress(t) {
          try {
            if (!B.state.activeCaipNetwork) return [];
            const e = de.getEnsFromCacheForAddress(t);
            if (e) return e;
            const r = await be.reverseLookupEnsName({ address: t });
            return (
              de.updateEnsCache({ address: t, ens: r, timestamp: Date.now() }),
              r
            );
          } catch (e) {
            const r = this.parseEnsApiError(
              e,
              "Error fetching names for address"
            );
            throw new Error(r);
          }
        },
        async registerName(t) {
          const e = B.state.activeCaipNetwork;
          if (!e) throw new Error("Network not found");
          const r = fe.state.address,
            i = oe.getAuthConnector();
          if (!r || !i) throw new Error("Address or auth connector not found");
          Ui.loading = !0;
          try {
            const s = JSON.stringify({
              name: t,
              attributes: {},
              timestamp: Math.floor(Date.now() / 1e3),
            });
            ie.pushTransactionStack({
              view: "RegisterAccountNameSuccess",
              goBack: !1,
              replace: !0,
              onCancel() {
                Ui.loading = !1;
              },
            });
            const n = await pe.signMessage(s),
              o = e.id;
            if (!o) throw new Error("Network not found");
            const a = jJ.convertEVMChainIdToCoinType(Number(o));
            await be.registerEnsName({
              coinType: a,
              address: r,
              signature: n,
              message: s,
            }),
              fe.setProfileName(t, e.chainNamespace),
              ie.replace("RegisterAccountNameSuccess");
          } catch (s) {
            const n = this.parseEnsApiError(s, `Error registering name ${t}`);
            throw (ie.replace("RegisterAccountName"), new Error(n));
          } finally {
            Ui.loading = !1;
          }
        },
        validateName(t) {
          return /^[a-zA-Z0-9-]{4,}$/u.test(t);
        },
        parseEnsApiError(t, e) {
          return t?.reasons?.[0]?.description || e;
        },
      };
    ot({ isLegalCheckboxChecked: !1 });
    var MJ = Object.defineProperty,
      zJ = (t, e, r) =>
        e in t
          ? MJ(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      aC = (t, e, r) => zJ(t, typeof e != "symbol" ? e + "" : e, r);
    class qJ extends ci {
      constructor(e) {
        super(),
          (this.opts = e),
          aC(this, "protocol", "wc"),
          aC(this, "version", 2);
      }
    }
    var HJ = Object.defineProperty,
      VJ = (t, e, r) =>
        e in t
          ? HJ(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      WJ = (t, e, r) => VJ(t, typeof e != "symbol" ? e + "" : e, r);
    class KJ extends ci {
      constructor(e, r) {
        super(),
          (this.core = e),
          (this.logger = r),
          WJ(this, "records", new Map());
      }
    }
    class GJ {
      constructor(e, r) {
        (this.logger = e), (this.core = r);
      }
    }
    class ZJ extends ci {
      constructor(e, r) {
        super(), (this.relayer = e), (this.logger = r);
      }
    }
    class YJ extends ci {
      constructor(e) {
        super();
      }
    }
    class JJ {
      constructor(e, r, i, s) {
        (this.core = e), (this.logger = r), (this.name = i);
      }
    }
    class XJ extends ci {
      constructor(e, r) {
        super(), (this.relayer = e), (this.logger = r);
      }
    }
    class QJ extends ci {
      constructor(e, r) {
        super(), (this.core = e), (this.logger = r);
      }
    }
    class eX {
      constructor(e, r, i) {
        (this.core = e), (this.logger = r), (this.store = i);
      }
    }
    class tX {
      constructor(e, r) {
        (this.projectId = e), (this.logger = r);
      }
    }
    class rX {
      constructor(e, r, i) {
        (this.core = e), (this.logger = r), (this.telemetryEnabled = i);
      }
    }
    var iX = Object.defineProperty,
      sX = (t, e, r) =>
        e in t
          ? iX(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      cC = (t, e, r) => sX(t, typeof e != "symbol" ? e + "" : e, r);
    class nX {
      constructor(e) {
        (this.opts = e), cC(this, "protocol", "wc"), cC(this, "version", 2);
      }
    }
    class oX {
      constructor(e) {
        this.client = e;
      }
    }
    function Oh(t, { strict: e = !0 } = {}) {
      return !t || typeof t != "string"
        ? !1
        : e
        ? /^0x[0-9a-fA-F]*$/.test(t)
        : t.startsWith("0x");
    }
    function lC(t) {
      return Oh(t, { strict: !1 }) ? Math.ceil((t.length - 2) / 2) : t.length;
    }
    const uC = "2.23.2";
    let km = {
      getDocsUrl: ({ docsBaseUrl: t, docsPath: e = "", docsSlug: r }) =>
        e ? `${t ?? "https://viem.sh"}${e}${r ? `#${r}` : ""}` : void 0,
      version: `viem@${uC}`,
    };
    class ha extends Error {
      constructor(e, r = {}) {
        const i =
            r.cause instanceof ha
              ? r.cause.details
              : r.cause?.message
              ? r.cause.message
              : r.details,
          s = (r.cause instanceof ha && r.cause.docsPath) || r.docsPath,
          n = km.getDocsUrl?.({ ...r, docsPath: s }),
          o = [
            e || "An error occurred.",
            "",
            ...(r.metaMessages ? [...r.metaMessages, ""] : []),
            ...(n ? [`Docs: ${n}`] : []),
            ...(i ? [`Details: ${i}`] : []),
            ...(km.version ? [`Version: ${km.version}`] : []),
          ].join(`
`);
        super(o, r.cause ? { cause: r.cause } : void 0),
          Object.defineProperty(this, "details", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "docsPath", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "metaMessages", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "shortMessage", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "version", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "BaseError",
          }),
          (this.details = i),
          (this.docsPath = s),
          (this.metaMessages = r.metaMessages),
          (this.name = r.name ?? this.name),
          (this.shortMessage = e),
          (this.version = uC);
      }
      walk(e) {
        return hC(this, e);
      }
    }
    function hC(t, e) {
      return e?.(t)
        ? t
        : t && typeof t == "object" && "cause" in t && t.cause !== void 0
        ? hC(t.cause, e)
        : e
        ? null
        : t;
    }
    class dC extends ha {
      constructor({ size: e, targetSize: r, type: i }) {
        super(
          `${i.charAt(0).toUpperCase()}${i
            .slice(1)
            .toLowerCase()} size (${e}) exceeds padding size (${r}).`,
          { name: "SizeExceedsPaddingSizeError" }
        );
      }
    }
    function cl(t, { dir: e, size: r = 32 } = {}) {
      return typeof t == "string"
        ? aX(t, { dir: e, size: r })
        : cX(t, { dir: e, size: r });
    }
    function aX(t, { dir: e, size: r = 32 } = {}) {
      if (r === null) return t;
      const i = t.replace("0x", "");
      if (i.length > r * 2)
        throw new dC({
          size: Math.ceil(i.length / 2),
          targetSize: r,
          type: "hex",
        });
      return `0x${i[e === "right" ? "padEnd" : "padStart"](r * 2, "0")}`;
    }
    function cX(t, { dir: e, size: r = 32 } = {}) {
      if (r === null) return t;
      if (t.length > r)
        throw new dC({ size: t.length, targetSize: r, type: "bytes" });
      const i = new Uint8Array(r);
      for (let s = 0; s < r; s++) {
        const n = e === "right";
        i[n ? s : r - s - 1] = t[n ? s : t.length - s - 1];
      }
      return i;
    }
    class lX extends ha {
      constructor({ max: e, min: r, signed: i, size: s, value: n }) {
        super(
          `Number "${n}" is not in safe ${
            s ? `${s * 8}-bit ${i ? "signed" : "unsigned"} ` : ""
          }integer range ${e ? `(${r} to ${e})` : `(above ${r})`}`,
          { name: "IntegerOutOfRangeError" }
        );
      }
    }
    class uX extends ha {
      constructor({ givenSize: e, maxSize: r }) {
        super(`Size cannot exceed ${r} bytes. Given size: ${e} bytes.`, {
          name: "SizeOverflowError",
        });
      }
    }
    function ll(t, { size: e }) {
      if (lC(t) > e) throw new uX({ givenSize: lC(t), maxSize: e });
    }
    function Rm(t, e = {}) {
      const { signed: r } = e;
      e.size && ll(t, { size: e.size });
      const i = BigInt(t);
      if (!r) return i;
      const s = (t.length - 2) / 2,
        n = (1n << (BigInt(s) * 8n - 1n)) - 1n;
      return i <= n ? i : i - BigInt(`0x${"f".padStart(s * 2, "f")}`) - 1n;
    }
    function hX(t, e = {}) {
      return Number(Rm(t, e));
    }
    const dX = Array.from({ length: 256 }, (t, e) =>
      e.toString(16).padStart(2, "0")
    );
    function $m(t, e = {}) {
      return typeof t == "number" || typeof t == "bigint"
        ? fC(t, e)
        : typeof t == "string"
        ? gX(t, e)
        : typeof t == "boolean"
        ? pX(t, e)
        : pC(t, e);
    }
    function pX(t, e = {}) {
      const r = `0x${Number(t)}`;
      return typeof e.size == "number"
        ? (ll(r, { size: e.size }), cl(r, { size: e.size }))
        : r;
    }
    function pC(t, e = {}) {
      let r = "";
      for (let s = 0; s < t.length; s++) r += dX[t[s]];
      const i = `0x${r}`;
      return typeof e.size == "number"
        ? (ll(i, { size: e.size }), cl(i, { dir: "right", size: e.size }))
        : i;
    }
    function fC(t, e = {}) {
      const { signed: r, size: i } = e,
        s = BigInt(t);
      let n;
      i
        ? r
          ? (n = (1n << (BigInt(i) * 8n - 1n)) - 1n)
          : (n = 2n ** (BigInt(i) * 8n) - 1n)
        : typeof t == "number" && (n = BigInt(Number.MAX_SAFE_INTEGER));
      const o = typeof n == "bigint" && r ? -n - 1n : 0;
      if ((n && s > n) || s < o) {
        const c = typeof t == "bigint" ? "n" : "";
        throw new lX({
          max: n ? `${n}${c}` : void 0,
          min: `${o}${c}`,
          signed: r,
          size: i,
          value: `${t}${c}`,
        });
      }
      const a = `0x${(r && s < 0
        ? (1n << BigInt(i * 8)) + BigInt(s)
        : s
      ).toString(16)}`;
      return i ? cl(a, { size: i }) : a;
    }
    const fX = new TextEncoder();
    function gX(t, e = {}) {
      const r = fX.encode(t);
      return pC(r, e);
    }
    const wX = new TextEncoder();
    function mX(t, e = {}) {
      return typeof t == "number" || typeof t == "bigint"
        ? bX(t, e)
        : typeof t == "boolean"
        ? yX(t, e)
        : Oh(t)
        ? wC(t, e)
        : mC(t, e);
    }
    function yX(t, e = {}) {
      const r = new Uint8Array(1);
      return (
        (r[0] = Number(t)),
        typeof e.size == "number"
          ? (ll(r, { size: e.size }), cl(r, { size: e.size }))
          : r
      );
    }
    const bn = { zero: 48, nine: 57, A: 65, F: 70, a: 97, f: 102 };
    function gC(t) {
      if (t >= bn.zero && t <= bn.nine) return t - bn.zero;
      if (t >= bn.A && t <= bn.F) return t - (bn.A - 10);
      if (t >= bn.a && t <= bn.f) return t - (bn.a - 10);
    }
    function wC(t, e = {}) {
      let r = t;
      e.size &&
        (ll(r, { size: e.size }), (r = cl(r, { dir: "right", size: e.size })));
      let i = r.slice(2);
      i.length % 2 && (i = `0${i}`);
      const s = i.length / 2,
        n = new Uint8Array(s);
      for (let o = 0, a = 0; o < s; o++) {
        const c = gC(i.charCodeAt(a++)),
          l = gC(i.charCodeAt(a++));
        if (c === void 0 || l === void 0)
          throw new ha(
            `Invalid byte sequence ("${i[a - 2]}${i[a - 1]}" in "${i}").`
          );
        n[o] = c * 16 + l;
      }
      return n;
    }
    function bX(t, e) {
      const r = fC(t, e);
      return wC(r);
    }
    function mC(t, e = {}) {
      const r = wX.encode(t);
      return typeof e.size == "number"
        ? (ll(r, { size: e.size }), cl(r, { dir: "right", size: e.size }))
        : r;
    }
    function yC(t, e) {
      const r = e || "hex",
        i = To(Oh(t, { strict: !1 }) ? mX(t) : t);
      return r === "bytes" ? i : $m(i);
    }
    class bC extends Map {
      constructor(e) {
        super(),
          Object.defineProperty(this, "maxSize", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          (this.maxSize = e);
      }
      get(e) {
        const r = super.get(e);
        return (
          super.has(e) && r !== void 0 && (this.delete(e), super.set(e, r)), r
        );
      }
      set(e, r) {
        if ((super.set(e, r), this.maxSize && this.size > this.maxSize)) {
          const i = this.keys().next().value;
          i && this.delete(i);
        }
        return this;
      }
    }
    const Fm = new bC(8192);
    function vX(t, e) {
      if (Fm.has(`${t}.${e}`)) return Fm.get(`${t}.${e}`);
      const r = e ? `${e}${t.toLowerCase()}` : t.substring(2).toLowerCase(),
        i = yC(mC(r), "bytes"),
        s = (e ? r.substring(`${e}0x`.length) : r).split("");
      for (let o = 0; o < 40; o += 2)
        i[o >> 1] >> 4 >= 8 && s[o] && (s[o] = s[o].toUpperCase()),
          (i[o >> 1] & 15) >= 8 &&
            s[o + 1] &&
            (s[o + 1] = s[o + 1].toUpperCase());
      const n = `0x${s.join("")}`;
      return Fm.set(`${t}.${e}`, n), n;
    }
    function EX(t) {
      const e = yC(`0x${t.substring(4)}`).substring(26);
      return vX(`0x${e}`);
    }
    async function CX({ hash: t, signature: e }) {
      const r = Oh(t) ? t : $m(t),
        { secp256k1: i } = await Promise.resolve().then(function () {
          return X2;
        });
      return `0x${(() => {
        if (typeof e == "object" && "r" in e && "s" in e) {
          const { r: a, s: c, v: l, yParity: u } = e,
            h = Number(u ?? l),
            d = vC(h);
          return new i.Signature(Rm(a), Rm(c)).addRecoveryBit(d);
        }
        const s = Oh(e) ? e : $m(e),
          n = hX(`0x${s.slice(130)}`),
          o = vC(n);
        return i.Signature.fromCompact(s.substring(2, 130)).addRecoveryBit(o);
      })()
        .recoverPublicKey(r.substring(2))
        .toHex(!1)}`;
    }
    function vC(t) {
      if (t === 0 || t === 1) return t;
      if (t === 27) return 0;
      if (t === 28) return 1;
      throw new Error("Invalid yParityOrV value");
    }
    async function xX({ hash: t, signature: e }) {
      return EX(await CX({ hash: t, signature: e }));
    }
    new bC(128);
    const IX = "0.1.1";
    function _X() {
      return IX;
    }
    class Dr extends Error {
      constructor(e, r = {}) {
        const i = (() => {
            if (r.cause instanceof Dr) {
              if (r.cause.details) return r.cause.details;
              if (r.cause.shortMessage) return r.cause.shortMessage;
            }
            return r.cause?.message ? r.cause.message : r.details;
          })(),
          s = (r.cause instanceof Dr && r.cause.docsPath) || r.docsPath,
          n = `https://oxlib.sh${s ?? ""}`,
          o = [
            e || "An error occurred.",
            ...(r.metaMessages ? ["", ...r.metaMessages] : []),
            ...(i || s
              ? ["", i ? `Details: ${i}` : void 0, s ? `See: ${n}` : void 0]
              : []),
          ].filter((a) => typeof a == "string").join(`
`);
        super(o, r.cause ? { cause: r.cause } : void 0),
          Object.defineProperty(this, "details", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "docs", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "docsPath", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "shortMessage", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "cause", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "BaseError",
          }),
          Object.defineProperty(this, "version", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: `ox@${_X()}`,
          }),
          (this.cause = r.cause),
          (this.details = i),
          (this.docs = n),
          (this.docsPath = s),
          (this.shortMessage = e);
      }
      walk(e) {
        return EC(this, e);
      }
    }
    function EC(t, e) {
      return e?.(t)
        ? t
        : t && typeof t == "object" && "cause" in t && t.cause
        ? EC(t.cause, e)
        : e
        ? null
        : t;
    }
    function AX(t, e) {
      if (IC(t) > e) throw new $X({ givenSize: IC(t), maxSize: e });
    }
    const vn = { zero: 48, nine: 57, A: 65, F: 70, a: 97, f: 102 };
    function CC(t) {
      if (t >= vn.zero && t <= vn.nine) return t - vn.zero;
      if (t >= vn.A && t <= vn.F) return t - (vn.A - 10);
      if (t >= vn.a && t <= vn.f) return t - (vn.a - 10);
    }
    function SX(t, e = {}) {
      const { dir: r, size: i = 32 } = e;
      if (i === 0) return t;
      if (t.length > i)
        throw new FX({ size: t.length, targetSize: i, type: "Bytes" });
      const s = new Uint8Array(i);
      for (let n = 0; n < i; n++) {
        const o = r === "right";
        s[o ? n : i - n - 1] = t[o ? n : t.length - n - 1];
      }
      return s;
    }
    function Bm(t, e) {
      if (Um(t) > e) throw new zX({ givenSize: Um(t), maxSize: e });
    }
    function xC(t, e = {}) {
      const { dir: r, size: i = 32 } = e;
      if (i === 0) return t;
      const s = t.replace("0x", "");
      if (s.length > i * 2)
        throw new qX({
          size: Math.ceil(s.length / 2),
          targetSize: i,
          type: "Hex",
        });
      return `0x${s[r === "right" ? "padEnd" : "padStart"](i * 2, "0")}`;
    }
    const PX = new TextEncoder();
    function OX(t) {
      return t instanceof Uint8Array ? t : typeof t == "string" ? TX(t) : NX(t);
    }
    function NX(t) {
      return t instanceof Uint8Array ? t : new Uint8Array(t);
    }
    function TX(t, e = {}) {
      const { size: r } = e;
      let i = t;
      r && (Bm(t, r), (i = Lm(t, r)));
      let s = i.slice(2);
      s.length % 2 && (s = `0${s}`);
      const n = s.length / 2,
        o = new Uint8Array(n);
      for (let a = 0, c = 0; a < n; a++) {
        const l = CC(s.charCodeAt(c++)),
          u = CC(s.charCodeAt(c++));
        if (l === void 0 || u === void 0)
          throw new Dr(
            `Invalid byte sequence ("${s[c - 2]}${s[c - 1]}" in "${s}").`
          );
        o[a] = l * 16 + u;
      }
      return o;
    }
    function kX(t, e = {}) {
      const { size: r } = e,
        i = PX.encode(t);
      return typeof r == "number" ? (AX(i, r), RX(i, r)) : i;
    }
    function RX(t, e) {
      return SX(t, { dir: "right", size: e });
    }
    function IC(t) {
      return t.length;
    }
    class $X extends Dr {
      constructor({ givenSize: e, maxSize: r }) {
        super(`Size cannot exceed \`${r}\` bytes. Given size: \`${e}\` bytes.`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Bytes.SizeOverflowError",
          });
      }
    }
    class FX extends Dr {
      constructor({ size: e, targetSize: r, type: i }) {
        super(
          `${i.charAt(0).toUpperCase()}${i
            .slice(1)
            .toLowerCase()} size (\`${e}\`) exceeds padding size (\`${r}\`).`
        ),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Bytes.SizeExceedsPaddingSizeError",
          });
      }
    }
    const BX = new TextEncoder(),
      LX = Array.from({ length: 256 }, (t, e) =>
        e.toString(16).padStart(2, "0")
      );
    function _C(...t) {
      return `0x${t.reduce((e, r) => e + r.replace("0x", ""), "")}`;
    }
    function UX(t, e = {}) {
      const r = `0x${Number(t)}`;
      return typeof e.size == "number" ? (Bm(r, e.size), Sf(r, e.size)) : r;
    }
    function AC(t, e = {}) {
      let r = "";
      for (let s = 0; s < t.length; s++) r += LX[t[s]];
      const i = `0x${r}`;
      return typeof e.size == "number" ? (Bm(i, e.size), Lm(i, e.size)) : i;
    }
    function DX(t, e = {}) {
      const { signed: r, size: i } = e,
        s = BigInt(t);
      let n;
      i
        ? r
          ? (n = (1n << (BigInt(i) * 8n - 1n)) - 1n)
          : (n = 2n ** (BigInt(i) * 8n) - 1n)
        : typeof t == "number" && (n = BigInt(Number.MAX_SAFE_INTEGER));
      const o = typeof n == "bigint" && r ? -n - 1n : 0;
      if ((n && s > n) || s < o) {
        const c = typeof t == "bigint" ? "n" : "";
        throw new MX({
          max: n ? `${n}${c}` : void 0,
          min: `${o}${c}`,
          signed: r,
          size: i,
          value: `${t}${c}`,
        });
      }
      const a = `0x${(r && s < 0
        ? (1n << BigInt(i * 8)) + BigInt(s)
        : s
      ).toString(16)}`;
      return i ? Sf(a, i) : a;
    }
    function jX(t, e = {}) {
      return AC(BX.encode(t), e);
    }
    function Sf(t, e) {
      return xC(t, { dir: "left", size: e });
    }
    function Lm(t, e) {
      return xC(t, { dir: "right", size: e });
    }
    function Um(t) {
      return Math.ceil((t.length - 2) / 2);
    }
    class MX extends Dr {
      constructor({ max: e, min: r, signed: i, size: s, value: n }) {
        super(
          `Number \`${n}\` is not in safe${s ? ` ${s * 8}-bit` : ""}${
            i ? " signed" : " unsigned"
          } integer range ${e ? `(\`${r}\` to \`${e}\`)` : `(above \`${r}\`)`}`
        ),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Hex.IntegerOutOfRangeError",
          });
      }
    }
    class zX extends Dr {
      constructor({ givenSize: e, maxSize: r }) {
        super(`Size cannot exceed \`${r}\` bytes. Given size: \`${e}\` bytes.`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Hex.SizeOverflowError",
          });
      }
    }
    class qX extends Dr {
      constructor({ size: e, targetSize: r, type: i }) {
        super(
          `${i.charAt(0).toUpperCase()}${i
            .slice(1)
            .toLowerCase()} size (\`${e}\`) exceeds padding size (\`${r}\`).`
        ),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Hex.SizeExceedsPaddingSizeError",
          });
      }
    }
    function HX(t, e = {}) {
      const { as: r = typeof t == "string" ? "Hex" : "Bytes" } = e,
        i = To(OX(t));
      return r === "Bytes" ? i : AC(i);
    }
    class VX extends Map {
      constructor(e) {
        super(),
          Object.defineProperty(this, "maxSize", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0,
          }),
          (this.maxSize = e);
      }
      get(e) {
        const r = super.get(e);
        return (
          super.has(e) && r !== void 0 && (this.delete(e), super.set(e, r)), r
        );
      }
      set(e, r) {
        if ((super.set(e, r), this.maxSize && this.size > this.maxSize)) {
          const i = this.keys().next().value;
          i && this.delete(i);
        }
        return this;
      }
    }
    const Dm = { checksum: new VX(8192) }.checksum,
      WX = /^0x[a-fA-F0-9]{40}$/;
    function SC(t, e = {}) {
      const { strict: r = !0 } = e;
      if (!WX.test(t)) throw new PC({ address: t, cause: new GX() });
      if (r) {
        if (t.toLowerCase() === t) return;
        if (KX(t) !== t) throw new PC({ address: t, cause: new ZX() });
      }
    }
    function KX(t) {
      if (Dm.has(t)) return Dm.get(t);
      SC(t, { strict: !1 });
      const e = t.substring(2).toLowerCase(),
        r = HX(kX(e), { as: "Bytes" }),
        i = e.split("");
      for (let n = 0; n < 40; n += 2)
        r[n >> 1] >> 4 >= 8 && i[n] && (i[n] = i[n].toUpperCase()),
          (r[n >> 1] & 15) >= 8 &&
            i[n + 1] &&
            (i[n + 1] = i[n + 1].toUpperCase());
      const s = `0x${i.join("")}`;
      return Dm.set(t, s), s;
    }
    class PC extends Dr {
      constructor({ address: e, cause: r }) {
        super(`Address "${e}" is invalid.`, { cause: r }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Address.InvalidAddressError",
          });
      }
    }
    class GX extends Dr {
      constructor() {
        super("Address is not a 20 byte (40 hexadecimal character) value."),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Address.InvalidInputError",
          });
      }
    }
    class ZX extends Dr {
      constructor() {
        super("Address does not match its checksum counterpart."),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Address.InvalidChecksumError",
          });
      }
    }
    const YX = /^(.*)\[([0-9]*)\]$/,
      JX = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,
      XX =
        /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
    function jm(t, e) {
      if (t.length !== e.length)
        throw new eQ({ expectedLength: t.length, givenLength: e.length });
      const r = [];
      for (let i = 0; i < t.length; i++) {
        const s = t[i],
          n = e[i];
        r.push(jm.encode(s, n));
      }
      return _C(...r);
    }
    (function (t) {
      function e(r, i, s = !1) {
        if (r === "address") {
          const c = i;
          return SC(c), Sf(c.toLowerCase(), s ? 32 : 0);
        }
        if (r === "string") return jX(i);
        if (r === "bytes") return i;
        if (r === "bool") return Sf(UX(i), s ? 32 : 1);
        const n = r.match(XX);
        if (n) {
          const [c, l, u = "256"] = n,
            h = Number.parseInt(u) / 8;
          return DX(i, { size: s ? 32 : h, signed: l === "int" });
        }
        const o = r.match(JX);
        if (o) {
          const [c, l] = o;
          if (Number.parseInt(l) !== (i.length - 2) / 2)
            throw new QX({ expectedSize: Number.parseInt(l), value: i });
          return Lm(i, s ? 32 : 0);
        }
        const a = r.match(YX);
        if (a && Array.isArray(i)) {
          const [c, l] = a,
            u = [];
          for (let h = 0; h < i.length; h++) u.push(e(l, i[h], !0));
          return u.length === 0 ? "0x" : _C(...u);
        }
        throw new tQ(r);
      }
      t.encode = e;
    })(jm || (jm = {}));
    class QX extends Dr {
      constructor({ expectedSize: e, value: r }) {
        super(
          `Size of bytes "${r}" (bytes${Um(
            r
          )}) does not match expected size (bytes${e}).`
        ),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiParameters.BytesSizeMismatchError",
          });
      }
    }
    class eQ extends Dr {
      constructor({ expectedLength: e, givenLength: r }) {
        super(
          [
            "ABI encoding parameters/values length mismatch.",
            `Expected length (parameters): ${e}`,
            `Given length (values): ${r}`,
          ].join(`
`)
        ),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiParameters.LengthMismatchError",
          });
      }
    }
    class tQ extends Dr {
      constructor(e) {
        super(`Type \`${e}\` is not a valid ABI Type.`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiParameters.InvalidTypeError",
          });
      }
    }
    const rQ = ":";
    function ul(t) {
      const [e, r] = t.split(rQ);
      return { namespace: e, reference: r };
    }
    function OC(t, e) {
      return t.includes(":") ? [t] : e.chains || [];
    }
    var iQ = Object.defineProperty,
      sQ = Object.defineProperties,
      nQ = Object.getOwnPropertyDescriptors,
      NC = Object.getOwnPropertySymbols,
      oQ = Object.prototype.hasOwnProperty,
      aQ = Object.prototype.propertyIsEnumerable,
      TC = (t, e, r) =>
        e in t
          ? iQ(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      kC = (t, e) => {
        for (var r in e || (e = {})) oQ.call(e, r) && TC(t, r, e[r]);
        if (NC) for (var r of NC(e)) aQ.call(e, r) && TC(t, r, e[r]);
        return t;
      },
      cQ = (t, e) => sQ(t, nQ(e));
    const lQ = "ReactNative",
      vi = {
        reactNative: "react-native",
        node: "node",
        browser: "browser",
        unknown: "unknown",
      },
      uQ = "js";
    function Pf() {
      return (
        typeof ut < "u" &&
        typeof ut.versions < "u" &&
        typeof ut.versions.node < "u"
      );
    }
    function uo() {
      return !Gi() && !!tu() && navigator.product === lQ;
    }
    function hQ() {
      return (
        uo() &&
        typeof globalThis < "u" &&
        typeof globalThis?.Platform < "u" &&
        globalThis?.Platform.OS === "android"
      );
    }
    function dQ() {
      return (
        uo() &&
        typeof globalThis < "u" &&
        typeof globalThis?.Platform < "u" &&
        globalThis?.Platform.OS === "ios"
      );
    }
    function Nh() {
      return !Pf() && !!tu() && !!Gi();
    }
    function Th() {
      return uo()
        ? vi.reactNative
        : Pf()
        ? vi.node
        : Nh()
        ? vi.browser
        : vi.unknown;
    }
    function RC() {
      var t;
      try {
        return uo() &&
          typeof globalThis < "u" &&
          typeof globalThis?.Application < "u"
          ? (t = globalThis.Application) == null
            ? void 0
            : t.applicationId
          : void 0;
      } catch {
        return;
      }
    }
    function pQ(t, e) {
      const r = new URLSearchParams(t);
      for (const i of Object.keys(e).sort())
        if (e.hasOwnProperty(i)) {
          const s = e[i];
          s !== void 0 && r.set(i, s);
        }
      return r.toString();
    }
    function fQ(t) {
      var e, r;
      const i = $C();
      try {
        return (
          t != null &&
            t.url &&
            i.url &&
            t.url !== i.url &&
            (console.warn(
              `The configured WalletConnect 'metadata.url':${t.url} differs from the actual page url:${i.url}. This is probably unintended and can lead to issues.`
            ),
            (t.url = i.url)),
          (e = t?.icons) != null &&
            e.length &&
            t.icons.length > 0 &&
            (t.icons = t.icons.filter((s) => s !== "")),
          cQ(kC(kC({}, i), t), {
            url: t?.url || i.url,
            name: t?.name || i.name,
            description: t?.description || i.description,
            icons:
              (r = t?.icons) != null && r.length && t.icons.length > 0
                ? t.icons
                : i.icons,
          })
        );
      } catch (s) {
        return console.warn("Error populating app metadata", s), t || i;
      }
    }
    function $C() {
      return cg() || { name: "", description: "", url: "", icons: [""] };
    }
    function gQ() {
      if (
        Th() === vi.reactNative &&
        typeof globalThis < "u" &&
        typeof globalThis?.Platform < "u"
      ) {
        const { OS: r, Version: i } = globalThis.Platform;
        return [r, i].join("-");
      }
      const t = Pv();
      if (t === null) return "unknown";
      const e = t.os ? t.os.replace(" ", "").toLowerCase() : "unknown";
      return t.type === "browser"
        ? [e, t.name, t.version].join("-")
        : [e, t.version].join("-");
    }
    function wQ() {
      var t;
      const e = Th();
      return e === vi.browser
        ? [e, ((t = og()) == null ? void 0 : t.host) || "unknown"].join(":")
        : e;
    }
    function FC(t, e, r) {
      const i = gQ(),
        s = wQ();
      return [[t, e].join("-"), [uQ, r].join("-"), i, s].join("/");
    }
    function mQ({
      protocol: t,
      version: e,
      relayUrl: r,
      sdkVersion: i,
      auth: s,
      projectId: n,
      useOnCloseEvent: o,
      bundleId: a,
      packageName: c,
    }) {
      const l = r.split("?"),
        u = FC(t, e, i),
        h = {
          auth: s,
          ua: u,
          projectId: n,
          useOnCloseEvent: o || void 0,
          packageName: c || void 0,
          bundleId: a || void 0,
        },
        d = pQ(l[1] || "", h);
      return l[0] + "?" + d;
    }
    function da(t, e) {
      return t.filter((r) => e.includes(r)).length === t.length;
    }
    function Mm(t) {
      return Object.fromEntries(t.entries());
    }
    function zm(t) {
      return new Map(Object.entries(t));
    }
    function pa(t = z.FIVE_MINUTES, e) {
      const r = z.toMiliseconds(t || z.FIVE_MINUTES);
      let i, s, n, o;
      return {
        resolve: (a) => {
          n && i && (clearTimeout(n), i(a), (o = Promise.resolve(a)));
        },
        reject: (a) => {
          n && s && (clearTimeout(n), s(a));
        },
        done: () =>
          new Promise((a, c) => {
            if (o) return a(o);
            (n = setTimeout(() => {
              const l = new Error(e);
              (o = Promise.reject(l)), c(l);
            }, r)),
              (i = a),
              (s = c);
          }),
      };
    }
    function ho(t, e, r) {
      return new Promise(async (i, s) => {
        const n = setTimeout(() => s(new Error(r)), e);
        try {
          const o = await t;
          i(o);
        } catch (o) {
          s(o);
        }
        clearTimeout(n);
      });
    }
    function BC(t, e) {
      if (typeof e == "string" && e.startsWith(`${t}:`)) return e;
      if (t.toLowerCase() === "topic") {
        if (typeof e != "string")
          throw new Error(
            'Value must be "string" for expirer target type: topic'
          );
        return `topic:${e}`;
      } else if (t.toLowerCase() === "id") {
        if (typeof e != "number")
          throw new Error('Value must be "number" for expirer target type: id');
        return `id:${e}`;
      }
      throw new Error(`Unknown expirer target type: ${t}`);
    }
    function yQ(t) {
      return BC("topic", t);
    }
    function bQ(t) {
      return BC("id", t);
    }
    function LC(t) {
      const [e, r] = t.split(":"),
        i = { id: void 0, topic: void 0 };
      if (e === "topic" && typeof r == "string") i.topic = r;
      else if (e === "id" && Number.isInteger(Number(r))) i.id = Number(r);
      else
        throw new Error(
          `Invalid target, expected id:number or topic:string, got ${e}:${r}`
        );
      return i;
    }
    function Mt(t, e) {
      return z.fromMiliseconds((e || Date.now()) + z.toMiliseconds(t));
    }
    function po(t) {
      return Date.now() >= z.toMiliseconds(t);
    }
    function Ke(t, e) {
      return `${t}${e ? `:${e}` : ""}`;
    }
    function Of(t = [], e = []) {
      return [...new Set([...t, ...e])];
    }
    async function vQ({ id: t, topic: e, wcDeepLink: r }) {
      var i;
      try {
        if (!r) return;
        const s = typeof r == "string" ? JSON.parse(r) : r,
          n = s?.href;
        if (typeof n != "string") return;
        const o = EQ(n, t, e),
          a = Th();
        if (a === vi.browser) {
          if (!((i = Gi()) != null && i.hasFocus())) {
            console.warn("Document does not have focus, skipping deeplink.");
            return;
          }
          CQ(o);
        } else a === vi.reactNative && typeof globalThis?.Linking < "u" && (await globalThis.Linking.openURL(o));
      } catch (s) {
        console.error(s);
      }
    }
    function EQ(t, e, r) {
      const i = `requestId=${e}&sessionTopic=${r}`;
      t.endsWith("/") && (t = t.slice(0, -1));
      let s = `${t}`;
      if (t.startsWith("https://t.me")) {
        const n = t.includes("?") ? "&startapp=" : "?startapp=";
        s = `${s}${n}${AQ(i, !0)}`;
      } else s = `${s}/wc?${i}`;
      return s;
    }
    function CQ(t) {
      let e = "_self";
      _Q()
        ? (e = "_top")
        : (IQ() || t.startsWith("https://") || t.startsWith("http://")) &&
          (e = "_blank"),
        window.open(t, e, "noreferrer noopener");
    }
    async function xQ(t, e) {
      let r = "";
      try {
        if (Nh() && ((r = localStorage.getItem(e)), r)) return r;
        r = await t.getItem(e);
      } catch (i) {
        console.error(i);
      }
      return r;
    }
    function UC(t, e) {
      if (!t.includes(e)) return null;
      const r = t.split(/([&,?,=])/),
        i = r.indexOf(e);
      return r[i + 2];
    }
    function DC() {
      return typeof crypto < "u" && crypto != null && crypto.randomUUID
        ? crypto.randomUUID()
        : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (t) => {
            const e = (Math.random() * 16) | 0;
            return (t === "x" ? e : (e & 3) | 8).toString(16);
          });
    }
    function qm() {
      return typeof ut < "u" && {}.IS_VITEST === "true";
    }
    function IQ() {
      return (
        typeof window < "u" &&
        (!!window.TelegramWebviewProxy ||
          !!window.Telegram ||
          !!window.TelegramWebviewProxyProto)
      );
    }
    function _Q() {
      try {
        return window.self !== window.top;
      } catch {
        return !1;
      }
    }
    function AQ(t, e = !1) {
      const r = Fe.from(t).toString("base64");
      return e ? r.replace(/[=]/g, "") : r;
    }
    function jC(t) {
      return Fe.from(t, "base64").toString("utf-8");
    }
    function SQ(t) {
      return new Promise((e) => setTimeout(e, t));
    }
    function kh(t) {
      if (!Number.isSafeInteger(t) || t < 0)
        throw new Error("positive integer expected, got " + t);
    }
    function PQ(t) {
      return (
        t instanceof Uint8Array ||
        (ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array")
      );
    }
    function Rh(t, ...e) {
      if (!PQ(t)) throw new Error("Uint8Array expected");
      if (e.length > 0 && !e.includes(t.length))
        throw new Error(
          "Uint8Array expected of length " + e + ", got length=" + t.length
        );
    }
    function Hm(t) {
      if (typeof t != "function" || typeof t.create != "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      kh(t.outputLen), kh(t.blockLen);
    }
    function hl(t, e = !0) {
      if (t.destroyed) throw new Error("Hash instance has been destroyed");
      if (e && t.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function MC(t, e) {
      Rh(t);
      const r = e.outputLen;
      if (t.length < r)
        throw new Error(
          "digestInto() expects output buffer of length at least " + r
        );
    }
    const Nf = BigInt(2 ** 32 - 1),
      zC = BigInt(32);
    function OQ(t, e = !1) {
      return e
        ? { h: Number(t & Nf), l: Number((t >> zC) & Nf) }
        : { h: Number((t >> zC) & Nf) | 0, l: Number(t & Nf) | 0 };
    }
    function NQ(t, e = !1) {
      let r = new Uint32Array(t.length),
        i = new Uint32Array(t.length);
      for (let s = 0; s < t.length; s++) {
        const { h: n, l: o } = OQ(t[s], e);
        [r[s], i[s]] = [n, o];
      }
      return [r, i];
    }
    const TQ = (t, e, r) => (t << r) | (e >>> (32 - r)),
      kQ = (t, e, r) => (e << r) | (t >>> (32 - r)),
      RQ = (t, e, r) => (e << (r - 32)) | (t >>> (64 - r)),
      $Q = (t, e, r) => (t << (r - 32)) | (e >>> (64 - r)),
      dl =
        typeof globalThis == "object" && "crypto" in globalThis
          ? globalThis.crypto
          : void 0;
    function FQ(t) {
      return new Uint32Array(
        t.buffer,
        t.byteOffset,
        Math.floor(t.byteLength / 4)
      );
    }
    function Vm(t) {
      return new DataView(t.buffer, t.byteOffset, t.byteLength);
    }
    function Ns(t, e) {
      return (t << (32 - e)) | (t >>> e);
    }
    const qC = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    function BQ(t) {
      return (
        ((t << 24) & 4278190080) |
        ((t << 8) & 16711680) |
        ((t >>> 8) & 65280) |
        ((t >>> 24) & 255)
      );
    }
    function HC(t) {
      for (let e = 0; e < t.length; e++) t[e] = BQ(t[e]);
    }
    function LQ(t) {
      if (typeof t != "string")
        throw new Error("utf8ToBytes expected string, got " + typeof t);
      return new Uint8Array(new TextEncoder().encode(t));
    }
    function pl(t) {
      return typeof t == "string" && (t = LQ(t)), Rh(t), t;
    }
    function UQ(...t) {
      let e = 0;
      for (let i = 0; i < t.length; i++) {
        const s = t[i];
        Rh(s), (e += s.length);
      }
      const r = new Uint8Array(e);
      for (let i = 0, s = 0; i < t.length; i++) {
        const n = t[i];
        r.set(n, s), (s += n.length);
      }
      return r;
    }
    class Wm {
      clone() {
        return this._cloneInto();
      }
    }
    function VC(t) {
      const e = (i) => t().update(pl(i)).digest(),
        r = t();
      return (
        (e.outputLen = r.outputLen),
        (e.blockLen = r.blockLen),
        (e.create = () => t()),
        e
      );
    }
    function fl(t = 32) {
      if (dl && typeof dl.getRandomValues == "function")
        return dl.getRandomValues(new Uint8Array(t));
      if (dl && typeof dl.randomBytes == "function") return dl.randomBytes(t);
      throw new Error("crypto.getRandomValues must be defined");
    }
    const WC = [],
      KC = [],
      GC = [],
      DQ = BigInt(0),
      $h = BigInt(1),
      jQ = BigInt(2),
      MQ = BigInt(7),
      zQ = BigInt(256),
      qQ = BigInt(113);
    for (let t = 0, e = $h, r = 1, i = 0; t < 24; t++) {
      ([r, i] = [i, (2 * r + 3 * i) % 5]),
        WC.push(2 * (5 * i + r)),
        KC.push((((t + 1) * (t + 2)) / 2) % 64);
      let s = DQ;
      for (let n = 0; n < 7; n++)
        (e = ((e << $h) ^ ((e >> MQ) * qQ)) % zQ),
          e & jQ && (s ^= $h << (($h << BigInt(n)) - $h));
      GC.push(s);
    }
    const [HQ, VQ] = NQ(GC, !0),
      ZC = (t, e, r) => (r > 32 ? RQ(t, e, r) : TQ(t, e, r)),
      YC = (t, e, r) => (r > 32 ? $Q(t, e, r) : kQ(t, e, r));
    function WQ(t, e = 24) {
      const r = new Uint32Array(10);
      for (let i = 24 - e; i < 24; i++) {
        for (let o = 0; o < 10; o++)
          r[o] = t[o] ^ t[o + 10] ^ t[o + 20] ^ t[o + 30] ^ t[o + 40];
        for (let o = 0; o < 10; o += 2) {
          const a = (o + 8) % 10,
            c = (o + 2) % 10,
            l = r[c],
            u = r[c + 1],
            h = ZC(l, u, 1) ^ r[a],
            d = YC(l, u, 1) ^ r[a + 1];
          for (let g = 0; g < 50; g += 10) (t[o + g] ^= h), (t[o + g + 1] ^= d);
        }
        let s = t[2],
          n = t[3];
        for (let o = 0; o < 24; o++) {
          const a = KC[o],
            c = ZC(s, n, a),
            l = YC(s, n, a),
            u = WC[o];
          (s = t[u]), (n = t[u + 1]), (t[u] = c), (t[u + 1] = l);
        }
        for (let o = 0; o < 50; o += 10) {
          for (let a = 0; a < 10; a++) r[a] = t[o + a];
          for (let a = 0; a < 10; a++)
            t[o + a] ^= ~r[(a + 2) % 10] & r[(a + 4) % 10];
        }
        (t[0] ^= HQ[i]), (t[1] ^= VQ[i]);
      }
      r.fill(0);
    }
    class Km extends Wm {
      constructor(e, r, i, s = !1, n = 24) {
        if (
          (super(),
          (this.blockLen = e),
          (this.suffix = r),
          (this.outputLen = i),
          (this.enableXOF = s),
          (this.rounds = n),
          (this.pos = 0),
          (this.posOut = 0),
          (this.finished = !1),
          (this.destroyed = !1),
          kh(i),
          0 >= this.blockLen || this.blockLen >= 200)
        )
          throw new Error("Sha3 supports only keccak-f1600 function");
        (this.state = new Uint8Array(200)), (this.state32 = FQ(this.state));
      }
      keccak() {
        qC || HC(this.state32),
          WQ(this.state32, this.rounds),
          qC || HC(this.state32),
          (this.posOut = 0),
          (this.pos = 0);
      }
      update(e) {
        hl(this);
        const { blockLen: r, state: i } = this;
        e = pl(e);
        const s = e.length;
        for (let n = 0; n < s; ) {
          const o = Math.min(r - this.pos, s - n);
          for (let a = 0; a < o; a++) i[this.pos++] ^= e[n++];
          this.pos === r && this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished) return;
        this.finished = !0;
        const { state: e, suffix: r, pos: i, blockLen: s } = this;
        (e[i] ^= r),
          (r & 128) !== 0 && i === s - 1 && this.keccak(),
          (e[s - 1] ^= 128),
          this.keccak();
      }
      writeInto(e) {
        hl(this, !1), Rh(e), this.finish();
        const r = this.state,
          { blockLen: i } = this;
        for (let s = 0, n = e.length; s < n; ) {
          this.posOut >= i && this.keccak();
          const o = Math.min(i - this.posOut, n - s);
          e.set(r.subarray(this.posOut, this.posOut + o), s),
            (this.posOut += o),
            (s += o);
        }
        return e;
      }
      xofInto(e) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(e);
      }
      xof(e) {
        return kh(e), this.xofInto(new Uint8Array(e));
      }
      digestInto(e) {
        if ((MC(e, this), this.finished))
          throw new Error("digest() was already called");
        return this.writeInto(e), this.destroy(), e;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        (this.destroyed = !0), this.state.fill(0);
      }
      _cloneInto(e) {
        const {
          blockLen: r,
          suffix: i,
          outputLen: s,
          rounds: n,
          enableXOF: o,
        } = this;
        return (
          e || (e = new Km(r, i, s, o, n)),
          e.state32.set(this.state32),
          (e.pos = this.pos),
          (e.posOut = this.posOut),
          (e.finished = this.finished),
          (e.rounds = n),
          (e.suffix = i),
          (e.outputLen = s),
          (e.enableXOF = o),
          (e.destroyed = this.destroyed),
          e
        );
      }
    }
    const KQ = (t, e, r) => VC(() => new Km(e, t, r)),
      GQ = KQ(1, 136, 256 / 8),
      ZQ = "https://rpc.walletconnect.org/v1";
    function JC(t) {
      const e = `Ethereum Signed Message:
${t.length}`,
        r = new TextEncoder().encode(e + t);
      return "0x" + Fe.from(GQ(r)).toString("hex");
    }
    async function YQ(t, e, r, i, s, n) {
      switch (r.t) {
        case "eip191":
          return await JQ(t, e, r.s);
        case "eip1271":
          return await XQ(t, e, r.s, i, s, n);
        default:
          throw new Error(
            `verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${r.t}`
          );
      }
    }
    async function JQ(t, e, r) {
      return (
        (await xX({ hash: JC(e), signature: r })).toLowerCase() ===
        t.toLowerCase()
      );
    }
    async function XQ(t, e, r, i, s, n) {
      const o = ul(i);
      if (!o.namespace || !o.reference)
        throw new Error(
          `isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${i}`
        );
      try {
        const a = "0x1626ba7e",
          c =
            "0000000000000000000000000000000000000000000000000000000000000040",
          l =
            "0000000000000000000000000000000000000000000000000000000000000041",
          u = r.substring(2),
          h = JC(e).substring(2),
          d = a + h + c + l + u,
          g = await fetch(`${n || ZQ}/?chainId=${i}&projectId=${s}`, {
            method: "POST",
            body: JSON.stringify({
              id: QQ(),
              jsonrpc: "2.0",
              method: "eth_call",
              params: [{ to: t, data: d }, "latest"],
            }),
          }),
          { result: p } = await g.json();
        return p ? p.slice(0, a.length).toLowerCase() === a.toLowerCase() : !1;
      } catch (a) {
        return console.error("isValidEip1271Signature: ", a), !1;
      }
    }
    function QQ() {
      return Date.now() + Math.floor(Math.random() * 1e3);
    }
    function eee(t) {
      const e = atob(t),
        r = new Uint8Array(e.length);
      for (let o = 0; o < e.length; o++) r[o] = e.charCodeAt(o);
      const i = r[0];
      if (i === 0) throw new Error("No signatures found");
      const s = 1 + i * 64;
      if (r.length < s)
        throw new Error(
          "Transaction data too short for claimed signature count"
        );
      if (r.length < 100) throw new Error("Transaction too short");
      const n = Fe.from(t, "base64").slice(1, 65);
      return Dg.encode(n);
    }
    var tee = Object.defineProperty,
      ree = Object.defineProperties,
      iee = Object.getOwnPropertyDescriptors,
      XC = Object.getOwnPropertySymbols,
      see = Object.prototype.hasOwnProperty,
      nee = Object.prototype.propertyIsEnumerable,
      QC = (t, e, r) =>
        e in t
          ? tee(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      oee = (t, e) => {
        for (var r in e || (e = {})) see.call(e, r) && QC(t, r, e[r]);
        if (XC) for (var r of XC(e)) nee.call(e, r) && QC(t, r, e[r]);
        return t;
      },
      aee = (t, e) => ree(t, iee(e));
    const cee = "did:pkh:",
      Gm = (t) => t?.split(":"),
      lee = (t) => {
        const e = t && Gm(t);
        if (e) return t.includes(cee) ? e[3] : e[1];
      },
      Zm = (t) => {
        const e = t && Gm(t);
        if (e) return e[2] + ":" + e[3];
      },
      Tf = (t) => {
        const e = t && Gm(t);
        if (e) return e.pop();
      };
    async function e7(t) {
      const { cacao: e, projectId: r } = t,
        { s: i, p: s } = e,
        n = t7(s, s.iss),
        o = Tf(s.iss);
      return await YQ(o, n, i, Zm(s.iss), r);
    }
    const t7 = (t, e) => {
      const r = `${t.domain} wants you to sign in with your Ethereum account:`,
        i = Tf(e);
      if (!t.aud && !t.uri)
        throw new Error(
          "Either `aud` or `uri` is required to construct the message"
        );
      let s = t.statement || void 0;
      const n = `URI: ${t.aud || t.uri}`,
        o = `Version: ${t.version}`,
        a = `Chain ID: ${lee(e)}`,
        c = `Nonce: ${t.nonce}`,
        l = `Issued At: ${t.iat}`,
        u = t.exp ? `Expiration Time: ${t.exp}` : void 0,
        h = t.nbf ? `Not Before: ${t.nbf}` : void 0,
        d = t.requestId ? `Request ID: ${t.requestId}` : void 0,
        g = t.resources
          ? `Resources:${t.resources
              .map(
                (w) => `
- ${w}`
              )
              .join("")}`
          : void 0,
        p = kf(t.resources);
      if (p) {
        const w = Fh(p);
        s = yee(s, w);
      }
      return [r, i, "", s, "", n, o, a, c, l, u, h, d, g].filter(
        (w) => w != null
      ).join(`
`);
    };
    function uee(t) {
      return Fe.from(JSON.stringify(t)).toString("base64");
    }
    function hee(t) {
      return JSON.parse(Fe.from(t, "base64").toString("utf-8"));
    }
    function fa(t) {
      if (!t) throw new Error("No recap provided, value is undefined");
      if (!t.att) throw new Error("No `att` property found");
      const e = Object.keys(t.att);
      if (!(e != null && e.length))
        throw new Error("No resources found in `att` property");
      e.forEach((r) => {
        const i = t.att[r];
        if (Array.isArray(i))
          throw new Error(`Resource must be an object: ${r}`);
        if (typeof i != "object")
          throw new Error(`Resource must be an object: ${r}`);
        if (!Object.keys(i).length)
          throw new Error(`Resource object is empty: ${r}`);
        Object.keys(i).forEach((s) => {
          const n = i[s];
          if (!Array.isArray(n))
            throw new Error(
              `Ability limits ${s} must be an array of objects, found: ${n}`
            );
          if (!n.length)
            throw new Error(
              `Value of ${s} is empty array, must be an array with objects`
            );
          n.forEach((o) => {
            if (typeof o != "object")
              throw new Error(
                `Ability limits (${s}) must be an array of objects, found: ${o}`
              );
          });
        });
      });
    }
    function dee(t, e, r, i = {}) {
      return (
        r?.sort((s, n) => s.localeCompare(n)), { att: { [t]: pee(e, r, i) } }
      );
    }
    function pee(t, e, r = {}) {
      e = e?.sort((s, n) => s.localeCompare(n));
      const i = e.map((s) => ({ [`${t}/${s}`]: [r] }));
      return Object.assign({}, ...i);
    }
    function r7(t) {
      return fa(t), `urn:recap:${uee(t).replace(/=/g, "")}`;
    }
    function Fh(t) {
      const e = hee(t.replace("urn:recap:", ""));
      return fa(e), e;
    }
    function fee(t, e, r) {
      const i = dee(t, e, r);
      return r7(i);
    }
    function gee(t) {
      return t && t.includes("urn:recap:");
    }
    function wee(t, e) {
      const r = Fh(t),
        i = Fh(e),
        s = mee(r, i);
      return r7(s);
    }
    function mee(t, e) {
      fa(t), fa(e);
      const r = Object.keys(t.att)
          .concat(Object.keys(e.att))
          .sort((s, n) => s.localeCompare(n)),
        i = { att: {} };
      return (
        r.forEach((s) => {
          var n, o;
          Object.keys(((n = t.att) == null ? void 0 : n[s]) || {})
            .concat(Object.keys(((o = e.att) == null ? void 0 : o[s]) || {}))
            .sort((a, c) => a.localeCompare(c))
            .forEach((a) => {
              var c, l;
              i.att[s] = aee(oee({}, i.att[s]), {
                [a]:
                  ((c = t.att[s]) == null ? void 0 : c[a]) ||
                  ((l = e.att[s]) == null ? void 0 : l[a]),
              });
            });
        }),
        i
      );
    }
    function yee(t = "", e) {
      fa(e);
      const r =
        "I further authorize the stated URI to perform the following actions on my behalf: ";
      if (t.includes(r)) return t;
      const i = [];
      let s = 0;
      Object.keys(e.att).forEach((a) => {
        const c = Object.keys(e.att[a]).map((h) => ({
          ability: h.split("/")[0],
          action: h.split("/")[1],
        }));
        c.sort((h, d) => h.action.localeCompare(d.action));
        const l = {};
        c.forEach((h) => {
          l[h.ability] || (l[h.ability] = []), l[h.ability].push(h.action);
        });
        const u = Object.keys(l).map(
          (h) => (s++, `(${s}) '${h}': '${l[h].join("', '")}' for '${a}'.`)
        );
        i.push(u.join(", ").replace(".,", "."));
      });
      const n = i.join(" "),
        o = `${r}${n}`;
      return `${t ? t + " " : ""}${o}`;
    }
    function i7(t) {
      var e;
      const r = Fh(t);
      fa(r);
      const i = (e = r.att) == null ? void 0 : e.eip155;
      return i ? Object.keys(i).map((s) => s.split("/")[1]) : [];
    }
    function s7(t) {
      const e = Fh(t);
      fa(e);
      const r = [];
      return (
        Object.values(e.att).forEach((i) => {
          Object.values(i).forEach((s) => {
            var n;
            (n = s?.[0]) != null && n.chains && r.push(s[0].chains);
          });
        }),
        [...new Set(r.flat())]
      );
    }
    function kf(t) {
      if (!t) return;
      const e = t?.[t.length - 1];
      return gee(e) ? e : void 0;
    }
    function Ym(t) {
      if (!Number.isSafeInteger(t) || t < 0)
        throw new Error("positive integer expected, got " + t);
    }
    function n7(t) {
      return (
        t instanceof Uint8Array ||
        (ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array")
      );
    }
    function Ei(t, ...e) {
      if (!n7(t)) throw new Error("Uint8Array expected");
      if (e.length > 0 && !e.includes(t.length))
        throw new Error(
          "Uint8Array expected of length " + e + ", got length=" + t.length
        );
    }
    function o7(t, e = !0) {
      if (t.destroyed) throw new Error("Hash instance has been destroyed");
      if (e && t.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function bee(t, e) {
      Ei(t);
      const r = e.outputLen;
      if (t.length < r)
        throw new Error(
          "digestInto() expects output buffer of length at least " + r
        );
    }
    function a7(t) {
      if (typeof t != "boolean") throw new Error(`boolean expected, not ${t}`);
    }
    const fo = (t) =>
        new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4)),
      vee = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength);
    if (new Uint8Array(new Uint32Array([287454020]).buffer)[0] !== 68)
      throw new Error("Non little-endian hardware is not supported");
    function Eee(t) {
      if (typeof t != "string") throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(t));
    }
    function Jm(t) {
      if (typeof t == "string") t = Eee(t);
      else if (n7(t)) t = Xm(t);
      else throw new Error("Uint8Array expected, got " + typeof t);
      return t;
    }
    function Cee(t, e) {
      if (e == null || typeof e != "object")
        throw new Error("options must be defined");
      return Object.assign(t, e);
    }
    function xee(t, e) {
      if (t.length !== e.length) return !1;
      let r = 0;
      for (let i = 0; i < t.length; i++) r |= t[i] ^ e[i];
      return r === 0;
    }
    const Iee = (t, e) => {
      function r(i, ...s) {
        if ((Ei(i), t.nonceLength !== void 0)) {
          const l = s[0];
          if (!l) throw new Error("nonce / iv required");
          t.varSizeNonce ? Ei(l) : Ei(l, t.nonceLength);
        }
        const n = t.tagLength;
        n && s[1] !== void 0 && Ei(s[1]);
        const o = e(i, ...s),
          a = (l, u) => {
            if (u !== void 0) {
              if (l !== 2) throw new Error("cipher output not supported");
              Ei(u);
            }
          };
        let c = !1;
        return {
          encrypt(l, u) {
            if (c)
              throw new Error("cannot encrypt() twice with same key + nonce");
            return (c = !0), Ei(l), a(o.encrypt.length, u), o.encrypt(l, u);
          },
          decrypt(l, u) {
            if ((Ei(l), n && l.length < n))
              throw new Error(
                "invalid ciphertext length: smaller than tagLength=" + n
              );
            return a(o.decrypt.length, u), o.decrypt(l, u);
          },
        };
      }
      return Object.assign(r, t), r;
    };
    function c7(t, e, r = !0) {
      if (e === void 0) return new Uint8Array(t);
      if (e.length !== t)
        throw new Error(
          "invalid output length, expected " + t + ", got: " + e.length
        );
      if (r && !_ee(e)) throw new Error("invalid output, must be aligned");
      return e;
    }
    function l7(t, e, r, i) {
      if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, r, i);
      const s = BigInt(32),
        n = BigInt(4294967295),
        o = Number((r >> s) & n),
        a = Number(r & n),
        c = i ? 4 : 0,
        l = i ? 0 : 4;
      t.setUint32(e + c, o, i), t.setUint32(e + l, a, i);
    }
    function _ee(t) {
      return t.byteOffset % 4 === 0;
    }
    function Xm(t) {
      return Uint8Array.from(t);
    }
    function gl(...t) {
      for (let e = 0; e < t.length; e++) t[e].fill(0);
    }
    const u7 = (t) => Uint8Array.from(t.split("").map((e) => e.charCodeAt(0))),
      Aee = u7("expand 16-byte k"),
      See = u7("expand 32-byte k"),
      Pee = fo(Aee),
      Oee = fo(See);
    function je(t, e) {
      return (t << e) | (t >>> (32 - e));
    }
    function Qm(t) {
      return t.byteOffset % 4 === 0;
    }
    const Rf = 64,
      Nee = 16,
      h7 = 2 ** 32 - 1,
      d7 = new Uint32Array();
    function Tee(t, e, r, i, s, n, o, a) {
      const c = s.length,
        l = new Uint8Array(Rf),
        u = fo(l),
        h = Qm(s) && Qm(n),
        d = h ? fo(s) : d7,
        g = h ? fo(n) : d7;
      for (let p = 0; p < c; o++) {
        if ((t(e, r, i, u, o, a), o >= h7))
          throw new Error("arx: counter overflow");
        const w = Math.min(Rf, c - p);
        if (h && w === Rf) {
          const f = p / 4;
          if (p % 4 !== 0) throw new Error("arx: invalid block position");
          for (let m = 0, y; m < Nee; m++) (y = f + m), (g[y] = d[y] ^ u[m]);
          p += Rf;
          continue;
        }
        for (let f = 0, m; f < w; f++) (m = p + f), (n[m] = s[m] ^ l[f]);
        p += w;
      }
    }
    function kee(t, e) {
      const {
        allowShortKeys: r,
        extendNonceFn: i,
        counterLength: s,
        counterRight: n,
        rounds: o,
      } = Cee(
        { allowShortKeys: !1, counterLength: 8, counterRight: !1, rounds: 20 },
        e
      );
      if (typeof t != "function") throw new Error("core must be a function");
      return (
        Ym(s),
        Ym(o),
        a7(n),
        a7(r),
        (a, c, l, u, h = 0) => {
          Ei(a), Ei(c), Ei(l);
          const d = l.length;
          if (
            (u === void 0 && (u = new Uint8Array(d)),
            Ei(u),
            Ym(h),
            h < 0 || h >= h7)
          )
            throw new Error("arx: counter overflow");
          if (u.length < d)
            throw new Error(
              `arx: output (${u.length}) is shorter than data (${d})`
            );
          const g = [];
          let p = a.length,
            w,
            f;
          if (p === 32) g.push((w = Xm(a))), (f = Oee);
          else if (p === 16 && r)
            (w = new Uint8Array(32)),
              w.set(a),
              w.set(a, 16),
              (f = Pee),
              g.push(w);
          else throw new Error(`arx: invalid 32-byte key, got length=${p}`);
          Qm(c) || g.push((c = Xm(c)));
          const m = fo(w);
          if (i) {
            if (c.length !== 24)
              throw new Error("arx: extended nonce must be 24 bytes");
            i(f, m, fo(c.subarray(0, 16)), m), (c = c.subarray(16));
          }
          const y = 16 - s;
          if (y !== c.length)
            throw new Error(`arx: nonce must be ${y} or 16 bytes`);
          if (y !== 12) {
            const C = new Uint8Array(12);
            C.set(c, n ? 0 : 12 - c.length), (c = C), g.push(c);
          }
          const E = fo(c);
          return Tee(t, f, m, E, l, u, h, o), gl(...g), u;
        }
      );
    }
    const mr = (t, e) => (t[e++] & 255) | ((t[e++] & 255) << 8);
    class Ree {
      constructor(e) {
        (this.blockLen = 16),
          (this.outputLen = 16),
          (this.buffer = new Uint8Array(16)),
          (this.r = new Uint16Array(10)),
          (this.h = new Uint16Array(10)),
          (this.pad = new Uint16Array(8)),
          (this.pos = 0),
          (this.finished = !1),
          (e = Jm(e)),
          Ei(e, 32);
        const r = mr(e, 0),
          i = mr(e, 2),
          s = mr(e, 4),
          n = mr(e, 6),
          o = mr(e, 8),
          a = mr(e, 10),
          c = mr(e, 12),
          l = mr(e, 14);
        (this.r[0] = r & 8191),
          (this.r[1] = ((r >>> 13) | (i << 3)) & 8191),
          (this.r[2] = ((i >>> 10) | (s << 6)) & 7939),
          (this.r[3] = ((s >>> 7) | (n << 9)) & 8191),
          (this.r[4] = ((n >>> 4) | (o << 12)) & 255),
          (this.r[5] = (o >>> 1) & 8190),
          (this.r[6] = ((o >>> 14) | (a << 2)) & 8191),
          (this.r[7] = ((a >>> 11) | (c << 5)) & 8065),
          (this.r[8] = ((c >>> 8) | (l << 8)) & 8191),
          (this.r[9] = (l >>> 5) & 127);
        for (let u = 0; u < 8; u++) this.pad[u] = mr(e, 16 + 2 * u);
      }
      process(e, r, i = !1) {
        const s = i ? 0 : 2048,
          { h: n, r: o } = this,
          a = o[0],
          c = o[1],
          l = o[2],
          u = o[3],
          h = o[4],
          d = o[5],
          g = o[6],
          p = o[7],
          w = o[8],
          f = o[9],
          m = mr(e, r + 0),
          y = mr(e, r + 2),
          E = mr(e, r + 4),
          C = mr(e, r + 6),
          O = mr(e, r + 8),
          A = mr(e, r + 10),
          P = mr(e, r + 12),
          N = mr(e, r + 14);
        let x = n[0] + (m & 8191),
          $ = n[1] + (((m >>> 13) | (y << 3)) & 8191),
          k = n[2] + (((y >>> 10) | (E << 6)) & 8191),
          F = n[3] + (((E >>> 7) | (C << 9)) & 8191),
          j = n[4] + (((C >>> 4) | (O << 12)) & 8191),
          I = n[5] + ((O >>> 1) & 8191),
          b = n[6] + (((O >>> 14) | (A << 2)) & 8191),
          v = n[7] + (((A >>> 11) | (P << 5)) & 8191),
          S = n[8] + (((P >>> 8) | (N << 8)) & 8191),
          T = n[9] + ((N >>> 5) | s),
          _ = 0,
          R = _ + x * a + $ * (5 * f) + k * (5 * w) + F * (5 * p) + j * (5 * g);
        (_ = R >>> 13),
          (R &= 8191),
          (R +=
            I * (5 * d) +
            b * (5 * h) +
            v * (5 * u) +
            S * (5 * l) +
            T * (5 * c)),
          (_ += R >>> 13),
          (R &= 8191);
        let U = _ + x * c + $ * a + k * (5 * f) + F * (5 * w) + j * (5 * p);
        (_ = U >>> 13),
          (U &= 8191),
          (U +=
            I * (5 * g) +
            b * (5 * d) +
            v * (5 * h) +
            S * (5 * u) +
            T * (5 * l)),
          (_ += U >>> 13),
          (U &= 8191);
        let D = _ + x * l + $ * c + k * a + F * (5 * f) + j * (5 * w);
        (_ = D >>> 13),
          (D &= 8191),
          (D +=
            I * (5 * p) +
            b * (5 * g) +
            v * (5 * d) +
            S * (5 * h) +
            T * (5 * u)),
          (_ += D >>> 13),
          (D &= 8191);
        let H = _ + x * u + $ * l + k * c + F * a + j * (5 * f);
        (_ = H >>> 13),
          (H &= 8191),
          (H +=
            I * (5 * w) +
            b * (5 * p) +
            v * (5 * g) +
            S * (5 * d) +
            T * (5 * h)),
          (_ += H >>> 13),
          (H &= 8191);
        let q = _ + x * h + $ * u + k * l + F * c + j * a;
        (_ = q >>> 13),
          (q &= 8191),
          (q +=
            I * (5 * f) +
            b * (5 * w) +
            v * (5 * p) +
            S * (5 * g) +
            T * (5 * d)),
          (_ += q >>> 13),
          (q &= 8191);
        let V = _ + x * d + $ * h + k * u + F * l + j * c;
        (_ = V >>> 13),
          (V &= 8191),
          (V += I * a + b * (5 * f) + v * (5 * w) + S * (5 * p) + T * (5 * g)),
          (_ += V >>> 13),
          (V &= 8191);
        let Y = _ + x * g + $ * d + k * h + F * u + j * l;
        (_ = Y >>> 13),
          (Y &= 8191),
          (Y += I * c + b * a + v * (5 * f) + S * (5 * w) + T * (5 * p)),
          (_ += Y >>> 13),
          (Y &= 8191);
        let ae = _ + x * p + $ * g + k * d + F * h + j * u;
        (_ = ae >>> 13),
          (ae &= 8191),
          (ae += I * l + b * c + v * a + S * (5 * f) + T * (5 * w)),
          (_ += ae >>> 13),
          (ae &= 8191);
        let re = _ + x * w + $ * p + k * g + F * d + j * h;
        (_ = re >>> 13),
          (re &= 8191),
          (re += I * u + b * l + v * c + S * a + T * (5 * f)),
          (_ += re >>> 13),
          (re &= 8191);
        let te = _ + x * f + $ * w + k * p + F * g + j * d;
        (_ = te >>> 13),
          (te &= 8191),
          (te += I * h + b * u + v * l + S * c + T * a),
          (_ += te >>> 13),
          (te &= 8191),
          (_ = ((_ << 2) + _) | 0),
          (_ = (_ + R) | 0),
          (R = _ & 8191),
          (_ = _ >>> 13),
          (U += _),
          (n[0] = R),
          (n[1] = U),
          (n[2] = D),
          (n[3] = H),
          (n[4] = q),
          (n[5] = V),
          (n[6] = Y),
          (n[7] = ae),
          (n[8] = re),
          (n[9] = te);
      }
      finalize() {
        const { h: e, pad: r } = this,
          i = new Uint16Array(10);
        let s = e[1] >>> 13;
        e[1] &= 8191;
        for (let a = 2; a < 10; a++)
          (e[a] += s), (s = e[a] >>> 13), (e[a] &= 8191);
        (e[0] += s * 5),
          (s = e[0] >>> 13),
          (e[0] &= 8191),
          (e[1] += s),
          (s = e[1] >>> 13),
          (e[1] &= 8191),
          (e[2] += s),
          (i[0] = e[0] + 5),
          (s = i[0] >>> 13),
          (i[0] &= 8191);
        for (let a = 1; a < 10; a++)
          (i[a] = e[a] + s), (s = i[a] >>> 13), (i[a] &= 8191);
        i[9] -= 8192;
        let n = (s ^ 1) - 1;
        for (let a = 0; a < 10; a++) i[a] &= n;
        n = ~n;
        for (let a = 0; a < 10; a++) e[a] = (e[a] & n) | i[a];
        (e[0] = (e[0] | (e[1] << 13)) & 65535),
          (e[1] = ((e[1] >>> 3) | (e[2] << 10)) & 65535),
          (e[2] = ((e[2] >>> 6) | (e[3] << 7)) & 65535),
          (e[3] = ((e[3] >>> 9) | (e[4] << 4)) & 65535),
          (e[4] = ((e[4] >>> 12) | (e[5] << 1) | (e[6] << 14)) & 65535),
          (e[5] = ((e[6] >>> 2) | (e[7] << 11)) & 65535),
          (e[6] = ((e[7] >>> 5) | (e[8] << 8)) & 65535),
          (e[7] = ((e[8] >>> 8) | (e[9] << 5)) & 65535);
        let o = e[0] + r[0];
        e[0] = o & 65535;
        for (let a = 1; a < 8; a++)
          (o = (((e[a] + r[a]) | 0) + (o >>> 16)) | 0), (e[a] = o & 65535);
        gl(i);
      }
      update(e) {
        o7(this);
        const { buffer: r, blockLen: i } = this;
        e = Jm(e);
        const s = e.length;
        for (let n = 0; n < s; ) {
          const o = Math.min(i - this.pos, s - n);
          if (o === i) {
            for (; i <= s - n; n += i) this.process(e, n);
            continue;
          }
          r.set(e.subarray(n, n + o), this.pos),
            (this.pos += o),
            (n += o),
            this.pos === i && (this.process(r, 0, !1), (this.pos = 0));
        }
        return this;
      }
      destroy() {
        gl(this.h, this.r, this.buffer, this.pad);
      }
      digestInto(e) {
        o7(this), bee(e, this), (this.finished = !0);
        const { buffer: r, h: i } = this;
        let { pos: s } = this;
        if (s) {
          for (r[s++] = 1; s < 16; s++) r[s] = 0;
          this.process(r, 0, !0);
        }
        this.finalize();
        let n = 0;
        for (let o = 0; o < 8; o++)
          (e[n++] = i[o] >>> 0), (e[n++] = i[o] >>> 8);
        return e;
      }
      digest() {
        const { buffer: e, outputLen: r } = this;
        this.digestInto(e);
        const i = e.slice(0, r);
        return this.destroy(), i;
      }
    }
    function $ee(t) {
      const e = (i, s) => t(s).update(Jm(i)).digest(),
        r = t(new Uint8Array(32));
      return (
        (e.outputLen = r.outputLen),
        (e.blockLen = r.blockLen),
        (e.create = (i) => t(i)),
        e
      );
    }
    const Fee = $ee((t) => new Ree(t));
    function Bee(t, e, r, i, s, n = 20) {
      let o = t[0],
        a = t[1],
        c = t[2],
        l = t[3],
        u = e[0],
        h = e[1],
        d = e[2],
        g = e[3],
        p = e[4],
        w = e[5],
        f = e[6],
        m = e[7],
        y = s,
        E = r[0],
        C = r[1],
        O = r[2],
        A = o,
        P = a,
        N = c,
        x = l,
        $ = u,
        k = h,
        F = d,
        j = g,
        I = p,
        b = w,
        v = f,
        S = m,
        T = y,
        _ = E,
        R = C,
        U = O;
      for (let H = 0; H < n; H += 2)
        (A = (A + $) | 0),
          (T = je(T ^ A, 16)),
          (I = (I + T) | 0),
          ($ = je($ ^ I, 12)),
          (A = (A + $) | 0),
          (T = je(T ^ A, 8)),
          (I = (I + T) | 0),
          ($ = je($ ^ I, 7)),
          (P = (P + k) | 0),
          (_ = je(_ ^ P, 16)),
          (b = (b + _) | 0),
          (k = je(k ^ b, 12)),
          (P = (P + k) | 0),
          (_ = je(_ ^ P, 8)),
          (b = (b + _) | 0),
          (k = je(k ^ b, 7)),
          (N = (N + F) | 0),
          (R = je(R ^ N, 16)),
          (v = (v + R) | 0),
          (F = je(F ^ v, 12)),
          (N = (N + F) | 0),
          (R = je(R ^ N, 8)),
          (v = (v + R) | 0),
          (F = je(F ^ v, 7)),
          (x = (x + j) | 0),
          (U = je(U ^ x, 16)),
          (S = (S + U) | 0),
          (j = je(j ^ S, 12)),
          (x = (x + j) | 0),
          (U = je(U ^ x, 8)),
          (S = (S + U) | 0),
          (j = je(j ^ S, 7)),
          (A = (A + k) | 0),
          (U = je(U ^ A, 16)),
          (v = (v + U) | 0),
          (k = je(k ^ v, 12)),
          (A = (A + k) | 0),
          (U = je(U ^ A, 8)),
          (v = (v + U) | 0),
          (k = je(k ^ v, 7)),
          (P = (P + F) | 0),
          (T = je(T ^ P, 16)),
          (S = (S + T) | 0),
          (F = je(F ^ S, 12)),
          (P = (P + F) | 0),
          (T = je(T ^ P, 8)),
          (S = (S + T) | 0),
          (F = je(F ^ S, 7)),
          (N = (N + j) | 0),
          (_ = je(_ ^ N, 16)),
          (I = (I + _) | 0),
          (j = je(j ^ I, 12)),
          (N = (N + j) | 0),
          (_ = je(_ ^ N, 8)),
          (I = (I + _) | 0),
          (j = je(j ^ I, 7)),
          (x = (x + $) | 0),
          (R = je(R ^ x, 16)),
          (b = (b + R) | 0),
          ($ = je($ ^ b, 12)),
          (x = (x + $) | 0),
          (R = je(R ^ x, 8)),
          (b = (b + R) | 0),
          ($ = je($ ^ b, 7));
      let D = 0;
      (i[D++] = (o + A) | 0),
        (i[D++] = (a + P) | 0),
        (i[D++] = (c + N) | 0),
        (i[D++] = (l + x) | 0),
        (i[D++] = (u + $) | 0),
        (i[D++] = (h + k) | 0),
        (i[D++] = (d + F) | 0),
        (i[D++] = (g + j) | 0),
        (i[D++] = (p + I) | 0),
        (i[D++] = (w + b) | 0),
        (i[D++] = (f + v) | 0),
        (i[D++] = (m + S) | 0),
        (i[D++] = (y + T) | 0),
        (i[D++] = (E + _) | 0),
        (i[D++] = (C + R) | 0),
        (i[D++] = (O + U) | 0);
    }
    const Lee = kee(Bee, {
        counterRight: !1,
        counterLength: 4,
        allowShortKeys: !1,
      }),
      Uee = new Uint8Array(16),
      p7 = (t, e) => {
        t.update(e);
        const r = e.length % 16;
        r && t.update(Uee.subarray(r));
      },
      Dee = new Uint8Array(32);
    function f7(t, e, r, i, s) {
      const n = t(e, r, Dee),
        o = Fee.create(n);
      s && p7(o, s), p7(o, i);
      const a = new Uint8Array(16),
        c = vee(a);
      l7(c, 0, BigInt(s ? s.length : 0), !0),
        l7(c, 8, BigInt(i.length), !0),
        o.update(a);
      const l = o.digest();
      return gl(n, a), l;
    }
    const jee = (t) => (e, r, i) => ({
        encrypt(s, n) {
          const o = s.length;
          (n = c7(o + 16, n, !1)), n.set(s);
          const a = n.subarray(0, -16);
          t(e, r, a, a, 1);
          const c = f7(t, e, r, a, i);
          return n.set(c, o), gl(c), n;
        },
        decrypt(s, n) {
          n = c7(s.length - 16, n, !1);
          const o = s.subarray(0, -16),
            a = s.subarray(-16),
            c = f7(t, e, r, o, i);
          if (!xee(a, c)) throw new Error("invalid tag");
          return n.set(s.subarray(0, -16)), t(e, r, n, n, 1), gl(c), n;
        },
      }),
      g7 = Iee({ blockSize: 64, nonceLength: 12, tagLength: 16 }, jee(Lee));
    class w7 extends Wm {
      constructor(e, r) {
        super(), (this.finished = !1), (this.destroyed = !1), Hm(e);
        const i = pl(r);
        if (((this.iHash = e.create()), typeof this.iHash.update != "function"))
          throw new Error(
            "Expected instance of class which extends utils.Hash"
          );
        (this.blockLen = this.iHash.blockLen),
          (this.outputLen = this.iHash.outputLen);
        const s = this.blockLen,
          n = new Uint8Array(s);
        n.set(i.length > s ? e.create().update(i).digest() : i);
        for (let o = 0; o < n.length; o++) n[o] ^= 54;
        this.iHash.update(n), (this.oHash = e.create());
        for (let o = 0; o < n.length; o++) n[o] ^= 106;
        this.oHash.update(n), n.fill(0);
      }
      update(e) {
        return hl(this), this.iHash.update(e), this;
      }
      digestInto(e) {
        hl(this),
          Rh(e, this.outputLen),
          (this.finished = !0),
          this.iHash.digestInto(e),
          this.oHash.update(e),
          this.oHash.digestInto(e),
          this.destroy();
      }
      digest() {
        const e = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(e), e;
      }
      _cloneInto(e) {
        e || (e = Object.create(Object.getPrototypeOf(this), {}));
        const {
          oHash: r,
          iHash: i,
          finished: s,
          destroyed: n,
          blockLen: o,
          outputLen: a,
        } = this;
        return (
          (e = e),
          (e.finished = s),
          (e.destroyed = n),
          (e.blockLen = o),
          (e.outputLen = a),
          (e.oHash = r._cloneInto(e.oHash)),
          (e.iHash = i._cloneInto(e.iHash)),
          e
        );
      }
      destroy() {
        (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
      }
    }
    const $f = (t, e, r) => new w7(t, e).update(r).digest();
    $f.create = (t, e) => new w7(t, e);
    function Mee(t, e, r) {
      return (
        Hm(t),
        r === void 0 && (r = new Uint8Array(t.outputLen)),
        $f(t, pl(r), pl(e))
      );
    }
    const ey = new Uint8Array([0]),
      m7 = new Uint8Array();
    function zee(t, e, r, i = 32) {
      if ((Hm(t), kh(i), i > 255 * t.outputLen))
        throw new Error("Length should be <= 255*HashLen");
      const s = Math.ceil(i / t.outputLen);
      r === void 0 && (r = m7);
      const n = new Uint8Array(s * t.outputLen),
        o = $f.create(t, e),
        a = o._cloneInto(),
        c = new Uint8Array(o.outputLen);
      for (let l = 0; l < s; l++)
        (ey[0] = l + 1),
          a
            .update(l === 0 ? m7 : c)
            .update(r)
            .update(ey)
            .digestInto(c),
          n.set(c, t.outputLen * l),
          o._cloneInto(a);
      return o.destroy(), a.destroy(), c.fill(0), ey.fill(0), n.slice(0, i);
    }
    const qee = (t, e, r, i, s) => zee(t, Mee(t, e, r), i, s);
    function Hee(t, e, r, i) {
      if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, r, i);
      const s = BigInt(32),
        n = BigInt(4294967295),
        o = Number((r >> s) & n),
        a = Number(r & n),
        c = i ? 4 : 0,
        l = i ? 0 : 4;
      t.setUint32(e + c, o, i), t.setUint32(e + l, a, i);
    }
    function Vee(t, e, r) {
      return (t & e) ^ (~t & r);
    }
    function Wee(t, e, r) {
      return (t & e) ^ (t & r) ^ (e & r);
    }
    class Kee extends Wm {
      constructor(e, r, i, s) {
        super(),
          (this.blockLen = e),
          (this.outputLen = r),
          (this.padOffset = i),
          (this.isLE = s),
          (this.finished = !1),
          (this.length = 0),
          (this.pos = 0),
          (this.destroyed = !1),
          (this.buffer = new Uint8Array(e)),
          (this.view = Vm(this.buffer));
      }
      update(e) {
        hl(this);
        const { view: r, buffer: i, blockLen: s } = this;
        e = pl(e);
        const n = e.length;
        for (let o = 0; o < n; ) {
          const a = Math.min(s - this.pos, n - o);
          if (a === s) {
            const c = Vm(e);
            for (; s <= n - o; o += s) this.process(c, o);
            continue;
          }
          i.set(e.subarray(o, o + a), this.pos),
            (this.pos += a),
            (o += a),
            this.pos === s && (this.process(r, 0), (this.pos = 0));
        }
        return (this.length += e.length), this.roundClean(), this;
      }
      digestInto(e) {
        hl(this), MC(e, this), (this.finished = !0);
        const { buffer: r, view: i, blockLen: s, isLE: n } = this;
        let { pos: o } = this;
        (r[o++] = 128),
          this.buffer.subarray(o).fill(0),
          this.padOffset > s - o && (this.process(i, 0), (o = 0));
        for (let h = o; h < s; h++) r[h] = 0;
        Hee(i, s - 8, BigInt(this.length * 8), n), this.process(i, 0);
        const a = Vm(e),
          c = this.outputLen;
        if (c % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const l = c / 4,
          u = this.get();
        if (l > u.length) throw new Error("_sha2: outputLen bigger than state");
        for (let h = 0; h < l; h++) a.setUint32(4 * h, u[h], n);
      }
      digest() {
        const { buffer: e, outputLen: r } = this;
        this.digestInto(e);
        const i = e.slice(0, r);
        return this.destroy(), i;
      }
      _cloneInto(e) {
        e || (e = new this.constructor()), e.set(...this.get());
        const {
          blockLen: r,
          buffer: i,
          length: s,
          finished: n,
          destroyed: o,
          pos: a,
        } = this;
        return (
          (e.length = s),
          (e.pos = a),
          (e.finished = n),
          (e.destroyed = o),
          s % r && e.buffer.set(i),
          e
        );
      }
    }
    const Gee = new Uint32Array([
        1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
        2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
        1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
        264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
        2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
        113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
        1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
        3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
        430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
        1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
        2428436474, 2756734187, 3204031479, 3329325298,
      ]),
      go = new Uint32Array([
        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924,
        528734635, 1541459225,
      ]),
      wo = new Uint32Array(64);
    class Zee extends Kee {
      constructor() {
        super(64, 32, 8, !1),
          (this.A = go[0] | 0),
          (this.B = go[1] | 0),
          (this.C = go[2] | 0),
          (this.D = go[3] | 0),
          (this.E = go[4] | 0),
          (this.F = go[5] | 0),
          (this.G = go[6] | 0),
          (this.H = go[7] | 0);
      }
      get() {
        const { A: e, B: r, C: i, D: s, E: n, F: o, G: a, H: c } = this;
        return [e, r, i, s, n, o, a, c];
      }
      set(e, r, i, s, n, o, a, c) {
        (this.A = e | 0),
          (this.B = r | 0),
          (this.C = i | 0),
          (this.D = s | 0),
          (this.E = n | 0),
          (this.F = o | 0),
          (this.G = a | 0),
          (this.H = c | 0);
      }
      process(e, r) {
        for (let h = 0; h < 16; h++, r += 4) wo[h] = e.getUint32(r, !1);
        for (let h = 16; h < 64; h++) {
          const d = wo[h - 15],
            g = wo[h - 2],
            p = Ns(d, 7) ^ Ns(d, 18) ^ (d >>> 3),
            w = Ns(g, 17) ^ Ns(g, 19) ^ (g >>> 10);
          wo[h] = (w + wo[h - 7] + p + wo[h - 16]) | 0;
        }
        let { A: i, B: s, C: n, D: o, E: a, F: c, G: l, H: u } = this;
        for (let h = 0; h < 64; h++) {
          const d = Ns(a, 6) ^ Ns(a, 11) ^ Ns(a, 25),
            g = (u + d + Vee(a, c, l) + Gee[h] + wo[h]) | 0,
            p = ((Ns(i, 2) ^ Ns(i, 13) ^ Ns(i, 22)) + Wee(i, s, n)) | 0;
          (u = l),
            (l = c),
            (c = a),
            (a = (o + g) | 0),
            (o = n),
            (n = s),
            (s = i),
            (i = (g + p) | 0);
        }
        (i = (i + this.A) | 0),
          (s = (s + this.B) | 0),
          (n = (n + this.C) | 0),
          (o = (o + this.D) | 0),
          (a = (a + this.E) | 0),
          (c = (c + this.F) | 0),
          (l = (l + this.G) | 0),
          (u = (u + this.H) | 0),
          this.set(i, s, n, o, a, c, l, u);
      }
      roundClean() {
        wo.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
      }
    }
    const Bh = VC(() => new Zee());
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Ff =
        BigInt(0),
      Bf = BigInt(1),
      Yee = BigInt(2);
    function ga(t) {
      return (
        t instanceof Uint8Array ||
        (ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array")
      );
    }
    function Lh(t) {
      if (!ga(t)) throw new Error("Uint8Array expected");
    }
    function wl(t, e) {
      if (typeof e != "boolean")
        throw new Error(t + " boolean expected, got " + e);
    }
    const Jee = Array.from({ length: 256 }, (t, e) =>
      e.toString(16).padStart(2, "0")
    );
    function ml(t) {
      Lh(t);
      let e = "";
      for (let r = 0; r < t.length; r++) e += Jee[t[r]];
      return e;
    }
    function yl(t) {
      const e = t.toString(16);
      return e.length & 1 ? "0" + e : e;
    }
    function ty(t) {
      if (typeof t != "string")
        throw new Error("hex string expected, got " + typeof t);
      return t === "" ? Ff : BigInt("0x" + t);
    }
    const En = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function y7(t) {
      if (t >= En._0 && t <= En._9) return t - En._0;
      if (t >= En.A && t <= En.F) return t - (En.A - 10);
      if (t >= En.a && t <= En.f) return t - (En.a - 10);
    }
    function bl(t) {
      if (typeof t != "string")
        throw new Error("hex string expected, got " + typeof t);
      const e = t.length,
        r = e / 2;
      if (e % 2)
        throw new Error("hex string expected, got unpadded hex of length " + e);
      const i = new Uint8Array(r);
      for (let s = 0, n = 0; s < r; s++, n += 2) {
        const o = y7(t.charCodeAt(n)),
          a = y7(t.charCodeAt(n + 1));
        if (o === void 0 || a === void 0) {
          const c = t[n] + t[n + 1];
          throw new Error(
            'hex string expected, got non-hex character "' +
              c +
              '" at index ' +
              n
          );
        }
        i[s] = o * 16 + a;
      }
      return i;
    }
    function wa(t) {
      return ty(ml(t));
    }
    function Uh(t) {
      return Lh(t), ty(ml(Uint8Array.from(t).reverse()));
    }
    function vl(t, e) {
      return bl(t.toString(16).padStart(e * 2, "0"));
    }
    function Lf(t, e) {
      return vl(t, e).reverse();
    }
    function Xee(t) {
      return bl(yl(t));
    }
    function Ci(t, e, r) {
      let i;
      if (typeof e == "string")
        try {
          i = bl(e);
        } catch (n) {
          throw new Error(t + " must be hex string or Uint8Array, cause: " + n);
        }
      else if (ga(e)) i = Uint8Array.from(e);
      else throw new Error(t + " must be hex string or Uint8Array");
      const s = i.length;
      if (typeof r == "number" && s !== r)
        throw new Error(t + " of length " + r + " expected, got " + s);
      return i;
    }
    function Dh(...t) {
      let e = 0;
      for (let i = 0; i < t.length; i++) {
        const s = t[i];
        Lh(s), (e += s.length);
      }
      const r = new Uint8Array(e);
      for (let i = 0, s = 0; i < t.length; i++) {
        const n = t[i];
        r.set(n, s), (s += n.length);
      }
      return r;
    }
    function Qee(t, e) {
      if (t.length !== e.length) return !1;
      let r = 0;
      for (let i = 0; i < t.length; i++) r |= t[i] ^ e[i];
      return r === 0;
    }
    function ete(t) {
      if (typeof t != "string") throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(t));
    }
    const ry = (t) => typeof t == "bigint" && Ff <= t;
    function Uf(t, e, r) {
      return ry(t) && ry(e) && ry(r) && e <= t && t < r;
    }
    function Cn(t, e, r, i) {
      if (!Uf(e, r, i))
        throw new Error(
          "expected valid " + t + ": " + r + " <= n < " + i + ", got " + e
        );
    }
    function b7(t) {
      let e;
      for (e = 0; t > Ff; t >>= Bf, e += 1);
      return e;
    }
    function tte(t, e) {
      return (t >> BigInt(e)) & Bf;
    }
    function rte(t, e, r) {
      return t | ((r ? Bf : Ff) << BigInt(e));
    }
    const iy = (t) => (Yee << BigInt(t - 1)) - Bf,
      sy = (t) => new Uint8Array(t),
      v7 = (t) => Uint8Array.from(t);
    function E7(t, e, r) {
      if (typeof t != "number" || t < 2)
        throw new Error("hashLen must be a number");
      if (typeof e != "number" || e < 2)
        throw new Error("qByteLen must be a number");
      if (typeof r != "function") throw new Error("hmacFn must be a function");
      let i = sy(t),
        s = sy(t),
        n = 0;
      const o = () => {
          i.fill(1), s.fill(0), (n = 0);
        },
        a = (...u) => r(s, i, ...u),
        c = (u = sy()) => {
          (s = a(v7([0]), u)),
            (i = a()),
            u.length !== 0 && ((s = a(v7([1]), u)), (i = a()));
        },
        l = () => {
          if (n++ >= 1e3) throw new Error("drbg: tried 1000 values");
          let u = 0;
          const h = [];
          for (; u < e; ) {
            i = a();
            const d = i.slice();
            h.push(d), (u += i.length);
          }
          return Dh(...h);
        };
      return (u, h) => {
        o(), c(u);
        let d;
        for (; !(d = h(l())); ) c();
        return o(), d;
      };
    }
    const ite = {
      bigint: (t) => typeof t == "bigint",
      function: (t) => typeof t == "function",
      boolean: (t) => typeof t == "boolean",
      string: (t) => typeof t == "string",
      stringOrUint8Array: (t) => typeof t == "string" || ga(t),
      isSafeInteger: (t) => Number.isSafeInteger(t),
      array: (t) => Array.isArray(t),
      field: (t, e) => e.Fp.isValid(t),
      hash: (t) => typeof t == "function" && Number.isSafeInteger(t.outputLen),
    };
    function El(t, e, r = {}) {
      const i = (s, n, o) => {
        const a = ite[n];
        if (typeof a != "function")
          throw new Error("invalid validator function");
        const c = t[s];
        if (!(o && c === void 0) && !a(c, t))
          throw new Error(
            "param " + String(s) + " is invalid. Expected " + n + ", got " + c
          );
      };
      for (const [s, n] of Object.entries(e)) i(s, n, !1);
      for (const [s, n] of Object.entries(r)) i(s, n, !0);
      return t;
    }
    const ste = () => {
      throw new Error("not implemented");
    };
    function ny(t) {
      const e = new WeakMap();
      return (r, ...i) => {
        const s = e.get(r);
        if (s !== void 0) return s;
        const n = t(r, ...i);
        return e.set(r, n), n;
      };
    }
    var nte = Object.freeze({
      __proto__: null,
      isBytes: ga,
      abytes: Lh,
      abool: wl,
      bytesToHex: ml,
      numberToHexUnpadded: yl,
      hexToNumber: ty,
      hexToBytes: bl,
      bytesToNumberBE: wa,
      bytesToNumberLE: Uh,
      numberToBytesBE: vl,
      numberToBytesLE: Lf,
      numberToVarBytesBE: Xee,
      ensureBytes: Ci,
      concatBytes: Dh,
      equalBytes: Qee,
      utf8ToBytes: ete,
      inRange: Uf,
      aInRange: Cn,
      bitLen: b7,
      bitGet: tte,
      bitSet: rte,
      bitMask: iy,
      createHmacDrbg: E7,
      validateObject: El,
      notImplemented: ste,
      memoized: ny,
    });
    const rr = BigInt(0),
      Pt = BigInt(1),
      ma = BigInt(2),
      ote = BigInt(3),
      oy = BigInt(4),
      C7 = BigInt(5),
      x7 = BigInt(8);
    function Xr(t, e) {
      const r = t % e;
      return r >= rr ? r : e + r;
    }
    function I7(t, e, r) {
      if (e < rr) throw new Error("invalid exponent, negatives unsupported");
      if (r <= rr) throw new Error("invalid modulus");
      if (r === Pt) return rr;
      let i = Pt;
      for (; e > rr; )
        e & Pt && (i = (i * t) % r), (t = (t * t) % r), (e >>= Pt);
      return i;
    }
    function os(t, e, r) {
      let i = t;
      for (; e-- > rr; ) (i *= i), (i %= r);
      return i;
    }
    function ay(t, e) {
      if (t === rr) throw new Error("invert: expected non-zero number");
      if (e <= rr)
        throw new Error("invert: expected positive modulus, got " + e);
      let r = Xr(t, e),
        i = e,
        s = rr,
        n = Pt;
      for (; r !== rr; ) {
        const o = i / r,
          a = i % r,
          c = s - n * o;
        (i = r), (r = a), (s = n), (n = c);
      }
      if (i !== Pt) throw new Error("invert: does not exist");
      return Xr(s, e);
    }
    function ate(t) {
      const e = (t - Pt) / ma;
      let r, i, s;
      for (r = t - Pt, i = 0; r % ma === rr; r /= ma, i++);
      for (s = ma; s < t && I7(s, e, t) !== t - Pt; s++)
        if (s > 1e3)
          throw new Error("Cannot find square root: likely non-prime P");
      if (i === 1) {
        const o = (t + Pt) / oy;
        return function (a, c) {
          const l = a.pow(c, o);
          if (!a.eql(a.sqr(l), c)) throw new Error("Cannot find square root");
          return l;
        };
      }
      const n = (r + Pt) / ma;
      return function (o, a) {
        if (o.pow(a, e) === o.neg(o.ONE))
          throw new Error("Cannot find square root");
        let c = i,
          l = o.pow(o.mul(o.ONE, s), r),
          u = o.pow(a, n),
          h = o.pow(a, r);
        for (; !o.eql(h, o.ONE); ) {
          if (o.eql(h, o.ZERO)) return o.ZERO;
          let d = 1;
          for (let p = o.sqr(h); d < c && !o.eql(p, o.ONE); d++) p = o.sqr(p);
          const g = o.pow(l, Pt << BigInt(c - d - 1));
          (l = o.sqr(g)), (u = o.mul(u, g)), (h = o.mul(h, l)), (c = d);
        }
        return u;
      };
    }
    function cte(t) {
      if (t % oy === ote) {
        const e = (t + Pt) / oy;
        return function (r, i) {
          const s = r.pow(i, e);
          if (!r.eql(r.sqr(s), i)) throw new Error("Cannot find square root");
          return s;
        };
      }
      if (t % x7 === C7) {
        const e = (t - C7) / x7;
        return function (r, i) {
          const s = r.mul(i, ma),
            n = r.pow(s, e),
            o = r.mul(i, n),
            a = r.mul(r.mul(o, ma), n),
            c = r.mul(o, r.sub(a, r.ONE));
          if (!r.eql(r.sqr(c), i)) throw new Error("Cannot find square root");
          return c;
        };
      }
      return ate(t);
    }
    const lte = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN",
    ];
    function ute(t) {
      const e = {
          ORDER: "bigint",
          MASK: "bigint",
          BYTES: "isSafeInteger",
          BITS: "isSafeInteger",
        },
        r = lte.reduce((i, s) => ((i[s] = "function"), i), e);
      return El(t, r);
    }
    function hte(t, e, r) {
      if (r < rr) throw new Error("invalid exponent, negatives unsupported");
      if (r === rr) return t.ONE;
      if (r === Pt) return e;
      let i = t.ONE,
        s = e;
      for (; r > rr; ) r & Pt && (i = t.mul(i, s)), (s = t.sqr(s)), (r >>= Pt);
      return i;
    }
    function dte(t, e) {
      const r = new Array(e.length),
        i = e.reduce(
          (n, o, a) => (t.is0(o) ? n : ((r[a] = n), t.mul(n, o))),
          t.ONE
        ),
        s = t.inv(i);
      return (
        e.reduceRight(
          (n, o, a) => (t.is0(o) ? n : ((r[a] = t.mul(n, r[a])), t.mul(n, o))),
          s
        ),
        r
      );
    }
    function _7(t, e) {
      const r = e !== void 0 ? e : t.toString(2).length,
        i = Math.ceil(r / 8);
      return { nBitLength: r, nByteLength: i };
    }
    function A7(t, e, r = !1, i = {}) {
      if (t <= rr)
        throw new Error("invalid field: expected ORDER > 0, got " + t);
      const { nBitLength: s, nByteLength: n } = _7(t, e);
      if (n > 2048)
        throw new Error("invalid field: expected ORDER of <= 2048 bytes");
      let o;
      const a = Object.freeze({
        ORDER: t,
        isLE: r,
        BITS: s,
        BYTES: n,
        MASK: iy(s),
        ZERO: rr,
        ONE: Pt,
        create: (c) => Xr(c, t),
        isValid: (c) => {
          if (typeof c != "bigint")
            throw new Error(
              "invalid field element: expected bigint, got " + typeof c
            );
          return rr <= c && c < t;
        },
        is0: (c) => c === rr,
        isOdd: (c) => (c & Pt) === Pt,
        neg: (c) => Xr(-c, t),
        eql: (c, l) => c === l,
        sqr: (c) => Xr(c * c, t),
        add: (c, l) => Xr(c + l, t),
        sub: (c, l) => Xr(c - l, t),
        mul: (c, l) => Xr(c * l, t),
        pow: (c, l) => hte(a, c, l),
        div: (c, l) => Xr(c * ay(l, t), t),
        sqrN: (c) => c * c,
        addN: (c, l) => c + l,
        subN: (c, l) => c - l,
        mulN: (c, l) => c * l,
        inv: (c) => ay(c, t),
        sqrt: i.sqrt || ((c) => (o || (o = cte(t)), o(a, c))),
        invertBatch: (c) => dte(a, c),
        cmov: (c, l, u) => (u ? l : c),
        toBytes: (c) => (r ? Lf(c, n) : vl(c, n)),
        fromBytes: (c) => {
          if (c.length !== n)
            throw new Error(
              "Field.fromBytes: expected " + n + " bytes, got " + c.length
            );
          return r ? Uh(c) : wa(c);
        },
      });
      return Object.freeze(a);
    }
    function S7(t) {
      if (typeof t != "bigint") throw new Error("field order must be bigint");
      const e = t.toString(2).length;
      return Math.ceil(e / 8);
    }
    function P7(t) {
      const e = S7(t);
      return e + Math.ceil(e / 2);
    }
    function pte(t, e, r = !1) {
      const i = t.length,
        s = S7(e),
        n = P7(e);
      if (i < 16 || i < n || i > 1024)
        throw new Error("expected " + n + "-1024 bytes of input, got " + i);
      const o = r ? Uh(t) : wa(t),
        a = Xr(o, e - Pt) + Pt;
      return r ? Lf(a, s) : vl(a, s);
    }
    const O7 = BigInt(0),
      Df = BigInt(1);
    function cy(t, e) {
      const r = e.negate();
      return t ? r : e;
    }
    function N7(t, e) {
      if (!Number.isSafeInteger(t) || t <= 0 || t > e)
        throw new Error(
          "invalid window size, expected [1.." + e + "], got W=" + t
        );
    }
    function ly(t, e) {
      N7(t, e);
      const r = Math.ceil(e / t) + 1,
        i = 2 ** (t - 1);
      return { windows: r, windowSize: i };
    }
    function fte(t, e) {
      if (!Array.isArray(t)) throw new Error("array expected");
      t.forEach((r, i) => {
        if (!(r instanceof e)) throw new Error("invalid point at index " + i);
      });
    }
    function gte(t, e) {
      if (!Array.isArray(t)) throw new Error("array of scalars expected");
      t.forEach((r, i) => {
        if (!e.isValid(r)) throw new Error("invalid scalar at index " + i);
      });
    }
    const uy = new WeakMap(),
      T7 = new WeakMap();
    function hy(t) {
      return T7.get(t) || 1;
    }
    function wte(t, e) {
      return {
        constTimeNegate: cy,
        hasPrecomputes(r) {
          return hy(r) !== 1;
        },
        unsafeLadder(r, i, s = t.ZERO) {
          let n = r;
          for (; i > O7; )
            i & Df && (s = s.add(n)), (n = n.double()), (i >>= Df);
          return s;
        },
        precomputeWindow(r, i) {
          const { windows: s, windowSize: n } = ly(i, e),
            o = [];
          let a = r,
            c = a;
          for (let l = 0; l < s; l++) {
            (c = a), o.push(c);
            for (let u = 1; u < n; u++) (c = c.add(a)), o.push(c);
            a = c.double();
          }
          return o;
        },
        wNAF(r, i, s) {
          const { windows: n, windowSize: o } = ly(r, e);
          let a = t.ZERO,
            c = t.BASE;
          const l = BigInt(2 ** r - 1),
            u = 2 ** r,
            h = BigInt(r);
          for (let d = 0; d < n; d++) {
            const g = d * o;
            let p = Number(s & l);
            (s >>= h), p > o && ((p -= u), (s += Df));
            const w = g,
              f = g + Math.abs(p) - 1,
              m = d % 2 !== 0,
              y = p < 0;
            p === 0 ? (c = c.add(cy(m, i[w]))) : (a = a.add(cy(y, i[f])));
          }
          return { p: a, f: c };
        },
        wNAFUnsafe(r, i, s, n = t.ZERO) {
          const { windows: o, windowSize: a } = ly(r, e),
            c = BigInt(2 ** r - 1),
            l = 2 ** r,
            u = BigInt(r);
          for (let h = 0; h < o; h++) {
            const d = h * a;
            if (s === O7) break;
            let g = Number(s & c);
            if (((s >>= u), g > a && ((g -= l), (s += Df)), g === 0)) continue;
            let p = i[d + Math.abs(g) - 1];
            g < 0 && (p = p.negate()), (n = n.add(p));
          }
          return n;
        },
        getPrecomputes(r, i, s) {
          let n = uy.get(i);
          return (
            n ||
              ((n = this.precomputeWindow(i, r)), r !== 1 && uy.set(i, s(n))),
            n
          );
        },
        wNAFCached(r, i, s) {
          const n = hy(r);
          return this.wNAF(n, this.getPrecomputes(n, r, s), i);
        },
        wNAFCachedUnsafe(r, i, s, n) {
          const o = hy(r);
          return o === 1
            ? this.unsafeLadder(r, i, n)
            : this.wNAFUnsafe(o, this.getPrecomputes(o, r, s), i, n);
        },
        setWindowSize(r, i) {
          N7(i, e), T7.set(r, i), uy.delete(r);
        },
      };
    }
    function mte(t, e, r, i) {
      if ((fte(r, t), gte(i, e), r.length !== i.length))
        throw new Error("arrays of points and scalars must have equal length");
      const s = t.ZERO,
        n = b7(BigInt(r.length)),
        o = n > 12 ? n - 3 : n > 4 ? n - 2 : n ? 2 : 1,
        a = (1 << o) - 1,
        c = new Array(a + 1).fill(s),
        l = Math.floor((e.BITS - 1) / o) * o;
      let u = s;
      for (let h = l; h >= 0; h -= o) {
        c.fill(s);
        for (let g = 0; g < i.length; g++) {
          const p = i[g],
            w = Number((p >> BigInt(h)) & BigInt(a));
          c[w] = c[w].add(r[g]);
        }
        let d = s;
        for (let g = c.length - 1, p = s; g > 0; g--)
          (p = p.add(c[g])), (d = d.add(p));
        if (((u = u.add(d)), h !== 0))
          for (let g = 0; g < o; g++) u = u.double();
      }
      return u;
    }
    function k7(t) {
      return (
        ute(t.Fp),
        El(
          t,
          { n: "bigint", h: "bigint", Gx: "field", Gy: "field" },
          { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }
        ),
        Object.freeze({ ..._7(t.n, t.nBitLength), ...t, p: t.Fp.ORDER })
      );
    }
    BigInt(0), BigInt(1), BigInt(2), BigInt(8);
    const Cl = BigInt(0),
      dy = BigInt(1);
    function yte(t) {
      return (
        El(
          t,
          { a: "bigint" },
          {
            montgomeryBits: "isSafeInteger",
            nByteLength: "isSafeInteger",
            adjustScalarBytes: "function",
            domain: "function",
            powPminus2: "function",
            Gu: "bigint",
          }
        ),
        Object.freeze({ ...t })
      );
    }
    function bte(t) {
      const e = yte(t),
        { P: r } = e,
        i = (y) => Xr(y, r),
        s = e.montgomeryBits,
        n = Math.ceil(s / 8),
        o = e.nByteLength,
        a = e.adjustScalarBytes || ((y) => y),
        c = e.powPminus2 || ((y) => I7(y, r - BigInt(2), r));
      function l(y, E, C) {
        const O = i(y * (E - C));
        return (E = i(E - O)), (C = i(C + O)), [E, C];
      }
      const u = (e.a - BigInt(2)) / BigInt(4);
      function h(y, E) {
        Cn("u", y, Cl, r), Cn("scalar", E, Cl, r);
        const C = E,
          O = y;
        let A = dy,
          P = Cl,
          N = y,
          x = dy,
          $ = Cl,
          k;
        for (let j = BigInt(s - 1); j >= Cl; j--) {
          const I = (C >> j) & dy;
          ($ ^= I),
            (k = l($, A, N)),
            (A = k[0]),
            (N = k[1]),
            (k = l($, P, x)),
            (P = k[0]),
            (x = k[1]),
            ($ = I);
          const b = A + P,
            v = i(b * b),
            S = A - P,
            T = i(S * S),
            _ = v - T,
            R = N + x,
            U = N - x,
            D = i(U * b),
            H = i(R * S),
            q = D + H,
            V = D - H;
          (N = i(q * q)),
            (x = i(O * i(V * V))),
            (A = i(v * T)),
            (P = i(_ * (v + i(u * _))));
        }
        (k = l($, A, N)),
          (A = k[0]),
          (N = k[1]),
          (k = l($, P, x)),
          (P = k[0]),
          (x = k[1]);
        const F = c(P);
        return i(A * F);
      }
      function d(y) {
        return Lf(i(y), n);
      }
      function g(y) {
        const E = Ci("u coordinate", y, n);
        return o === 32 && (E[31] &= 127), Uh(E);
      }
      function p(y) {
        const E = Ci("scalar", y),
          C = E.length;
        if (C !== n && C !== o) {
          let O = "" + n + " or " + o;
          throw new Error("invalid scalar, expected " + O + " bytes, got " + C);
        }
        return Uh(a(E));
      }
      function w(y, E) {
        const C = g(E),
          O = p(y),
          A = h(C, O);
        if (A === Cl) throw new Error("invalid private or public key received");
        return d(A);
      }
      const f = d(e.Gu);
      function m(y) {
        return w(y, f);
      }
      return {
        scalarMult: w,
        scalarMultBase: m,
        getSharedSecret: (y, E) => w(y, E),
        getPublicKey: (y) => m(y),
        utils: { randomPrivateKey: () => e.randomBytes(e.nByteLength) },
        GuBytes: f,
      };
    }
    const py = BigInt(
      "57896044618658097711785492504343953926634992332820282019728792003956564819949"
    );
    BigInt(0);
    const vte = BigInt(1),
      R7 = BigInt(2),
      Ete = BigInt(3),
      Cte = BigInt(5);
    BigInt(8);
    function xte(t) {
      const e = BigInt(10),
        r = BigInt(20),
        i = BigInt(40),
        s = BigInt(80),
        n = py,
        o = (((t * t) % n) * t) % n,
        a = (os(o, R7, n) * o) % n,
        c = (os(a, vte, n) * t) % n,
        l = (os(c, Cte, n) * c) % n,
        u = (os(l, e, n) * l) % n,
        h = (os(u, r, n) * u) % n,
        d = (os(h, i, n) * h) % n,
        g = (os(d, s, n) * d) % n,
        p = (os(g, s, n) * d) % n,
        w = (os(p, e, n) * l) % n;
      return { pow_p_5_8: (os(w, R7, n) * t) % n, b2: o };
    }
    function Ite(t) {
      return (t[0] &= 248), (t[31] &= 127), (t[31] |= 64), t;
    }
    const fy = bte({
      P: py,
      a: BigInt(486662),
      montgomeryBits: 255,
      nByteLength: 32,
      Gu: BigInt(9),
      powPminus2: (t) => {
        const e = py,
          { pow_p_5_8: r, b2: i } = xte(t);
        return Xr(os(r, Ete, e) * i, e);
      },
      adjustScalarBytes: Ite,
      randomBytes: fl,
    });
    function $7(t) {
      t.lowS !== void 0 && wl("lowS", t.lowS),
        t.prehash !== void 0 && wl("prehash", t.prehash);
    }
    function _te(t) {
      const e = k7(t);
      El(
        e,
        { a: "field", b: "field" },
        {
          allowedPrivateKeyLengths: "array",
          wrapPrivateKey: "boolean",
          isTorsionFree: "function",
          clearCofactor: "function",
          allowInfinityPoint: "boolean",
          fromBytes: "function",
          toBytes: "function",
        }
      );
      const { endo: r, Fp: i, a: s } = e;
      if (r) {
        if (!i.eql(s, i.ZERO))
          throw new Error(
            "invalid endomorphism, can only be defined for Koblitz curves that have a=0"
          );
        if (
          typeof r != "object" ||
          typeof r.beta != "bigint" ||
          typeof r.splitScalar != "function"
        )
          throw new Error(
            "invalid endomorphism, expected beta: bigint and splitScalar: function"
          );
      }
      return Object.freeze({ ...e });
    }
    const { bytesToNumberBE: Ate, hexToBytes: Ste } = nte;
    class Pte extends Error {
      constructor(e = "") {
        super(e);
      }
    }
    const xn = {
        Err: Pte,
        _tlv: {
          encode: (t, e) => {
            const { Err: r } = xn;
            if (t < 0 || t > 256) throw new r("tlv.encode: wrong tag");
            if (e.length & 1) throw new r("tlv.encode: unpadded data");
            const i = e.length / 2,
              s = yl(i);
            if ((s.length / 2) & 128)
              throw new r("tlv.encode: long form length too big");
            const n = i > 127 ? yl((s.length / 2) | 128) : "";
            return yl(t) + n + s + e;
          },
          decode(t, e) {
            const { Err: r } = xn;
            let i = 0;
            if (t < 0 || t > 256) throw new r("tlv.encode: wrong tag");
            if (e.length < 2 || e[i++] !== t)
              throw new r("tlv.decode: wrong tlv");
            const s = e[i++],
              n = !!(s & 128);
            let o = 0;
            if (!n) o = s;
            else {
              const c = s & 127;
              if (!c)
                throw new r(
                  "tlv.decode(long): indefinite length not supported"
                );
              if (c > 4)
                throw new r("tlv.decode(long): byte length is too big");
              const l = e.subarray(i, i + c);
              if (l.length !== c)
                throw new r("tlv.decode: length bytes not complete");
              if (l[0] === 0)
                throw new r("tlv.decode(long): zero leftmost byte");
              for (const u of l) o = (o << 8) | u;
              if (((i += c), o < 128))
                throw new r("tlv.decode(long): not minimal encoding");
            }
            const a = e.subarray(i, i + o);
            if (a.length !== o) throw new r("tlv.decode: wrong value length");
            return { v: a, l: e.subarray(i + o) };
          },
        },
        _int: {
          encode(t) {
            const { Err: e } = xn;
            if (t < In)
              throw new e("integer: negative integers are not allowed");
            let r = yl(t);
            if ((Number.parseInt(r[0], 16) & 8 && (r = "00" + r), r.length & 1))
              throw new e("unexpected DER parsing assertion: unpadded hex");
            return r;
          },
          decode(t) {
            const { Err: e } = xn;
            if (t[0] & 128) throw new e("invalid signature integer: negative");
            if (t[0] === 0 && !(t[1] & 128))
              throw new e(
                "invalid signature integer: unnecessary leading zero"
              );
            return Ate(t);
          },
        },
        toSig(t) {
          const { Err: e, _int: r, _tlv: i } = xn,
            s = typeof t == "string" ? Ste(t) : t;
          Lh(s);
          const { v: n, l: o } = i.decode(48, s);
          if (o.length)
            throw new e("invalid signature: left bytes after parsing");
          const { v: a, l: c } = i.decode(2, n),
            { v: l, l: u } = i.decode(2, c);
          if (u.length)
            throw new e("invalid signature: left bytes after parsing");
          return { r: r.decode(a), s: r.decode(l) };
        },
        hexFromSig(t) {
          const { _tlv: e, _int: r } = xn,
            i = e.encode(2, r.encode(t.r)),
            s = e.encode(2, r.encode(t.s)),
            n = i + s;
          return e.encode(48, n);
        },
      },
      In = BigInt(0),
      ir = BigInt(1);
    BigInt(2);
    const F7 = BigInt(3);
    BigInt(4);
    function Ote(t) {
      const e = _te(t),
        { Fp: r } = e,
        i = A7(e.n, e.nBitLength),
        s =
          e.toBytes ||
          ((w, f, m) => {
            const y = f.toAffine();
            return Dh(Uint8Array.from([4]), r.toBytes(y.x), r.toBytes(y.y));
          }),
        n =
          e.fromBytes ||
          ((w) => {
            const f = w.subarray(1),
              m = r.fromBytes(f.subarray(0, r.BYTES)),
              y = r.fromBytes(f.subarray(r.BYTES, 2 * r.BYTES));
            return { x: m, y };
          });
      function o(w) {
        const { a: f, b: m } = e,
          y = r.sqr(w),
          E = r.mul(y, w);
        return r.add(r.add(E, r.mul(w, f)), m);
      }
      if (!r.eql(r.sqr(e.Gy), o(e.Gx)))
        throw new Error("bad generator point: equation left != right");
      function a(w) {
        return Uf(w, ir, e.n);
      }
      function c(w) {
        const {
          allowedPrivateKeyLengths: f,
          nByteLength: m,
          wrapPrivateKey: y,
          n: E,
        } = e;
        if (f && typeof w != "bigint") {
          if (
            (ga(w) && (w = ml(w)),
            typeof w != "string" || !f.includes(w.length))
          )
            throw new Error("invalid private key");
          w = w.padStart(m * 2, "0");
        }
        let C;
        try {
          C = typeof w == "bigint" ? w : wa(Ci("private key", w, m));
        } catch {
          throw new Error(
            "invalid private key, expected hex or " +
              m +
              " bytes, got " +
              typeof w
          );
        }
        return y && (C = Xr(C, E)), Cn("private key", C, ir, E), C;
      }
      function l(w) {
        if (!(w instanceof d)) throw new Error("ProjectivePoint expected");
      }
      const u = ny((w, f) => {
          const { px: m, py: y, pz: E } = w;
          if (r.eql(E, r.ONE)) return { x: m, y };
          const C = w.is0();
          f == null && (f = C ? r.ONE : r.inv(E));
          const O = r.mul(m, f),
            A = r.mul(y, f),
            P = r.mul(E, f);
          if (C) return { x: r.ZERO, y: r.ZERO };
          if (!r.eql(P, r.ONE)) throw new Error("invZ was invalid");
          return { x: O, y: A };
        }),
        h = ny((w) => {
          if (w.is0()) {
            if (e.allowInfinityPoint && !r.is0(w.py)) return;
            throw new Error("bad point: ZERO");
          }
          const { x: f, y: m } = w.toAffine();
          if (!r.isValid(f) || !r.isValid(m))
            throw new Error("bad point: x or y not FE");
          const y = r.sqr(m),
            E = o(f);
          if (!r.eql(y, E))
            throw new Error("bad point: equation left != right");
          if (!w.isTorsionFree())
            throw new Error("bad point: not in prime-order subgroup");
          return !0;
        });
      class d {
        constructor(f, m, y) {
          if (
            ((this.px = f),
            (this.py = m),
            (this.pz = y),
            f == null || !r.isValid(f))
          )
            throw new Error("x required");
          if (m == null || !r.isValid(m)) throw new Error("y required");
          if (y == null || !r.isValid(y)) throw new Error("z required");
          Object.freeze(this);
        }
        static fromAffine(f) {
          const { x: m, y } = f || {};
          if (!f || !r.isValid(m) || !r.isValid(y))
            throw new Error("invalid affine point");
          if (f instanceof d) throw new Error("projective point not allowed");
          const E = (C) => r.eql(C, r.ZERO);
          return E(m) && E(y) ? d.ZERO : new d(m, y, r.ONE);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        static normalizeZ(f) {
          const m = r.invertBatch(f.map((y) => y.pz));
          return f.map((y, E) => y.toAffine(m[E])).map(d.fromAffine);
        }
        static fromHex(f) {
          const m = d.fromAffine(n(Ci("pointHex", f)));
          return m.assertValidity(), m;
        }
        static fromPrivateKey(f) {
          return d.BASE.multiply(c(f));
        }
        static msm(f, m) {
          return mte(d, i, f, m);
        }
        _setWindowSize(f) {
          p.setWindowSize(this, f);
        }
        assertValidity() {
          h(this);
        }
        hasEvenY() {
          const { y: f } = this.toAffine();
          if (r.isOdd) return !r.isOdd(f);
          throw new Error("Field doesn't support isOdd");
        }
        equals(f) {
          l(f);
          const { px: m, py: y, pz: E } = this,
            { px: C, py: O, pz: A } = f,
            P = r.eql(r.mul(m, A), r.mul(C, E)),
            N = r.eql(r.mul(y, A), r.mul(O, E));
          return P && N;
        }
        negate() {
          return new d(this.px, r.neg(this.py), this.pz);
        }
        double() {
          const { a: f, b: m } = e,
            y = r.mul(m, F7),
            { px: E, py: C, pz: O } = this;
          let A = r.ZERO,
            P = r.ZERO,
            N = r.ZERO,
            x = r.mul(E, E),
            $ = r.mul(C, C),
            k = r.mul(O, O),
            F = r.mul(E, C);
          return (
            (F = r.add(F, F)),
            (N = r.mul(E, O)),
            (N = r.add(N, N)),
            (A = r.mul(f, N)),
            (P = r.mul(y, k)),
            (P = r.add(A, P)),
            (A = r.sub($, P)),
            (P = r.add($, P)),
            (P = r.mul(A, P)),
            (A = r.mul(F, A)),
            (N = r.mul(y, N)),
            (k = r.mul(f, k)),
            (F = r.sub(x, k)),
            (F = r.mul(f, F)),
            (F = r.add(F, N)),
            (N = r.add(x, x)),
            (x = r.add(N, x)),
            (x = r.add(x, k)),
            (x = r.mul(x, F)),
            (P = r.add(P, x)),
            (k = r.mul(C, O)),
            (k = r.add(k, k)),
            (x = r.mul(k, F)),
            (A = r.sub(A, x)),
            (N = r.mul(k, $)),
            (N = r.add(N, N)),
            (N = r.add(N, N)),
            new d(A, P, N)
          );
        }
        add(f) {
          l(f);
          const { px: m, py: y, pz: E } = this,
            { px: C, py: O, pz: A } = f;
          let P = r.ZERO,
            N = r.ZERO,
            x = r.ZERO;
          const $ = e.a,
            k = r.mul(e.b, F7);
          let F = r.mul(m, C),
            j = r.mul(y, O),
            I = r.mul(E, A),
            b = r.add(m, y),
            v = r.add(C, O);
          (b = r.mul(b, v)),
            (v = r.add(F, j)),
            (b = r.sub(b, v)),
            (v = r.add(m, E));
          let S = r.add(C, A);
          return (
            (v = r.mul(v, S)),
            (S = r.add(F, I)),
            (v = r.sub(v, S)),
            (S = r.add(y, E)),
            (P = r.add(O, A)),
            (S = r.mul(S, P)),
            (P = r.add(j, I)),
            (S = r.sub(S, P)),
            (x = r.mul($, v)),
            (P = r.mul(k, I)),
            (x = r.add(P, x)),
            (P = r.sub(j, x)),
            (x = r.add(j, x)),
            (N = r.mul(P, x)),
            (j = r.add(F, F)),
            (j = r.add(j, F)),
            (I = r.mul($, I)),
            (v = r.mul(k, v)),
            (j = r.add(j, I)),
            (I = r.sub(F, I)),
            (I = r.mul($, I)),
            (v = r.add(v, I)),
            (F = r.mul(j, v)),
            (N = r.add(N, F)),
            (F = r.mul(S, v)),
            (P = r.mul(b, P)),
            (P = r.sub(P, F)),
            (F = r.mul(b, j)),
            (x = r.mul(S, x)),
            (x = r.add(x, F)),
            new d(P, N, x)
          );
        }
        subtract(f) {
          return this.add(f.negate());
        }
        is0() {
          return this.equals(d.ZERO);
        }
        wNAF(f) {
          return p.wNAFCached(this, f, d.normalizeZ);
        }
        multiplyUnsafe(f) {
          const { endo: m, n: y } = e;
          Cn("scalar", f, In, y);
          const E = d.ZERO;
          if (f === In) return E;
          if (this.is0() || f === ir) return this;
          if (!m || p.hasPrecomputes(this))
            return p.wNAFCachedUnsafe(this, f, d.normalizeZ);
          let { k1neg: C, k1: O, k2neg: A, k2: P } = m.splitScalar(f),
            N = E,
            x = E,
            $ = this;
          for (; O > In || P > In; )
            O & ir && (N = N.add($)),
              P & ir && (x = x.add($)),
              ($ = $.double()),
              (O >>= ir),
              (P >>= ir);
          return (
            C && (N = N.negate()),
            A && (x = x.negate()),
            (x = new d(r.mul(x.px, m.beta), x.py, x.pz)),
            N.add(x)
          );
        }
        multiply(f) {
          const { endo: m, n: y } = e;
          Cn("scalar", f, ir, y);
          let E, C;
          if (m) {
            const { k1neg: O, k1: A, k2neg: P, k2: N } = m.splitScalar(f);
            let { p: x, f: $ } = this.wNAF(A),
              { p: k, f: F } = this.wNAF(N);
            (x = p.constTimeNegate(O, x)),
              (k = p.constTimeNegate(P, k)),
              (k = new d(r.mul(k.px, m.beta), k.py, k.pz)),
              (E = x.add(k)),
              (C = $.add(F));
          } else {
            const { p: O, f: A } = this.wNAF(f);
            (E = O), (C = A);
          }
          return d.normalizeZ([E, C])[0];
        }
        multiplyAndAddUnsafe(f, m, y) {
          const E = d.BASE,
            C = (A, P) =>
              P === In || P === ir || !A.equals(E)
                ? A.multiplyUnsafe(P)
                : A.multiply(P),
            O = C(this, m).add(C(f, y));
          return O.is0() ? void 0 : O;
        }
        toAffine(f) {
          return u(this, f);
        }
        isTorsionFree() {
          const { h: f, isTorsionFree: m } = e;
          if (f === ir) return !0;
          if (m) return m(d, this);
          throw new Error(
            "isTorsionFree() has not been declared for the elliptic curve"
          );
        }
        clearCofactor() {
          const { h: f, clearCofactor: m } = e;
          return f === ir ? this : m ? m(d, this) : this.multiplyUnsafe(e.h);
        }
        toRawBytes(f = !0) {
          return wl("isCompressed", f), this.assertValidity(), s(d, this, f);
        }
        toHex(f = !0) {
          return wl("isCompressed", f), ml(this.toRawBytes(f));
        }
      }
      (d.BASE = new d(e.Gx, e.Gy, r.ONE)),
        (d.ZERO = new d(r.ZERO, r.ONE, r.ZERO));
      const g = e.nBitLength,
        p = wte(d, e.endo ? Math.ceil(g / 2) : g);
      return {
        CURVE: e,
        ProjectivePoint: d,
        normPrivateKeyToScalar: c,
        weierstrassEquation: o,
        isWithinCurveOrder: a,
      };
    }
    function Nte(t) {
      const e = k7(t);
      return (
        El(
          e,
          { hash: "hash", hmac: "function", randomBytes: "function" },
          { bits2int: "function", bits2int_modN: "function", lowS: "boolean" }
        ),
        Object.freeze({ lowS: !0, ...e })
      );
    }
    function Tte(t) {
      const e = Nte(t),
        { Fp: r, n: i } = e,
        s = r.BYTES + 1,
        n = 2 * r.BYTES + 1;
      function o(I) {
        return Xr(I, i);
      }
      function a(I) {
        return ay(I, i);
      }
      const {
          ProjectivePoint: c,
          normPrivateKeyToScalar: l,
          weierstrassEquation: u,
          isWithinCurveOrder: h,
        } = Ote({
          ...e,
          toBytes(I, b, v) {
            const S = b.toAffine(),
              T = r.toBytes(S.x),
              _ = Dh;
            return (
              wl("isCompressed", v),
              v
                ? _(Uint8Array.from([b.hasEvenY() ? 2 : 3]), T)
                : _(Uint8Array.from([4]), T, r.toBytes(S.y))
            );
          },
          fromBytes(I) {
            const b = I.length,
              v = I[0],
              S = I.subarray(1);
            if (b === s && (v === 2 || v === 3)) {
              const T = wa(S);
              if (!Uf(T, ir, r.ORDER)) throw new Error("Point is not on curve");
              const _ = u(T);
              let R;
              try {
                R = r.sqrt(_);
              } catch (D) {
                const H = D instanceof Error ? ": " + D.message : "";
                throw new Error("Point is not on curve" + H);
              }
              const U = (R & ir) === ir;
              return ((v & 1) === 1) !== U && (R = r.neg(R)), { x: T, y: R };
            } else if (b === n && v === 4) {
              const T = r.fromBytes(S.subarray(0, r.BYTES)),
                _ = r.fromBytes(S.subarray(r.BYTES, 2 * r.BYTES));
              return { x: T, y: _ };
            } else {
              const T = s,
                _ = n;
              throw new Error(
                "invalid Point, expected length of " +
                  T +
                  ", or uncompressed " +
                  _ +
                  ", got " +
                  b
              );
            }
          },
        }),
        d = (I) => ml(vl(I, e.nByteLength));
      function g(I) {
        const b = i >> ir;
        return I > b;
      }
      function p(I) {
        return g(I) ? o(-I) : I;
      }
      const w = (I, b, v) => wa(I.slice(b, v));
      class f {
        constructor(b, v, S) {
          (this.r = b),
            (this.s = v),
            (this.recovery = S),
            this.assertValidity();
        }
        static fromCompact(b) {
          const v = e.nByteLength;
          return (
            (b = Ci("compactSignature", b, v * 2)),
            new f(w(b, 0, v), w(b, v, 2 * v))
          );
        }
        static fromDER(b) {
          const { r: v, s: S } = xn.toSig(Ci("DER", b));
          return new f(v, S);
        }
        assertValidity() {
          Cn("r", this.r, ir, i), Cn("s", this.s, ir, i);
        }
        addRecoveryBit(b) {
          return new f(this.r, this.s, b);
        }
        recoverPublicKey(b) {
          const { r: v, s: S, recovery: T } = this,
            _ = A(Ci("msgHash", b));
          if (T == null || ![0, 1, 2, 3].includes(T))
            throw new Error("recovery id invalid");
          const R = T === 2 || T === 3 ? v + e.n : v;
          if (R >= r.ORDER) throw new Error("recovery id 2 or 3 invalid");
          const U = (T & 1) === 0 ? "02" : "03",
            D = c.fromHex(U + d(R)),
            H = a(R),
            q = o(-_ * H),
            V = o(S * H),
            Y = c.BASE.multiplyAndAddUnsafe(D, q, V);
          if (!Y) throw new Error("point at infinify");
          return Y.assertValidity(), Y;
        }
        hasHighS() {
          return g(this.s);
        }
        normalizeS() {
          return this.hasHighS()
            ? new f(this.r, o(-this.s), this.recovery)
            : this;
        }
        toDERRawBytes() {
          return bl(this.toDERHex());
        }
        toDERHex() {
          return xn.hexFromSig({ r: this.r, s: this.s });
        }
        toCompactRawBytes() {
          return bl(this.toCompactHex());
        }
        toCompactHex() {
          return d(this.r) + d(this.s);
        }
      }
      const m = {
        isValidPrivateKey(I) {
          try {
            return l(I), !0;
          } catch {
            return !1;
          }
        },
        normPrivateKeyToScalar: l,
        randomPrivateKey: () => {
          const I = P7(e.n);
          return pte(e.randomBytes(I), e.n);
        },
        precompute(I = 8, b = c.BASE) {
          return b._setWindowSize(I), b.multiply(BigInt(3)), b;
        },
      };
      function y(I, b = !0) {
        return c.fromPrivateKey(I).toRawBytes(b);
      }
      function E(I) {
        const b = ga(I),
          v = typeof I == "string",
          S = (b || v) && I.length;
        return b
          ? S === s || S === n
          : v
          ? S === 2 * s || S === 2 * n
          : I instanceof c;
      }
      function C(I, b, v = !0) {
        if (E(I)) throw new Error("first arg must be private key");
        if (!E(b)) throw new Error("second arg must be public key");
        return c.fromHex(b).multiply(l(I)).toRawBytes(v);
      }
      const O =
          e.bits2int ||
          function (I) {
            if (I.length > 8192) throw new Error("input is too large");
            const b = wa(I),
              v = I.length * 8 - e.nBitLength;
            return v > 0 ? b >> BigInt(v) : b;
          },
        A =
          e.bits2int_modN ||
          function (I) {
            return o(O(I));
          },
        P = iy(e.nBitLength);
      function N(I) {
        return Cn("num < 2^" + e.nBitLength, I, In, P), vl(I, e.nByteLength);
      }
      function x(I, b, v = $) {
        if (["recovered", "canonical"].some((re) => re in v))
          throw new Error("sign() legacy options not supported");
        const { hash: S, randomBytes: T } = e;
        let { lowS: _, prehash: R, extraEntropy: U } = v;
        _ == null && (_ = !0),
          (I = Ci("msgHash", I)),
          $7(v),
          R && (I = Ci("prehashed msgHash", S(I)));
        const D = A(I),
          H = l(b),
          q = [N(H), N(D)];
        if (U != null && U !== !1) {
          const re = U === !0 ? T(r.BYTES) : U;
          q.push(Ci("extraEntropy", re));
        }
        const V = Dh(...q),
          Y = D;
        function ae(re) {
          const te = O(re);
          if (!h(te)) return;
          const ve = a(te),
            Ee = c.BASE.multiply(te).toAffine(),
            Ce = o(Ee.x);
          if (Ce === In) return;
          const Ie = o(ve * o(Y + Ce * H));
          if (Ie === In) return;
          let mt = (Ee.x === Ce ? 0 : 2) | Number(Ee.y & ir),
            Ir = Ie;
          return _ && g(Ie) && ((Ir = p(Ie)), (mt ^= 1)), new f(Ce, Ir, mt);
        }
        return { seed: V, k2sig: ae };
      }
      const $ = { lowS: e.lowS, prehash: !1 },
        k = { lowS: e.lowS, prehash: !1 };
      function F(I, b, v = $) {
        const { seed: S, k2sig: T } = x(I, b, v),
          _ = e;
        return E7(_.hash.outputLen, _.nByteLength, _.hmac)(S, T);
      }
      c.BASE._setWindowSize(8);
      function j(I, b, v, S = k) {
        const T = I;
        (b = Ci("msgHash", b)), (v = Ci("publicKey", v));
        const { lowS: _, prehash: R, format: U } = S;
        if (($7(S), "strict" in S))
          throw new Error("options.strict was renamed to lowS");
        if (U !== void 0 && U !== "compact" && U !== "der")
          throw new Error("format must be compact or der");
        const D = typeof T == "string" || ga(T),
          H =
            !D &&
            !U &&
            typeof T == "object" &&
            T !== null &&
            typeof T.r == "bigint" &&
            typeof T.s == "bigint";
        if (!D && !H)
          throw new Error(
            "invalid signature, expected Uint8Array, hex string or Signature instance"
          );
        let q, V;
        try {
          if ((H && (q = new f(T.r, T.s)), D)) {
            try {
              U !== "compact" && (q = f.fromDER(T));
            } catch (Ie) {
              if (!(Ie instanceof xn.Err)) throw Ie;
            }
            !q && U !== "der" && (q = f.fromCompact(T));
          }
          V = c.fromHex(v);
        } catch {
          return !1;
        }
        if (!q || (_ && q.hasHighS())) return !1;
        R && (b = e.hash(b));
        const { r: Y, s: ae } = q,
          re = A(b),
          te = a(ae),
          ve = o(re * te),
          Ee = o(Y * te),
          Ce = c.BASE.multiplyAndAddUnsafe(V, ve, Ee)?.toAffine();
        return Ce ? o(Ce.x) === Y : !1;
      }
      return {
        CURVE: e,
        getPublicKey: y,
        getSharedSecret: C,
        sign: F,
        verify: j,
        ProjectivePoint: c,
        Signature: f,
        utils: m,
      };
    }
    function kte(t) {
      return {
        hash: t,
        hmac: (e, ...r) => $f(t, e, UQ(...r)),
        randomBytes: fl,
      };
    }
    function Rte(t, e) {
      const r = (i) => Tte({ ...t, ...kte(i) });
      return { ...r(e), create: r };
    }
    const B7 = A7(
        BigInt(
          "0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"
        )
      ),
      $te = B7.create(BigInt("-3")),
      Fte = BigInt(
        "0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"
      ),
      Bte = Rte(
        {
          a: $te,
          b: Fte,
          Fp: B7,
          n: BigInt(
            "0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"
          ),
          Gx: BigInt(
            "0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"
          ),
          Gy: BigInt(
            "0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"
          ),
          h: BigInt(1),
          lowS: !1,
        },
        Bh
      ),
      L7 = "base10",
      jr = "base16",
      as = "base64pad",
      mo = "base64url",
      jh = "utf8",
      U7 = 0,
      _n = 1,
      Mh = 2,
      Lte = 0,
      D7 = 1,
      zh = 12,
      gy = 32;
    function Ute() {
      const t = fy.utils.randomPrivateKey(),
        e = fy.getPublicKey(t);
      return { privateKey: et(t, jr), publicKey: et(e, jr) };
    }
    function wy() {
      const t = fl(gy);
      return et(t, jr);
    }
    function Dte(t, e) {
      const r = fy.getSharedSecret(yt(t, jr), yt(e, jr)),
        i = qee(Bh, r, void 0, void 0, gy);
      return et(i, jr);
    }
    function jf(t) {
      const e = Bh(yt(t, jr));
      return et(e, jr);
    }
    function Ts(t) {
      const e = Bh(yt(t, jh));
      return et(e, jr);
    }
    function j7(t) {
      return yt(`${t}`, L7);
    }
    function ya(t) {
      return Number(et(t, L7));
    }
    function M7(t) {
      return t.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
    }
    function z7(t) {
      const e = t.replace(/-/g, "+").replace(/_/g, "/"),
        r = (4 - (e.length % 4)) % 4;
      return e + "=".repeat(r);
    }
    function jte(t) {
      const e = j7(typeof t.type < "u" ? t.type : U7);
      if (ya(e) === _n && typeof t.senderPublicKey > "u")
        throw new Error("Missing sender public key for type 1 envelope");
      const r =
          typeof t.senderPublicKey < "u" ? yt(t.senderPublicKey, jr) : void 0,
        i = typeof t.iv < "u" ? yt(t.iv, jr) : fl(zh),
        s = yt(t.symKey, jr),
        n = g7(s, i).encrypt(yt(t.message, jh)),
        o = q7({ type: e, sealed: n, iv: i, senderPublicKey: r });
      return t.encoding === mo ? M7(o) : o;
    }
    function Mte(t) {
      const e = yt(t.symKey, jr),
        { sealed: r, iv: i } = qh({ encoded: t.encoded, encoding: t.encoding }),
        s = g7(e, i).decrypt(r);
      if (s === null) throw new Error("Failed to decrypt");
      return et(s, jh);
    }
    function zte(t, e) {
      const r = j7(Mh),
        i = fl(zh),
        s = yt(t, jh),
        n = q7({ type: r, sealed: s, iv: i });
      return e === mo ? M7(n) : n;
    }
    function qte(t, e) {
      const { sealed: r } = qh({ encoded: t, encoding: e });
      return et(r, jh);
    }
    function q7(t) {
      if (ya(t.type) === Mh) return et(vs([t.type, t.sealed]), as);
      if (ya(t.type) === _n) {
        if (typeof t.senderPublicKey > "u")
          throw new Error("Missing sender public key for type 1 envelope");
        return et(vs([t.type, t.senderPublicKey, t.iv, t.sealed]), as);
      }
      return et(vs([t.type, t.iv, t.sealed]), as);
    }
    function qh(t) {
      const e = (t.encoding || as) === mo ? z7(t.encoded) : t.encoded,
        r = yt(e, as),
        i = r.slice(Lte, D7),
        s = D7;
      if (ya(i) === _n) {
        const c = s + gy,
          l = c + zh,
          u = r.slice(s, c),
          h = r.slice(c, l),
          d = r.slice(l);
        return { type: i, sealed: d, iv: h, senderPublicKey: u };
      }
      if (ya(i) === Mh) {
        const c = r.slice(s),
          l = fl(zh);
        return { type: i, sealed: c, iv: l };
      }
      const n = s + zh,
        o = r.slice(s, n),
        a = r.slice(n);
      return { type: i, sealed: a, iv: o };
    }
    function Hte(t, e) {
      const r = qh({ encoded: t, encoding: e?.encoding });
      return H7({
        type: ya(r.type),
        senderPublicKey:
          typeof r.senderPublicKey < "u" ? et(r.senderPublicKey, jr) : void 0,
        receiverPublicKey: e?.receiverPublicKey,
      });
    }
    function H7(t) {
      const e = t?.type || U7;
      if (e === _n) {
        if (typeof t?.senderPublicKey > "u")
          throw new Error("missing sender public key");
        if (typeof t?.receiverPublicKey > "u")
          throw new Error("missing receiver public key");
      }
      return {
        type: e,
        senderPublicKey: t?.senderPublicKey,
        receiverPublicKey: t?.receiverPublicKey,
      };
    }
    function V7(t) {
      return (
        t.type === _n &&
        typeof t.senderPublicKey == "string" &&
        typeof t.receiverPublicKey == "string"
      );
    }
    function W7(t) {
      return t.type === Mh;
    }
    function Vte(t) {
      const e = Fe.from(t.x, "base64"),
        r = Fe.from(t.y, "base64");
      return vs([new Uint8Array([4]), e, r]);
    }
    function Wte(t, e) {
      const [r, i, s] = t.split("."),
        n = Fe.from(z7(s), "base64");
      if (n.length !== 64) throw new Error("Invalid signature length");
      const o = n.slice(0, 32),
        a = n.slice(32, 64),
        c = `${r}.${i}`,
        l = Bh(c),
        u = Vte(e);
      if (!Bte.verify(vs([o, a]), l, u)) throw new Error("Invalid signature");
      return oc(t).payload;
    }
    const Kte = "irn";
    function Mf(t) {
      return t?.relay || { protocol: Kte };
    }
    function Hh(t) {
      const e = u5[t];
      if (typeof e > "u") throw new Error(`Relay Protocol not supported: ${t}`);
      return e;
    }
    function Gte(t, e = "-") {
      const r = {},
        i = "relay" + e;
      return (
        Object.keys(t).forEach((s) => {
          if (s.startsWith(i)) {
            const n = s.replace(i, ""),
              o = t[s];
            r[n] = o;
          }
        }),
        r
      );
    }
    function K7(t) {
      if (!t.includes("wc:")) {
        const l = jC(t);
        l != null && l.includes("wc:") && (t = l);
      }
      (t = t.includes("wc://") ? t.replace("wc://", "") : t),
        (t = t.includes("wc:") ? t.replace("wc:", "") : t);
      const e = t.indexOf(":"),
        r = t.indexOf("?") !== -1 ? t.indexOf("?") : void 0,
        i = t.substring(0, e),
        s = t.substring(e + 1, r).split("@"),
        n = typeof r < "u" ? t.substring(r) : "",
        o = new URLSearchParams(n),
        a = {};
      o.forEach((l, u) => {
        a[u] = l;
      });
      const c = typeof a.methods == "string" ? a.methods.split(",") : void 0;
      return {
        protocol: i,
        topic: Zte(s[0]),
        version: parseInt(s[1], 10),
        symKey: a.symKey,
        relay: Gte(a),
        methods: c,
        expiryTimestamp: a.expiryTimestamp
          ? parseInt(a.expiryTimestamp, 10)
          : void 0,
      };
    }
    function Zte(t) {
      return t.startsWith("//") ? t.substring(2) : t;
    }
    function Yte(t, e = "-") {
      const r = "relay",
        i = {};
      return (
        Object.keys(t).forEach((s) => {
          const n = s,
            o = r + e + n;
          t[n] && (i[o] = t[n]);
        }),
        i
      );
    }
    function G7(t) {
      const e = new URLSearchParams(),
        r = Yte(t.relay);
      Object.keys(r)
        .sort()
        .forEach((s) => {
          e.set(s, r[s]);
        }),
        e.set("symKey", t.symKey),
        t.expiryTimestamp &&
          e.set("expiryTimestamp", t.expiryTimestamp.toString()),
        t.methods && e.set("methods", t.methods.join(","));
      const i = e.toString();
      return `${t.protocol}:${t.topic}@${t.version}?${i}`;
    }
    function zf(t, e, r) {
      return `${t}?wc_ev=${r}&topic=${e}`;
    }
    function xl(t) {
      const e = [];
      return (
        t.forEach((r) => {
          const [i, s] = r.split(":");
          e.push(`${i}:${s}`);
        }),
        e
      );
    }
    function Jte(t) {
      const e = [];
      return (
        Object.values(t).forEach((r) => {
          e.push(...xl(r.accounts));
        }),
        e
      );
    }
    function Xte(t, e) {
      const r = [];
      return (
        Object.values(t).forEach((i) => {
          xl(i.accounts).includes(e) && r.push(...i.methods);
        }),
        r
      );
    }
    function Qte(t, e) {
      const r = [];
      return (
        Object.values(t).forEach((i) => {
          xl(i.accounts).includes(e) && r.push(...i.events);
        }),
        r
      );
    }
    function my(t) {
      return t.includes(":");
    }
    function Vh(t) {
      return my(t) ? t.split(":")[0] : t;
    }
    function ere(t) {
      const e = {};
      return (
        t?.forEach((r) => {
          var i;
          const [s, n] = r.split(":");
          e[s] ||
            (e[s] = { accounts: [], chains: [], events: [], methods: [] }),
            e[s].accounts.push(r),
            (i = e[s].chains) == null || i.push(`${s}:${n}`);
        }),
        e
      );
    }
    function Z7(t, e) {
      e = e.map((i) => i.replace("did:pkh:", ""));
      const r = ere(e);
      for (const [i, s] of Object.entries(r))
        s.methods ? (s.methods = Of(s.methods, t)) : (s.methods = t),
          (s.events = ["chainChanged", "accountsChanged"]);
      return r;
    }
    const tre = {
        INVALID_METHOD: { message: "Invalid method.", code: 1001 },
        INVALID_EVENT: { message: "Invalid event.", code: 1002 },
        INVALID_UPDATE_REQUEST: {
          message: "Invalid update request.",
          code: 1003,
        },
        INVALID_EXTEND_REQUEST: {
          message: "Invalid extend request.",
          code: 1004,
        },
        INVALID_SESSION_SETTLE_REQUEST: {
          message: "Invalid session settle request.",
          code: 1005,
        },
        UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 },
        UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 },
        UNAUTHORIZED_UPDATE_REQUEST: {
          message: "Unauthorized update request.",
          code: 3003,
        },
        UNAUTHORIZED_EXTEND_REQUEST: {
          message: "Unauthorized extend request.",
          code: 3004,
        },
        USER_REJECTED: { message: "User rejected.", code: 5e3 },
        USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 },
        USER_REJECTED_METHODS: {
          message: "User rejected methods.",
          code: 5002,
        },
        USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 },
        UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 },
        UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 },
        UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 },
        UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 },
        UNSUPPORTED_NAMESPACE_KEY: {
          message: "Unsupported namespace key.",
          code: 5104,
        },
        USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 },
        SESSION_SETTLEMENT_FAILED: {
          message: "Session settlement failed.",
          code: 7e3,
        },
        WC_METHOD_UNSUPPORTED: {
          message: "Unsupported wc_ method.",
          code: 10001,
        },
      },
      rre = {
        NOT_INITIALIZED: { message: "Not initialized.", code: 1 },
        NO_MATCHING_KEY: { message: "No matching key.", code: 2 },
        RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 },
        RESUBSCRIBED: { message: "Resubscribed.", code: 4 },
        MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 },
        EXPIRED: { message: "Expired.", code: 6 },
        UNKNOWN_TYPE: { message: "Unknown type.", code: 7 },
        MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 },
        NON_CONFORMING_NAMESPACES: {
          message: "Non conforming namespaces.",
          code: 9,
        },
      };
    function Q(t, e) {
      const { message: r, code: i } = rre[t];
      return { message: e ? `${r} ${e}` : r, code: i };
    }
    function tt(t, e) {
      const { message: r, code: i } = tre[t];
      return { message: e ? `${r} ${e}` : r, code: i };
    }
    function yo(t, e) {
      return Array.isArray(t)
        ? typeof e < "u" && t.length
          ? t.every(e)
          : !0
        : !1;
    }
    function Wh(t) {
      return (
        Object.getPrototypeOf(t) === Object.prototype && Object.keys(t).length
      );
    }
    function yr(t) {
      return typeof t > "u";
    }
    function kt(t, e) {
      return e && yr(t) ? !0 : typeof t == "string" && !!t.trim().length;
    }
    function yy(t, e) {
      return e && yr(t) ? !0 : typeof t == "number" && !isNaN(t);
    }
    function ire(t, e) {
      const { requiredNamespaces: r } = e,
        i = Object.keys(t.namespaces),
        s = Object.keys(r);
      let n = !0;
      return da(s, i)
        ? (i.forEach((o) => {
            const { accounts: a, methods: c, events: l } = t.namespaces[o],
              u = xl(a),
              h = r[o];
            (!da(OC(o, h), u) || !da(h.methods, c) || !da(h.events, l)) &&
              (n = !1);
          }),
          n)
        : !1;
    }
    function qf(t) {
      return kt(t, !1) && t.includes(":") ? t.split(":").length === 2 : !1;
    }
    function sre(t) {
      if (kt(t, !1) && t.includes(":")) {
        const e = t.split(":");
        if (e.length === 3) {
          const r = e[0] + ":" + e[1];
          return !!e[2] && qf(r);
        }
      }
      return !1;
    }
    function nre(t) {
      function e(r) {
        try {
          return typeof new URL(r) < "u";
        } catch {
          return !1;
        }
      }
      try {
        if (kt(t, !1)) {
          if (e(t)) return !0;
          const r = jC(t);
          return e(r);
        }
      } catch {}
      return !1;
    }
    function ore(t) {
      var e;
      return (e = t?.proposer) == null ? void 0 : e.publicKey;
    }
    function are(t) {
      return t?.topic;
    }
    function cre(t, e) {
      let r = null;
      return (
        kt(t?.publicKey, !1) ||
          (r = Q(
            "MISSING_OR_INVALID",
            `${e} controller public key should be a string`
          )),
        r
      );
    }
    function Y7(t) {
      let e = !0;
      return yo(t) ? t.length && (e = t.every((r) => kt(r, !1))) : (e = !1), e;
    }
    function lre(t, e, r) {
      let i = null;
      return (
        yo(e) && e.length
          ? e.forEach((s) => {
              i ||
                qf(s) ||
                (i = tt(
                  "UNSUPPORTED_CHAINS",
                  `${r}, chain ${s} should be a string and conform to "namespace:chainId" format`
                ));
            })
          : qf(t) ||
            (i = tt(
              "UNSUPPORTED_CHAINS",
              `${r}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`
            )),
        i
      );
    }
    function ure(t, e, r) {
      let i = null;
      return (
        Object.entries(t).forEach(([s, n]) => {
          if (i) return;
          const o = lre(s, OC(s, n), `${e} ${r}`);
          o && (i = o);
        }),
        i
      );
    }
    function hre(t, e) {
      let r = null;
      return (
        yo(t)
          ? t.forEach((i) => {
              r ||
                sre(i) ||
                (r = tt(
                  "UNSUPPORTED_ACCOUNTS",
                  `${e}, account ${i} should be a string and conform to "namespace:chainId:address" format`
                ));
            })
          : (r = tt(
              "UNSUPPORTED_ACCOUNTS",
              `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`
            )),
        r
      );
    }
    function dre(t, e) {
      let r = null;
      return (
        Object.values(t).forEach((i) => {
          if (r) return;
          const s = hre(i?.accounts, `${e} namespace`);
          s && (r = s);
        }),
        r
      );
    }
    function pre(t, e) {
      let r = null;
      return (
        Y7(t?.methods)
          ? Y7(t?.events) ||
            (r = tt(
              "UNSUPPORTED_EVENTS",
              `${e}, events should be an array of strings or empty array for no events`
            ))
          : (r = tt(
              "UNSUPPORTED_METHODS",
              `${e}, methods should be an array of strings or empty array for no methods`
            )),
        r
      );
    }
    function J7(t, e) {
      let r = null;
      return (
        Object.values(t).forEach((i) => {
          if (r) return;
          const s = pre(i, `${e}, namespace`);
          s && (r = s);
        }),
        r
      );
    }
    function fre(t, e, r) {
      let i = null;
      if (t && Wh(t)) {
        const s = J7(t, e);
        s && (i = s);
        const n = ure(t, e, r);
        n && (i = n);
      } else i = Q("MISSING_OR_INVALID", `${e}, ${r} should be an object with data`);
      return i;
    }
    function by(t, e) {
      let r = null;
      if (t && Wh(t)) {
        const i = J7(t, e);
        i && (r = i);
        const s = dre(t, e);
        s && (r = s);
      } else r = Q("MISSING_OR_INVALID", `${e}, namespaces should be an object with data`);
      return r;
    }
    function X7(t) {
      return kt(t.protocol, !0);
    }
    function gre(t, e) {
      let r = !1;
      return (
        e && !t
          ? (r = !0)
          : t &&
            yo(t) &&
            t.length &&
            t.forEach((i) => {
              r = X7(i);
            }),
        r
      );
    }
    function wre(t) {
      return typeof t == "number";
    }
    function Qr(t) {
      return typeof t < "u" && typeof t !== null;
    }
    function mre(t) {
      return !(
        !t ||
        typeof t != "object" ||
        !t.code ||
        !yy(t.code, !1) ||
        !t.message ||
        !kt(t.message, !1)
      );
    }
    function yre(t) {
      return !(yr(t) || !kt(t.method, !1));
    }
    function bre(t) {
      return !(
        yr(t) ||
        (yr(t.result) && yr(t.error)) ||
        !yy(t.id, !1) ||
        !kt(t.jsonrpc, !1)
      );
    }
    function vre(t) {
      return !(yr(t) || !kt(t.name, !1));
    }
    function Q7(t, e) {
      return !(!qf(e) || !Jte(t).includes(e));
    }
    function Ere(t, e, r) {
      return kt(r, !1) ? Xte(t, e).includes(r) : !1;
    }
    function Cre(t, e, r) {
      return kt(r, !1) ? Qte(t, e).includes(r) : !1;
    }
    function ex(t, e, r) {
      let i = null;
      const s = xre(t),
        n = Ire(e),
        o = Object.keys(s),
        a = Object.keys(n),
        c = tx(Object.keys(t)),
        l = tx(Object.keys(e)),
        u = c.filter((h) => !l.includes(h));
      return (
        u.length &&
          (i = Q(
            "NON_CONFORMING_NAMESPACES",
            `${r} namespaces keys don't satisfy requiredNamespaces.
      Required: ${u.toString()}
      Received: ${Object.keys(e).toString()}`
          )),
        da(o, a) ||
          (i = Q(
            "NON_CONFORMING_NAMESPACES",
            `${r} namespaces chains don't satisfy required namespaces.
      Required: ${o.toString()}
      Approved: ${a.toString()}`
          )),
        Object.keys(e).forEach((h) => {
          if (!h.includes(":") || i) return;
          const d = xl(e[h].accounts);
          d.includes(h) ||
            (i = Q(
              "NON_CONFORMING_NAMESPACES",
              `${r} namespaces accounts don't satisfy namespace accounts for ${h}
        Required: ${h}
        Approved: ${d.toString()}`
            ));
        }),
        o.forEach((h) => {
          i ||
            (da(s[h].methods, n[h].methods)
              ? da(s[h].events, n[h].events) ||
                (i = Q(
                  "NON_CONFORMING_NAMESPACES",
                  `${r} namespaces events don't satisfy namespace events for ${h}`
                ))
              : (i = Q(
                  "NON_CONFORMING_NAMESPACES",
                  `${r} namespaces methods don't satisfy namespace methods for ${h}`
                )));
        }),
        i
      );
    }
    function xre(t) {
      const e = {};
      return (
        Object.keys(t).forEach((r) => {
          var i;
          r.includes(":")
            ? (e[r] = t[r])
            : (i = t[r].chains) == null ||
              i.forEach((s) => {
                e[s] = { methods: t[r].methods, events: t[r].events };
              });
        }),
        e
      );
    }
    function tx(t) {
      return [
        ...new Set(t.map((e) => (e.includes(":") ? e.split(":")[0] : e))),
      ];
    }
    function Ire(t) {
      const e = {};
      return (
        Object.keys(t).forEach((r) => {
          r.includes(":")
            ? (e[r] = t[r])
            : xl(t[r].accounts)?.forEach((i) => {
                e[i] = {
                  accounts: t[r].accounts.filter((s) => s.includes(`${i}:`)),
                  methods: t[r].methods,
                  events: t[r].events,
                };
              });
        }),
        e
      );
    }
    function _re(t, e) {
      return yy(t, !1) && t <= e.max && t >= e.min;
    }
    function rx() {
      const t = Th();
      return new Promise((e) => {
        switch (t) {
          case vi.browser:
            e(Are());
            break;
          case vi.reactNative:
            e(Sre());
            break;
          case vi.node:
            e(Pre());
            break;
          default:
            e(!0);
        }
      });
    }
    function Are() {
      return Nh() && navigator?.onLine;
    }
    async function Sre() {
      return uo() &&
        typeof globalThis < "u" &&
        globalThis != null &&
        globalThis.NetInfo
        ? (await globalThis?.NetInfo.fetch())?.isConnected
        : !0;
    }
    function Pre() {
      return !0;
    }
    function Ore(t) {
      switch (Th()) {
        case vi.browser:
          Nre(t);
          break;
        case vi.reactNative:
          Tre(t);
          break;
      }
    }
    function Nre(t) {
      !uo() &&
        Nh() &&
        (window.addEventListener("online", () => t(!0)),
        window.addEventListener("offline", () => t(!1)));
    }
    function Tre(t) {
      uo() &&
        typeof globalThis < "u" &&
        globalThis != null &&
        globalThis.NetInfo &&
        globalThis?.NetInfo.addEventListener((e) => t(e?.isConnected));
    }
    const vy = {};
    class Kh {
      static get(e) {
        return vy[e];
      }
      static set(e, r) {
        vy[e] = r;
      }
      static delete(e) {
        delete vy[e];
      }
    }
    const ix = "wc",
      sx = 2,
      Hf = "core",
      ks = `${ix}@2:${Hf}:`,
      kre = { name: Hf, logger: "error" },
      Rre = { database: ":memory:" },
      $re = "crypto",
      nx = "client_ed25519_seed",
      Fre = z.ONE_DAY,
      Bre = "keychain",
      Lre = "0.3",
      Ure = "messages",
      Dre = "0.3",
      ox = z.SIX_HOURS,
      jre = "publisher",
      ax = "irn",
      Mre = "error",
      cx = "wss://relay.walletconnect.org",
      zre = "relayer",
      sr = {
        message: "relayer_message",
        message_ack: "relayer_message_ack",
        connect: "relayer_connect",
        disconnect: "relayer_disconnect",
        error: "relayer_error",
        connection_stalled: "relayer_connection_stalled",
        transport_closed: "relayer_transport_closed",
        publish: "relayer_publish",
      },
      qre = "_subscription",
      Di = {
        payload: "payload",
        connect: "connect",
        disconnect: "disconnect",
        error: "error",
      },
      Hre = 0.1,
      Ey = "2.19.2",
      wt = { link_mode: "link_mode", relay: "relay" },
      Vf = { inbound: "inbound", outbound: "outbound" },
      Vre = "0.3",
      Wre = "WALLETCONNECT_CLIENT_ID",
      lx = "WALLETCONNECT_LINK_MODE_APPS",
      xi = {
        created: "subscription_created",
        deleted: "subscription_deleted",
        expired: "subscription_expired",
        disabled: "subscription_disabled",
        sync: "subscription_sync",
        resubscribed: "subscription_resubscribed",
      },
      Kre = "subscription",
      Gre = "0.3",
      Zre = "pairing",
      Yre = "0.3",
      Gh = {
        wc_pairingDelete: {
          req: { ttl: z.ONE_DAY, prompt: !1, tag: 1e3 },
          res: { ttl: z.ONE_DAY, prompt: !1, tag: 1001 },
        },
        wc_pairingPing: {
          req: { ttl: z.THIRTY_SECONDS, prompt: !1, tag: 1002 },
          res: { ttl: z.THIRTY_SECONDS, prompt: !1, tag: 1003 },
        },
        unregistered_method: {
          req: { ttl: z.ONE_DAY, prompt: !1, tag: 0 },
          res: { ttl: z.ONE_DAY, prompt: !1, tag: 0 },
        },
      },
      ba = {
        create: "pairing_create",
        expire: "pairing_expire",
        delete: "pairing_delete",
        ping: "pairing_ping",
      },
      cs = {
        created: "history_created",
        updated: "history_updated",
        deleted: "history_deleted",
        sync: "history_sync",
      },
      Jre = "history",
      Xre = "0.3",
      Qre = "expirer",
      ji = {
        created: "expirer_created",
        deleted: "expirer_deleted",
        expired: "expirer_expired",
        sync: "expirer_sync",
      },
      eie = "0.3",
      tie = "verify-api",
      rie = "https://verify.walletconnect.com",
      ux = "https://verify.walletconnect.org",
      Zh = ux,
      iie = `${Zh}/v3`,
      sie = [rie, ux],
      nie = "echo",
      oie = "https://echo.walletconnect.com",
      Rs = {
        pairing_started: "pairing_started",
        pairing_uri_validation_success: "pairing_uri_validation_success",
        pairing_uri_not_expired: "pairing_uri_not_expired",
        store_new_pairing: "store_new_pairing",
        subscribing_pairing_topic: "subscribing_pairing_topic",
        subscribe_pairing_topic_success: "subscribe_pairing_topic_success",
        existing_pairing: "existing_pairing",
        pairing_not_expired: "pairing_not_expired",
        emit_inactive_pairing: "emit_inactive_pairing",
        emit_session_proposal: "emit_session_proposal",
        subscribing_to_pairing_topic: "subscribing_to_pairing_topic",
      },
      An = {
        no_wss_connection: "no_wss_connection",
        no_internet_connection: "no_internet_connection",
        malformed_pairing_uri: "malformed_pairing_uri",
        active_pairing_already_exists: "active_pairing_already_exists",
        subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure",
        pairing_expired: "pairing_expired",
        proposal_expired: "proposal_expired",
        proposal_listener_not_found: "proposal_listener_not_found",
      },
      ls = {
        session_approve_started: "session_approve_started",
        proposal_not_expired: "proposal_not_expired",
        session_namespaces_validation_success:
          "session_namespaces_validation_success",
        create_session_topic: "create_session_topic",
        subscribing_session_topic: "subscribing_session_topic",
        subscribe_session_topic_success: "subscribe_session_topic_success",
        publishing_session_approve: "publishing_session_approve",
        session_approve_publish_success: "session_approve_publish_success",
        store_session: "store_session",
        publishing_session_settle: "publishing_session_settle",
        session_settle_publish_success: "session_settle_publish_success",
      },
      va = {
        no_internet_connection: "no_internet_connection",
        no_wss_connection: "no_wss_connection",
        proposal_expired: "proposal_expired",
        subscribe_session_topic_failure: "subscribe_session_topic_failure",
        session_approve_publish_failure: "session_approve_publish_failure",
        session_settle_publish_failure: "session_settle_publish_failure",
        session_approve_namespace_validation_failure:
          "session_approve_namespace_validation_failure",
        proposal_not_found: "proposal_not_found",
      },
      Ea = {
        authenticated_session_approve_started:
          "authenticated_session_approve_started",
        authenticated_session_not_expired: "authenticated_session_not_expired",
        chains_caip2_compliant: "chains_caip2_compliant",
        chains_evm_compliant: "chains_evm_compliant",
        create_authenticated_session_topic:
          "create_authenticated_session_topic",
        cacaos_verified: "cacaos_verified",
        store_authenticated_session: "store_authenticated_session",
        subscribing_authenticated_session_topic:
          "subscribing_authenticated_session_topic",
        subscribe_authenticated_session_topic_success:
          "subscribe_authenticated_session_topic_success",
        publishing_authenticated_session_approve:
          "publishing_authenticated_session_approve",
        authenticated_session_approve_publish_success:
          "authenticated_session_approve_publish_success",
      },
      Yh = {
        no_internet_connection: "no_internet_connection",
        no_wss_connection: "no_wss_connection",
        missing_session_authenticate_request:
          "missing_session_authenticate_request",
        session_authenticate_request_expired:
          "session_authenticate_request_expired",
        chains_caip2_compliant_failure: "chains_caip2_compliant_failure",
        chains_evm_compliant_failure: "chains_evm_compliant_failure",
        invalid_cacao: "invalid_cacao",
        subscribe_authenticated_session_topic_failure:
          "subscribe_authenticated_session_topic_failure",
        authenticated_session_approve_publish_failure:
          "authenticated_session_approve_publish_failure",
        authenticated_session_pending_request_not_found:
          "authenticated_session_pending_request_not_found",
      },
      aie = 0.1,
      cie = "event-client",
      lie = 86400,
      uie = "https://pulse.walletconnect.org/batch";
    function hie(t, e) {
      if (t.length >= 255) throw new TypeError("Alphabet too long");
      for (var r = new Uint8Array(256), i = 0; i < r.length; i++) r[i] = 255;
      for (var s = 0; s < t.length; s++) {
        var n = t.charAt(s),
          o = n.charCodeAt(0);
        if (r[o] !== 255) throw new TypeError(n + " is ambiguous");
        r[o] = s;
      }
      var a = t.length,
        c = t.charAt(0),
        l = Math.log(a) / Math.log(256),
        u = Math.log(256) / Math.log(a);
      function h(p) {
        if (
          (p instanceof Uint8Array ||
            (ArrayBuffer.isView(p)
              ? (p = new Uint8Array(p.buffer, p.byteOffset, p.byteLength))
              : Array.isArray(p) && (p = Uint8Array.from(p))),
          !(p instanceof Uint8Array))
        )
          throw new TypeError("Expected Uint8Array");
        if (p.length === 0) return "";
        for (var w = 0, f = 0, m = 0, y = p.length; m !== y && p[m] === 0; )
          m++, w++;
        for (
          var E = ((y - m) * u + 1) >>> 0, C = new Uint8Array(E);
          m !== y;

        ) {
          for (
            var O = p[m], A = 0, P = E - 1;
            (O !== 0 || A < f) && P !== -1;
            P--, A++
          )
            (O += (256 * C[P]) >>> 0),
              (C[P] = O % a >>> 0),
              (O = (O / a) >>> 0);
          if (O !== 0) throw new Error("Non-zero carry");
          (f = A), m++;
        }
        for (var N = E - f; N !== E && C[N] === 0; ) N++;
        for (var x = c.repeat(w); N < E; ++N) x += t.charAt(C[N]);
        return x;
      }
      function d(p) {
        if (typeof p != "string") throw new TypeError("Expected String");
        if (p.length === 0) return new Uint8Array();
        var w = 0;
        if (p[w] !== " ") {
          for (var f = 0, m = 0; p[w] === c; ) f++, w++;
          for (
            var y = ((p.length - w) * l + 1) >>> 0, E = new Uint8Array(y);
            p[w];

          ) {
            var C = r[p.charCodeAt(w)];
            if (C === 255) return;
            for (var O = 0, A = y - 1; (C !== 0 || O < m) && A !== -1; A--, O++)
              (C += (a * E[A]) >>> 0),
                (E[A] = C % 256 >>> 0),
                (C = (C / 256) >>> 0);
            if (C !== 0) throw new Error("Non-zero carry");
            (m = O), w++;
          }
          if (p[w] !== " ") {
            for (var P = y - m; P !== y && E[P] === 0; ) P++;
            for (var N = new Uint8Array(f + (y - P)), x = f; P !== y; )
              N[x++] = E[P++];
            return N;
          }
        }
      }
      function g(p) {
        var w = d(p);
        if (w) return w;
        throw new Error(`Non-${e} character`);
      }
      return { encode: h, decodeUnsafe: d, decode: g };
    }
    var die = hie,
      pie = die;
    const hx = (t) => {
        if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
          return t;
        if (t instanceof ArrayBuffer) return new Uint8Array(t);
        if (ArrayBuffer.isView(t))
          return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
        throw new Error("Unknown type, must be binary type");
      },
      fie = (t) => new TextEncoder().encode(t),
      gie = (t) => new TextDecoder().decode(t);
    class wie {
      constructor(e, r, i) {
        (this.name = e), (this.prefix = r), (this.baseEncode = i);
      }
      encode(e) {
        if (e instanceof Uint8Array)
          return `${this.prefix}${this.baseEncode(e)}`;
        throw Error("Unknown type, must be binary type");
      }
    }
    class mie {
      constructor(e, r, i) {
        if (((this.name = e), (this.prefix = r), r.codePointAt(0) === void 0))
          throw new Error("Invalid prefix character");
        (this.prefixCodePoint = r.codePointAt(0)), (this.baseDecode = i);
      }
      decode(e) {
        if (typeof e == "string") {
          if (e.codePointAt(0) !== this.prefixCodePoint)
            throw Error(
              `Unable to decode multibase string ${JSON.stringify(e)}, ${
                this.name
              } decoder only supports inputs prefixed with ${this.prefix}`
            );
          return this.baseDecode(e.slice(this.prefix.length));
        } else throw Error("Can only multibase decode strings");
      }
      or(e) {
        return dx(this, e);
      }
    }
    class yie {
      constructor(e) {
        this.decoders = e;
      }
      or(e) {
        return dx(this, e);
      }
      decode(e) {
        const r = e[0],
          i = this.decoders[r];
        if (i) return i.decode(e);
        throw RangeError(
          `Unable to decode multibase string ${JSON.stringify(
            e
          )}, only inputs prefixed with ${Object.keys(
            this.decoders
          )} are supported`
        );
      }
    }
    const dx = (t, e) =>
      new yie({
        ...(t.decoders || { [t.prefix]: t }),
        ...(e.decoders || { [e.prefix]: e }),
      });
    class bie {
      constructor(e, r, i, s) {
        (this.name = e),
          (this.prefix = r),
          (this.baseEncode = i),
          (this.baseDecode = s),
          (this.encoder = new wie(e, r, i)),
          (this.decoder = new mie(e, r, s));
      }
      encode(e) {
        return this.encoder.encode(e);
      }
      decode(e) {
        return this.decoder.decode(e);
      }
    }
    const Wf = ({ name: t, prefix: e, encode: r, decode: i }) =>
        new bie(t, e, r, i),
      Jh = ({ prefix: t, name: e, alphabet: r }) => {
        const { encode: i, decode: s } = pie(r, e);
        return Wf({ prefix: t, name: e, encode: i, decode: (n) => hx(s(n)) });
      },
      vie = (t, e, r, i) => {
        const s = {};
        for (let u = 0; u < e.length; ++u) s[e[u]] = u;
        let n = t.length;
        for (; t[n - 1] === "="; ) --n;
        const o = new Uint8Array(((n * r) / 8) | 0);
        let a = 0,
          c = 0,
          l = 0;
        for (let u = 0; u < n; ++u) {
          const h = s[t[u]];
          if (h === void 0) throw new SyntaxError(`Non-${i} character`);
          (c = (c << r) | h),
            (a += r),
            a >= 8 && ((a -= 8), (o[l++] = 255 & (c >> a)));
        }
        if (a >= r || 255 & (c << (8 - a)))
          throw new SyntaxError("Unexpected end of data");
        return o;
      },
      Eie = (t, e, r) => {
        const i = e[e.length - 1] === "=",
          s = (1 << r) - 1;
        let n = "",
          o = 0,
          a = 0;
        for (let c = 0; c < t.length; ++c)
          for (a = (a << 8) | t[c], o += 8; o > r; )
            (o -= r), (n += e[s & (a >> o)]);
        if ((o && (n += e[s & (a << (r - o))]), i))
          for (; (n.length * r) & 7; ) n += "=";
        return n;
      },
      br = ({ name: t, prefix: e, bitsPerChar: r, alphabet: i }) =>
        Wf({
          prefix: e,
          name: t,
          encode(s) {
            return Eie(s, i, r);
          },
          decode(s) {
            return vie(s, i, r, t);
          },
        }),
      Cie = Wf({
        prefix: "\0",
        name: "identity",
        encode: (t) => gie(t),
        decode: (t) => fie(t),
      });
    var xie = Object.freeze({ __proto__: null, identity: Cie });
    const Iie = br({
      prefix: "0",
      name: "base2",
      alphabet: "01",
      bitsPerChar: 1,
    });
    var _ie = Object.freeze({ __proto__: null, base2: Iie });
    const Aie = br({
      prefix: "7",
      name: "base8",
      alphabet: "01234567",
      bitsPerChar: 3,
    });
    var Sie = Object.freeze({ __proto__: null, base8: Aie });
    const Pie = Jh({ prefix: "9", name: "base10", alphabet: "0123456789" });
    var Oie = Object.freeze({ __proto__: null, base10: Pie });
    const Nie = br({
        prefix: "f",
        name: "base16",
        alphabet: "0123456789abcdef",
        bitsPerChar: 4,
      }),
      Tie = br({
        prefix: "F",
        name: "base16upper",
        alphabet: "0123456789ABCDEF",
        bitsPerChar: 4,
      });
    var kie = Object.freeze({ __proto__: null, base16: Nie, base16upper: Tie });
    const Rie = br({
        prefix: "b",
        name: "base32",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567",
        bitsPerChar: 5,
      }),
      $ie = br({
        prefix: "B",
        name: "base32upper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
        bitsPerChar: 5,
      }),
      Fie = br({
        prefix: "c",
        name: "base32pad",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
        bitsPerChar: 5,
      }),
      Bie = br({
        prefix: "C",
        name: "base32padupper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
        bitsPerChar: 5,
      }),
      Lie = br({
        prefix: "v",
        name: "base32hex",
        alphabet: "0123456789abcdefghijklmnopqrstuv",
        bitsPerChar: 5,
      }),
      Uie = br({
        prefix: "V",
        name: "base32hexupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
        bitsPerChar: 5,
      }),
      Die = br({
        prefix: "t",
        name: "base32hexpad",
        alphabet: "0123456789abcdefghijklmnopqrstuv=",
        bitsPerChar: 5,
      }),
      jie = br({
        prefix: "T",
        name: "base32hexpadupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
        bitsPerChar: 5,
      }),
      Mie = br({
        prefix: "h",
        name: "base32z",
        alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
        bitsPerChar: 5,
      });
    var zie = Object.freeze({
      __proto__: null,
      base32: Rie,
      base32upper: $ie,
      base32pad: Fie,
      base32padupper: Bie,
      base32hex: Lie,
      base32hexupper: Uie,
      base32hexpad: Die,
      base32hexpadupper: jie,
      base32z: Mie,
    });
    const qie = Jh({
        prefix: "k",
        name: "base36",
        alphabet: "0123456789abcdefghijklmnopqrstuvwxyz",
      }),
      Hie = Jh({
        prefix: "K",
        name: "base36upper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
      });
    var Vie = Object.freeze({ __proto__: null, base36: qie, base36upper: Hie });
    const Wie = Jh({
        name: "base58btc",
        prefix: "z",
        alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
      }),
      Kie = Jh({
        name: "base58flickr",
        prefix: "Z",
        alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
      });
    var Gie = Object.freeze({
      __proto__: null,
      base58btc: Wie,
      base58flickr: Kie,
    });
    const Zie = br({
        prefix: "m",
        name: "base64",
        alphabet:
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        bitsPerChar: 6,
      }),
      Yie = br({
        prefix: "M",
        name: "base64pad",
        alphabet:
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        bitsPerChar: 6,
      }),
      Jie = br({
        prefix: "u",
        name: "base64url",
        alphabet:
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
        bitsPerChar: 6,
      }),
      Xie = br({
        prefix: "U",
        name: "base64urlpad",
        alphabet:
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
        bitsPerChar: 6,
      });
    var Qie = Object.freeze({
      __proto__: null,
      base64: Zie,
      base64pad: Yie,
      base64url: Jie,
      base64urlpad: Xie,
    });
    const px = Array.from(
        "\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"
      ),
      ese = px.reduce((t, e, r) => ((t[r] = e), t), []),
      tse = px.reduce((t, e, r) => ((t[e.codePointAt(0)] = r), t), []);
    function rse(t) {
      return t.reduce((e, r) => ((e += ese[r]), e), "");
    }
    function ise(t) {
      const e = [];
      for (const r of t) {
        const i = tse[r.codePointAt(0)];
        if (i === void 0) throw new Error(`Non-base256emoji character: ${r}`);
        e.push(i);
      }
      return new Uint8Array(e);
    }
    const sse = Wf({
      prefix: "\u{1F680}",
      name: "base256emoji",
      encode: rse,
      decode: ise,
    });
    var nse = Object.freeze({ __proto__: null, base256emoji: sse }),
      ose = gx,
      fx = 128,
      ase = 127,
      cse = ~ase,
      lse = Math.pow(2, 31);
    function gx(t, e, r) {
      (e = e || []), (r = r || 0);
      for (var i = r; t >= lse; ) (e[r++] = (t & 255) | fx), (t /= 128);
      for (; t & cse; ) (e[r++] = (t & 255) | fx), (t >>>= 7);
      return (e[r] = t | 0), (gx.bytes = r - i + 1), e;
    }
    var use = Cy,
      hse = 128,
      wx = 127;
    function Cy(t, i) {
      var r = 0,
        i = i || 0,
        s = 0,
        n = i,
        o,
        a = t.length;
      do {
        if (n >= a)
          throw ((Cy.bytes = 0), new RangeError("Could not decode varint"));
        (o = t[n++]),
          (r += s < 28 ? (o & wx) << s : (o & wx) * Math.pow(2, s)),
          (s += 7);
      } while (o >= hse);
      return (Cy.bytes = n - i), r;
    }
    var dse = Math.pow(2, 7),
      pse = Math.pow(2, 14),
      fse = Math.pow(2, 21),
      gse = Math.pow(2, 28),
      wse = Math.pow(2, 35),
      mse = Math.pow(2, 42),
      yse = Math.pow(2, 49),
      bse = Math.pow(2, 56),
      vse = Math.pow(2, 63),
      Ese = function (t) {
        return t < dse
          ? 1
          : t < pse
          ? 2
          : t < fse
          ? 3
          : t < gse
          ? 4
          : t < wse
          ? 5
          : t < mse
          ? 6
          : t < yse
          ? 7
          : t < bse
          ? 8
          : t < vse
          ? 9
          : 10;
      },
      Cse = { encode: ose, decode: use, encodingLength: Ese },
      mx = Cse;
    const yx = (t, e, r = 0) => (mx.encode(t, e, r), e),
      bx = (t) => mx.encodingLength(t),
      xy = (t, e) => {
        const r = e.byteLength,
          i = bx(t),
          s = i + bx(r),
          n = new Uint8Array(s + r);
        return yx(t, n, 0), yx(r, n, i), n.set(e, s), new xse(t, r, e, n);
      };
    class xse {
      constructor(e, r, i, s) {
        (this.code = e), (this.size = r), (this.digest = i), (this.bytes = s);
      }
    }
    const vx = ({ name: t, code: e, encode: r }) => new Ise(t, e, r);
    class Ise {
      constructor(e, r, i) {
        (this.name = e), (this.code = r), (this.encode = i);
      }
      digest(e) {
        if (e instanceof Uint8Array) {
          const r = this.encode(e);
          return r instanceof Uint8Array
            ? xy(this.code, r)
            : r.then((i) => xy(this.code, i));
        } else throw Error("Unknown type, must be binary type");
      }
    }
    const Ex = (t) => async (e) =>
        new Uint8Array(await crypto.subtle.digest(t, e)),
      _se = vx({ name: "sha2-256", code: 18, encode: Ex("SHA-256") }),
      Ase = vx({ name: "sha2-512", code: 19, encode: Ex("SHA-512") });
    var Sse = Object.freeze({ __proto__: null, sha256: _se, sha512: Ase });
    const Cx = 0,
      Pse = "identity",
      xx = hx;
    var Ose = Object.freeze({
      __proto__: null,
      identity: {
        code: Cx,
        name: Pse,
        encode: xx,
        digest: (t) => xy(Cx, xx(t)),
      },
    });
    new TextEncoder(), new TextDecoder();
    const Ix = {
      ...xie,
      ..._ie,
      ...Sie,
      ...Oie,
      ...kie,
      ...zie,
      ...Vie,
      ...Gie,
      ...Qie,
      ...nse,
    };
    ({ ...Sse, ...Ose });
    function Nse(t = 0) {
      return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null
        ? globalThis.Buffer.allocUnsafe(t)
        : new Uint8Array(t);
    }
    function _x(t, e, r, i) {
      return {
        name: t,
        prefix: e,
        encoder: { name: t, prefix: e, encode: r },
        decoder: { decode: i },
      };
    }
    const Ax = _x(
        "utf8",
        "u",
        (t) => "u" + new TextDecoder("utf8").decode(t),
        (t) => new TextEncoder().encode(t.substring(1))
      ),
      Iy = _x(
        "ascii",
        "a",
        (t) => {
          let e = "a";
          for (let r = 0; r < t.length; r++) e += String.fromCharCode(t[r]);
          return e;
        },
        (t) => {
          t = t.substring(1);
          const e = Nse(t.length);
          for (let r = 0; r < t.length; r++) e[r] = t.charCodeAt(r);
          return e;
        }
      ),
      Tse = {
        utf8: Ax,
        "utf-8": Ax,
        hex: Ix.base16,
        latin1: Iy,
        ascii: Iy,
        binary: Iy,
        ...Ix,
      };
    function kse(t, e = "utf8") {
      const r = Tse[e];
      if (!r) throw new Error(`Unsupported encoding "${e}"`);
      return (e === "utf8" || e === "utf-8") &&
        globalThis.Buffer != null &&
        globalThis.Buffer.from != null
        ? globalThis.Buffer.from(t, "utf8")
        : r.decoder.decode(`${r.prefix}${t}`);
    }
    var Rse = Object.defineProperty,
      $se = (t, e, r) =>
        e in t
          ? Rse(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      $s = (t, e, r) => $se(t, typeof e != "symbol" ? e + "" : e, r);
    class Fse {
      constructor(e, r) {
        (this.core = e),
          (this.logger = r),
          $s(this, "keychain", new Map()),
          $s(this, "name", Bre),
          $s(this, "version", Lre),
          $s(this, "initialized", !1),
          $s(this, "storagePrefix", ks),
          $s(this, "init", async () => {
            if (!this.initialized) {
              const i = await this.getKeyChain();
              typeof i < "u" && (this.keychain = i), (this.initialized = !0);
            }
          }),
          $s(this, "has", (i) => (this.isInitialized(), this.keychain.has(i))),
          $s(this, "set", async (i, s) => {
            this.isInitialized(), this.keychain.set(i, s), await this.persist();
          }),
          $s(this, "get", (i) => {
            this.isInitialized();
            const s = this.keychain.get(i);
            if (typeof s > "u") {
              const { message: n } = Q("NO_MATCHING_KEY", `${this.name}: ${i}`);
              throw new Error(n);
            }
            return s;
          }),
          $s(this, "del", async (i) => {
            this.isInitialized(), this.keychain.delete(i), await this.persist();
          }),
          (this.core = e),
          (this.logger = Ve(r, this.name));
      }
      get context() {
        return it(this.logger);
      }
      get storageKey() {
        return (
          this.storagePrefix +
          this.version +
          this.core.customStoragePrefix +
          "//" +
          this.name
        );
      }
      async setKeyChain(e) {
        await this.core.storage.setItem(this.storageKey, Mm(e));
      }
      async getKeyChain() {
        const e = await this.core.storage.getItem(this.storageKey);
        return typeof e < "u" ? zm(e) : void 0;
      }
      async persist() {
        await this.setKeyChain(this.keychain);
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e } = Q("NOT_INITIALIZED", this.name);
          throw new Error(e);
        }
      }
    }
    var Bse = Object.defineProperty,
      Lse = (t, e, r) =>
        e in t
          ? Bse(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      vr = (t, e, r) => Lse(t, typeof e != "symbol" ? e + "" : e, r);
    class Use {
      constructor(e, r, i) {
        (this.core = e),
          (this.logger = r),
          vr(this, "name", $re),
          vr(this, "keychain"),
          vr(this, "randomSessionIdentifier", wy()),
          vr(this, "initialized", !1),
          vr(this, "init", async () => {
            this.initialized ||
              (await this.keychain.init(), (this.initialized = !0));
          }),
          vr(
            this,
            "hasKeys",
            (s) => (this.isInitialized(), this.keychain.has(s))
          ),
          vr(this, "getClientId", async () => {
            this.isInitialized();
            const s = await this.getClientSeed(),
              n = pp(s);
            return o1(n.publicKey);
          }),
          vr(this, "generateKeyPair", () => {
            this.isInitialized();
            const s = Ute();
            return this.setPrivateKey(s.publicKey, s.privateKey);
          }),
          vr(this, "signJWT", async (s) => {
            this.isInitialized();
            const n = await this.getClientSeed(),
              o = pp(n),
              a = this.randomSessionIdentifier;
            return await V3(a, s, Fre, o);
          }),
          vr(this, "generateSharedKey", (s, n, o) => {
            this.isInitialized();
            const a = this.getPrivateKey(s),
              c = Dte(a, n);
            return this.setSymKey(c, o);
          }),
          vr(this, "setSymKey", async (s, n) => {
            this.isInitialized();
            const o = n || jf(s);
            return await this.keychain.set(o, s), o;
          }),
          vr(this, "deleteKeyPair", async (s) => {
            this.isInitialized(), await this.keychain.del(s);
          }),
          vr(this, "deleteSymKey", async (s) => {
            this.isInitialized(), await this.keychain.del(s);
          }),
          vr(this, "encode", async (s, n, o) => {
            this.isInitialized();
            const a = H7(o),
              c = ys(n);
            if (W7(a)) return zte(c, o?.encoding);
            if (V7(a)) {
              const d = a.senderPublicKey,
                g = a.receiverPublicKey;
              s = await this.generateSharedKey(d, g);
            }
            const l = this.getSymKey(s),
              { type: u, senderPublicKey: h } = a;
            return jte({
              type: u,
              symKey: l,
              message: c,
              senderPublicKey: h,
              encoding: o?.encoding,
            });
          }),
          vr(this, "decode", async (s, n, o) => {
            this.isInitialized();
            const a = Hte(n, o);
            if (W7(a)) {
              const c = qte(n, o?.encoding);
              return Ws(c);
            }
            if (V7(a)) {
              const c = a.receiverPublicKey,
                l = a.senderPublicKey;
              s = await this.generateSharedKey(c, l);
            }
            try {
              const c = this.getSymKey(s),
                l = Mte({ symKey: c, encoded: n, encoding: o?.encoding });
              return Ws(l);
            } catch (c) {
              this.logger.error(
                `Failed to decode message from topic: '${s}', clientId: '${await this.getClientId()}'`
              ),
                this.logger.error(c);
            }
          }),
          vr(this, "getPayloadType", (s, n = as) => {
            const o = qh({ encoded: s, encoding: n });
            return ya(o.type);
          }),
          vr(this, "getPayloadSenderPublicKey", (s, n = as) => {
            const o = qh({ encoded: s, encoding: n });
            return o.senderPublicKey ? et(o.senderPublicKey, jr) : void 0;
          }),
          (this.core = e),
          (this.logger = Ve(r, this.name)),
          (this.keychain = i || new Fse(this.core, this.logger));
      }
      get context() {
        return it(this.logger);
      }
      async setPrivateKey(e, r) {
        return await this.keychain.set(e, r), e;
      }
      getPrivateKey(e) {
        return this.keychain.get(e);
      }
      async getClientSeed() {
        let e = "";
        try {
          e = this.keychain.get(nx);
        } catch {
          (e = wy()), await this.keychain.set(nx, e);
        }
        return kse(e, "base16");
      }
      getSymKey(e) {
        return this.keychain.get(e);
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e } = Q("NOT_INITIALIZED", this.name);
          throw new Error(e);
        }
      }
    }
    var Dse = Object.defineProperty,
      jse = Object.defineProperties,
      Mse = Object.getOwnPropertyDescriptors,
      Sx = Object.getOwnPropertySymbols,
      zse = Object.prototype.hasOwnProperty,
      qse = Object.prototype.propertyIsEnumerable,
      _y = (t, e, r) =>
        e in t
          ? Dse(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Hse = (t, e) => {
        for (var r in e || (e = {})) zse.call(e, r) && _y(t, r, e[r]);
        if (Sx) for (var r of Sx(e)) qse.call(e, r) && _y(t, r, e[r]);
        return t;
      },
      Vse = (t, e) => jse(t, Mse(e)),
      Ii = (t, e, r) => _y(t, typeof e != "symbol" ? e + "" : e, r);
    class Wse extends GJ {
      constructor(e, r) {
        super(e, r),
          (this.logger = e),
          (this.core = r),
          Ii(this, "messages", new Map()),
          Ii(this, "messagesWithoutClientAck", new Map()),
          Ii(this, "name", Ure),
          Ii(this, "version", Dre),
          Ii(this, "initialized", !1),
          Ii(this, "storagePrefix", ks),
          Ii(this, "init", async () => {
            if (!this.initialized) {
              this.logger.trace("Initialized");
              try {
                const i = await this.getRelayerMessages();
                typeof i < "u" && (this.messages = i);
                const s = await this.getRelayerMessagesWithoutClientAck();
                typeof s < "u" && (this.messagesWithoutClientAck = s),
                  this.logger.debug(
                    `Successfully Restored records for ${this.name}`
                  ),
                  this.logger.trace({
                    type: "method",
                    method: "restore",
                    size: this.messages.size,
                  });
              } catch (i) {
                this.logger.debug(`Failed to Restore records for ${this.name}`),
                  this.logger.error(i);
              } finally {
                this.initialized = !0;
              }
            }
          }),
          Ii(this, "set", async (i, s, n) => {
            this.isInitialized();
            const o = Ts(s);
            let a = this.messages.get(i);
            if ((typeof a > "u" && (a = {}), typeof a[o] < "u")) return o;
            if (((a[o] = s), this.messages.set(i, a), n === Vf.inbound)) {
              const c = this.messagesWithoutClientAck.get(i) || {};
              this.messagesWithoutClientAck.set(i, Vse(Hse({}, c), { [o]: s }));
            }
            return await this.persist(), o;
          }),
          Ii(this, "get", (i) => {
            this.isInitialized();
            let s = this.messages.get(i);
            return typeof s > "u" && (s = {}), s;
          }),
          Ii(this, "getWithoutAck", (i) => {
            this.isInitialized();
            const s = {};
            for (const n of i) {
              const o = this.messagesWithoutClientAck.get(n) || {};
              s[n] = Object.values(o);
            }
            return s;
          }),
          Ii(this, "has", (i, s) => {
            this.isInitialized();
            const n = this.get(i),
              o = Ts(s);
            return typeof n[o] < "u";
          }),
          Ii(this, "ack", async (i, s) => {
            this.isInitialized();
            const n = this.messagesWithoutClientAck.get(i);
            if (typeof n > "u") return;
            const o = Ts(s);
            delete n[o],
              Object.keys(n).length === 0
                ? this.messagesWithoutClientAck.delete(i)
                : this.messagesWithoutClientAck.set(i, n),
              await this.persist();
          }),
          Ii(this, "del", async (i) => {
            this.isInitialized(),
              this.messages.delete(i),
              this.messagesWithoutClientAck.delete(i),
              await this.persist();
          }),
          (this.logger = Ve(e, this.name)),
          (this.core = r);
      }
      get context() {
        return it(this.logger);
      }
      get storageKey() {
        return (
          this.storagePrefix +
          this.version +
          this.core.customStoragePrefix +
          "//" +
          this.name
        );
      }
      get storageKeyWithoutClientAck() {
        return (
          this.storagePrefix +
          this.version +
          this.core.customStoragePrefix +
          "//" +
          this.name +
          "_withoutClientAck"
        );
      }
      async setRelayerMessages(e) {
        await this.core.storage.setItem(this.storageKey, Mm(e));
      }
      async setRelayerMessagesWithoutClientAck(e) {
        await this.core.storage.setItem(this.storageKeyWithoutClientAck, Mm(e));
      }
      async getRelayerMessages() {
        const e = await this.core.storage.getItem(this.storageKey);
        return typeof e < "u" ? zm(e) : void 0;
      }
      async getRelayerMessagesWithoutClientAck() {
        const e = await this.core.storage.getItem(
          this.storageKeyWithoutClientAck
        );
        return typeof e < "u" ? zm(e) : void 0;
      }
      async persist() {
        await this.setRelayerMessages(this.messages),
          await this.setRelayerMessagesWithoutClientAck(
            this.messagesWithoutClientAck
          );
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e } = Q("NOT_INITIALIZED", this.name);
          throw new Error(e);
        }
      }
    }
    var Kse = Object.defineProperty,
      Gse = Object.defineProperties,
      Zse = Object.getOwnPropertyDescriptors,
      Px = Object.getOwnPropertySymbols,
      Yse = Object.prototype.hasOwnProperty,
      Jse = Object.prototype.propertyIsEnumerable,
      Ay = (t, e, r) =>
        e in t
          ? Kse(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Kf = (t, e) => {
        for (var r in e || (e = {})) Yse.call(e, r) && Ay(t, r, e[r]);
        if (Px) for (var r of Px(e)) Jse.call(e, r) && Ay(t, r, e[r]);
        return t;
      },
      Sy = (t, e) => Gse(t, Zse(e)),
      us = (t, e, r) => Ay(t, typeof e != "symbol" ? e + "" : e, r);
    class Xse extends ZJ {
      constructor(e, r) {
        super(e, r),
          (this.relayer = e),
          (this.logger = r),
          us(this, "events", new rt.exports.EventEmitter()),
          us(this, "name", jre),
          us(this, "queue", new Map()),
          us(this, "publishTimeout", z.toMiliseconds(z.ONE_MINUTE)),
          us(this, "initialPublishTimeout", z.toMiliseconds(z.ONE_SECOND * 15)),
          us(this, "needsTransportRestart", !1),
          us(this, "publish", async (i, s, n) => {
            var o;
            this.logger.debug("Publishing Payload"),
              this.logger.trace({
                type: "method",
                method: "publish",
                params: { topic: i, message: s, opts: n },
              });
            const a = n?.ttl || ox,
              c = Mf(n),
              l = n?.prompt || !1,
              u = n?.tag || 0,
              h = n?.id || ui().toString(),
              d = {
                topic: i,
                message: s,
                opts: {
                  ttl: a,
                  relay: c,
                  prompt: l,
                  tag: u,
                  id: h,
                  attestation: n?.attestation,
                  tvf: n?.tvf,
                },
              },
              g = `Failed to publish payload, please try again. id:${h} tag:${u}`;
            try {
              const p = new Promise(async (w) => {
                const f = ({ id: y }) => {
                  d.opts.id === y &&
                    (this.removeRequestFromQueue(y),
                    this.relayer.events.removeListener(sr.publish, f),
                    w(d));
                };
                this.relayer.events.on(sr.publish, f);
                const m = ho(
                  new Promise((y, E) => {
                    this.rpcPublish({
                      topic: i,
                      message: s,
                      ttl: a,
                      prompt: l,
                      tag: u,
                      id: h,
                      attestation: n?.attestation,
                      tvf: n?.tvf,
                    })
                      .then(y)
                      .catch((C) => {
                        this.logger.warn(C, C?.message), E(C);
                      });
                  }),
                  this.initialPublishTimeout,
                  `Failed initial publish, retrying.... id:${h} tag:${u}`
                );
                try {
                  await m, this.events.removeListener(sr.publish, f);
                } catch (y) {
                  this.queue.set(h, Sy(Kf({}, d), { attempt: 1 })),
                    this.logger.warn(y, y?.message);
                }
              });
              this.logger.trace({
                type: "method",
                method: "publish",
                params: { id: h, topic: i, message: s, opts: n },
              }),
                await ho(p, this.publishTimeout, g);
            } catch (p) {
              if (
                (this.logger.debug("Failed to Publish Payload"),
                this.logger.error(p),
                (o = n?.internal) != null && o.throwOnFailedPublish)
              )
                throw p;
            } finally {
              this.queue.delete(h);
            }
          }),
          us(this, "on", (i, s) => {
            this.events.on(i, s);
          }),
          us(this, "once", (i, s) => {
            this.events.once(i, s);
          }),
          us(this, "off", (i, s) => {
            this.events.off(i, s);
          }),
          us(this, "removeListener", (i, s) => {
            this.events.removeListener(i, s);
          }),
          (this.relayer = e),
          (this.logger = Ve(r, this.name)),
          this.registerEventListeners();
      }
      get context() {
        return it(this.logger);
      }
      async rpcPublish(e) {
        var r, i, s, n;
        const {
            topic: o,
            message: a,
            ttl: c = ox,
            prompt: l,
            tag: u,
            id: h,
            attestation: d,
            tvf: g,
          } = e,
          p = {
            method: Hh(Mf().protocol).publish,
            params: Kf(
              {
                topic: o,
                message: a,
                ttl: c,
                prompt: l,
                tag: u,
                attestation: d,
              },
              g
            ),
            id: h,
          };
        yr((r = p.params) == null ? void 0 : r.prompt) &&
          ((i = p.params) == null || delete i.prompt),
          yr((s = p.params) == null ? void 0 : s.tag) &&
            ((n = p.params) == null || delete n.tag),
          this.logger.debug("Outgoing Relay Payload"),
          this.logger.trace({
            type: "message",
            direction: "outgoing",
            request: p,
          });
        const w = await this.relayer.request(p);
        return (
          this.relayer.events.emit(sr.publish, e),
          this.logger.debug("Successfully Published Payload"),
          w
        );
      }
      removeRequestFromQueue(e) {
        this.queue.delete(e);
      }
      checkQueue() {
        this.queue.forEach(async (e, r) => {
          const i = e.attempt + 1;
          this.queue.set(r, Sy(Kf({}, e), { attempt: i }));
          const { topic: s, message: n, opts: o, attestation: a } = e;
          this.logger.warn(
            {},
            `Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${i}`
          ),
            await this.rpcPublish(
              Sy(Kf({}, e), {
                topic: s,
                message: n,
                ttl: o.ttl,
                prompt: o.prompt,
                tag: o.tag,
                id: o.id,
                attestation: a,
                tvf: o.tvf,
              })
            ),
            this.logger.warn({}, `Publisher: queue->published: ${e.opts.id}`);
        });
      }
      registerEventListeners() {
        this.relayer.core.heartbeat.on(Ti.pulse, () => {
          if (this.needsTransportRestart) {
            (this.needsTransportRestart = !1),
              this.relayer.events.emit(sr.connection_stalled);
            return;
          }
          this.checkQueue();
        }),
          this.relayer.on(sr.message_ack, (e) => {
            this.removeRequestFromQueue(e.id.toString());
          });
      }
    }
    var Qse = Object.defineProperty,
      ene = (t, e, r) =>
        e in t
          ? Qse(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Il = (t, e, r) => ene(t, typeof e != "symbol" ? e + "" : e, r);
    class tne {
      constructor() {
        Il(this, "map", new Map()),
          Il(this, "set", (e, r) => {
            const i = this.get(e);
            this.exists(e, r) || this.map.set(e, [...i, r]);
          }),
          Il(this, "get", (e) => this.map.get(e) || []),
          Il(this, "exists", (e, r) => this.get(e).includes(r)),
          Il(this, "delete", (e, r) => {
            if (typeof r > "u") {
              this.map.delete(e);
              return;
            }
            if (!this.map.has(e)) return;
            const i = this.get(e);
            if (!this.exists(e, r)) return;
            const s = i.filter((n) => n !== r);
            if (!s.length) {
              this.map.delete(e);
              return;
            }
            this.map.set(e, s);
          }),
          Il(this, "clear", () => {
            this.map.clear();
          });
      }
      get topics() {
        return Array.from(this.map.keys());
      }
    }
    var rne = Object.defineProperty,
      ine = Object.defineProperties,
      sne = Object.getOwnPropertyDescriptors,
      Ox = Object.getOwnPropertySymbols,
      nne = Object.prototype.hasOwnProperty,
      one = Object.prototype.propertyIsEnumerable,
      Py = (t, e, r) =>
        e in t
          ? rne(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Xh = (t, e) => {
        for (var r in e || (e = {})) nne.call(e, r) && Py(t, r, e[r]);
        if (Ox) for (var r of Ox(e)) one.call(e, r) && Py(t, r, e[r]);
        return t;
      },
      Oy = (t, e) => ine(t, sne(e)),
      ct = (t, e, r) => Py(t, typeof e != "symbol" ? e + "" : e, r);
    class ane extends XJ {
      constructor(e, r) {
        super(e, r),
          (this.relayer = e),
          (this.logger = r),
          ct(this, "subscriptions", new Map()),
          ct(this, "topicMap", new tne()),
          ct(this, "events", new rt.exports.EventEmitter()),
          ct(this, "name", Kre),
          ct(this, "version", Gre),
          ct(this, "pending", new Map()),
          ct(this, "cached", []),
          ct(this, "initialized", !1),
          ct(this, "storagePrefix", ks),
          ct(this, "subscribeTimeout", z.toMiliseconds(z.ONE_MINUTE)),
          ct(
            this,
            "initialSubscribeTimeout",
            z.toMiliseconds(z.ONE_SECOND * 15)
          ),
          ct(this, "clientId"),
          ct(this, "batchSubscribeTopicsLimit", 500),
          ct(this, "init", async () => {
            this.initialized ||
              (this.logger.trace("Initialized"),
              this.registerEventListeners(),
              await this.restore()),
              (this.initialized = !0);
          }),
          ct(this, "subscribe", async (i, s) => {
            this.isInitialized(),
              this.logger.debug("Subscribing Topic"),
              this.logger.trace({
                type: "method",
                method: "subscribe",
                params: { topic: i, opts: s },
              });
            try {
              const n = Mf(s),
                o = { topic: i, relay: n, transportType: s?.transportType };
              this.pending.set(i, o);
              const a = await this.rpcSubscribe(i, n, s);
              return (
                typeof a == "string" &&
                  (this.onSubscribe(a, o),
                  this.logger.debug("Successfully Subscribed Topic"),
                  this.logger.trace({
                    type: "method",
                    method: "subscribe",
                    params: { topic: i, opts: s },
                  })),
                a
              );
            } catch (n) {
              throw (
                (this.logger.debug("Failed to Subscribe Topic"),
                this.logger.error(n),
                n)
              );
            }
          }),
          ct(this, "unsubscribe", async (i, s) => {
            this.isInitialized(),
              typeof s?.id < "u"
                ? await this.unsubscribeById(i, s.id, s)
                : await this.unsubscribeByTopic(i, s);
          }),
          ct(
            this,
            "isSubscribed",
            (i) =>
              new Promise((s) => {
                s(this.topicMap.topics.includes(i));
              })
          ),
          ct(
            this,
            "isKnownTopic",
            (i) =>
              new Promise((s) => {
                s(
                  this.topicMap.topics.includes(i) ||
                    this.pending.has(i) ||
                    this.cached.some((n) => n.topic === i)
                );
              })
          ),
          ct(this, "on", (i, s) => {
            this.events.on(i, s);
          }),
          ct(this, "once", (i, s) => {
            this.events.once(i, s);
          }),
          ct(this, "off", (i, s) => {
            this.events.off(i, s);
          }),
          ct(this, "removeListener", (i, s) => {
            this.events.removeListener(i, s);
          }),
          ct(this, "start", async () => {
            await this.onConnect();
          }),
          ct(this, "stop", async () => {
            await this.onDisconnect();
          }),
          ct(this, "restart", async () => {
            await this.restore(), await this.onRestart();
          }),
          ct(this, "checkPending", async () => {
            if (
              this.pending.size === 0 &&
              (!this.initialized || !this.relayer.connected)
            )
              return;
            const i = [];
            this.pending.forEach((s) => {
              i.push(s);
            }),
              await this.batchSubscribe(i);
          }),
          ct(this, "registerEventListeners", () => {
            this.relayer.core.heartbeat.on(Ti.pulse, async () => {
              await this.checkPending();
            }),
              this.events.on(xi.created, async (i) => {
                const s = xi.created;
                this.logger.info(`Emitting ${s}`),
                  this.logger.debug({ type: "event", event: s, data: i }),
                  await this.persist();
              }),
              this.events.on(xi.deleted, async (i) => {
                const s = xi.deleted;
                this.logger.info(`Emitting ${s}`),
                  this.logger.debug({ type: "event", event: s, data: i }),
                  await this.persist();
              });
          }),
          (this.relayer = e),
          (this.logger = Ve(r, this.name)),
          (this.clientId = "");
      }
      get context() {
        return it(this.logger);
      }
      get storageKey() {
        return (
          this.storagePrefix +
          this.version +
          this.relayer.core.customStoragePrefix +
          "//" +
          this.name
        );
      }
      get length() {
        return this.subscriptions.size;
      }
      get ids() {
        return Array.from(this.subscriptions.keys());
      }
      get values() {
        return Array.from(this.subscriptions.values());
      }
      get topics() {
        return this.topicMap.topics;
      }
      get hasAnyTopics() {
        return (
          this.topicMap.topics.length > 0 ||
          this.pending.size > 0 ||
          this.cached.length > 0 ||
          this.subscriptions.size > 0
        );
      }
      hasSubscription(e, r) {
        let i = !1;
        try {
          i = this.getSubscription(e).topic === r;
        } catch {}
        return i;
      }
      reset() {
        (this.cached = []), (this.initialized = !0);
      }
      onDisable() {
        (this.cached = this.values),
          this.subscriptions.clear(),
          this.topicMap.clear();
      }
      async unsubscribeByTopic(e, r) {
        const i = this.topicMap.get(e);
        await Promise.all(
          i.map(async (s) => await this.unsubscribeById(e, s, r))
        );
      }
      async unsubscribeById(e, r, i) {
        this.logger.debug("Unsubscribing Topic"),
          this.logger.trace({
            type: "method",
            method: "unsubscribe",
            params: { topic: e, id: r, opts: i },
          });
        try {
          const s = Mf(i);
          await this.restartToComplete({ topic: e, id: r, relay: s }),
            await this.rpcUnsubscribe(e, r, s);
          const n = tt("USER_DISCONNECTED", `${this.name}, ${e}`);
          await this.onUnsubscribe(e, r, n),
            this.logger.debug("Successfully Unsubscribed Topic"),
            this.logger.trace({
              type: "method",
              method: "unsubscribe",
              params: { topic: e, id: r, opts: i },
            });
        } catch (s) {
          throw (
            (this.logger.debug("Failed to Unsubscribe Topic"),
            this.logger.error(s),
            s)
          );
        }
      }
      async rpcSubscribe(e, r, i) {
        var s;
        (!i || i?.transportType === wt.relay) &&
          (await this.restartToComplete({ topic: e, id: e, relay: r }));
        const n = { method: Hh(r.protocol).subscribe, params: { topic: e } };
        this.logger.debug("Outgoing Relay Payload"),
          this.logger.trace({
            type: "payload",
            direction: "outgoing",
            request: n,
          });
        const o = (s = i?.internal) == null ? void 0 : s.throwOnFailedPublish;
        try {
          const a = await this.getSubscriptionId(e);
          if (i?.transportType === wt.link_mode)
            return (
              setTimeout(() => {
                (this.relayer.connected || this.relayer.connecting) &&
                  this.relayer.request(n).catch((u) => this.logger.warn(u));
              }, z.toMiliseconds(z.ONE_SECOND)),
              a
            );
          const c = new Promise(async (u) => {
              const h = (d) => {
                d.topic === e &&
                  (this.events.removeListener(xi.created, h), u(d.id));
              };
              this.events.on(xi.created, h);
              try {
                const d = await ho(
                  new Promise((g, p) => {
                    this.relayer
                      .request(n)
                      .catch((w) => {
                        this.logger.warn(w, w?.message), p(w);
                      })
                      .then(g);
                  }),
                  this.initialSubscribeTimeout,
                  `Subscribing to ${e} failed, please try again`
                );
                this.events.removeListener(xi.created, h), u(d);
              } catch {}
            }),
            l = await ho(
              c,
              this.subscribeTimeout,
              `Subscribing to ${e} failed, please try again`
            );
          if (!l && o)
            throw new Error(`Subscribing to ${e} failed, please try again`);
          return l ? a : null;
        } catch (a) {
          if (
            (this.logger.debug("Outgoing Relay Subscribe Payload stalled"),
            this.relayer.events.emit(sr.connection_stalled),
            o)
          )
            throw a;
        }
        return null;
      }
      async rpcBatchSubscribe(e) {
        if (!e.length) return;
        const r = e[0].relay,
          i = {
            method: Hh(r.protocol).batchSubscribe,
            params: { topics: e.map((s) => s.topic) },
          };
        this.logger.debug("Outgoing Relay Payload"),
          this.logger.trace({
            type: "payload",
            direction: "outgoing",
            request: i,
          });
        try {
          await await ho(
            new Promise((s) => {
              this.relayer
                .request(i)
                .catch((n) => this.logger.warn(n))
                .then(s);
            }),
            this.subscribeTimeout,
            "rpcBatchSubscribe failed, please try again"
          );
        } catch {
          this.relayer.events.emit(sr.connection_stalled);
        }
      }
      async rpcBatchFetchMessages(e) {
        if (!e.length) return;
        const r = e[0].relay,
          i = {
            method: Hh(r.protocol).batchFetchMessages,
            params: { topics: e.map((n) => n.topic) },
          };
        this.logger.debug("Outgoing Relay Payload"),
          this.logger.trace({
            type: "payload",
            direction: "outgoing",
            request: i,
          });
        let s;
        try {
          s = await await ho(
            new Promise((n, o) => {
              this.relayer
                .request(i)
                .catch((a) => {
                  this.logger.warn(a), o(a);
                })
                .then(n);
            }),
            this.subscribeTimeout,
            "rpcBatchFetchMessages failed, please try again"
          );
        } catch {
          this.relayer.events.emit(sr.connection_stalled);
        }
        return s;
      }
      rpcUnsubscribe(e, r, i) {
        const s = {
          method: Hh(i.protocol).unsubscribe,
          params: { topic: e, id: r },
        };
        return (
          this.logger.debug("Outgoing Relay Payload"),
          this.logger.trace({
            type: "payload",
            direction: "outgoing",
            request: s,
          }),
          this.relayer.request(s)
        );
      }
      onSubscribe(e, r) {
        this.setSubscription(e, Oy(Xh({}, r), { id: e })),
          this.pending.delete(r.topic);
      }
      onBatchSubscribe(e) {
        e.length &&
          e.forEach((r) => {
            this.setSubscription(r.id, Xh({}, r)), this.pending.delete(r.topic);
          });
      }
      async onUnsubscribe(e, r, i) {
        this.events.removeAllListeners(r),
          this.hasSubscription(r, e) && this.deleteSubscription(r, i),
          await this.relayer.messages.del(e);
      }
      async setRelayerSubscriptions(e) {
        await this.relayer.core.storage.setItem(this.storageKey, e);
      }
      async getRelayerSubscriptions() {
        return await this.relayer.core.storage.getItem(this.storageKey);
      }
      setSubscription(e, r) {
        this.logger.debug("Setting subscription"),
          this.logger.trace({
            type: "method",
            method: "setSubscription",
            id: e,
            subscription: r,
          }),
          this.addSubscription(e, r);
      }
      addSubscription(e, r) {
        this.subscriptions.set(e, Xh({}, r)),
          this.topicMap.set(r.topic, e),
          this.events.emit(xi.created, r);
      }
      getSubscription(e) {
        this.logger.debug("Getting subscription"),
          this.logger.trace({
            type: "method",
            method: "getSubscription",
            id: e,
          });
        const r = this.subscriptions.get(e);
        if (!r) {
          const { message: i } = Q("NO_MATCHING_KEY", `${this.name}: ${e}`);
          throw new Error(i);
        }
        return r;
      }
      deleteSubscription(e, r) {
        this.logger.debug("Deleting subscription"),
          this.logger.trace({
            type: "method",
            method: "deleteSubscription",
            id: e,
            reason: r,
          });
        const i = this.getSubscription(e);
        this.subscriptions.delete(e),
          this.topicMap.delete(i.topic, e),
          this.events.emit(xi.deleted, Oy(Xh({}, i), { reason: r }));
      }
      async persist() {
        await this.setRelayerSubscriptions(this.values),
          this.events.emit(xi.sync);
      }
      async onRestart() {
        if (this.cached.length) {
          const e = [...this.cached],
            r = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
          for (let i = 0; i < r; i++) {
            const s = e.splice(0, this.batchSubscribeTopicsLimit);
            await this.batchSubscribe(s);
          }
        }
        this.events.emit(xi.resubscribed);
      }
      async restore() {
        try {
          const e = await this.getRelayerSubscriptions();
          if (typeof e > "u" || !e.length) return;
          if (this.subscriptions.size) {
            const { message: r } = Q("RESTORE_WILL_OVERRIDE", this.name);
            throw (
              (this.logger.error(r),
              this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`),
              new Error(r))
            );
          }
          (this.cached = e),
            this.logger.debug(
              `Successfully Restored subscriptions for ${this.name}`
            ),
            this.logger.trace({
              type: "method",
              method: "restore",
              subscriptions: this.values,
            });
        } catch (e) {
          this.logger.debug(`Failed to Restore subscriptions for ${this.name}`),
            this.logger.error(e);
        }
      }
      async batchSubscribe(e) {
        e.length &&
          (await this.rpcBatchSubscribe(e),
          this.onBatchSubscribe(
            await Promise.all(
              e.map(async (r) =>
                Oy(Xh({}, r), { id: await this.getSubscriptionId(r.topic) })
              )
            )
          ));
      }
      async batchFetchMessages(e) {
        if (!e.length) return;
        this.logger.trace(
          `Fetching batch messages for ${e.length} subscriptions`
        );
        const r = await this.rpcBatchFetchMessages(e);
        r &&
          r.messages &&
          (await SQ(z.toMiliseconds(z.ONE_SECOND)),
          await this.relayer.handleBatchMessageEvents(r.messages));
      }
      async onConnect() {
        await this.restart(), this.reset();
      }
      onDisconnect() {
        this.onDisable();
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e } = Q("NOT_INITIALIZED", this.name);
          throw new Error(e);
        }
      }
      async restartToComplete(e) {
        !this.relayer.connected &&
          !this.relayer.connecting &&
          (this.cached.push(e), await this.relayer.transportOpen());
      }
      async getClientId() {
        return (
          this.clientId ||
            (this.clientId = await this.relayer.core.crypto.getClientId()),
          this.clientId
        );
      }
      async getSubscriptionId(e) {
        return Ts(e + (await this.getClientId()));
      }
    }
    var cne = Object.defineProperty,
      Nx = Object.getOwnPropertySymbols,
      lne = Object.prototype.hasOwnProperty,
      une = Object.prototype.propertyIsEnumerable,
      Ny = (t, e, r) =>
        e in t
          ? cne(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Tx = (t, e) => {
        for (var r in e || (e = {})) lne.call(e, r) && Ny(t, r, e[r]);
        if (Nx) for (var r of Nx(e)) une.call(e, r) && Ny(t, r, e[r]);
        return t;
      },
      Me = (t, e, r) => Ny(t, typeof e != "symbol" ? e + "" : e, r);
    class hne extends YJ {
      constructor(e) {
        super(e),
          Me(this, "protocol", "wc"),
          Me(this, "version", 2),
          Me(this, "core"),
          Me(this, "logger"),
          Me(this, "events", new rt.exports.EventEmitter()),
          Me(this, "provider"),
          Me(this, "messages"),
          Me(this, "subscriber"),
          Me(this, "publisher"),
          Me(this, "name", zre),
          Me(this, "transportExplicitlyClosed", !1),
          Me(this, "initialized", !1),
          Me(this, "connectionAttemptInProgress", !1),
          Me(this, "relayUrl"),
          Me(this, "projectId"),
          Me(this, "packageName"),
          Me(this, "bundleId"),
          Me(this, "hasExperiencedNetworkDisruption", !1),
          Me(this, "pingTimeout"),
          Me(
            this,
            "heartBeatTimeout",
            z.toMiliseconds(z.THIRTY_SECONDS + z.FIVE_SECONDS)
          ),
          Me(this, "reconnectTimeout"),
          Me(this, "connectPromise"),
          Me(this, "reconnectInProgress", !1),
          Me(this, "requestsInFlight", []),
          Me(this, "connectTimeout", z.toMiliseconds(z.ONE_SECOND * 15)),
          Me(this, "request", async (r) => {
            var i, s;
            this.logger.debug("Publishing Request Payload");
            const n = r.id || ui().toString();
            await this.toEstablishConnection();
            try {
              this.logger.trace(
                {
                  id: n,
                  method: r.method,
                  topic: (i = r.params) == null ? void 0 : i.topic,
                },
                "relayer.request - publishing..."
              );
              const o = `${n}:${
                ((s = r.params) == null ? void 0 : s.tag) || ""
              }`;
              this.requestsInFlight.push(o);
              const a = await this.provider.request(r);
              return (
                (this.requestsInFlight = this.requestsInFlight.filter(
                  (c) => c !== o
                )),
                a
              );
            } catch (o) {
              throw (this.logger.debug(`Failed to Publish Request: ${n}`), o);
            }
          }),
          Me(this, "resetPingTimeout", () => {
            Pf() &&
              (clearTimeout(this.pingTimeout),
              (this.pingTimeout = setTimeout(() => {
                var r, i, s, n;
                try {
                  this.logger.debug(
                    {},
                    "pingTimeout: Connection stalled, terminating..."
                  ),
                    (n =
                      (s =
                        (i =
                          (r = this.provider) == null
                            ? void 0
                            : r.connection) == null
                          ? void 0
                          : i.socket) == null
                        ? void 0
                        : s.terminate) == null || n.call(s);
                } catch (o) {
                  this.logger.warn(o, o?.message);
                }
              }, this.heartBeatTimeout)));
          }),
          Me(this, "onPayloadHandler", (r) => {
            this.onProviderPayload(r), this.resetPingTimeout();
          }),
          Me(this, "onConnectHandler", () => {
            this.logger.warn({}, "Relayer connected \u{1F6DC}"),
              this.startPingTimeout(),
              this.events.emit(sr.connect);
          }),
          Me(this, "onDisconnectHandler", () => {
            this.logger.warn({}, "Relayer disconnected \u{1F6D1}"),
              (this.requestsInFlight = []),
              this.onProviderDisconnect();
          }),
          Me(this, "onProviderErrorHandler", (r) => {
            this.logger.fatal(`Fatal socket error: ${r.message}`),
              this.events.emit(sr.error, r),
              this.logger.fatal(
                "Fatal socket error received, closing transport"
              ),
              this.transportClose();
          }),
          Me(this, "registerProviderListeners", () => {
            this.provider.on(Di.payload, this.onPayloadHandler),
              this.provider.on(Di.connect, this.onConnectHandler),
              this.provider.on(Di.disconnect, this.onDisconnectHandler),
              this.provider.on(Di.error, this.onProviderErrorHandler);
          }),
          (this.core = e.core),
          (this.logger =
            typeof e.logger < "u" && typeof e.logger != "string"
              ? Ve(e.logger, this.name)
              : li(tn({ level: e.logger || Mre }))),
          (this.messages = new Wse(this.logger, e.core)),
          (this.subscriber = new ane(this, this.logger)),
          (this.publisher = new Xse(this, this.logger)),
          (this.relayUrl = e?.relayUrl || cx),
          (this.projectId = e.projectId),
          hQ() ? (this.packageName = RC()) : dQ() && (this.bundleId = RC()),
          (this.provider = {});
      }
      async init() {
        if (
          (this.logger.trace("Initialized"),
          this.registerEventListeners(),
          await Promise.all([this.messages.init(), this.subscriber.init()]),
          (this.initialized = !0),
          this.subscriber.hasAnyTopics)
        )
          try {
            await this.transportOpen();
          } catch (e) {
            this.logger.warn(e, e?.message);
          }
      }
      get context() {
        return it(this.logger);
      }
      get connected() {
        var e, r, i;
        return (
          ((i =
            (r = (e = this.provider) == null ? void 0 : e.connection) == null
              ? void 0
              : r.socket) == null
            ? void 0
            : i.readyState) === 1 || !1
        );
      }
      get connecting() {
        var e, r, i;
        return (
          ((i =
            (r = (e = this.provider) == null ? void 0 : e.connection) == null
              ? void 0
              : r.socket) == null
            ? void 0
            : i.readyState) === 0 ||
          this.connectPromise !== void 0 ||
          !1
        );
      }
      async publish(e, r, i) {
        this.isInitialized(),
          await this.publisher.publish(e, r, i),
          await this.recordMessageEvent(
            {
              topic: e,
              message: r,
              publishedAt: Date.now(),
              transportType: wt.relay,
            },
            Vf.outbound
          );
      }
      async subscribe(e, r) {
        var i, s, n;
        this.isInitialized(),
          (!(r != null && r.transportType) || r?.transportType === "relay") &&
            (await this.toEstablishConnection());
        const o =
          typeof ((i = r?.internal) == null ? void 0 : i.throwOnFailedPublish) >
          "u"
            ? !0
            : (s = r?.internal) == null
            ? void 0
            : s.throwOnFailedPublish;
        let a =
            ((n = this.subscriber.topicMap.get(e)) == null ? void 0 : n[0]) ||
            "",
          c;
        const l = (u) => {
          u.topic === e && (this.subscriber.off(xi.created, l), c());
        };
        return (
          await Promise.all([
            new Promise((u) => {
              (c = u), this.subscriber.on(xi.created, l);
            }),
            new Promise(async (u, h) => {
              (a =
                (await this.subscriber
                  .subscribe(
                    e,
                    Tx({ internal: { throwOnFailedPublish: o } }, r)
                  )
                  .catch((d) => {
                    o && h(d);
                  })) || a),
                u();
            }),
          ]),
          a
        );
      }
      async unsubscribe(e, r) {
        this.isInitialized(), await this.subscriber.unsubscribe(e, r);
      }
      on(e, r) {
        this.events.on(e, r);
      }
      once(e, r) {
        this.events.once(e, r);
      }
      off(e, r) {
        this.events.off(e, r);
      }
      removeListener(e, r) {
        this.events.removeListener(e, r);
      }
      async transportDisconnect() {
        this.provider.disconnect &&
        (this.hasExperiencedNetworkDisruption || this.connected)
          ? await ho(
              this.provider.disconnect(),
              2e3,
              "provider.disconnect()"
            ).catch(() => this.onProviderDisconnect())
          : this.onProviderDisconnect();
      }
      async transportClose() {
        (this.transportExplicitlyClosed = !0), await this.transportDisconnect();
      }
      async transportOpen(e) {
        if (!this.subscriber.hasAnyTopics) {
          this.logger.warn(
            "Starting WS connection skipped because the client has no topics to work with."
          );
          return;
        }
        if (
          (this.connectPromise
            ? (this.logger.debug(
                {},
                "Waiting for existing connection attempt to resolve..."
              ),
              await this.connectPromise,
              this.logger.debug({}, "Existing connection attempt resolved"))
            : ((this.connectPromise = new Promise(async (r, i) => {
                await this.connect(e)
                  .then(r)
                  .catch(i)
                  .finally(() => {
                    this.connectPromise = void 0;
                  });
              })),
              await this.connectPromise),
          !this.connected)
        )
          throw new Error(
            `Couldn't establish socket connection to the relay server: ${this.relayUrl}`
          );
      }
      async restartTransport(e) {
        this.logger.debug({}, "Restarting transport..."),
          !this.connectionAttemptInProgress &&
            ((this.relayUrl = e || this.relayUrl),
            await this.confirmOnlineStateOrThrow(),
            await this.transportClose(),
            await this.transportOpen());
      }
      async confirmOnlineStateOrThrow() {
        if (!(await rx()))
          throw new Error(
            "No internet connection detected. Please restart your network and try again."
          );
      }
      async handleBatchMessageEvents(e) {
        if (e?.length === 0) {
          this.logger.trace("Batch message events is empty. Ignoring...");
          return;
        }
        const r = e.sort((i, s) => i.publishedAt - s.publishedAt);
        this.logger.debug(`Batch of ${r.length} message events sorted`);
        for (const i of r)
          try {
            await this.onMessageEvent(i);
          } catch (s) {
            this.logger.warn(
              s,
              "Error while processing batch message event: " + s?.message
            );
          }
        this.logger.trace(`Batch of ${r.length} message events processed`);
      }
      async onLinkMessageEvent(e, r) {
        const { topic: i } = e;
        if (!r.sessionExists) {
          const s = Mt(z.FIVE_MINUTES),
            n = { topic: i, expiry: s, relay: { protocol: "irn" }, active: !1 };
          await this.core.pairing.pairings.set(i, n);
        }
        this.events.emit(sr.message, e),
          await this.recordMessageEvent(e, Vf.inbound);
      }
      async connect(e) {
        await this.confirmOnlineStateOrThrow(),
          e &&
            e !== this.relayUrl &&
            ((this.relayUrl = e), await this.transportDisconnect()),
          (this.connectionAttemptInProgress = !0),
          (this.transportExplicitlyClosed = !1);
        let r = 1;
        for (; r < 6; ) {
          try {
            if (this.transportExplicitlyClosed) break;
            this.logger.debug(
              {},
              `Connecting to ${this.relayUrl}, attempt: ${r}...`
            ),
              await this.createProvider(),
              await new Promise(async (i, s) => {
                const n = () => {
                  s(
                    new Error(
                      "Connection interrupted while trying to subscribe"
                    )
                  );
                };
                this.provider.once(Di.disconnect, n),
                  await ho(
                    new Promise((o, a) => {
                      this.provider.connect().then(o).catch(a);
                    }),
                    this.connectTimeout,
                    `Socket stalled when trying to connect to ${this.relayUrl}`
                  )
                    .catch((o) => {
                      s(o);
                    })
                    .finally(() => {
                      this.provider.off(Di.disconnect, n),
                        clearTimeout(this.reconnectTimeout);
                    }),
                  await new Promise(async (o, a) => {
                    const c = () => {
                      a(
                        new Error(
                          "Connection interrupted while trying to subscribe"
                        )
                      );
                    };
                    this.provider.once(Di.disconnect, c),
                      await this.subscriber
                        .start()
                        .then(o)
                        .catch(a)
                        .finally(() => {
                          this.provider.off(Di.disconnect, c);
                        });
                  }),
                  (this.hasExperiencedNetworkDisruption = !1),
                  i();
              });
          } catch (i) {
            await this.subscriber.stop();
            const s = i;
            this.logger.warn({}, s.message),
              (this.hasExperiencedNetworkDisruption = !0);
          } finally {
            this.connectionAttemptInProgress = !1;
          }
          if (this.connected) {
            this.logger.debug(
              {},
              `Connected to ${this.relayUrl} successfully on attempt: ${r}`
            );
            break;
          }
          await new Promise((i) => setTimeout(i, z.toMiliseconds(r * 1))), r++;
        }
      }
      startPingTimeout() {
        var e, r, i, s, n;
        if (Pf())
          try {
            (r = (e = this.provider) == null ? void 0 : e.connection) != null &&
              r.socket &&
              ((n =
                (s = (i = this.provider) == null ? void 0 : i.connection) ==
                null
                  ? void 0
                  : s.socket) == null ||
                n.on("ping", () => {
                  this.resetPingTimeout();
                })),
              this.resetPingTimeout();
          } catch (o) {
            this.logger.warn(o, o?.message);
          }
      }
      async createProvider() {
        this.provider.connection && this.unregisterProviderListeners();
        const e = await this.core.crypto.signJWT(this.relayUrl);
        (this.provider = new bt(
          new y6(
            mQ({
              sdkVersion: Ey,
              protocol: this.protocol,
              version: this.version,
              relayUrl: this.relayUrl,
              projectId: this.projectId,
              auth: e,
              useOnCloseEvent: !0,
              bundleId: this.bundleId,
              packageName: this.packageName,
            })
          )
        )),
          this.registerProviderListeners();
      }
      async recordMessageEvent(e, r) {
        const { topic: i, message: s } = e;
        await this.messages.set(i, s, r);
      }
      async shouldIgnoreMessageEvent(e) {
        const { topic: r, message: i } = e;
        if (!i || i.length === 0)
          return this.logger.warn(`Ignoring invalid/empty message: ${i}`), !0;
        if (!(await this.subscriber.isKnownTopic(r)))
          return (
            this.logger.warn(`Ignoring message for unknown topic ${r}`), !0
          );
        const s = this.messages.has(r, i);
        return s && this.logger.warn(`Ignoring duplicate message: ${i}`), s;
      }
      async onProviderPayload(e) {
        if (
          (this.logger.debug("Incoming Relay Payload"),
          this.logger.trace({
            type: "payload",
            direction: "incoming",
            payload: e,
          }),
          _c(e))
        ) {
          if (!e.method.endsWith(qre)) return;
          const r = e.params,
            { topic: i, message: s, publishedAt: n, attestation: o } = r.data,
            a = {
              topic: i,
              message: s,
              publishedAt: n,
              transportType: wt.relay,
              attestation: o,
            };
          this.logger.debug("Emitting Relayer Payload"),
            this.logger.trace(Tx({ type: "event", event: r.id }, a)),
            this.events.emit(r.id, a),
            await this.acknowledgePayload(e),
            await this.onMessageEvent(a);
        } else qo(e) && this.events.emit(sr.message_ack, e);
      }
      async onMessageEvent(e) {
        (await this.shouldIgnoreMessageEvent(e)) ||
          (await this.recordMessageEvent(e, Vf.inbound),
          this.events.emit(sr.message, e));
      }
      async acknowledgePayload(e) {
        const r = Jn(e.id, !0);
        await this.provider.connection.send(r);
      }
      unregisterProviderListeners() {
        this.provider.off(Di.payload, this.onPayloadHandler),
          this.provider.off(Di.connect, this.onConnectHandler),
          this.provider.off(Di.disconnect, this.onDisconnectHandler),
          this.provider.off(Di.error, this.onProviderErrorHandler),
          clearTimeout(this.pingTimeout);
      }
      async registerEventListeners() {
        let e = await rx();
        Ore(async (r) => {
          e !== r &&
            ((e = r),
            r
              ? await this.transportOpen().catch((i) =>
                  this.logger.error(i, i?.message)
                )
              : ((this.hasExperiencedNetworkDisruption = !0),
                await this.transportDisconnect(),
                (this.transportExplicitlyClosed = !1)));
        });
      }
      async onProviderDisconnect() {
        clearTimeout(this.pingTimeout),
          this.events.emit(sr.disconnect),
          (this.connectionAttemptInProgress = !1),
          !this.reconnectInProgress &&
            ((this.reconnectInProgress = !0),
            await this.subscriber.stop(),
            this.subscriber.hasAnyTopics &&
              (this.transportExplicitlyClosed ||
                (this.reconnectTimeout = setTimeout(async () => {
                  await this.transportOpen().catch((e) =>
                    this.logger.error(e, e?.message)
                  ),
                    (this.reconnectTimeout = void 0),
                    (this.reconnectInProgress = !1);
                }, z.toMiliseconds(Hre)))));
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e } = Q("NOT_INITIALIZED", this.name);
          throw new Error(e);
        }
      }
      async toEstablishConnection() {
        await this.confirmOnlineStateOrThrow(),
          !this.connected && (await this.connect());
      }
    }
    function dne() {}
    function kx(t) {
      if (!t || typeof t != "object") return !1;
      const e = Object.getPrototypeOf(t);
      return e === null ||
        e === Object.prototype ||
        Object.getPrototypeOf(e) === null
        ? Object.prototype.toString.call(t) === "[object Object]"
        : !1;
    }
    function Rx(t) {
      return Object.getOwnPropertySymbols(t).filter((e) =>
        Object.prototype.propertyIsEnumerable.call(t, e)
      );
    }
    function $x(t) {
      return t == null
        ? t === void 0
          ? "[object Undefined]"
          : "[object Null]"
        : Object.prototype.toString.call(t);
    }
    const pne = "[object RegExp]",
      fne = "[object String]",
      gne = "[object Number]",
      wne = "[object Boolean]",
      Fx = "[object Arguments]",
      mne = "[object Symbol]",
      yne = "[object Date]",
      bne = "[object Map]",
      vne = "[object Set]",
      Ene = "[object Array]",
      Cne = "[object Function]",
      xne = "[object ArrayBuffer]",
      Ty = "[object Object]",
      Ine = "[object Error]",
      _ne = "[object DataView]",
      Ane = "[object Uint8Array]",
      Sne = "[object Uint8ClampedArray]",
      Pne = "[object Uint16Array]",
      One = "[object Uint32Array]",
      Nne = "[object BigUint64Array]",
      Tne = "[object Int8Array]",
      kne = "[object Int16Array]",
      Rne = "[object Int32Array]",
      $ne = "[object BigInt64Array]",
      Fne = "[object Float32Array]",
      Bne = "[object Float64Array]";
    function Lne(t, e) {
      return t === e || (Number.isNaN(t) && Number.isNaN(e));
    }
    function Une(t, e, r) {
      return Qh(t, e, void 0, void 0, void 0, void 0, r);
    }
    function Qh(t, e, r, i, s, n, o) {
      const a = o(t, e, r, i, s, n);
      if (a !== void 0) return a;
      if (typeof t == typeof e)
        switch (typeof t) {
          case "bigint":
          case "string":
          case "boolean":
          case "symbol":
          case "undefined":
            return t === e;
          case "number":
            return t === e || Object.is(t, e);
          case "function":
            return t === e;
          case "object":
            return ed(t, e, n, o);
        }
      return ed(t, e, n, o);
    }
    function ed(t, e, r, i) {
      if (Object.is(t, e)) return !0;
      let s = $x(t),
        n = $x(e);
      if ((s === Fx && (s = Ty), n === Fx && (n = Ty), s !== n)) return !1;
      switch (s) {
        case fne:
          return t.toString() === e.toString();
        case gne: {
          const c = t.valueOf(),
            l = e.valueOf();
          return Lne(c, l);
        }
        case wne:
        case yne:
        case mne:
          return Object.is(t.valueOf(), e.valueOf());
        case pne:
          return t.source === e.source && t.flags === e.flags;
        case Cne:
          return t === e;
      }
      r = r ?? new Map();
      const o = r.get(t),
        a = r.get(e);
      if (o != null && a != null) return o === e;
      r.set(t, e), r.set(e, t);
      try {
        switch (s) {
          case bne: {
            if (t.size !== e.size) return !1;
            for (const [c, l] of t.entries())
              if (!e.has(c) || !Qh(l, e.get(c), c, t, e, r, i)) return !1;
            return !0;
          }
          case vne: {
            if (t.size !== e.size) return !1;
            const c = Array.from(t.values()),
              l = Array.from(e.values());
            for (let u = 0; u < c.length; u++) {
              const h = c[u],
                d = l.findIndex((g) => Qh(h, g, void 0, t, e, r, i));
              if (d === -1) return !1;
              l.splice(d, 1);
            }
            return !0;
          }
          case Ene:
          case Ane:
          case Sne:
          case Pne:
          case One:
          case Nne:
          case Tne:
          case kne:
          case Rne:
          case $ne:
          case Fne:
          case Bne: {
            if (
              (typeof Fe < "u" && Fe.isBuffer(t) !== Fe.isBuffer(e)) ||
              t.length !== e.length
            )
              return !1;
            for (let c = 0; c < t.length; c++)
              if (!Qh(t[c], e[c], c, t, e, r, i)) return !1;
            return !0;
          }
          case xne:
            return t.byteLength !== e.byteLength
              ? !1
              : ed(new Uint8Array(t), new Uint8Array(e), r, i);
          case _ne:
            return t.byteLength !== e.byteLength ||
              t.byteOffset !== e.byteOffset
              ? !1
              : ed(new Uint8Array(t), new Uint8Array(e), r, i);
          case Ine:
            return t.name === e.name && t.message === e.message;
          case Ty: {
            if (!(ed(t.constructor, e.constructor, r, i) || (kx(t) && kx(e))))
              return !1;
            const c = [...Object.keys(t), ...Rx(t)],
              l = [...Object.keys(e), ...Rx(e)];
            if (c.length !== l.length) return !1;
            for (let u = 0; u < c.length; u++) {
              const h = c[u],
                d = t[h];
              if (!Object.hasOwn(e, h)) return !1;
              const g = e[h];
              if (!Qh(d, g, h, t, e, r, i)) return !1;
            }
            return !0;
          }
          default:
            return !1;
        }
      } finally {
        r.delete(t), r.delete(e);
      }
    }
    function Dne(t, e) {
      return Une(t, e, dne);
    }
    var jne = Object.defineProperty,
      Bx = Object.getOwnPropertySymbols,
      Mne = Object.prototype.hasOwnProperty,
      zne = Object.prototype.propertyIsEnumerable,
      ky = (t, e, r) =>
        e in t
          ? jne(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Lx = (t, e) => {
        for (var r in e || (e = {})) Mne.call(e, r) && ky(t, r, e[r]);
        if (Bx) for (var r of Bx(e)) zne.call(e, r) && ky(t, r, e[r]);
        return t;
      },
      ei = (t, e, r) => ky(t, typeof e != "symbol" ? e + "" : e, r);
    class Ca extends JJ {
      constructor(e, r, i, s = ks, n = void 0) {
        super(e, r, i, s),
          (this.core = e),
          (this.logger = r),
          (this.name = i),
          ei(this, "map", new Map()),
          ei(this, "version", Vre),
          ei(this, "cached", []),
          ei(this, "initialized", !1),
          ei(this, "getKey"),
          ei(this, "storagePrefix", ks),
          ei(this, "recentlyDeleted", []),
          ei(this, "recentlyDeletedLimit", 200),
          ei(this, "init", async () => {
            this.initialized ||
              (this.logger.trace("Initialized"),
              await this.restore(),
              this.cached.forEach((o) => {
                this.getKey && o !== null && !yr(o)
                  ? this.map.set(this.getKey(o), o)
                  : ore(o)
                  ? this.map.set(o.id, o)
                  : are(o) && this.map.set(o.topic, o);
              }),
              (this.cached = []),
              (this.initialized = !0));
          }),
          ei(this, "set", async (o, a) => {
            this.isInitialized(),
              this.map.has(o)
                ? await this.update(o, a)
                : (this.logger.debug("Setting value"),
                  this.logger.trace({
                    type: "method",
                    method: "set",
                    key: o,
                    value: a,
                  }),
                  this.map.set(o, a),
                  await this.persist());
          }),
          ei(
            this,
            "get",
            (o) => (
              this.isInitialized(),
              this.logger.debug("Getting value"),
              this.logger.trace({ type: "method", method: "get", key: o }),
              this.getData(o)
            )
          ),
          ei(
            this,
            "getAll",
            (o) => (
              this.isInitialized(),
              o
                ? this.values.filter((a) =>
                    Object.keys(o).every((c) => Dne(a[c], o[c]))
                  )
                : this.values
            )
          ),
          ei(this, "update", async (o, a) => {
            this.isInitialized(),
              this.logger.debug("Updating value"),
              this.logger.trace({
                type: "method",
                method: "update",
                key: o,
                update: a,
              });
            const c = Lx(Lx({}, this.getData(o)), a);
            this.map.set(o, c), await this.persist();
          }),
          ei(this, "delete", async (o, a) => {
            this.isInitialized(),
              this.map.has(o) &&
                (this.logger.debug("Deleting value"),
                this.logger.trace({
                  type: "method",
                  method: "delete",
                  key: o,
                  reason: a,
                }),
                this.map.delete(o),
                this.addToRecentlyDeleted(o),
                await this.persist());
          }),
          (this.logger = Ve(r, this.name)),
          (this.storagePrefix = s),
          (this.getKey = n);
      }
      get context() {
        return it(this.logger);
      }
      get storageKey() {
        return (
          this.storagePrefix +
          this.version +
          this.core.customStoragePrefix +
          "//" +
          this.name
        );
      }
      get length() {
        return this.map.size;
      }
      get keys() {
        return Array.from(this.map.keys());
      }
      get values() {
        return Array.from(this.map.values());
      }
      addToRecentlyDeleted(e) {
        this.recentlyDeleted.push(e),
          this.recentlyDeleted.length >= this.recentlyDeletedLimit &&
            this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
      }
      async setDataStore(e) {
        await this.core.storage.setItem(this.storageKey, e);
      }
      async getDataStore() {
        return await this.core.storage.getItem(this.storageKey);
      }
      getData(e) {
        const r = this.map.get(e);
        if (!r) {
          if (this.recentlyDeleted.includes(e)) {
            const { message: s } = Q(
              "MISSING_OR_INVALID",
              `Record was recently deleted - ${this.name}: ${e}`
            );
            throw (this.logger.error(s), new Error(s));
          }
          const { message: i } = Q("NO_MATCHING_KEY", `${this.name}: ${e}`);
          throw (this.logger.error(i), new Error(i));
        }
        return r;
      }
      async persist() {
        await this.setDataStore(this.values);
      }
      async restore() {
        try {
          const e = await this.getDataStore();
          if (typeof e > "u" || !e.length) return;
          if (this.map.size) {
            const { message: r } = Q("RESTORE_WILL_OVERRIDE", this.name);
            throw (this.logger.error(r), new Error(r));
          }
          (this.cached = e),
            this.logger.debug(`Successfully Restored value for ${this.name}`),
            this.logger.trace({
              type: "method",
              method: "restore",
              value: this.values,
            });
        } catch (e) {
          this.logger.debug(`Failed to Restore value for ${this.name}`),
            this.logger.error(e);
        }
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e } = Q("NOT_INITIALIZED", this.name);
          throw new Error(e);
        }
      }
    }
    var qne = Object.defineProperty,
      Hne = (t, e, r) =>
        e in t
          ? qne(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Te = (t, e, r) => Hne(t, typeof e != "symbol" ? e + "" : e, r);
    class Vne {
      constructor(e, r) {
        (this.core = e),
          (this.logger = r),
          Te(this, "name", Zre),
          Te(this, "version", Yre),
          Te(this, "events", new rt.exports()),
          Te(this, "pairings"),
          Te(this, "initialized", !1),
          Te(this, "storagePrefix", ks),
          Te(this, "ignoredPayloadTypes", [_n]),
          Te(this, "registeredMethods", []),
          Te(this, "init", async () => {
            this.initialized ||
              (await this.pairings.init(),
              await this.cleanup(),
              this.registerRelayerEvents(),
              this.registerExpirerEvents(),
              (this.initialized = !0),
              this.logger.trace("Initialized"));
          }),
          Te(this, "register", ({ methods: i }) => {
            this.isInitialized(),
              (this.registeredMethods = [
                ...new Set([...this.registeredMethods, ...i]),
              ]);
          }),
          Te(this, "create", async (i) => {
            this.isInitialized();
            const s = wy(),
              n = await this.core.crypto.setSymKey(s),
              o = Mt(z.FIVE_MINUTES),
              a = { protocol: ax },
              c = {
                topic: n,
                expiry: o,
                relay: a,
                active: !1,
                methods: i?.methods,
              },
              l = G7({
                protocol: this.core.protocol,
                version: this.core.version,
                topic: n,
                symKey: s,
                relay: a,
                expiryTimestamp: o,
                methods: i?.methods,
              });
            return (
              this.events.emit(ba.create, c),
              this.core.expirer.set(n, o),
              await this.pairings.set(n, c),
              await this.core.relayer.subscribe(n, {
                transportType: i?.transportType,
              }),
              { topic: n, uri: l }
            );
          }),
          Te(this, "pair", async (i) => {
            this.isInitialized();
            const s = this.core.eventClient.createEvent({
              properties: { topic: i?.uri, trace: [Rs.pairing_started] },
            });
            this.isValidPair(i, s);
            const {
              topic: n,
              symKey: o,
              relay: a,
              expiryTimestamp: c,
              methods: l,
            } = K7(i.uri);
            (s.props.properties.topic = n),
              s.addTrace(Rs.pairing_uri_validation_success),
              s.addTrace(Rs.pairing_uri_not_expired);
            let u;
            if (this.pairings.keys.includes(n)) {
              if (
                ((u = this.pairings.get(n)),
                s.addTrace(Rs.existing_pairing),
                u.active)
              )
                throw (
                  (s.setError(An.active_pairing_already_exists),
                  new Error(
                    `Pairing already exists: ${n}. Please try again with a new connection URI.`
                  ))
                );
              s.addTrace(Rs.pairing_not_expired);
            }
            const h = c || Mt(z.FIVE_MINUTES),
              d = { topic: n, relay: a, expiry: h, active: !1, methods: l };
            this.core.expirer.set(n, h),
              await this.pairings.set(n, d),
              s.addTrace(Rs.store_new_pairing),
              i.activatePairing && (await this.activate({ topic: n })),
              this.events.emit(ba.create, d),
              s.addTrace(Rs.emit_inactive_pairing),
              this.core.crypto.keychain.has(n) ||
                (await this.core.crypto.setSymKey(o, n)),
              s.addTrace(Rs.subscribing_pairing_topic);
            try {
              await this.core.relayer.confirmOnlineStateOrThrow();
            } catch {
              s.setError(An.no_internet_connection);
            }
            try {
              await this.core.relayer.subscribe(n, { relay: a });
            } catch (g) {
              throw (s.setError(An.subscribe_pairing_topic_failure), g);
            }
            return s.addTrace(Rs.subscribe_pairing_topic_success), d;
          }),
          Te(this, "activate", async ({ topic: i }) => {
            this.isInitialized();
            const s = Mt(z.FIVE_MINUTES);
            this.core.expirer.set(i, s),
              await this.pairings.update(i, { active: !0, expiry: s });
          }),
          Te(this, "ping", async (i) => {
            this.isInitialized(),
              await this.isValidPing(i),
              this.logger.warn(
                "ping() is deprecated and will be removed in the next major release."
              );
            const { topic: s } = i;
            if (this.pairings.keys.includes(s)) {
              const n = await this.sendRequest(s, "wc_pairingPing", {}),
                { done: o, resolve: a, reject: c } = pa();
              this.events.once(Ke("pairing_ping", n), ({ error: l }) => {
                l ? c(l) : a();
              }),
                await o();
            }
          }),
          Te(this, "updateExpiry", async ({ topic: i, expiry: s }) => {
            this.isInitialized(), await this.pairings.update(i, { expiry: s });
          }),
          Te(this, "updateMetadata", async ({ topic: i, metadata: s }) => {
            this.isInitialized(),
              await this.pairings.update(i, { peerMetadata: s });
          }),
          Te(
            this,
            "getPairings",
            () => (this.isInitialized(), this.pairings.values)
          ),
          Te(this, "disconnect", async (i) => {
            this.isInitialized(), await this.isValidDisconnect(i);
            const { topic: s } = i;
            this.pairings.keys.includes(s) &&
              (await this.sendRequest(
                s,
                "wc_pairingDelete",
                tt("USER_DISCONNECTED")
              ),
              await this.deletePairing(s));
          }),
          Te(this, "formatUriFromPairing", (i) => {
            this.isInitialized();
            const { topic: s, relay: n, expiry: o, methods: a } = i,
              c = this.core.crypto.keychain.get(s);
            return G7({
              protocol: this.core.protocol,
              version: this.core.version,
              topic: s,
              symKey: c,
              relay: n,
              expiryTimestamp: o,
              methods: a,
            });
          }),
          Te(this, "sendRequest", async (i, s, n) => {
            const o = kr(s, n),
              a = await this.core.crypto.encode(i, o),
              c = Gh[s].req;
            return (
              this.core.history.set(i, o),
              this.core.relayer.publish(i, a, c),
              o.id
            );
          }),
          Te(this, "sendResult", async (i, s, n) => {
            const o = Jn(i, n),
              a = await this.core.crypto.encode(s, o),
              c = (await this.core.history.get(s, i)).request.method,
              l = Gh[c].res;
            await this.core.relayer.publish(s, a, l),
              await this.core.history.resolve(o);
          }),
          Te(this, "sendError", async (i, s, n) => {
            const o = Ic(i, n),
              a = await this.core.crypto.encode(s, o),
              c = (await this.core.history.get(s, i)).request.method,
              l = Gh[c] ? Gh[c].res : Gh.unregistered_method.res;
            await this.core.relayer.publish(s, a, l),
              await this.core.history.resolve(o);
          }),
          Te(this, "deletePairing", async (i, s) => {
            await this.core.relayer.unsubscribe(i),
              await Promise.all([
                this.pairings.delete(i, tt("USER_DISCONNECTED")),
                this.core.crypto.deleteSymKey(i),
                s ? Promise.resolve() : this.core.expirer.del(i),
              ]);
          }),
          Te(this, "cleanup", async () => {
            const i = this.pairings.getAll().filter((s) => po(s.expiry));
            await Promise.all(i.map((s) => this.deletePairing(s.topic)));
          }),
          Te(this, "onRelayEventRequest", async (i) => {
            const { topic: s, payload: n } = i;
            switch (n.method) {
              case "wc_pairingPing":
                return await this.onPairingPingRequest(s, n);
              case "wc_pairingDelete":
                return await this.onPairingDeleteRequest(s, n);
              default:
                return await this.onUnknownRpcMethodRequest(s, n);
            }
          }),
          Te(this, "onRelayEventResponse", async (i) => {
            const { topic: s, payload: n } = i,
              o = (await this.core.history.get(s, n.id)).request.method;
            switch (o) {
              case "wc_pairingPing":
                return this.onPairingPingResponse(s, n);
              default:
                return this.onUnknownRpcMethodResponse(o);
            }
          }),
          Te(this, "onPairingPingRequest", async (i, s) => {
            const { id: n } = s;
            try {
              this.isValidPing({ topic: i }),
                await this.sendResult(n, i, !0),
                this.events.emit(ba.ping, { id: n, topic: i });
            } catch (o) {
              await this.sendError(n, i, o), this.logger.error(o);
            }
          }),
          Te(this, "onPairingPingResponse", (i, s) => {
            const { id: n } = s;
            setTimeout(() => {
              Bt(s)
                ? this.events.emit(Ke("pairing_ping", n), {})
                : Ct(s) &&
                  this.events.emit(Ke("pairing_ping", n), { error: s.error });
            }, 500);
          }),
          Te(this, "onPairingDeleteRequest", async (i, s) => {
            const { id: n } = s;
            try {
              this.isValidDisconnect({ topic: i }),
                await this.deletePairing(i),
                this.events.emit(ba.delete, { id: n, topic: i });
            } catch (o) {
              await this.sendError(n, i, o), this.logger.error(o);
            }
          }),
          Te(this, "onUnknownRpcMethodRequest", async (i, s) => {
            const { id: n, method: o } = s;
            try {
              if (this.registeredMethods.includes(o)) return;
              const a = tt("WC_METHOD_UNSUPPORTED", o);
              await this.sendError(n, i, a), this.logger.error(a);
            } catch (a) {
              await this.sendError(n, i, a), this.logger.error(a);
            }
          }),
          Te(this, "onUnknownRpcMethodResponse", (i) => {
            this.registeredMethods.includes(i) ||
              this.logger.error(tt("WC_METHOD_UNSUPPORTED", i));
          }),
          Te(this, "isValidPair", (i, s) => {
            var n;
            if (!Qr(i)) {
              const { message: a } = Q(
                "MISSING_OR_INVALID",
                `pair() params: ${i}`
              );
              throw (s.setError(An.malformed_pairing_uri), new Error(a));
            }
            if (!nre(i.uri)) {
              const { message: a } = Q(
                "MISSING_OR_INVALID",
                `pair() uri: ${i.uri}`
              );
              throw (s.setError(An.malformed_pairing_uri), new Error(a));
            }
            const o = K7(i?.uri);
            if (!((n = o?.relay) != null && n.protocol)) {
              const { message: a } = Q(
                "MISSING_OR_INVALID",
                "pair() uri#relay-protocol"
              );
              throw (s.setError(An.malformed_pairing_uri), new Error(a));
            }
            if (!(o != null && o.symKey)) {
              const { message: a } = Q(
                "MISSING_OR_INVALID",
                "pair() uri#symKey"
              );
              throw (s.setError(An.malformed_pairing_uri), new Error(a));
            }
            if (
              o != null &&
              o.expiryTimestamp &&
              z.toMiliseconds(o?.expiryTimestamp) < Date.now()
            ) {
              s.setError(An.pairing_expired);
              const { message: a } = Q(
                "EXPIRED",
                "pair() URI has expired. Please try again with a new connection URI."
              );
              throw new Error(a);
            }
          }),
          Te(this, "isValidPing", async (i) => {
            if (!Qr(i)) {
              const { message: n } = Q(
                "MISSING_OR_INVALID",
                `ping() params: ${i}`
              );
              throw new Error(n);
            }
            const { topic: s } = i;
            await this.isValidPairingTopic(s);
          }),
          Te(this, "isValidDisconnect", async (i) => {
            if (!Qr(i)) {
              const { message: n } = Q(
                "MISSING_OR_INVALID",
                `disconnect() params: ${i}`
              );
              throw new Error(n);
            }
            const { topic: s } = i;
            await this.isValidPairingTopic(s);
          }),
          Te(this, "isValidPairingTopic", async (i) => {
            if (!kt(i, !1)) {
              const { message: s } = Q(
                "MISSING_OR_INVALID",
                `pairing topic should be a string: ${i}`
              );
              throw new Error(s);
            }
            if (!this.pairings.keys.includes(i)) {
              const { message: s } = Q(
                "NO_MATCHING_KEY",
                `pairing topic doesn't exist: ${i}`
              );
              throw new Error(s);
            }
            if (po(this.pairings.get(i).expiry)) {
              await this.deletePairing(i);
              const { message: s } = Q("EXPIRED", `pairing topic: ${i}`);
              throw new Error(s);
            }
          }),
          (this.core = e),
          (this.logger = Ve(r, this.name)),
          (this.pairings = new Ca(
            this.core,
            this.logger,
            this.name,
            this.storagePrefix
          ));
      }
      get context() {
        return it(this.logger);
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e } = Q("NOT_INITIALIZED", this.name);
          throw new Error(e);
        }
      }
      registerRelayerEvents() {
        this.core.relayer.on(sr.message, async (e) => {
          const { topic: r, message: i, transportType: s } = e;
          if (
            this.pairings.keys.includes(r) &&
            s !== wt.link_mode &&
            !this.ignoredPayloadTypes.includes(
              this.core.crypto.getPayloadType(i)
            )
          )
            try {
              const n = await this.core.crypto.decode(r, i);
              _c(n)
                ? (this.core.history.set(r, n),
                  await this.onRelayEventRequest({ topic: r, payload: n }))
                : qo(n) &&
                  (await this.core.history.resolve(n),
                  await this.onRelayEventResponse({ topic: r, payload: n }),
                  this.core.history.delete(r, n.id)),
                await this.core.relayer.messages.ack(r, i);
            } catch (n) {
              this.logger.error(n);
            }
        });
      }
      registerExpirerEvents() {
        this.core.expirer.on(ji.expired, async (e) => {
          const { topic: r } = LC(e.target);
          r &&
            this.pairings.keys.includes(r) &&
            (await this.deletePairing(r, !0),
            this.events.emit(ba.expire, { topic: r }));
        });
      }
    }
    var Wne = Object.defineProperty,
      Kne = (t, e, r) =>
        e in t
          ? Wne(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Er = (t, e, r) => Kne(t, typeof e != "symbol" ? e + "" : e, r);
    class Gne extends KJ {
      constructor(e, r) {
        super(e, r),
          (this.core = e),
          (this.logger = r),
          Er(this, "records", new Map()),
          Er(this, "events", new rt.exports.EventEmitter()),
          Er(this, "name", Jre),
          Er(this, "version", Xre),
          Er(this, "cached", []),
          Er(this, "initialized", !1),
          Er(this, "storagePrefix", ks),
          Er(this, "init", async () => {
            this.initialized ||
              (this.logger.trace("Initialized"),
              await this.restore(),
              this.cached.forEach((i) => this.records.set(i.id, i)),
              (this.cached = []),
              this.registerEventListeners(),
              (this.initialized = !0));
          }),
          Er(this, "set", (i, s, n) => {
            if (
              (this.isInitialized(),
              this.logger.debug("Setting JSON-RPC request history record"),
              this.logger.trace({
                type: "method",
                method: "set",
                topic: i,
                request: s,
                chainId: n,
              }),
              this.records.has(s.id))
            )
              return;
            const o = {
              id: s.id,
              topic: i,
              request: { method: s.method, params: s.params || null },
              chainId: n,
              expiry: Mt(z.THIRTY_DAYS),
            };
            this.records.set(o.id, o),
              this.persist(),
              this.events.emit(cs.created, o);
          }),
          Er(this, "resolve", async (i) => {
            if (
              (this.isInitialized(),
              this.logger.debug("Updating JSON-RPC response history record"),
              this.logger.trace({
                type: "method",
                method: "update",
                response: i,
              }),
              !this.records.has(i.id))
            )
              return;
            const s = await this.getRecord(i.id);
            typeof s.response > "u" &&
              ((s.response = Ct(i) ? { error: i.error } : { result: i.result }),
              this.records.set(s.id, s),
              this.persist(),
              this.events.emit(cs.updated, s));
          }),
          Er(
            this,
            "get",
            async (i, s) => (
              this.isInitialized(),
              this.logger.debug("Getting record"),
              this.logger.trace({
                type: "method",
                method: "get",
                topic: i,
                id: s,
              }),
              await this.getRecord(s)
            )
          ),
          Er(this, "delete", (i, s) => {
            this.isInitialized(),
              this.logger.debug("Deleting record"),
              this.logger.trace({ type: "method", method: "delete", id: s }),
              this.values.forEach((n) => {
                if (n.topic === i) {
                  if (typeof s < "u" && n.id !== s) return;
                  this.records.delete(n.id), this.events.emit(cs.deleted, n);
                }
              }),
              this.persist();
          }),
          Er(
            this,
            "exists",
            async (i, s) => (
              this.isInitialized(),
              this.records.has(s) ? (await this.getRecord(s)).topic === i : !1
            )
          ),
          Er(this, "on", (i, s) => {
            this.events.on(i, s);
          }),
          Er(this, "once", (i, s) => {
            this.events.once(i, s);
          }),
          Er(this, "off", (i, s) => {
            this.events.off(i, s);
          }),
          Er(this, "removeListener", (i, s) => {
            this.events.removeListener(i, s);
          }),
          (this.logger = Ve(r, this.name));
      }
      get context() {
        return it(this.logger);
      }
      get storageKey() {
        return (
          this.storagePrefix +
          this.version +
          this.core.customStoragePrefix +
          "//" +
          this.name
        );
      }
      get size() {
        return this.records.size;
      }
      get keys() {
        return Array.from(this.records.keys());
      }
      get values() {
        return Array.from(this.records.values());
      }
      get pending() {
        const e = [];
        return (
          this.values.forEach((r) => {
            if (typeof r.response < "u") return;
            const i = {
              topic: r.topic,
              request: kr(r.request.method, r.request.params, r.id),
              chainId: r.chainId,
            };
            return e.push(i);
          }),
          e
        );
      }
      async setJsonRpcRecords(e) {
        await this.core.storage.setItem(this.storageKey, e);
      }
      async getJsonRpcRecords() {
        return await this.core.storage.getItem(this.storageKey);
      }
      getRecord(e) {
        this.isInitialized();
        const r = this.records.get(e);
        if (!r) {
          const { message: i } = Q("NO_MATCHING_KEY", `${this.name}: ${e}`);
          throw new Error(i);
        }
        return r;
      }
      async persist() {
        await this.setJsonRpcRecords(this.values), this.events.emit(cs.sync);
      }
      async restore() {
        try {
          const e = await this.getJsonRpcRecords();
          if (typeof e > "u" || !e.length) return;
          if (this.records.size) {
            const { message: r } = Q("RESTORE_WILL_OVERRIDE", this.name);
            throw (this.logger.error(r), new Error(r));
          }
          (this.cached = e),
            this.logger.debug(`Successfully Restored records for ${this.name}`),
            this.logger.trace({
              type: "method",
              method: "restore",
              records: this.values,
            });
        } catch (e) {
          this.logger.debug(`Failed to Restore records for ${this.name}`),
            this.logger.error(e);
        }
      }
      registerEventListeners() {
        this.events.on(cs.created, (e) => {
          const r = cs.created;
          this.logger.info(`Emitting ${r}`),
            this.logger.debug({ type: "event", event: r, record: e });
        }),
          this.events.on(cs.updated, (e) => {
            const r = cs.updated;
            this.logger.info(`Emitting ${r}`),
              this.logger.debug({ type: "event", event: r, record: e });
          }),
          this.events.on(cs.deleted, (e) => {
            const r = cs.deleted;
            this.logger.info(`Emitting ${r}`),
              this.logger.debug({ type: "event", event: r, record: e });
          }),
          this.core.heartbeat.on(Ti.pulse, () => {
            this.cleanup();
          });
      }
      cleanup() {
        try {
          this.isInitialized();
          let e = !1;
          this.records.forEach((r) => {
            z.toMiliseconds(r.expiry || 0) - Date.now() <= 0 &&
              (this.logger.info(`Deleting expired history log: ${r.id}`),
              this.records.delete(r.id),
              this.events.emit(cs.deleted, r, !1),
              (e = !0));
          }),
            e && this.persist();
        } catch (e) {
          this.logger.warn(e);
        }
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e } = Q("NOT_INITIALIZED", this.name);
          throw new Error(e);
        }
      }
    }
    var Zne = Object.defineProperty,
      Yne = (t, e, r) =>
        e in t
          ? Zne(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Pr = (t, e, r) => Yne(t, typeof e != "symbol" ? e + "" : e, r);
    class Jne extends QJ {
      constructor(e, r) {
        super(e, r),
          (this.core = e),
          (this.logger = r),
          Pr(this, "expirations", new Map()),
          Pr(this, "events", new rt.exports.EventEmitter()),
          Pr(this, "name", Qre),
          Pr(this, "version", eie),
          Pr(this, "cached", []),
          Pr(this, "initialized", !1),
          Pr(this, "storagePrefix", ks),
          Pr(this, "init", async () => {
            this.initialized ||
              (this.logger.trace("Initialized"),
              await this.restore(),
              this.cached.forEach((i) => this.expirations.set(i.target, i)),
              (this.cached = []),
              this.registerEventListeners(),
              (this.initialized = !0));
          }),
          Pr(this, "has", (i) => {
            try {
              const s = this.formatTarget(i);
              return typeof this.getExpiration(s) < "u";
            } catch {
              return !1;
            }
          }),
          Pr(this, "set", (i, s) => {
            this.isInitialized();
            const n = this.formatTarget(i),
              o = { target: n, expiry: s };
            this.expirations.set(n, o),
              this.checkExpiry(n, o),
              this.events.emit(ji.created, { target: n, expiration: o });
          }),
          Pr(this, "get", (i) => {
            this.isInitialized();
            const s = this.formatTarget(i);
            return this.getExpiration(s);
          }),
          Pr(this, "del", (i) => {
            if ((this.isInitialized(), this.has(i))) {
              const s = this.formatTarget(i),
                n = this.getExpiration(s);
              this.expirations.delete(s),
                this.events.emit(ji.deleted, { target: s, expiration: n });
            }
          }),
          Pr(this, "on", (i, s) => {
            this.events.on(i, s);
          }),
          Pr(this, "once", (i, s) => {
            this.events.once(i, s);
          }),
          Pr(this, "off", (i, s) => {
            this.events.off(i, s);
          }),
          Pr(this, "removeListener", (i, s) => {
            this.events.removeListener(i, s);
          }),
          (this.logger = Ve(r, this.name));
      }
      get context() {
        return it(this.logger);
      }
      get storageKey() {
        return (
          this.storagePrefix +
          this.version +
          this.core.customStoragePrefix +
          "//" +
          this.name
        );
      }
      get length() {
        return this.expirations.size;
      }
      get keys() {
        return Array.from(this.expirations.keys());
      }
      get values() {
        return Array.from(this.expirations.values());
      }
      formatTarget(e) {
        if (typeof e == "string") return yQ(e);
        if (typeof e == "number") return bQ(e);
        const { message: r } = Q("UNKNOWN_TYPE", `Target type: ${typeof e}`);
        throw new Error(r);
      }
      async setExpirations(e) {
        await this.core.storage.setItem(this.storageKey, e);
      }
      async getExpirations() {
        return await this.core.storage.getItem(this.storageKey);
      }
      async persist() {
        await this.setExpirations(this.values), this.events.emit(ji.sync);
      }
      async restore() {
        try {
          const e = await this.getExpirations();
          if (typeof e > "u" || !e.length) return;
          if (this.expirations.size) {
            const { message: r } = Q("RESTORE_WILL_OVERRIDE", this.name);
            throw (this.logger.error(r), new Error(r));
          }
          (this.cached = e),
            this.logger.debug(
              `Successfully Restored expirations for ${this.name}`
            ),
            this.logger.trace({
              type: "method",
              method: "restore",
              expirations: this.values,
            });
        } catch (e) {
          this.logger.debug(`Failed to Restore expirations for ${this.name}`),
            this.logger.error(e);
        }
      }
      getExpiration(e) {
        const r = this.expirations.get(e);
        if (!r) {
          const { message: i } = Q("NO_MATCHING_KEY", `${this.name}: ${e}`);
          throw (this.logger.warn(i), new Error(i));
        }
        return r;
      }
      checkExpiry(e, r) {
        const { expiry: i } = r;
        z.toMiliseconds(i) - Date.now() <= 0 && this.expire(e, r);
      }
      expire(e, r) {
        this.expirations.delete(e),
          this.events.emit(ji.expired, { target: e, expiration: r });
      }
      checkExpirations() {
        this.core.relayer.connected &&
          this.expirations.forEach((e, r) => this.checkExpiry(r, e));
      }
      registerEventListeners() {
        this.core.heartbeat.on(Ti.pulse, () => this.checkExpirations()),
          this.events.on(ji.created, (e) => {
            const r = ji.created;
            this.logger.info(`Emitting ${r}`),
              this.logger.debug({ type: "event", event: r, data: e }),
              this.persist();
          }),
          this.events.on(ji.expired, (e) => {
            const r = ji.expired;
            this.logger.info(`Emitting ${r}`),
              this.logger.debug({ type: "event", event: r, data: e }),
              this.persist();
          }),
          this.events.on(ji.deleted, (e) => {
            const r = ji.deleted;
            this.logger.info(`Emitting ${r}`),
              this.logger.debug({ type: "event", event: r, data: e }),
              this.persist();
          });
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e } = Q("NOT_INITIALIZED", this.name);
          throw new Error(e);
        }
      }
    }
    var Xne = Object.defineProperty,
      Qne = (t, e, r) =>
        e in t
          ? Xne(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Rt = (t, e, r) => Qne(t, typeof e != "symbol" ? e + "" : e, r);
    class eoe extends eX {
      constructor(e, r, i) {
        super(e, r, i),
          (this.core = e),
          (this.logger = r),
          (this.store = i),
          Rt(this, "name", tie),
          Rt(this, "abortController"),
          Rt(this, "isDevEnv"),
          Rt(this, "verifyUrlV3", iie),
          Rt(this, "storagePrefix", ks),
          Rt(this, "version", sx),
          Rt(this, "publicKey"),
          Rt(this, "fetchPromise"),
          Rt(this, "init", async () => {
            var s;
            this.isDevEnv ||
              ((this.publicKey = await this.store.getItem(this.storeKey)),
              this.publicKey &&
                z.toMiliseconds(
                  (s = this.publicKey) == null ? void 0 : s.expiresAt
                ) < Date.now() &&
                (this.logger.debug("verify v2 public key expired"),
                await this.removePublicKey()));
          }),
          Rt(this, "register", async (s) => {
            if (!Nh() || this.isDevEnv) return;
            const n = window.location.origin,
              { id: o, decryptedId: a } = s,
              c = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${n}&id=${o}&decryptedId=${a}`;
            try {
              const l = Gi(),
                u = this.startAbortTimer(z.ONE_SECOND * 5),
                h = await new Promise((d, g) => {
                  const p = () => {
                    window.removeEventListener("message", f),
                      l.body.removeChild(w),
                      g("attestation aborted");
                  };
                  this.abortController.signal.addEventListener("abort", p);
                  const w = l.createElement("iframe");
                  (w.src = c),
                    (w.style.display = "none"),
                    w.addEventListener("error", p, {
                      signal: this.abortController.signal,
                    });
                  const f = (m) => {
                    if (m.data && typeof m.data == "string")
                      try {
                        const y = JSON.parse(m.data);
                        if (y.type === "verify_attestation") {
                          if (oc(y.attestation).payload.id !== o) return;
                          clearInterval(u),
                            l.body.removeChild(w),
                            this.abortController.signal.removeEventListener(
                              "abort",
                              p
                            ),
                            window.removeEventListener("message", f),
                            d(y.attestation === null ? "" : y.attestation);
                        }
                      } catch (y) {
                        this.logger.warn(y);
                      }
                  };
                  l.body.appendChild(w),
                    window.addEventListener("message", f, {
                      signal: this.abortController.signal,
                    });
                });
              return this.logger.debug("jwt attestation", h), h;
            } catch (l) {
              this.logger.warn(l);
            }
            return "";
          }),
          Rt(this, "resolve", async (s) => {
            if (this.isDevEnv) return "";
            const { attestationId: n, hash: o, encryptedId: a } = s;
            if (n === "") {
              this.logger.debug("resolve: attestationId is empty, skipping");
              return;
            }
            if (n) {
              if (oc(n).payload.id !== a) return;
              const l = await this.isValidJwtAttestation(n);
              if (l) {
                if (!l.isVerified) {
                  this.logger.warn(
                    "resolve: jwt attestation: origin url not verified"
                  );
                  return;
                }
                return l;
              }
            }
            if (!o) return;
            const c = this.getVerifyUrl(s?.verifyUrl);
            return this.fetchAttestation(o, c);
          }),
          Rt(this, "fetchAttestation", async (s, n) => {
            this.logger.debug(`resolving attestation: ${s} from url: ${n}`);
            const o = this.startAbortTimer(z.ONE_SECOND * 5),
              a = await fetch(`${n}/attestation/${s}?v2Supported=true`, {
                signal: this.abortController.signal,
              });
            return clearTimeout(o), a.status === 200 ? await a.json() : void 0;
          }),
          Rt(this, "getVerifyUrl", (s) => {
            let n = s || Zh;
            return (
              sie.includes(n) ||
                (this.logger.info(
                  `verify url: ${n}, not included in trusted list, assigning default: ${Zh}`
                ),
                (n = Zh)),
              n
            );
          }),
          Rt(this, "fetchPublicKey", async () => {
            try {
              this.logger.debug(
                `fetching public key from: ${this.verifyUrlV3}`
              );
              const s = this.startAbortTimer(z.FIVE_SECONDS),
                n = await fetch(`${this.verifyUrlV3}/public-key`, {
                  signal: this.abortController.signal,
                });
              return clearTimeout(s), await n.json();
            } catch (s) {
              this.logger.warn(s);
            }
          }),
          Rt(this, "persistPublicKey", async (s) => {
            this.logger.debug("persisting public key to local storage", s),
              await this.store.setItem(this.storeKey, s),
              (this.publicKey = s);
          }),
          Rt(this, "removePublicKey", async () => {
            this.logger.debug("removing verify v2 public key from storage"),
              await this.store.removeItem(this.storeKey),
              (this.publicKey = void 0);
          }),
          Rt(this, "isValidJwtAttestation", async (s) => {
            const n = await this.getPublicKey();
            try {
              if (n) return this.validateAttestation(s, n);
            } catch (a) {
              this.logger.error(a),
                this.logger.warn("error validating attestation");
            }
            const o = await this.fetchAndPersistPublicKey();
            try {
              if (o) return this.validateAttestation(s, o);
            } catch (a) {
              this.logger.error(a),
                this.logger.warn("error validating attestation");
            }
          }),
          Rt(this, "getPublicKey", async () =>
            this.publicKey
              ? this.publicKey
              : await this.fetchAndPersistPublicKey()
          ),
          Rt(this, "fetchAndPersistPublicKey", async () => {
            if (this.fetchPromise)
              return await this.fetchPromise, this.publicKey;
            this.fetchPromise = new Promise(async (n) => {
              const o = await this.fetchPublicKey();
              o && (await this.persistPublicKey(o), n(o));
            });
            const s = await this.fetchPromise;
            return (this.fetchPromise = void 0), s;
          }),
          Rt(this, "validateAttestation", (s, n) => {
            const o = Wte(s, n.publicKey),
              a = {
                hasExpired: z.toMiliseconds(o.exp) < Date.now(),
                payload: o,
              };
            if (a.hasExpired)
              throw (
                (this.logger.warn("resolve: jwt attestation expired"),
                new Error("JWT attestation expired"))
              );
            return {
              origin: a.payload.origin,
              isScam: a.payload.isScam,
              isVerified: a.payload.isVerified,
            };
          }),
          (this.logger = Ve(r, this.name)),
          (this.abortController = new AbortController()),
          (this.isDevEnv = qm()),
          this.init();
      }
      get storeKey() {
        return (
          this.storagePrefix +
          this.version +
          this.core.customStoragePrefix +
          "//verify:public:key"
        );
      }
      get context() {
        return it(this.logger);
      }
      startAbortTimer(e) {
        return (
          (this.abortController = new AbortController()),
          setTimeout(() => this.abortController.abort(), z.toMiliseconds(e))
        );
      }
    }
    var toe = Object.defineProperty,
      roe = (t, e, r) =>
        e in t
          ? toe(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Ux = (t, e, r) => roe(t, typeof e != "symbol" ? e + "" : e, r);
    class ioe extends tX {
      constructor(e, r) {
        super(e, r),
          (this.projectId = e),
          (this.logger = r),
          Ux(this, "context", nie),
          Ux(this, "registerDeviceToken", async (i) => {
            const {
                clientId: s,
                token: n,
                notificationType: o,
                enableEncrypted: a = !1,
              } = i,
              c = `${oie}/${this.projectId}/clients`;
            await fetch(c, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                client_id: s,
                type: o,
                token: n,
                always_raw: a,
              }),
            });
          }),
          (this.logger = Ve(r, this.context));
      }
    }
    var soe = Object.defineProperty,
      Dx = Object.getOwnPropertySymbols,
      noe = Object.prototype.hasOwnProperty,
      ooe = Object.prototype.propertyIsEnumerable,
      Ry = (t, e, r) =>
        e in t
          ? soe(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      td = (t, e) => {
        for (var r in e || (e = {})) noe.call(e, r) && Ry(t, r, e[r]);
        if (Dx) for (var r of Dx(e)) ooe.call(e, r) && Ry(t, r, e[r]);
        return t;
      },
      nr = (t, e, r) => Ry(t, typeof e != "symbol" ? e + "" : e, r);
    class aoe extends rX {
      constructor(e, r, i = !0) {
        super(e, r, i),
          (this.core = e),
          (this.logger = r),
          nr(this, "context", cie),
          nr(this, "storagePrefix", ks),
          nr(this, "storageVersion", aie),
          nr(this, "events", new Map()),
          nr(this, "shouldPersist", !1),
          nr(this, "init", async () => {
            if (!qm())
              try {
                const s = {
                  eventId: DC(),
                  timestamp: Date.now(),
                  domain: this.getAppDomain(),
                  props: {
                    event: "INIT",
                    type: "",
                    properties: {
                      client_id: await this.core.crypto.getClientId(),
                      user_agent: FC(
                        this.core.relayer.protocol,
                        this.core.relayer.version,
                        Ey
                      ),
                    },
                  },
                };
                await this.sendEvent([s]);
              } catch (s) {
                this.logger.warn(s);
              }
          }),
          nr(this, "createEvent", (s) => {
            const {
                event: n = "ERROR",
                type: o = "",
                properties: { topic: a, trace: c },
              } = s,
              l = DC(),
              u = this.core.projectId || "",
              h = Date.now(),
              d = td(
                {
                  eventId: l,
                  timestamp: h,
                  props: {
                    event: n,
                    type: o,
                    properties: { topic: a, trace: c },
                  },
                  bundleId: u,
                  domain: this.getAppDomain(),
                },
                this.setMethods(l)
              );
            return (
              this.telemetryEnabled &&
                (this.events.set(l, d), (this.shouldPersist = !0)),
              d
            );
          }),
          nr(this, "getEvent", (s) => {
            const { eventId: n, topic: o } = s;
            if (n) return this.events.get(n);
            const a = Array.from(this.events.values()).find(
              (c) => c.props.properties.topic === o
            );
            if (a) return td(td({}, a), this.setMethods(a.eventId));
          }),
          nr(this, "deleteEvent", (s) => {
            const { eventId: n } = s;
            this.events.delete(n), (this.shouldPersist = !0);
          }),
          nr(this, "setEventListeners", () => {
            this.core.heartbeat.on(Ti.pulse, async () => {
              this.shouldPersist && (await this.persist()),
                this.events.forEach((s) => {
                  z.fromMiliseconds(Date.now()) -
                    z.fromMiliseconds(s.timestamp) >
                    lie &&
                    (this.events.delete(s.eventId), (this.shouldPersist = !0));
                });
            });
          }),
          nr(this, "setMethods", (s) => ({
            addTrace: (n) => this.addTrace(s, n),
            setError: (n) => this.setError(s, n),
          })),
          nr(this, "addTrace", (s, n) => {
            const o = this.events.get(s);
            o &&
              (o.props.properties.trace.push(n),
              this.events.set(s, o),
              (this.shouldPersist = !0));
          }),
          nr(this, "setError", (s, n) => {
            const o = this.events.get(s);
            o &&
              ((o.props.type = n),
              (o.timestamp = Date.now()),
              this.events.set(s, o),
              (this.shouldPersist = !0));
          }),
          nr(this, "persist", async () => {
            await this.core.storage.setItem(
              this.storageKey,
              Array.from(this.events.values())
            ),
              (this.shouldPersist = !1);
          }),
          nr(this, "restore", async () => {
            try {
              const s =
                (await this.core.storage.getItem(this.storageKey)) || [];
              if (!s.length) return;
              s.forEach((n) => {
                this.events.set(
                  n.eventId,
                  td(td({}, n), this.setMethods(n.eventId))
                );
              });
            } catch (s) {
              this.logger.warn(s);
            }
          }),
          nr(this, "submit", async () => {
            if (!this.telemetryEnabled || this.events.size === 0) return;
            const s = [];
            for (const [n, o] of this.events) o.props.type && s.push(o);
            if (s.length !== 0)
              try {
                if ((await this.sendEvent(s)).ok)
                  for (const n of s)
                    this.events.delete(n.eventId), (this.shouldPersist = !0);
              } catch (n) {
                this.logger.warn(n);
              }
          }),
          nr(this, "sendEvent", async (s) => {
            const n = this.getAppDomain() ? "" : "&sp=desktop";
            return await fetch(
              `${uie}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${Ey}${n}`,
              { method: "POST", body: JSON.stringify(s) }
            );
          }),
          nr(this, "getAppDomain", () => $C().url),
          (this.logger = Ve(r, this.context)),
          (this.telemetryEnabled = i),
          i
            ? this.restore().then(async () => {
                await this.submit(), this.setEventListeners();
              })
            : this.persist();
      }
      get storageKey() {
        return (
          this.storagePrefix +
          this.storageVersion +
          this.core.customStoragePrefix +
          "//" +
          this.context
        );
      }
    }
    var coe = Object.defineProperty,
      jx = Object.getOwnPropertySymbols,
      loe = Object.prototype.hasOwnProperty,
      uoe = Object.prototype.propertyIsEnumerable,
      $y = (t, e, r) =>
        e in t
          ? coe(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Mx = (t, e) => {
        for (var r in e || (e = {})) loe.call(e, r) && $y(t, r, e[r]);
        if (jx) for (var r of jx(e)) uoe.call(e, r) && $y(t, r, e[r]);
        return t;
      },
      ft = (t, e, r) => $y(t, typeof e != "symbol" ? e + "" : e, r);
    class Fy extends qJ {
      constructor(e) {
        var r;
        super(e),
          ft(this, "protocol", ix),
          ft(this, "version", sx),
          ft(this, "name", Hf),
          ft(this, "relayUrl"),
          ft(this, "projectId"),
          ft(this, "customStoragePrefix"),
          ft(this, "events", new rt.exports.EventEmitter()),
          ft(this, "logger"),
          ft(this, "heartbeat"),
          ft(this, "relayer"),
          ft(this, "crypto"),
          ft(this, "storage"),
          ft(this, "history"),
          ft(this, "expirer"),
          ft(this, "pairing"),
          ft(this, "verify"),
          ft(this, "echoClient"),
          ft(this, "linkModeSupportedApps"),
          ft(this, "eventClient"),
          ft(this, "initialized", !1),
          ft(this, "logChunkController"),
          ft(this, "on", (a, c) => this.events.on(a, c)),
          ft(this, "once", (a, c) => this.events.once(a, c)),
          ft(this, "off", (a, c) => this.events.off(a, c)),
          ft(this, "removeListener", (a, c) =>
            this.events.removeListener(a, c)
          ),
          ft(
            this,
            "dispatchEnvelope",
            ({ topic: a, message: c, sessionExists: l }) => {
              if (!a || !c) return;
              const u = {
                topic: a,
                message: c,
                publishedAt: Date.now(),
                transportType: wt.link_mode,
              };
              this.relayer.onLinkMessageEvent(u, { sessionExists: l });
            }
          );
        const i = this.getGlobalCore(e?.customStoragePrefix);
        if (i)
          try {
            return (
              (this.customStoragePrefix = i.customStoragePrefix),
              (this.logger = i.logger),
              (this.heartbeat = i.heartbeat),
              (this.crypto = i.crypto),
              (this.history = i.history),
              (this.expirer = i.expirer),
              (this.storage = i.storage),
              (this.relayer = i.relayer),
              (this.pairing = i.pairing),
              (this.verify = i.verify),
              (this.echoClient = i.echoClient),
              (this.linkModeSupportedApps = i.linkModeSupportedApps),
              (this.eventClient = i.eventClient),
              (this.initialized = i.initialized),
              (this.logChunkController = i.logChunkController),
              i
            );
          } catch (a) {
            console.warn("Failed to copy globalThis core", a);
          }
        (this.projectId = e?.projectId),
          (this.relayUrl = e?.relayUrl || cx),
          (this.customStoragePrefix =
            e != null && e.customStoragePrefix
              ? `:${e.customStoragePrefix}`
              : "");
        const s = tn({
            level:
              typeof e?.logger == "string" && e.logger ? e.logger : kre.logger,
            name: Hf,
          }),
          { logger: n, chunkLoggerController: o } = J1({
            opts: s,
            maxSizeInBytes: e?.maxLogBlobSizeInBytes,
            loggerOverride: e?.logger,
          });
        (this.logChunkController = o),
          (r = this.logChunkController) != null &&
            r.downloadLogsBlobInBrowser &&
            (window.downloadLogsBlobInBrowser = async () => {
              var a, c;
              (a = this.logChunkController) != null &&
                a.downloadLogsBlobInBrowser &&
                ((c = this.logChunkController) == null ||
                  c.downloadLogsBlobInBrowser({
                    clientId: await this.crypto.getClientId(),
                  }));
            }),
          (this.logger = Ve(n, this.name)),
          (this.heartbeat = new Tp()),
          (this.crypto = new Use(this, this.logger, e?.keychain)),
          (this.history = new Gne(this, this.logger)),
          (this.expirer = new Jne(this, this.logger)),
          (this.storage =
            e != null && e.storage
              ? e.storage
              : new G4(Mx(Mx({}, Rre), e?.storageOptions))),
          (this.relayer = new hne({
            core: this,
            logger: this.logger,
            relayUrl: this.relayUrl,
            projectId: this.projectId,
          })),
          (this.pairing = new Vne(this, this.logger)),
          (this.verify = new eoe(this, this.logger, this.storage)),
          (this.echoClient = new ioe(this.projectId || "", this.logger)),
          (this.linkModeSupportedApps = []),
          (this.eventClient = new aoe(this, this.logger, e?.telemetryEnabled)),
          this.setGlobalCore(this);
      }
      static async init(e) {
        const r = new Fy(e);
        await r.initialize();
        const i = await r.crypto.getClientId();
        return await r.storage.setItem(Wre, i), r;
      }
      get context() {
        return it(this.logger);
      }
      async start() {
        this.initialized || (await this.initialize());
      }
      async getLogsBlob() {
        var e;
        return (e = this.logChunkController) == null
          ? void 0
          : e.logsToBlob({ clientId: await this.crypto.getClientId() });
      }
      async addLinkModeSupportedApp(e) {
        this.linkModeSupportedApps.includes(e) ||
          (this.linkModeSupportedApps.push(e),
          await this.storage.setItem(lx, this.linkModeSupportedApps));
      }
      async initialize() {
        this.logger.trace("Initialized");
        try {
          await this.crypto.init(),
            await this.history.init(),
            await this.expirer.init(),
            await this.relayer.init(),
            await this.heartbeat.init(),
            await this.pairing.init(),
            (this.linkModeSupportedApps =
              (await this.storage.getItem(lx)) || []),
            (this.initialized = !0),
            this.logger.info("Core Initialization Success");
        } catch (e) {
          throw (
            (this.logger.warn(
              `Core Initialization Failure at epoch ${Date.now()}`,
              e
            ),
            this.logger.error(e.message),
            e)
          );
        }
      }
      getGlobalCore(e = "") {
        try {
          if (this.isGlobalCoreDisabled()) return;
          const r = `_walletConnectCore_${e}`,
            i = `${r}_count`;
          return (
            (globalThis[i] = (globalThis[i] || 0) + 1),
            globalThis[i] > 1 &&
              console.warn(
                `WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[i]} times.`
              ),
            globalThis[r]
          );
        } catch (r) {
          console.warn("Failed to get globalThis WalletConnect core", r);
          return;
        }
      }
      setGlobalCore(e) {
        var r;
        try {
          if (this.isGlobalCoreDisabled()) return;
          const i = `_walletConnectCore_${
            ((r = e.opts) == null ? void 0 : r.customStoragePrefix) || ""
          }`;
          globalThis[i] = e;
        } catch (i) {
          console.warn("Failed to set globalThis WalletConnect core", i);
        }
      }
      isGlobalCoreDisabled() {
        try {
          return typeof ut < "u" && {}.DISABLE_GLOBAL_CORE === "true";
        } catch {
          return !0;
        }
      }
    }
    const hoe = Fy,
      zx = "wc",
      qx = 2,
      Hx = "client",
      By = `${zx}@${qx}:${Hx}:`,
      Ly = {
        name: Hx,
        logger: "error",
        controller: !1,
        relayUrl: "wss://relay.walletconnect.org",
      },
      Vx = "WALLETCONNECT_DEEPLINK_CHOICE",
      doe = "proposal",
      Wx = "Proposal expired",
      poe = "session",
      _l = z.SEVEN_DAYS,
      foe = "engine",
      or = {
        wc_sessionPropose: {
          req: { ttl: z.FIVE_MINUTES, prompt: !0, tag: 1100 },
          res: { ttl: z.FIVE_MINUTES, prompt: !1, tag: 1101 },
          reject: { ttl: z.FIVE_MINUTES, prompt: !1, tag: 1120 },
          autoReject: { ttl: z.FIVE_MINUTES, prompt: !1, tag: 1121 },
        },
        wc_sessionSettle: {
          req: { ttl: z.FIVE_MINUTES, prompt: !1, tag: 1102 },
          res: { ttl: z.FIVE_MINUTES, prompt: !1, tag: 1103 },
        },
        wc_sessionUpdate: {
          req: { ttl: z.ONE_DAY, prompt: !1, tag: 1104 },
          res: { ttl: z.ONE_DAY, prompt: !1, tag: 1105 },
        },
        wc_sessionExtend: {
          req: { ttl: z.ONE_DAY, prompt: !1, tag: 1106 },
          res: { ttl: z.ONE_DAY, prompt: !1, tag: 1107 },
        },
        wc_sessionRequest: {
          req: { ttl: z.FIVE_MINUTES, prompt: !0, tag: 1108 },
          res: { ttl: z.FIVE_MINUTES, prompt: !1, tag: 1109 },
        },
        wc_sessionEvent: {
          req: { ttl: z.FIVE_MINUTES, prompt: !0, tag: 1110 },
          res: { ttl: z.FIVE_MINUTES, prompt: !1, tag: 1111 },
        },
        wc_sessionDelete: {
          req: { ttl: z.ONE_DAY, prompt: !1, tag: 1112 },
          res: { ttl: z.ONE_DAY, prompt: !1, tag: 1113 },
        },
        wc_sessionPing: {
          req: { ttl: z.ONE_DAY, prompt: !1, tag: 1114 },
          res: { ttl: z.ONE_DAY, prompt: !1, tag: 1115 },
        },
        wc_sessionAuthenticate: {
          req: { ttl: z.ONE_HOUR, prompt: !0, tag: 1116 },
          res: { ttl: z.ONE_HOUR, prompt: !1, tag: 1117 },
          reject: { ttl: z.FIVE_MINUTES, prompt: !1, tag: 1118 },
          autoReject: { ttl: z.FIVE_MINUTES, prompt: !1, tag: 1119 },
        },
      },
      Uy = { min: z.FIVE_MINUTES, max: z.SEVEN_DAYS },
      Fs = { idle: "IDLE", active: "ACTIVE" },
      Kx = {
        eth_sendTransaction: { key: "" },
        eth_sendRawTransaction: { key: "" },
        wallet_sendCalls: { key: "" },
        solana_signTransaction: { key: "signature" },
        solana_signAllTransactions: { key: "transactions" },
        solana_signAndSendTransaction: { key: "signature" },
      },
      goe = "request",
      woe = [
        "wc_sessionPropose",
        "wc_sessionRequest",
        "wc_authRequest",
        "wc_sessionAuthenticate",
      ],
      moe = "wc",
      yoe = "auth",
      boe = "authKeys",
      voe = "pairingTopics",
      Eoe = "requests",
      Gf = `${moe}@${1.5}:${yoe}:`,
      Zf = `${Gf}:PUB_KEY`;
    var Coe = Object.defineProperty,
      xoe = Object.defineProperties,
      Ioe = Object.getOwnPropertyDescriptors,
      Gx = Object.getOwnPropertySymbols,
      _oe = Object.prototype.hasOwnProperty,
      Aoe = Object.prototype.propertyIsEnumerable,
      Dy = (t, e, r) =>
        e in t
          ? Coe(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      lt = (t, e) => {
        for (var r in e || (e = {})) _oe.call(e, r) && Dy(t, r, e[r]);
        if (Gx) for (var r of Gx(e)) Aoe.call(e, r) && Dy(t, r, e[r]);
        return t;
      },
      Mr = (t, e) => xoe(t, Ioe(e)),
      K = (t, e, r) => Dy(t, typeof e != "symbol" ? e + "" : e, r);
    class Soe extends oX {
      constructor(e) {
        super(e),
          K(this, "name", foe),
          K(this, "events", new rt.exports()),
          K(this, "initialized", !1),
          K(this, "requestQueue", { state: Fs.idle, queue: [] }),
          K(this, "sessionRequestQueue", { state: Fs.idle, queue: [] }),
          K(this, "requestQueueDelay", z.ONE_SECOND),
          K(this, "expectedPairingMethodMap", new Map()),
          K(this, "recentlyDeletedMap", new Map()),
          K(this, "recentlyDeletedLimit", 200),
          K(this, "relayMessageCache", []),
          K(this, "pendingSessions", new Map()),
          K(this, "init", async () => {
            this.initialized ||
              (await this.cleanup(),
              this.registerRelayerEvents(),
              this.registerExpirerEvents(),
              this.registerPairingEvents(),
              await this.registerLinkModeListeners(),
              this.client.core.pairing.register({ methods: Object.keys(or) }),
              (this.initialized = !0),
              setTimeout(async () => {
                await this.processPendingMessageEvents(),
                  (this.sessionRequestQueue.queue =
                    this.getPendingSessionRequests()),
                  this.processSessionRequestQueue();
              }, z.toMiliseconds(this.requestQueueDelay)));
          }),
          K(this, "connect", async (r) => {
            this.isInitialized(), await this.confirmOnlineStateOrThrow();
            const i = Mr(lt({}, r), {
              requiredNamespaces: r.requiredNamespaces || {},
              optionalNamespaces: r.optionalNamespaces || {},
            });
            await this.isValidConnect(i);
            const {
              pairingTopic: s,
              requiredNamespaces: n,
              optionalNamespaces: o,
              sessionProperties: a,
              scopedProperties: c,
              relays: l,
            } = i;
            let u = s,
              h,
              d = !1;
            try {
              if (u) {
                const A = this.client.core.pairing.pairings.get(u);
                this.client.logger.warn(
                  "connect() with existing pairing topic is deprecated and will be removed in the next major release."
                ),
                  (d = A.active);
              }
            } catch (A) {
              throw (
                (this.client.logger.error(
                  `connect() -> pairing.get(${u}) failed`
                ),
                A)
              );
            }
            if (!u || !d) {
              const { topic: A, uri: P } =
                await this.client.core.pairing.create();
              (u = A), (h = P);
            }
            if (!u) {
              const { message: A } = Q(
                "NO_MATCHING_KEY",
                `connect() pairing topic: ${u}`
              );
              throw new Error(A);
            }
            const g = await this.client.core.crypto.generateKeyPair(),
              p = or.wc_sessionPropose.req.ttl || z.FIVE_MINUTES,
              w = Mt(p),
              f = Mr(
                lt(
                  lt(
                    {
                      requiredNamespaces: n,
                      optionalNamespaces: o,
                      relays: l ?? [{ protocol: ax }],
                      proposer: {
                        publicKey: g,
                        metadata: this.client.metadata,
                      },
                      expiryTimestamp: w,
                      pairingTopic: u,
                    },
                    a && { sessionProperties: a }
                  ),
                  c && { scopedProperties: c }
                ),
                { id: Yt() }
              ),
              m = Ke("session_connect", f.id),
              { reject: y, resolve: E, done: C } = pa(p, Wx),
              O = ({ id: A }) => {
                A === f.id &&
                  (this.client.events.off("proposal_expire", O),
                  this.pendingSessions.delete(f.id),
                  this.events.emit(m, { error: { message: Wx, code: 0 } }));
              };
            return (
              this.client.events.on("proposal_expire", O),
              this.events.once(m, ({ error: A, session: P }) => {
                this.client.events.off("proposal_expire", O),
                  A ? y(A) : P && E(P);
              }),
              await this.sendRequest({
                topic: u,
                method: "wc_sessionPropose",
                params: f,
                throwOnFailedPublish: !0,
                clientRpcId: f.id,
              }),
              await this.setProposal(f.id, f),
              { uri: h, approval: C }
            );
          }),
          K(this, "pair", async (r) => {
            this.isInitialized(), await this.confirmOnlineStateOrThrow();
            try {
              return await this.client.core.pairing.pair(r);
            } catch (i) {
              throw (this.client.logger.error("pair() failed"), i);
            }
          }),
          K(this, "approve", async (r) => {
            var i, s, n;
            const o = this.client.core.eventClient.createEvent({
              properties: {
                topic: (i = r?.id) == null ? void 0 : i.toString(),
                trace: [ls.session_approve_started],
              },
            });
            try {
              this.isInitialized(), await this.confirmOnlineStateOrThrow();
            } catch (x) {
              throw (o.setError(va.no_internet_connection), x);
            }
            try {
              await this.isValidProposalId(r?.id);
            } catch (x) {
              throw (
                (this.client.logger.error(
                  `approve() -> proposal.get(${r?.id}) failed`
                ),
                o.setError(va.proposal_not_found),
                x)
              );
            }
            try {
              await this.isValidApprove(r);
            } catch (x) {
              throw (
                (this.client.logger.error(
                  "approve() -> isValidApprove() failed"
                ),
                o.setError(va.session_approve_namespace_validation_failure),
                x)
              );
            }
            const {
                id: a,
                relayProtocol: c,
                namespaces: l,
                sessionProperties: u,
                scopedProperties: h,
                sessionConfig: d,
              } = r,
              g = this.client.proposal.get(a);
            this.client.core.eventClient.deleteEvent({ eventId: o.eventId });
            const {
              pairingTopic: p,
              proposer: w,
              requiredNamespaces: f,
              optionalNamespaces: m,
            } = g;
            let y =
              (s = this.client.core.eventClient) == null
                ? void 0
                : s.getEvent({ topic: p });
            y ||
              (y =
                (n = this.client.core.eventClient) == null
                  ? void 0
                  : n.createEvent({
                      type: ls.session_approve_started,
                      properties: {
                        topic: p,
                        trace: [
                          ls.session_approve_started,
                          ls.session_namespaces_validation_success,
                        ],
                      },
                    }));
            const E = await this.client.core.crypto.generateKeyPair(),
              C = w.publicKey,
              O = await this.client.core.crypto.generateSharedKey(E, C),
              A = lt(
                lt(
                  lt(
                    {
                      relay: { protocol: c ?? "irn" },
                      namespaces: l,
                      controller: {
                        publicKey: E,
                        metadata: this.client.metadata,
                      },
                      expiry: Mt(_l),
                    },
                    u && { sessionProperties: u }
                  ),
                  h && { scopedProperties: h }
                ),
                d && { sessionConfig: d }
              ),
              P = wt.relay;
            y.addTrace(ls.subscribing_session_topic);
            try {
              await this.client.core.relayer.subscribe(O, { transportType: P });
            } catch (x) {
              throw (y.setError(va.subscribe_session_topic_failure), x);
            }
            y.addTrace(ls.subscribe_session_topic_success);
            const N = Mr(lt({}, A), {
              topic: O,
              requiredNamespaces: f,
              optionalNamespaces: m,
              pairingTopic: p,
              acknowledged: !1,
              self: A.controller,
              peer: { publicKey: w.publicKey, metadata: w.metadata },
              controller: E,
              transportType: wt.relay,
            });
            await this.client.session.set(O, N), y.addTrace(ls.store_session);
            try {
              y.addTrace(ls.publishing_session_settle),
                await this.sendRequest({
                  topic: O,
                  method: "wc_sessionSettle",
                  params: A,
                  throwOnFailedPublish: !0,
                }).catch((x) => {
                  throw (y?.setError(va.session_settle_publish_failure), x);
                }),
                y.addTrace(ls.session_settle_publish_success),
                y.addTrace(ls.publishing_session_approve),
                await this.sendResult({
                  id: a,
                  topic: p,
                  result: {
                    relay: { protocol: c ?? "irn" },
                    responderPublicKey: E,
                  },
                  throwOnFailedPublish: !0,
                }).catch((x) => {
                  throw (y?.setError(va.session_approve_publish_failure), x);
                }),
                y.addTrace(ls.session_approve_publish_success);
            } catch (x) {
              throw (
                (this.client.logger.error(x),
                this.client.session.delete(O, tt("USER_DISCONNECTED")),
                await this.client.core.relayer.unsubscribe(O),
                x)
              );
            }
            return (
              this.client.core.eventClient.deleteEvent({ eventId: y.eventId }),
              await this.client.core.pairing.updateMetadata({
                topic: p,
                metadata: w.metadata,
              }),
              await this.client.proposal.delete(a, tt("USER_DISCONNECTED")),
              await this.client.core.pairing.activate({ topic: p }),
              await this.setExpiry(O, Mt(_l)),
              {
                topic: O,
                acknowledged: () => Promise.resolve(this.client.session.get(O)),
              }
            );
          }),
          K(this, "reject", async (r) => {
            this.isInitialized(), await this.confirmOnlineStateOrThrow();
            try {
              await this.isValidReject(r);
            } catch (o) {
              throw (
                (this.client.logger.error("reject() -> isValidReject() failed"),
                o)
              );
            }
            const { id: i, reason: s } = r;
            let n;
            try {
              n = this.client.proposal.get(i).pairingTopic;
            } catch (o) {
              throw (
                (this.client.logger.error(
                  `reject() -> proposal.get(${i}) failed`
                ),
                o)
              );
            }
            n &&
              (await this.sendError({
                id: i,
                topic: n,
                error: s,
                rpcOpts: or.wc_sessionPropose.reject,
              }),
              await this.client.proposal.delete(i, tt("USER_DISCONNECTED")));
          }),
          K(this, "update", async (r) => {
            this.isInitialized(), await this.confirmOnlineStateOrThrow();
            try {
              await this.isValidUpdate(r);
            } catch (h) {
              throw (
                (this.client.logger.error("update() -> isValidUpdate() failed"),
                h)
              );
            }
            const { topic: i, namespaces: s } = r,
              { done: n, resolve: o, reject: a } = pa(),
              c = Yt(),
              l = ui().toString(),
              u = this.client.session.get(i).namespaces;
            return (
              this.events.once(Ke("session_update", c), ({ error: h }) => {
                h ? a(h) : o();
              }),
              await this.client.session.update(i, { namespaces: s }),
              await this.sendRequest({
                topic: i,
                method: "wc_sessionUpdate",
                params: { namespaces: s },
                throwOnFailedPublish: !0,
                clientRpcId: c,
                relayRpcId: l,
              }).catch((h) => {
                this.client.logger.error(h),
                  this.client.session.update(i, { namespaces: u }),
                  a(h);
              }),
              { acknowledged: n }
            );
          }),
          K(this, "extend", async (r) => {
            this.isInitialized(), await this.confirmOnlineStateOrThrow();
            try {
              await this.isValidExtend(r);
            } catch (c) {
              throw (
                (this.client.logger.error("extend() -> isValidExtend() failed"),
                c)
              );
            }
            const { topic: i } = r,
              s = Yt(),
              { done: n, resolve: o, reject: a } = pa();
            return (
              this.events.once(Ke("session_extend", s), ({ error: c }) => {
                c ? a(c) : o();
              }),
              await this.setExpiry(i, Mt(_l)),
              this.sendRequest({
                topic: i,
                method: "wc_sessionExtend",
                params: {},
                clientRpcId: s,
                throwOnFailedPublish: !0,
              }).catch((c) => {
                a(c);
              }),
              { acknowledged: n }
            );
          }),
          K(this, "request", async (r) => {
            this.isInitialized();
            try {
              await this.isValidRequest(r);
            } catch (m) {
              throw (
                (this.client.logger.error(
                  "request() -> isValidRequest() failed"
                ),
                m)
              );
            }
            const {
                chainId: i,
                request: s,
                topic: n,
                expiry: o = or.wc_sessionRequest.req.ttl,
              } = r,
              a = this.client.session.get(n);
            a?.transportType === wt.relay &&
              (await this.confirmOnlineStateOrThrow());
            const c = Yt(),
              l = ui().toString(),
              {
                done: u,
                resolve: h,
                reject: d,
              } = pa(o, "Request expired. Please try again.");
            this.events.once(
              Ke("session_request", c),
              ({ error: m, result: y }) => {
                m ? d(m) : h(y);
              }
            );
            const g = "wc_sessionRequest",
              p = this.getAppLinkIfEnabled(a.peer.metadata, a.transportType);
            if (p)
              return (
                await this.sendRequest({
                  clientRpcId: c,
                  relayRpcId: l,
                  topic: n,
                  method: g,
                  params: {
                    request: Mr(lt({}, s), { expiryTimestamp: Mt(o) }),
                    chainId: i,
                  },
                  expiry: o,
                  throwOnFailedPublish: !0,
                  appLink: p,
                }).catch((m) => d(m)),
                this.client.events.emit("session_request_sent", {
                  topic: n,
                  request: s,
                  chainId: i,
                  id: c,
                }),
                await u()
              );
            const w = {
                request: Mr(lt({}, s), { expiryTimestamp: Mt(o) }),
                chainId: i,
              },
              f = this.shouldSetTVF(g, w);
            return await Promise.all([
              new Promise(async (m) => {
                await this.sendRequest(
                  lt(
                    {
                      clientRpcId: c,
                      relayRpcId: l,
                      topic: n,
                      method: g,
                      params: w,
                      expiry: o,
                      throwOnFailedPublish: !0,
                    },
                    f && { tvf: this.getTVFParams(c, w) }
                  )
                ).catch((y) => d(y)),
                  this.client.events.emit("session_request_sent", {
                    topic: n,
                    request: s,
                    chainId: i,
                    id: c,
                  }),
                  m();
              }),
              new Promise(async (m) => {
                var y;
                if (!((y = a.sessionConfig) != null && y.disableDeepLink)) {
                  const E = await xQ(this.client.core.storage, Vx);
                  await vQ({ id: c, topic: n, wcDeepLink: E });
                }
                m();
              }),
              u(),
            ]).then((m) => m[2]);
          }),
          K(this, "respond", async (r) => {
            this.isInitialized(), await this.isValidRespond(r);
            const { topic: i, response: s } = r,
              { id: n } = s,
              o = this.client.session.get(i);
            o.transportType === wt.relay &&
              (await this.confirmOnlineStateOrThrow());
            const a = this.getAppLinkIfEnabled(
              o.peer.metadata,
              o.transportType
            );
            Bt(s)
              ? await this.sendResult({
                  id: n,
                  topic: i,
                  result: s.result,
                  throwOnFailedPublish: !0,
                  appLink: a,
                })
              : Ct(s) &&
                (await this.sendError({
                  id: n,
                  topic: i,
                  error: s.error,
                  appLink: a,
                })),
              this.cleanupAfterResponse(r);
          }),
          K(this, "ping", async (r) => {
            this.isInitialized(), await this.confirmOnlineStateOrThrow();
            try {
              await this.isValidPing(r);
            } catch (s) {
              throw (
                (this.client.logger.error("ping() -> isValidPing() failed"), s)
              );
            }
            const { topic: i } = r;
            if (this.client.session.keys.includes(i)) {
              const s = Yt(),
                n = ui().toString(),
                { done: o, resolve: a, reject: c } = pa();
              this.events.once(Ke("session_ping", s), ({ error: l }) => {
                l ? c(l) : a();
              }),
                await Promise.all([
                  this.sendRequest({
                    topic: i,
                    method: "wc_sessionPing",
                    params: {},
                    throwOnFailedPublish: !0,
                    clientRpcId: s,
                    relayRpcId: n,
                  }),
                  o(),
                ]);
            } else
              this.client.core.pairing.pairings.keys.includes(i) &&
                (this.client.logger.warn(
                  "ping() on pairing topic is deprecated and will be removed in the next major release."
                ),
                await this.client.core.pairing.ping({ topic: i }));
          }),
          K(this, "emit", async (r) => {
            this.isInitialized(),
              await this.confirmOnlineStateOrThrow(),
              await this.isValidEmit(r);
            const { topic: i, event: s, chainId: n } = r,
              o = ui().toString(),
              a = Yt();
            await this.sendRequest({
              topic: i,
              method: "wc_sessionEvent",
              params: { event: s, chainId: n },
              throwOnFailedPublish: !0,
              relayRpcId: o,
              clientRpcId: a,
            });
          }),
          K(this, "disconnect", async (r) => {
            this.isInitialized(),
              await this.confirmOnlineStateOrThrow(),
              await this.isValidDisconnect(r);
            const { topic: i } = r;
            if (this.client.session.keys.includes(i))
              await this.sendRequest({
                topic: i,
                method: "wc_sessionDelete",
                params: tt("USER_DISCONNECTED"),
                throwOnFailedPublish: !0,
              }),
                await this.deleteSession({ topic: i, emitEvent: !1 });
            else if (this.client.core.pairing.pairings.keys.includes(i))
              await this.client.core.pairing.disconnect({ topic: i });
            else {
              const { message: s } = Q(
                "MISMATCHED_TOPIC",
                `Session or pairing topic not found: ${i}`
              );
              throw new Error(s);
            }
          }),
          K(
            this,
            "find",
            (r) => (
              this.isInitialized(),
              this.client.session.getAll().filter((i) => ire(i, r))
            )
          ),
          K(this, "getPendingSessionRequests", () =>
            this.client.pendingRequest.getAll()
          ),
          K(this, "authenticate", async (r, i) => {
            var s;
            this.isInitialized(), this.isValidAuthenticate(r);
            const n =
                i &&
                this.client.core.linkModeSupportedApps.includes(i) &&
                ((s = this.client.metadata.redirect) == null
                  ? void 0
                  : s.linkMode),
              o = n ? wt.link_mode : wt.relay;
            o === wt.relay && (await this.confirmOnlineStateOrThrow());
            const {
                chains: a,
                statement: c = "",
                uri: l,
                domain: u,
                nonce: h,
                type: d,
                exp: g,
                nbf: p,
                methods: w = [],
                expiry: f,
              } = r,
              m = [...(r.resources || [])],
              { topic: y, uri: E } = await this.client.core.pairing.create({
                methods: ["wc_sessionAuthenticate"],
                transportType: o,
              });
            this.client.logger.info({
              message: "Generated new pairing",
              pairing: { topic: y, uri: E },
            });
            const C = await this.client.core.crypto.generateKeyPair(),
              O = jf(C);
            if (
              (await Promise.all([
                this.client.auth.authKeys.set(Zf, {
                  responseTopic: O,
                  publicKey: C,
                }),
                this.client.auth.pairingTopics.set(O, {
                  topic: O,
                  pairingTopic: y,
                }),
              ]),
              await this.client.core.relayer.subscribe(O, { transportType: o }),
              this.client.logger.info(
                `sending request to new pairing topic: ${y}`
              ),
              w.length > 0)
            ) {
              const { namespace: _ } = ul(a[0]);
              let R = fee(_, "request", w);
              kf(m) && (R = wee(R, m.pop())), m.push(R);
            }
            const A =
                f && f > or.wc_sessionAuthenticate.req.ttl
                  ? f
                  : or.wc_sessionAuthenticate.req.ttl,
              P = {
                authPayload: {
                  type: d ?? "caip122",
                  chains: a,
                  statement: c,
                  aud: l,
                  domain: u,
                  version: "1",
                  nonce: h,
                  iat: new Date().toISOString(),
                  exp: g,
                  nbf: p,
                  resources: m,
                },
                requester: { publicKey: C, metadata: this.client.metadata },
                expiryTimestamp: Mt(A),
              },
              N = {
                eip155: {
                  chains: a,
                  methods: [...new Set(["personal_sign", ...w])],
                  events: ["chainChanged", "accountsChanged"],
                },
              },
              x = {
                requiredNamespaces: {},
                optionalNamespaces: N,
                relays: [{ protocol: "irn" }],
                pairingTopic: y,
                proposer: { publicKey: C, metadata: this.client.metadata },
                expiryTimestamp: Mt(or.wc_sessionPropose.req.ttl),
                id: Yt(),
              },
              { done: $, resolve: k, reject: F } = pa(A, "Request expired"),
              j = Yt(),
              I = Ke("session_connect", x.id),
              b = Ke("session_request", j),
              v = async ({ error: _, session: R }) => {
                this.events.off(b, S), _ ? F(_) : R && k({ session: R });
              },
              S = async (_) => {
                var R, U, D;
                if (
                  (await this.deletePendingAuthRequest(j, {
                    message: "fulfilled",
                    code: 0,
                  }),
                  _.error)
                ) {
                  const te = tt(
                    "WC_METHOD_UNSUPPORTED",
                    "wc_sessionAuthenticate"
                  );
                  return _.error.code === te.code
                    ? void 0
                    : (this.events.off(I, v), F(_.error.message));
                }
                await this.deleteProposal(x.id), this.events.off(I, v);
                const { cacaos: H, responder: q } = _.result,
                  V = [],
                  Y = [];
                for (const te of H) {
                  (await e7({
                    cacao: te,
                    projectId: this.client.core.projectId,
                  })) ||
                    (this.client.logger.error(
                      te,
                      "Signature verification failed"
                    ),
                    F(
                      tt(
                        "SESSION_SETTLEMENT_FAILED",
                        "Signature verification failed"
                      )
                    ));
                  const { p: ve } = te,
                    Ee = kf(ve.resources),
                    Ce = [Zm(ve.iss)],
                    Ie = Tf(ve.iss);
                  if (Ee) {
                    const mt = i7(Ee),
                      Ir = s7(Ee);
                    V.push(...mt), Ce.push(...Ir);
                  }
                  for (const mt of Ce) Y.push(`${mt}:${Ie}`);
                }
                const ae = await this.client.core.crypto.generateSharedKey(
                  C,
                  q.publicKey
                );
                let re;
                V.length > 0 &&
                  ((re = {
                    topic: ae,
                    acknowledged: !0,
                    self: { publicKey: C, metadata: this.client.metadata },
                    peer: q,
                    controller: q.publicKey,
                    expiry: Mt(_l),
                    requiredNamespaces: {},
                    optionalNamespaces: {},
                    relay: { protocol: "irn" },
                    pairingTopic: y,
                    namespaces: Z7([...new Set(V)], [...new Set(Y)]),
                    transportType: o,
                  }),
                  await this.client.core.relayer.subscribe(ae, {
                    transportType: o,
                  }),
                  await this.client.session.set(ae, re),
                  y &&
                    (await this.client.core.pairing.updateMetadata({
                      topic: y,
                      metadata: q.metadata,
                    })),
                  (re = this.client.session.get(ae))),
                  (R = this.client.metadata.redirect) != null &&
                    R.linkMode &&
                    (U = q.metadata.redirect) != null &&
                    U.linkMode &&
                    (D = q.metadata.redirect) != null &&
                    D.universal &&
                    i &&
                    (this.client.core.addLinkModeSupportedApp(
                      q.metadata.redirect.universal
                    ),
                    this.client.session.update(ae, {
                      transportType: wt.link_mode,
                    })),
                  k({ auths: H, session: re });
              };
            this.events.once(I, v), this.events.once(b, S);
            let T;
            try {
              if (n) {
                const _ = kr("wc_sessionAuthenticate", P, j);
                this.client.core.history.set(y, _);
                const R = await this.client.core.crypto.encode("", _, {
                  type: Mh,
                  encoding: mo,
                });
                T = zf(i, y, R);
              } else
                await Promise.all([
                  this.sendRequest({
                    topic: y,
                    method: "wc_sessionAuthenticate",
                    params: P,
                    expiry: r.expiry,
                    throwOnFailedPublish: !0,
                    clientRpcId: j,
                  }),
                  this.sendRequest({
                    topic: y,
                    method: "wc_sessionPropose",
                    params: x,
                    expiry: or.wc_sessionPropose.req.ttl,
                    throwOnFailedPublish: !0,
                    clientRpcId: x.id,
                  }),
                ]);
            } catch (_) {
              throw (this.events.off(I, v), this.events.off(b, S), _);
            }
            return (
              await this.setProposal(x.id, x),
              await this.setAuthRequest(j, {
                request: Mr(lt({}, P), { verifyContext: {} }),
                pairingTopic: y,
                transportType: o,
              }),
              { uri: T ?? E, response: $ }
            );
          }),
          K(this, "approveSessionAuthenticate", async (r) => {
            const { id: i, auths: s } = r,
              n = this.client.core.eventClient.createEvent({
                properties: {
                  topic: i.toString(),
                  trace: [Ea.authenticated_session_approve_started],
                },
              });
            try {
              this.isInitialized();
            } catch (f) {
              throw (n.setError(Yh.no_internet_connection), f);
            }
            const o = this.getPendingAuthRequest(i);
            if (!o)
              throw (
                (n.setError(Yh.authenticated_session_pending_request_not_found),
                new Error(`Could not find pending auth request with id ${i}`))
              );
            const a = o.transportType || wt.relay;
            a === wt.relay && (await this.confirmOnlineStateOrThrow());
            const c = o.requester.publicKey,
              l = await this.client.core.crypto.generateKeyPair(),
              u = jf(c),
              h = { type: _n, receiverPublicKey: c, senderPublicKey: l },
              d = [],
              g = [];
            for (const f of s) {
              if (
                !(await e7({ cacao: f, projectId: this.client.core.projectId }))
              ) {
                n.setError(Yh.invalid_cacao);
                const O = tt(
                  "SESSION_SETTLEMENT_FAILED",
                  "Signature verification failed"
                );
                throw (
                  (await this.sendError({
                    id: i,
                    topic: u,
                    error: O,
                    encodeOpts: h,
                  }),
                  new Error(O.message))
                );
              }
              n.addTrace(Ea.cacaos_verified);
              const { p: m } = f,
                y = kf(m.resources),
                E = [Zm(m.iss)],
                C = Tf(m.iss);
              if (y) {
                const O = i7(y),
                  A = s7(y);
                d.push(...O), E.push(...A);
              }
              for (const O of E) g.push(`${O}:${C}`);
            }
            const p = await this.client.core.crypto.generateSharedKey(l, c);
            n.addTrace(Ea.create_authenticated_session_topic);
            let w;
            if (d?.length > 0) {
              (w = {
                topic: p,
                acknowledged: !0,
                self: { publicKey: l, metadata: this.client.metadata },
                peer: { publicKey: c, metadata: o.requester.metadata },
                controller: c,
                expiry: Mt(_l),
                authentication: s,
                requiredNamespaces: {},
                optionalNamespaces: {},
                relay: { protocol: "irn" },
                pairingTopic: o.pairingTopic,
                namespaces: Z7([...new Set(d)], [...new Set(g)]),
                transportType: a,
              }),
                n.addTrace(Ea.subscribing_authenticated_session_topic);
              try {
                await this.client.core.relayer.subscribe(p, {
                  transportType: a,
                });
              } catch (f) {
                throw (
                  (n.setError(Yh.subscribe_authenticated_session_topic_failure),
                  f)
                );
              }
              n.addTrace(Ea.subscribe_authenticated_session_topic_success),
                await this.client.session.set(p, w),
                n.addTrace(Ea.store_authenticated_session),
                await this.client.core.pairing.updateMetadata({
                  topic: o.pairingTopic,
                  metadata: o.requester.metadata,
                });
            }
            n.addTrace(Ea.publishing_authenticated_session_approve);
            try {
              await this.sendResult({
                topic: u,
                id: i,
                result: {
                  cacaos: s,
                  responder: { publicKey: l, metadata: this.client.metadata },
                },
                encodeOpts: h,
                throwOnFailedPublish: !0,
                appLink: this.getAppLinkIfEnabled(o.requester.metadata, a),
              });
            } catch (f) {
              throw (
                (n.setError(Yh.authenticated_session_approve_publish_failure),
                f)
              );
            }
            return (
              await this.client.auth.requests.delete(i, {
                message: "fulfilled",
                code: 0,
              }),
              await this.client.core.pairing.activate({
                topic: o.pairingTopic,
              }),
              this.client.core.eventClient.deleteEvent({ eventId: n.eventId }),
              { session: w }
            );
          }),
          K(this, "rejectSessionAuthenticate", async (r) => {
            this.isInitialized();
            const { id: i, reason: s } = r,
              n = this.getPendingAuthRequest(i);
            if (!n)
              throw new Error(
                `Could not find pending auth request with id ${i}`
              );
            n.transportType === wt.relay &&
              (await this.confirmOnlineStateOrThrow());
            const o = n.requester.publicKey,
              a = await this.client.core.crypto.generateKeyPair(),
              c = jf(o),
              l = { type: _n, receiverPublicKey: o, senderPublicKey: a };
            await this.sendError({
              id: i,
              topic: c,
              error: s,
              encodeOpts: l,
              rpcOpts: or.wc_sessionAuthenticate.reject,
              appLink: this.getAppLinkIfEnabled(
                n.requester.metadata,
                n.transportType
              ),
            }),
              await this.client.auth.requests.delete(i, {
                message: "rejected",
                code: 0,
              }),
              await this.client.proposal.delete(i, tt("USER_DISCONNECTED"));
          }),
          K(this, "formatAuthMessage", (r) => {
            this.isInitialized();
            const { request: i, iss: s } = r;
            return t7(i, s);
          }),
          K(this, "processRelayMessageCache", () => {
            setTimeout(async () => {
              if (this.relayMessageCache.length !== 0)
                for (; this.relayMessageCache.length > 0; )
                  try {
                    const r = this.relayMessageCache.shift();
                    r && (await this.onRelayMessage(r));
                  } catch (r) {
                    this.client.logger.error(r);
                  }
            }, 50);
          }),
          K(this, "cleanupDuplicatePairings", async (r) => {
            if (r.pairingTopic)
              try {
                const i = this.client.core.pairing.pairings.get(r.pairingTopic),
                  s = this.client.core.pairing.pairings.getAll().filter((n) => {
                    var o, a;
                    return (
                      ((o = n.peerMetadata) == null ? void 0 : o.url) &&
                      ((a = n.peerMetadata) == null ? void 0 : a.url) ===
                        r.peer.metadata.url &&
                      n.topic &&
                      n.topic !== i.topic
                    );
                  });
                if (s.length === 0) return;
                this.client.logger.info(
                  `Cleaning up ${s.length} duplicate pairing(s)`
                ),
                  await Promise.all(
                    s.map((n) =>
                      this.client.core.pairing.disconnect({ topic: n.topic })
                    )
                  ),
                  this.client.logger.info(
                    "Duplicate pairings clean up finished"
                  );
              } catch (i) {
                this.client.logger.error(i);
              }
          }),
          K(this, "deleteSession", async (r) => {
            var i;
            const {
                topic: s,
                expirerHasDeleted: n = !1,
                emitEvent: o = !0,
                id: a = 0,
              } = r,
              { self: c } = this.client.session.get(s);
            await this.client.core.relayer.unsubscribe(s),
              await this.client.session.delete(s, tt("USER_DISCONNECTED")),
              this.addToRecentlyDeleted(s, "session"),
              this.client.core.crypto.keychain.has(c.publicKey) &&
                (await this.client.core.crypto.deleteKeyPair(c.publicKey)),
              this.client.core.crypto.keychain.has(s) &&
                (await this.client.core.crypto.deleteSymKey(s)),
              n || this.client.core.expirer.del(s),
              this.client.core.storage
                .removeItem(Vx)
                .catch((l) => this.client.logger.warn(l)),
              this.getPendingSessionRequests().forEach((l) => {
                l.topic === s &&
                  this.deletePendingSessionRequest(
                    l.id,
                    tt("USER_DISCONNECTED")
                  );
              }),
              s ===
                ((i = this.sessionRequestQueue.queue[0]) == null
                  ? void 0
                  : i.topic) && (this.sessionRequestQueue.state = Fs.idle),
              o &&
                this.client.events.emit("session_delete", { id: a, topic: s });
          }),
          K(this, "deleteProposal", async (r, i) => {
            if (i)
              try {
                const s = this.client.proposal.get(r);
                this.client.core.eventClient
                  .getEvent({ topic: s.pairingTopic })
                  ?.setError(va.proposal_expired);
              } catch {}
            await Promise.all([
              this.client.proposal.delete(r, tt("USER_DISCONNECTED")),
              i ? Promise.resolve() : this.client.core.expirer.del(r),
            ]),
              this.addToRecentlyDeleted(r, "proposal");
          }),
          K(this, "deletePendingSessionRequest", async (r, i, s = !1) => {
            await Promise.all([
              this.client.pendingRequest.delete(r, i),
              s ? Promise.resolve() : this.client.core.expirer.del(r),
            ]),
              this.addToRecentlyDeleted(r, "request"),
              (this.sessionRequestQueue.queue =
                this.sessionRequestQueue.queue.filter((n) => n.id !== r)),
              s &&
                ((this.sessionRequestQueue.state = Fs.idle),
                this.client.events.emit("session_request_expire", { id: r }));
          }),
          K(this, "deletePendingAuthRequest", async (r, i, s = !1) => {
            await Promise.all([
              this.client.auth.requests.delete(r, i),
              s ? Promise.resolve() : this.client.core.expirer.del(r),
            ]);
          }),
          K(this, "setExpiry", async (r, i) => {
            this.client.session.keys.includes(r) &&
              (this.client.core.expirer.set(r, i),
              await this.client.session.update(r, { expiry: i }));
          }),
          K(this, "setProposal", async (r, i) => {
            this.client.core.expirer.set(r, Mt(or.wc_sessionPropose.req.ttl)),
              await this.client.proposal.set(r, i);
          }),
          K(this, "setAuthRequest", async (r, i) => {
            const {
              request: s,
              pairingTopic: n,
              transportType: o = wt.relay,
            } = i;
            this.client.core.expirer.set(r, s.expiryTimestamp),
              await this.client.auth.requests.set(r, {
                authPayload: s.authPayload,
                requester: s.requester,
                expiryTimestamp: s.expiryTimestamp,
                id: r,
                pairingTopic: n,
                verifyContext: s.verifyContext,
                transportType: o,
              });
          }),
          K(this, "setPendingSessionRequest", async (r) => {
            const { id: i, topic: s, params: n, verifyContext: o } = r,
              a = n.request.expiryTimestamp || Mt(or.wc_sessionRequest.req.ttl);
            this.client.core.expirer.set(i, a),
              await this.client.pendingRequest.set(i, {
                id: i,
                topic: s,
                params: n,
                verifyContext: o,
              });
          }),
          K(this, "sendRequest", async (r) => {
            const {
                topic: i,
                method: s,
                params: n,
                expiry: o,
                relayRpcId: a,
                clientRpcId: c,
                throwOnFailedPublish: l,
                appLink: u,
                tvf: h,
              } = r,
              d = kr(s, n, c);
            let g;
            const p = !!u;
            try {
              const m = p ? mo : as;
              g = await this.client.core.crypto.encode(i, d, { encoding: m });
            } catch (m) {
              throw (
                (await this.cleanup(),
                this.client.logger.error(
                  `sendRequest() -> core.crypto.encode() for topic ${i} failed`
                ),
                m)
              );
            }
            let w;
            if (woe.includes(s)) {
              const m = Ts(JSON.stringify(d)),
                y = Ts(g);
              w = await this.client.core.verify.register({
                id: y,
                decryptedId: m,
              });
            }
            const f = or[s].req;
            if (
              ((f.attestation = w),
              o && (f.ttl = o),
              a && (f.id = a),
              this.client.core.history.set(i, d),
              p)
            ) {
              const m = zf(u, i, g);
              await globalThis.Linking.openURL(m, this.client.name);
            } else {
              const m = or[s].req;
              o && (m.ttl = o),
                a && (m.id = a),
                (m.tvf = Mr(lt({}, h), { correlationId: d.id })),
                l
                  ? ((m.internal = Mr(lt({}, m.internal), {
                      throwOnFailedPublish: !0,
                    })),
                    await this.client.core.relayer.publish(i, g, m))
                  : this.client.core.relayer
                      .publish(i, g, m)
                      .catch((y) => this.client.logger.error(y));
            }
            return d.id;
          }),
          K(this, "sendResult", async (r) => {
            const {
                id: i,
                topic: s,
                result: n,
                throwOnFailedPublish: o,
                encodeOpts: a,
                appLink: c,
              } = r,
              l = Jn(i, n);
            let u;
            const h = c && typeof globalThis?.Linking < "u";
            try {
              const p = h ? mo : as;
              u = await this.client.core.crypto.encode(
                s,
                l,
                Mr(lt({}, a || {}), { encoding: p })
              );
            } catch (p) {
              throw (
                (await this.cleanup(),
                this.client.logger.error(
                  `sendResult() -> core.crypto.encode() for topic ${s} failed`
                ),
                p)
              );
            }
            let d, g;
            try {
              d = await this.client.core.history.get(s, i);
              const p = d.request;
              try {
                this.shouldSetTVF(p.method, p.params) &&
                  (g = this.getTVFParams(i, p.params, n));
              } catch (w) {
                this.client.logger.warn(
                  "sendResult() -> getTVFParams() failed",
                  w
                );
              }
            } catch (p) {
              throw (
                (this.client.logger.error(
                  `sendResult() -> history.get(${s}, ${i}) failed`
                ),
                p)
              );
            }
            if (h) {
              const p = zf(c, s, u);
              await globalThis.Linking.openURL(p, this.client.name);
            } else {
              const p = d.request.method,
                w = or[p].res;
              (w.tvf = Mr(lt({}, g), { correlationId: i })),
                o
                  ? ((w.internal = Mr(lt({}, w.internal), {
                      throwOnFailedPublish: !0,
                    })),
                    await this.client.core.relayer.publish(s, u, w))
                  : this.client.core.relayer
                      .publish(s, u, w)
                      .catch((f) => this.client.logger.error(f));
            }
            await this.client.core.history.resolve(l);
          }),
          K(this, "sendError", async (r) => {
            const {
                id: i,
                topic: s,
                error: n,
                encodeOpts: o,
                rpcOpts: a,
                appLink: c,
              } = r,
              l = Ic(i, n);
            let u;
            const h = c && typeof globalThis?.Linking < "u";
            try {
              const g = h ? mo : as;
              u = await this.client.core.crypto.encode(
                s,
                l,
                Mr(lt({}, o || {}), { encoding: g })
              );
            } catch (g) {
              throw (
                (await this.cleanup(),
                this.client.logger.error(
                  `sendError() -> core.crypto.encode() for topic ${s} failed`
                ),
                g)
              );
            }
            let d;
            try {
              d = await this.client.core.history.get(s, i);
            } catch (g) {
              throw (
                (this.client.logger.error(
                  `sendError() -> history.get(${s}, ${i}) failed`
                ),
                g)
              );
            }
            if (h) {
              const g = zf(c, s, u);
              await globalThis.Linking.openURL(g, this.client.name);
            } else {
              const g = d.request.method,
                p = a || or[g].res;
              this.client.core.relayer.publish(s, u, p);
            }
            await this.client.core.history.resolve(l);
          }),
          K(this, "cleanup", async () => {
            const r = [],
              i = [];
            this.client.session.getAll().forEach((s) => {
              let n = !1;
              po(s.expiry) && (n = !0),
                this.client.core.crypto.keychain.has(s.topic) || (n = !0),
                n && r.push(s.topic);
            }),
              this.client.proposal.getAll().forEach((s) => {
                po(s.expiryTimestamp) && i.push(s.id);
              }),
              await Promise.all([
                ...r.map((s) => this.deleteSession({ topic: s })),
                ...i.map((s) => this.deleteProposal(s)),
              ]);
          }),
          K(this, "onProviderMessageEvent", async (r) => {
            !this.initialized || this.relayMessageCache.length > 0
              ? this.relayMessageCache.push(r)
              : await this.onRelayMessage(r);
          }),
          K(this, "onRelayEventRequest", async (r) => {
            this.requestQueue.queue.push(r), await this.processRequestsQueue();
          }),
          K(this, "processRequestsQueue", async () => {
            if (this.requestQueue.state === Fs.active) {
              this.client.logger.info(
                "Request queue already active, skipping..."
              );
              return;
            }
            for (
              this.client.logger.info(
                `Request queue starting with ${this.requestQueue.queue.length} requests`
              );
              this.requestQueue.queue.length > 0;

            ) {
              this.requestQueue.state = Fs.active;
              const r = this.requestQueue.queue.shift();
              if (r)
                try {
                  await this.processRequest(r);
                } catch (i) {
                  this.client.logger.warn(i);
                }
            }
            this.requestQueue.state = Fs.idle;
          }),
          K(this, "processRequest", async (r) => {
            const {
                topic: i,
                payload: s,
                attestation: n,
                transportType: o,
                encryptedId: a,
              } = r,
              c = s.method;
            if (
              !this.shouldIgnorePairingRequest({ topic: i, requestMethod: c })
            )
              switch (c) {
                case "wc_sessionPropose":
                  return await this.onSessionProposeRequest({
                    topic: i,
                    payload: s,
                    attestation: n,
                    encryptedId: a,
                  });
                case "wc_sessionSettle":
                  return await this.onSessionSettleRequest(i, s);
                case "wc_sessionUpdate":
                  return await this.onSessionUpdateRequest(i, s);
                case "wc_sessionExtend":
                  return await this.onSessionExtendRequest(i, s);
                case "wc_sessionPing":
                  return await this.onSessionPingRequest(i, s);
                case "wc_sessionDelete":
                  return await this.onSessionDeleteRequest(i, s);
                case "wc_sessionRequest":
                  return await this.onSessionRequest({
                    topic: i,
                    payload: s,
                    attestation: n,
                    encryptedId: a,
                    transportType: o,
                  });
                case "wc_sessionEvent":
                  return await this.onSessionEventRequest(i, s);
                case "wc_sessionAuthenticate":
                  return await this.onSessionAuthenticateRequest({
                    topic: i,
                    payload: s,
                    attestation: n,
                    encryptedId: a,
                    transportType: o,
                  });
                default:
                  return this.client.logger.info(
                    `Unsupported request method ${c}`
                  );
              }
          }),
          K(this, "onRelayEventResponse", async (r) => {
            const { topic: i, payload: s, transportType: n } = r,
              o = (await this.client.core.history.get(i, s.id)).request.method;
            switch (o) {
              case "wc_sessionPropose":
                return this.onSessionProposeResponse(i, s, n);
              case "wc_sessionSettle":
                return this.onSessionSettleResponse(i, s);
              case "wc_sessionUpdate":
                return this.onSessionUpdateResponse(i, s);
              case "wc_sessionExtend":
                return this.onSessionExtendResponse(i, s);
              case "wc_sessionPing":
                return this.onSessionPingResponse(i, s);
              case "wc_sessionRequest":
                return this.onSessionRequestResponse(i, s);
              case "wc_sessionAuthenticate":
                return this.onSessionAuthenticateResponse(i, s);
              default:
                return this.client.logger.info(
                  `Unsupported response method ${o}`
                );
            }
          }),
          K(this, "onRelayEventUnknownPayload", (r) => {
            const { topic: i } = r,
              { message: s } = Q(
                "MISSING_OR_INVALID",
                `Decoded payload on topic ${i} is not identifiable as a JSON-RPC request or a response.`
              );
            throw new Error(s);
          }),
          K(this, "shouldIgnorePairingRequest", (r) => {
            const { topic: i, requestMethod: s } = r,
              n = this.expectedPairingMethodMap.get(i);
            return !n || n.includes(s)
              ? !1
              : !!(
                  n.includes("wc_sessionAuthenticate") &&
                  this.client.events.listenerCount("session_authenticate") > 0
                );
          }),
          K(this, "onSessionProposeRequest", async (r) => {
            const { topic: i, payload: s, attestation: n, encryptedId: o } = r,
              { params: a, id: c } = s;
            try {
              const l = this.client.core.eventClient.getEvent({ topic: i });
              this.client.events.listenerCount("session_proposal") === 0 &&
                (console.warn("No listener for session_proposal event"),
                l?.setError(An.proposal_listener_not_found)),
                this.isValidConnect(lt({}, s.params));
              const u = a.expiryTimestamp || Mt(or.wc_sessionPropose.req.ttl),
                h = lt({ id: c, pairingTopic: i, expiryTimestamp: u }, a);
              await this.setProposal(c, h);
              const d = await this.getVerifyContext({
                attestationId: n,
                hash: Ts(JSON.stringify(s)),
                encryptedId: o,
                metadata: h.proposer.metadata,
              });
              l?.addTrace(Rs.emit_session_proposal),
                this.client.events.emit("session_proposal", {
                  id: c,
                  params: h,
                  verifyContext: d,
                });
            } catch (l) {
              await this.sendError({
                id: c,
                topic: i,
                error: l,
                rpcOpts: or.wc_sessionPropose.autoReject,
              }),
                this.client.logger.error(l);
            }
          }),
          K(this, "onSessionProposeResponse", async (r, i, s) => {
            const { id: n } = i;
            if (Bt(i)) {
              const { result: o } = i;
              this.client.logger.trace({
                type: "method",
                method: "onSessionProposeResponse",
                result: o,
              });
              const a = this.client.proposal.get(n);
              this.client.logger.trace({
                type: "method",
                method: "onSessionProposeResponse",
                proposal: a,
              });
              const c = a.proposer.publicKey;
              this.client.logger.trace({
                type: "method",
                method: "onSessionProposeResponse",
                selfPublicKey: c,
              });
              const l = o.responderPublicKey;
              this.client.logger.trace({
                type: "method",
                method: "onSessionProposeResponse",
                peerPublicKey: l,
              });
              const u = await this.client.core.crypto.generateSharedKey(c, l);
              this.pendingSessions.set(n, {
                sessionTopic: u,
                pairingTopic: r,
                proposalId: n,
                publicKey: c,
              });
              const h = await this.client.core.relayer.subscribe(u, {
                transportType: s,
              });
              this.client.logger.trace({
                type: "method",
                method: "onSessionProposeResponse",
                subscriptionId: h,
              }),
                await this.client.core.pairing.activate({ topic: r });
            } else if (Ct(i)) {
              await this.client.proposal.delete(n, tt("USER_DISCONNECTED"));
              const o = Ke("session_connect", n);
              if (this.events.listenerCount(o) === 0)
                throw new Error(`emitting ${o} without any listeners, 954`);
              this.events.emit(o, { error: i.error });
            }
          }),
          K(this, "onSessionSettleRequest", async (r, i) => {
            const { id: s, params: n } = i;
            try {
              this.isValidSessionSettleRequest(n);
              const {
                  relay: o,
                  controller: a,
                  expiry: c,
                  namespaces: l,
                  sessionProperties: u,
                  scopedProperties: h,
                  sessionConfig: d,
                } = i.params,
                g = [...this.pendingSessions.values()].find(
                  (f) => f.sessionTopic === r
                );
              if (!g)
                return this.client.logger.error(
                  `Pending session not found for topic ${r}`
                );
              const p = this.client.proposal.get(g.proposalId),
                w = Mr(
                  lt(
                    lt(
                      lt(
                        {
                          topic: r,
                          relay: o,
                          expiry: c,
                          namespaces: l,
                          acknowledged: !0,
                          pairingTopic: g.pairingTopic,
                          requiredNamespaces: p.requiredNamespaces,
                          optionalNamespaces: p.optionalNamespaces,
                          controller: a.publicKey,
                          self: {
                            publicKey: g.publicKey,
                            metadata: this.client.metadata,
                          },
                          peer: {
                            publicKey: a.publicKey,
                            metadata: a.metadata,
                          },
                        },
                        u && { sessionProperties: u }
                      ),
                      h && { scopedProperties: h }
                    ),
                    d && { sessionConfig: d }
                  ),
                  { transportType: wt.relay }
                );
              await this.client.session.set(w.topic, w),
                await this.setExpiry(w.topic, w.expiry),
                await this.client.core.pairing.updateMetadata({
                  topic: g.pairingTopic,
                  metadata: w.peer.metadata,
                }),
                this.client.events.emit("session_connect", { session: w }),
                this.events.emit(Ke("session_connect", g.proposalId), {
                  session: w,
                }),
                this.pendingSessions.delete(g.proposalId),
                this.deleteProposal(g.proposalId, !1),
                this.cleanupDuplicatePairings(w),
                await this.sendResult({
                  id: i.id,
                  topic: r,
                  result: !0,
                  throwOnFailedPublish: !0,
                });
            } catch (o) {
              await this.sendError({ id: s, topic: r, error: o }),
                this.client.logger.error(o);
            }
          }),
          K(this, "onSessionSettleResponse", async (r, i) => {
            const { id: s } = i;
            Bt(i)
              ? (await this.client.session.update(r, { acknowledged: !0 }),
                this.events.emit(Ke("session_approve", s), {}))
              : Ct(i) &&
                (await this.client.session.delete(r, tt("USER_DISCONNECTED")),
                this.events.emit(Ke("session_approve", s), { error: i.error }));
          }),
          K(this, "onSessionUpdateRequest", async (r, i) => {
            const { params: s, id: n } = i;
            try {
              const o = `${r}_session_update`,
                a = Kh.get(o);
              if (a && this.isRequestOutOfSync(a, n)) {
                this.client.logger.warn(
                  `Discarding out of sync request - ${n}`
                ),
                  this.sendError({
                    id: n,
                    topic: r,
                    error: tt("INVALID_UPDATE_REQUEST"),
                  });
                return;
              }
              this.isValidUpdate(lt({ topic: r }, s));
              try {
                Kh.set(o, n),
                  await this.client.session.update(r, {
                    namespaces: s.namespaces,
                  }),
                  await this.sendResult({
                    id: n,
                    topic: r,
                    result: !0,
                    throwOnFailedPublish: !0,
                  });
              } catch (c) {
                throw (Kh.delete(o), c);
              }
              this.client.events.emit("session_update", {
                id: n,
                topic: r,
                params: s,
              });
            } catch (o) {
              await this.sendError({ id: n, topic: r, error: o }),
                this.client.logger.error(o);
            }
          }),
          K(
            this,
            "isRequestOutOfSync",
            (r, i) => i.toString().slice(0, -3) < r.toString().slice(0, -3)
          ),
          K(this, "onSessionUpdateResponse", (r, i) => {
            const { id: s } = i,
              n = Ke("session_update", s);
            if (this.events.listenerCount(n) === 0)
              throw new Error(`emitting ${n} without any listeners`);
            Bt(i)
              ? this.events.emit(Ke("session_update", s), {})
              : Ct(i) &&
                this.events.emit(Ke("session_update", s), { error: i.error });
          }),
          K(this, "onSessionExtendRequest", async (r, i) => {
            const { id: s } = i;
            try {
              this.isValidExtend({ topic: r }),
                await this.setExpiry(r, Mt(_l)),
                await this.sendResult({
                  id: s,
                  topic: r,
                  result: !0,
                  throwOnFailedPublish: !0,
                }),
                this.client.events.emit("session_extend", { id: s, topic: r });
            } catch (n) {
              await this.sendError({ id: s, topic: r, error: n }),
                this.client.logger.error(n);
            }
          }),
          K(this, "onSessionExtendResponse", (r, i) => {
            const { id: s } = i,
              n = Ke("session_extend", s);
            if (this.events.listenerCount(n) === 0)
              throw new Error(`emitting ${n} without any listeners`);
            Bt(i)
              ? this.events.emit(Ke("session_extend", s), {})
              : Ct(i) &&
                this.events.emit(Ke("session_extend", s), { error: i.error });
          }),
          K(this, "onSessionPingRequest", async (r, i) => {
            const { id: s } = i;
            try {
              this.isValidPing({ topic: r }),
                await this.sendResult({
                  id: s,
                  topic: r,
                  result: !0,
                  throwOnFailedPublish: !0,
                }),
                this.client.events.emit("session_ping", { id: s, topic: r });
            } catch (n) {
              await this.sendError({ id: s, topic: r, error: n }),
                this.client.logger.error(n);
            }
          }),
          K(this, "onSessionPingResponse", (r, i) => {
            const { id: s } = i,
              n = Ke("session_ping", s);
            setTimeout(() => {
              if (this.events.listenerCount(n) === 0)
                throw new Error(`emitting ${n} without any listeners 2176`);
              Bt(i)
                ? this.events.emit(Ke("session_ping", s), {})
                : Ct(i) &&
                  this.events.emit(Ke("session_ping", s), { error: i.error });
            }, 500);
          }),
          K(this, "onSessionDeleteRequest", async (r, i) => {
            const { id: s } = i;
            try {
              this.isValidDisconnect({ topic: r, reason: i.params }),
                Promise.all([
                  new Promise((n) => {
                    this.client.core.relayer.once(sr.publish, async () => {
                      n(await this.deleteSession({ topic: r, id: s }));
                    });
                  }),
                  this.sendResult({
                    id: s,
                    topic: r,
                    result: !0,
                    throwOnFailedPublish: !0,
                  }),
                  this.cleanupPendingSentRequestsForTopic({
                    topic: r,
                    error: tt("USER_DISCONNECTED"),
                  }),
                ]).catch((n) => this.client.logger.error(n));
            } catch (n) {
              this.client.logger.error(n);
            }
          }),
          K(this, "onSessionRequest", async (r) => {
            var i, s, n;
            const {
                topic: o,
                payload: a,
                attestation: c,
                encryptedId: l,
                transportType: u,
              } = r,
              { id: h, params: d } = a;
            try {
              await this.isValidRequest(lt({ topic: o }, d));
              const g = this.client.session.get(o),
                p = await this.getVerifyContext({
                  attestationId: c,
                  hash: Ts(JSON.stringify(kr("wc_sessionRequest", d, h))),
                  encryptedId: l,
                  metadata: g.peer.metadata,
                  transportType: u,
                }),
                w = { id: h, topic: o, params: d, verifyContext: p };
              await this.setPendingSessionRequest(w),
                u === wt.link_mode &&
                  (i = g.peer.metadata.redirect) != null &&
                  i.universal &&
                  this.client.core.addLinkModeSupportedApp(
                    (s = g.peer.metadata.redirect) == null
                      ? void 0
                      : s.universal
                  ),
                (n = this.client.signConfig) != null && n.disableRequestQueue
                  ? this.emitSessionRequest(w)
                  : (this.addSessionRequestToSessionRequestQueue(w),
                    this.processSessionRequestQueue());
            } catch (g) {
              await this.sendError({ id: h, topic: o, error: g }),
                this.client.logger.error(g);
            }
          }),
          K(this, "onSessionRequestResponse", (r, i) => {
            const { id: s } = i,
              n = Ke("session_request", s);
            if (this.events.listenerCount(n) === 0)
              throw new Error(`emitting ${n} without any listeners`);
            Bt(i)
              ? this.events.emit(Ke("session_request", s), { result: i.result })
              : Ct(i) &&
                this.events.emit(Ke("session_request", s), { error: i.error });
          }),
          K(this, "onSessionEventRequest", async (r, i) => {
            const { id: s, params: n } = i;
            try {
              const o = `${r}_session_event_${n.event.name}`,
                a = Kh.get(o);
              if (a && this.isRequestOutOfSync(a, s)) {
                this.client.logger.info(
                  `Discarding out of sync request - ${s}`
                );
                return;
              }
              this.isValidEmit(lt({ topic: r }, n)),
                this.client.events.emit("session_event", {
                  id: s,
                  topic: r,
                  params: n,
                }),
                Kh.set(o, s);
            } catch (o) {
              await this.sendError({ id: s, topic: r, error: o }),
                this.client.logger.error(o);
            }
          }),
          K(this, "onSessionAuthenticateResponse", (r, i) => {
            const { id: s } = i;
            this.client.logger.trace({
              type: "method",
              method: "onSessionAuthenticateResponse",
              topic: r,
              payload: i,
            }),
              Bt(i)
                ? this.events.emit(Ke("session_request", s), {
                    result: i.result,
                  })
                : Ct(i) &&
                  this.events.emit(Ke("session_request", s), {
                    error: i.error,
                  });
          }),
          K(this, "onSessionAuthenticateRequest", async (r) => {
            var i;
            const {
              topic: s,
              payload: n,
              attestation: o,
              encryptedId: a,
              transportType: c,
            } = r;
            try {
              const {
                  requester: l,
                  authPayload: u,
                  expiryTimestamp: h,
                } = n.params,
                d = await this.getVerifyContext({
                  attestationId: o,
                  hash: Ts(JSON.stringify(n)),
                  encryptedId: a,
                  metadata: l.metadata,
                  transportType: c,
                }),
                g = {
                  requester: l,
                  pairingTopic: s,
                  id: n.id,
                  authPayload: u,
                  verifyContext: d,
                  expiryTimestamp: h,
                };
              await this.setAuthRequest(n.id, {
                request: g,
                pairingTopic: s,
                transportType: c,
              }),
                c === wt.link_mode &&
                  (i = l.metadata.redirect) != null &&
                  i.universal &&
                  this.client.core.addLinkModeSupportedApp(
                    l.metadata.redirect.universal
                  ),
                this.client.events.emit("session_authenticate", {
                  topic: s,
                  params: n.params,
                  id: n.id,
                  verifyContext: d,
                });
            } catch (l) {
              this.client.logger.error(l);
              const u = n.params.requester.publicKey,
                h = await this.client.core.crypto.generateKeyPair(),
                d = this.getAppLinkIfEnabled(n.params.requester.metadata, c),
                g = { type: _n, receiverPublicKey: u, senderPublicKey: h };
              await this.sendError({
                id: n.id,
                topic: s,
                error: l,
                encodeOpts: g,
                rpcOpts: or.wc_sessionAuthenticate.autoReject,
                appLink: d,
              });
            }
          }),
          K(this, "addSessionRequestToSessionRequestQueue", (r) => {
            this.sessionRequestQueue.queue.push(r);
          }),
          K(this, "cleanupAfterResponse", (r) => {
            this.deletePendingSessionRequest(r.response.id, {
              message: "fulfilled",
              code: 0,
            }),
              setTimeout(() => {
                (this.sessionRequestQueue.state = Fs.idle),
                  this.processSessionRequestQueue();
              }, z.toMiliseconds(this.requestQueueDelay));
          }),
          K(
            this,
            "cleanupPendingSentRequestsForTopic",
            ({ topic: r, error: i }) => {
              const s = this.client.core.history.pending;
              s.length > 0 &&
                s
                  .filter(
                    (n) =>
                      n.topic === r && n.request.method === "wc_sessionRequest"
                  )
                  .forEach((n) => {
                    const o = n.request.id,
                      a = Ke("session_request", o);
                    if (this.events.listenerCount(a) === 0)
                      throw new Error(`emitting ${a} without any listeners`);
                    this.events.emit(Ke("session_request", n.request.id), {
                      error: i,
                    });
                  });
            }
          ),
          K(this, "processSessionRequestQueue", () => {
            if (this.sessionRequestQueue.state === Fs.active) {
              this.client.logger.info(
                "session request queue is already active."
              );
              return;
            }
            const r = this.sessionRequestQueue.queue[0];
            if (!r) {
              this.client.logger.info("session request queue is empty.");
              return;
            }
            try {
              (this.sessionRequestQueue.state = Fs.active),
                this.emitSessionRequest(r);
            } catch (i) {
              this.client.logger.error(i);
            }
          }),
          K(this, "emitSessionRequest", (r) => {
            this.client.events.emit("session_request", r);
          }),
          K(this, "onPairingCreated", (r) => {
            if (
              (r.methods &&
                this.expectedPairingMethodMap.set(r.topic, r.methods),
              r.active)
            )
              return;
            const i = this.client.proposal
              .getAll()
              .find((s) => s.pairingTopic === r.topic);
            i &&
              this.onSessionProposeRequest({
                topic: r.topic,
                payload: kr(
                  "wc_sessionPropose",
                  Mr(lt({}, i), {
                    requiredNamespaces: i.requiredNamespaces,
                    optionalNamespaces: i.optionalNamespaces,
                    relays: i.relays,
                    proposer: i.proposer,
                    sessionProperties: i.sessionProperties,
                    scopedProperties: i.scopedProperties,
                  }),
                  i.id
                ),
              });
          }),
          K(this, "isValidConnect", async (r) => {
            if (!Qr(r)) {
              const { message: l } = Q(
                "MISSING_OR_INVALID",
                `connect() params: ${JSON.stringify(r)}`
              );
              throw new Error(l);
            }
            const {
              pairingTopic: i,
              requiredNamespaces: s,
              optionalNamespaces: n,
              sessionProperties: o,
              scopedProperties: a,
              relays: c,
            } = r;
            if ((yr(i) || (await this.isValidPairingTopic(i)), !gre(c, !0))) {
              const { message: l } = Q(
                "MISSING_OR_INVALID",
                `connect() relays: ${c}`
              );
              throw new Error(l);
            }
            if (
              (!yr(s) &&
                Wh(s) !== 0 &&
                this.validateNamespaces(s, "requiredNamespaces"),
              !yr(n) &&
                Wh(n) !== 0 &&
                this.validateNamespaces(n, "optionalNamespaces"),
              yr(o) || this.validateSessionProps(o, "sessionProperties"),
              !yr(a))
            ) {
              this.validateSessionProps(a, "scopedProperties");
              const l = Object.keys(s || {}).concat(Object.keys(n || {}));
              if (!Object.keys(a).every((u) => l.includes(u)))
                throw new Error(
                  `Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(
                    a
                  )}, required/optional namespaces: ${JSON.stringify(l)}`
                );
            }
          }),
          K(this, "validateNamespaces", (r, i) => {
            const s = fre(r, "connect()", i);
            if (s) throw new Error(s.message);
          }),
          K(this, "isValidApprove", async (r) => {
            if (!Qr(r))
              throw new Error(
                Q("MISSING_OR_INVALID", `approve() params: ${r}`).message
              );
            const {
              id: i,
              namespaces: s,
              relayProtocol: n,
              sessionProperties: o,
              scopedProperties: a,
            } = r;
            this.checkRecentlyDeleted(i), await this.isValidProposalId(i);
            const c = this.client.proposal.get(i),
              l = by(s, "approve()");
            if (l) throw new Error(l.message);
            const u = ex(c.requiredNamespaces, s, "approve()");
            if (u) throw new Error(u.message);
            if (!kt(n, !0)) {
              const { message: h } = Q(
                "MISSING_OR_INVALID",
                `approve() relayProtocol: ${n}`
              );
              throw new Error(h);
            }
            if (
              (yr(o) || this.validateSessionProps(o, "sessionProperties"),
              !yr(a))
            ) {
              this.validateSessionProps(a, "scopedProperties");
              const h = new Set(Object.keys(s));
              if (!Object.keys(a).every((d) => h.has(d)))
                throw new Error(
                  `Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(
                    a
                  )}, approved namespaces: ${Array.from(h).join(", ")}`
                );
            }
          }),
          K(this, "isValidReject", async (r) => {
            if (!Qr(r)) {
              const { message: n } = Q(
                "MISSING_OR_INVALID",
                `reject() params: ${r}`
              );
              throw new Error(n);
            }
            const { id: i, reason: s } = r;
            if (
              (this.checkRecentlyDeleted(i),
              await this.isValidProposalId(i),
              !mre(s))
            ) {
              const { message: n } = Q(
                "MISSING_OR_INVALID",
                `reject() reason: ${JSON.stringify(s)}`
              );
              throw new Error(n);
            }
          }),
          K(this, "isValidSessionSettleRequest", (r) => {
            if (!Qr(r)) {
              const { message: l } = Q(
                "MISSING_OR_INVALID",
                `onSessionSettleRequest() params: ${r}`
              );
              throw new Error(l);
            }
            const { relay: i, controller: s, namespaces: n, expiry: o } = r;
            if (!X7(i)) {
              const { message: l } = Q(
                "MISSING_OR_INVALID",
                "onSessionSettleRequest() relay protocol should be a string"
              );
              throw new Error(l);
            }
            const a = cre(s, "onSessionSettleRequest()");
            if (a) throw new Error(a.message);
            const c = by(n, "onSessionSettleRequest()");
            if (c) throw new Error(c.message);
            if (po(o)) {
              const { message: l } = Q("EXPIRED", "onSessionSettleRequest()");
              throw new Error(l);
            }
          }),
          K(this, "isValidUpdate", async (r) => {
            if (!Qr(r)) {
              const { message: c } = Q(
                "MISSING_OR_INVALID",
                `update() params: ${r}`
              );
              throw new Error(c);
            }
            const { topic: i, namespaces: s } = r;
            this.checkRecentlyDeleted(i), await this.isValidSessionTopic(i);
            const n = this.client.session.get(i),
              o = by(s, "update()");
            if (o) throw new Error(o.message);
            const a = ex(n.requiredNamespaces, s, "update()");
            if (a) throw new Error(a.message);
          }),
          K(this, "isValidExtend", async (r) => {
            if (!Qr(r)) {
              const { message: s } = Q(
                "MISSING_OR_INVALID",
                `extend() params: ${r}`
              );
              throw new Error(s);
            }
            const { topic: i } = r;
            this.checkRecentlyDeleted(i), await this.isValidSessionTopic(i);
          }),
          K(this, "isValidRequest", async (r) => {
            if (!Qr(r)) {
              const { message: c } = Q(
                "MISSING_OR_INVALID",
                `request() params: ${r}`
              );
              throw new Error(c);
            }
            const { topic: i, request: s, chainId: n, expiry: o } = r;
            this.checkRecentlyDeleted(i), await this.isValidSessionTopic(i);
            const { namespaces: a } = this.client.session.get(i);
            if (!Q7(a, n)) {
              const { message: c } = Q(
                "MISSING_OR_INVALID",
                `request() chainId: ${n}`
              );
              throw new Error(c);
            }
            if (!yre(s)) {
              const { message: c } = Q(
                "MISSING_OR_INVALID",
                `request() ${JSON.stringify(s)}`
              );
              throw new Error(c);
            }
            if (!Ere(a, n, s.method)) {
              const { message: c } = Q(
                "MISSING_OR_INVALID",
                `request() method: ${s.method}`
              );
              throw new Error(c);
            }
            if (o && !_re(o, Uy)) {
              const { message: c } = Q(
                "MISSING_OR_INVALID",
                `request() expiry: ${o}. Expiry must be a number (in seconds) between ${Uy.min} and ${Uy.max}`
              );
              throw new Error(c);
            }
          }),
          K(this, "isValidRespond", async (r) => {
            var i;
            if (!Qr(r)) {
              const { message: o } = Q(
                "MISSING_OR_INVALID",
                `respond() params: ${r}`
              );
              throw new Error(o);
            }
            const { topic: s, response: n } = r;
            try {
              await this.isValidSessionTopic(s);
            } catch (o) {
              throw (
                ((i = r?.response) != null &&
                  i.id &&
                  this.cleanupAfterResponse(r),
                o)
              );
            }
            if (!bre(n)) {
              const { message: o } = Q(
                "MISSING_OR_INVALID",
                `respond() response: ${JSON.stringify(n)}`
              );
              throw new Error(o);
            }
          }),
          K(this, "isValidPing", async (r) => {
            if (!Qr(r)) {
              const { message: s } = Q(
                "MISSING_OR_INVALID",
                `ping() params: ${r}`
              );
              throw new Error(s);
            }
            const { topic: i } = r;
            await this.isValidSessionOrPairingTopic(i);
          }),
          K(this, "isValidEmit", async (r) => {
            if (!Qr(r)) {
              const { message: a } = Q(
                "MISSING_OR_INVALID",
                `emit() params: ${r}`
              );
              throw new Error(a);
            }
            const { topic: i, event: s, chainId: n } = r;
            await this.isValidSessionTopic(i);
            const { namespaces: o } = this.client.session.get(i);
            if (!Q7(o, n)) {
              const { message: a } = Q(
                "MISSING_OR_INVALID",
                `emit() chainId: ${n}`
              );
              throw new Error(a);
            }
            if (!vre(s)) {
              const { message: a } = Q(
                "MISSING_OR_INVALID",
                `emit() event: ${JSON.stringify(s)}`
              );
              throw new Error(a);
            }
            if (!Cre(o, n, s.name)) {
              const { message: a } = Q(
                "MISSING_OR_INVALID",
                `emit() event: ${JSON.stringify(s)}`
              );
              throw new Error(a);
            }
          }),
          K(this, "isValidDisconnect", async (r) => {
            if (!Qr(r)) {
              const { message: s } = Q(
                "MISSING_OR_INVALID",
                `disconnect() params: ${r}`
              );
              throw new Error(s);
            }
            const { topic: i } = r;
            await this.isValidSessionOrPairingTopic(i);
          }),
          K(this, "isValidAuthenticate", (r) => {
            const { chains: i, uri: s, domain: n, nonce: o } = r;
            if (!Array.isArray(i) || i.length === 0)
              throw new Error(
                "chains is required and must be a non-empty array"
              );
            if (!kt(s, !1)) throw new Error("uri is required parameter");
            if (!kt(n, !1)) throw new Error("domain is required parameter");
            if (!kt(o, !1)) throw new Error("nonce is required parameter");
            if ([...new Set(i.map((c) => ul(c).namespace))].length > 1)
              throw new Error(
                "Multi-namespace requests are not supported. Please request single namespace only."
              );
            const { namespace: a } = ul(i[0]);
            if (a !== "eip155")
              throw new Error(
                "Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains."
              );
          }),
          K(this, "getVerifyContext", async (r) => {
            const {
                attestationId: i,
                hash: s,
                encryptedId: n,
                metadata: o,
                transportType: a,
              } = r,
              c = {
                verified: {
                  verifyUrl: o.verifyUrl || Zh,
                  validation: "UNKNOWN",
                  origin: o.url || "",
                },
              };
            try {
              if (a === wt.link_mode) {
                const u = this.getAppLinkIfEnabled(o, a);
                return (
                  (c.verified.validation =
                    u && new URL(u).origin === new URL(o.url).origin
                      ? "VALID"
                      : "INVALID"),
                  c
                );
              }
              const l = await this.client.core.verify.resolve({
                attestationId: i,
                hash: s,
                encryptedId: n,
                verifyUrl: o.verifyUrl,
              });
              l &&
                ((c.verified.origin = l.origin),
                (c.verified.isScam = l.isScam),
                (c.verified.validation =
                  l.origin === new URL(o.url).origin ? "VALID" : "INVALID"));
            } catch (l) {
              this.client.logger.warn(l);
            }
            return (
              this.client.logger.debug(`Verify context: ${JSON.stringify(c)}`),
              c
            );
          }),
          K(this, "validateSessionProps", (r, i) => {
            Object.values(r).forEach((s, n) => {
              if (s == null) {
                const { message: o } = Q(
                  "MISSING_OR_INVALID",
                  `${i} must contain an existing value for each key. Received: ${s} for key ${
                    Object.keys(r)[n]
                  }`
                );
                throw new Error(o);
              }
            });
          }),
          K(this, "getPendingAuthRequest", (r) => {
            const i = this.client.auth.requests.get(r);
            return typeof i == "object" ? i : void 0;
          }),
          K(this, "addToRecentlyDeleted", (r, i) => {
            if (
              (this.recentlyDeletedMap.set(r, i),
              this.recentlyDeletedMap.size >= this.recentlyDeletedLimit)
            ) {
              let s = 0;
              const n = this.recentlyDeletedLimit / 2;
              for (const o of this.recentlyDeletedMap.keys()) {
                if (s++ >= n) break;
                this.recentlyDeletedMap.delete(o);
              }
            }
          }),
          K(this, "checkRecentlyDeleted", (r) => {
            const i = this.recentlyDeletedMap.get(r);
            if (i) {
              const { message: s } = Q(
                "MISSING_OR_INVALID",
                `Record was recently deleted - ${i}: ${r}`
              );
              throw new Error(s);
            }
          }),
          K(this, "isLinkModeEnabled", (r, i) => {
            var s, n, o, a, c, l, u, h, d;
            return !r || i !== wt.link_mode
              ? !1
              : ((n =
                  (s = this.client.metadata) == null ? void 0 : s.redirect) ==
                null
                  ? void 0
                  : n.linkMode) === !0 &&
                  ((a =
                    (o = this.client.metadata) == null ? void 0 : o.redirect) ==
                  null
                    ? void 0
                    : a.universal) !== void 0 &&
                  ((l =
                    (c = this.client.metadata) == null ? void 0 : c.redirect) ==
                  null
                    ? void 0
                    : l.universal) !== "" &&
                  ((u = r?.redirect) == null ? void 0 : u.universal) !==
                    void 0 &&
                  ((h = r?.redirect) == null ? void 0 : h.universal) !== "" &&
                  ((d = r?.redirect) == null ? void 0 : d.linkMode) === !0 &&
                  this.client.core.linkModeSupportedApps.includes(
                    r.redirect.universal
                  ) &&
                  typeof globalThis?.Linking < "u";
          }),
          K(this, "getAppLinkIfEnabled", (r, i) => {
            var s;
            return this.isLinkModeEnabled(r, i)
              ? (s = r?.redirect) == null
                ? void 0
                : s.universal
              : void 0;
          }),
          K(this, "handleLinkModeMessage", ({ url: r }) => {
            if (!r || !r.includes("wc_ev") || !r.includes("topic")) return;
            const i = UC(r, "topic") || "",
              s = decodeURIComponent(UC(r, "wc_ev") || ""),
              n = this.client.session.keys.includes(i);
            n && this.client.session.update(i, { transportType: wt.link_mode }),
              this.client.core.dispatchEnvelope({
                topic: i,
                message: s,
                sessionExists: n,
              });
          }),
          K(this, "registerLinkModeListeners", async () => {
            var r;
            if (
              qm() ||
              (uo() &&
                (r = this.client.metadata.redirect) != null &&
                r.linkMode)
            ) {
              const i = globalThis?.Linking;
              if (typeof i < "u") {
                i.addEventListener(
                  "url",
                  this.handleLinkModeMessage,
                  this.client.name
                );
                const s = await i.getInitialURL();
                s &&
                  setTimeout(() => {
                    this.handleLinkModeMessage({ url: s });
                  }, 50);
              }
            }
          }),
          K(this, "shouldSetTVF", (r, i) => {
            if (!i || r !== "wc_sessionRequest") return !1;
            const { request: s } = i;
            return Object.keys(Kx).includes(s.method);
          }),
          K(this, "getTVFParams", (r, i, s) => {
            var n, o;
            try {
              const a = i.request.method,
                c = this.extractTxHashesFromResult(a, s);
              return Mr(
                lt(
                  { correlationId: r, rpcMethods: [a], chainId: i.chainId },
                  this.isValidContractData(i.request.params) && {
                    contractAddresses: [
                      (o = (n = i.request.params) == null ? void 0 : n[0]) ==
                      null
                        ? void 0
                        : o.to,
                    ],
                  }
                ),
                { txHashes: c }
              );
            } catch (a) {
              this.client.logger.warn("Error getting TVF params", a);
            }
            return {};
          }),
          K(this, "isValidContractData", (r) => {
            var i;
            if (!r) return !1;
            try {
              const s = r?.data || ((i = r?.[0]) == null ? void 0 : i.data);
              if (!s.startsWith("0x")) return !1;
              const n = s.slice(2);
              return /^[0-9a-fA-F]*$/.test(n) ? n.length % 2 === 0 : !1;
            } catch {}
            return !1;
          }),
          K(this, "extractTxHashesFromResult", (r, i) => {
            try {
              const s = Kx[r];
              if (typeof i == "string") return [i];
              const n = i[s.key];
              if (yo(n))
                return r === "solana_signAllTransactions"
                  ? n.map((o) => eee(o))
                  : n;
              if (typeof n == "string") return [n];
            } catch (s) {
              this.client.logger.warn(
                "Error extracting tx hashes from result",
                s
              );
            }
            return [];
          });
      }
      async processPendingMessageEvents() {
        try {
          const e = this.client.session.keys,
            r = this.client.core.relayer.messages.getWithoutAck(e);
          for (const [i, s] of Object.entries(r))
            for (const n of s)
              try {
                await this.onProviderMessageEvent({
                  topic: i,
                  message: n,
                  publishedAt: Date.now(),
                });
              } catch {
                this.client.logger.warn(
                  `Error processing pending message event for topic: ${i}, message: ${n}`
                );
              }
        } catch (e) {
          this.client.logger.warn("processPendingMessageEvents failed", e);
        }
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e } = Q("NOT_INITIALIZED", this.name);
          throw new Error(e);
        }
      }
      async confirmOnlineStateOrThrow() {
        await this.client.core.relayer.confirmOnlineStateOrThrow();
      }
      registerRelayerEvents() {
        this.client.core.relayer.on(sr.message, (e) => {
          this.onProviderMessageEvent(e);
        });
      }
      async onRelayMessage(e) {
        const { topic: r, message: i, attestation: s, transportType: n } = e,
          { publicKey: o } = this.client.auth.authKeys.keys.includes(Zf)
            ? this.client.auth.authKeys.get(Zf)
            : { responseTopic: void 0, publicKey: void 0 };
        try {
          const a = await this.client.core.crypto.decode(r, i, {
            receiverPublicKey: o,
            encoding: n === wt.link_mode ? mo : as,
          });
          _c(a)
            ? (this.client.core.history.set(r, a),
              await this.onRelayEventRequest({
                topic: r,
                payload: a,
                attestation: s,
                transportType: n,
                encryptedId: Ts(i),
              }))
            : qo(a)
            ? (await this.client.core.history.resolve(a),
              await this.onRelayEventResponse({
                topic: r,
                payload: a,
                transportType: n,
              }),
              this.client.core.history.delete(r, a.id))
            : await this.onRelayEventUnknownPayload({
                topic: r,
                payload: a,
                transportType: n,
              }),
            await this.client.core.relayer.messages.ack(r, i);
        } catch (a) {
          this.client.logger.error(a);
        }
      }
      registerExpirerEvents() {
        this.client.core.expirer.on(ji.expired, async (e) => {
          const { topic: r, id: i } = LC(e.target);
          if (i && this.client.pendingRequest.keys.includes(i))
            return await this.deletePendingSessionRequest(i, Q("EXPIRED"), !0);
          if (i && this.client.auth.requests.keys.includes(i))
            return await this.deletePendingAuthRequest(i, Q("EXPIRED"), !0);
          r
            ? this.client.session.keys.includes(r) &&
              (await this.deleteSession({ topic: r, expirerHasDeleted: !0 }),
              this.client.events.emit("session_expire", { topic: r }))
            : i &&
              (await this.deleteProposal(i, !0),
              this.client.events.emit("proposal_expire", { id: i }));
        });
      }
      registerPairingEvents() {
        this.client.core.pairing.events.on(ba.create, (e) =>
          this.onPairingCreated(e)
        ),
          this.client.core.pairing.events.on(ba.delete, (e) => {
            this.addToRecentlyDeleted(e.topic, "pairing");
          });
      }
      isValidPairingTopic(e) {
        if (!kt(e, !1)) {
          const { message: r } = Q(
            "MISSING_OR_INVALID",
            `pairing topic should be a string: ${e}`
          );
          throw new Error(r);
        }
        if (!this.client.core.pairing.pairings.keys.includes(e)) {
          const { message: r } = Q(
            "NO_MATCHING_KEY",
            `pairing topic doesn't exist: ${e}`
          );
          throw new Error(r);
        }
        if (po(this.client.core.pairing.pairings.get(e).expiry)) {
          const { message: r } = Q("EXPIRED", `pairing topic: ${e}`);
          throw new Error(r);
        }
      }
      async isValidSessionTopic(e) {
        if (!kt(e, !1)) {
          const { message: r } = Q(
            "MISSING_OR_INVALID",
            `session topic should be a string: ${e}`
          );
          throw new Error(r);
        }
        if (
          (this.checkRecentlyDeleted(e), !this.client.session.keys.includes(e))
        ) {
          const { message: r } = Q(
            "NO_MATCHING_KEY",
            `session topic doesn't exist: ${e}`
          );
          throw new Error(r);
        }
        if (po(this.client.session.get(e).expiry)) {
          await this.deleteSession({ topic: e });
          const { message: r } = Q("EXPIRED", `session topic: ${e}`);
          throw new Error(r);
        }
        if (!this.client.core.crypto.keychain.has(e)) {
          const { message: r } = Q(
            "MISSING_OR_INVALID",
            `session topic does not exist in keychain: ${e}`
          );
          throw (await this.deleteSession({ topic: e }), new Error(r));
        }
      }
      async isValidSessionOrPairingTopic(e) {
        if (
          (this.checkRecentlyDeleted(e), this.client.session.keys.includes(e))
        )
          await this.isValidSessionTopic(e);
        else if (this.client.core.pairing.pairings.keys.includes(e))
          this.isValidPairingTopic(e);
        else if (kt(e, !1)) {
          const { message: r } = Q(
            "NO_MATCHING_KEY",
            `session or pairing topic doesn't exist: ${e}`
          );
          throw new Error(r);
        } else {
          const { message: r } = Q(
            "MISSING_OR_INVALID",
            `session or pairing topic should be a string: ${e}`
          );
          throw new Error(r);
        }
      }
      async isValidProposalId(e) {
        if (!wre(e)) {
          const { message: r } = Q(
            "MISSING_OR_INVALID",
            `proposal id should be a number: ${e}`
          );
          throw new Error(r);
        }
        if (!this.client.proposal.keys.includes(e)) {
          const { message: r } = Q(
            "NO_MATCHING_KEY",
            `proposal id doesn't exist: ${e}`
          );
          throw new Error(r);
        }
        if (po(this.client.proposal.get(e).expiryTimestamp)) {
          await this.deleteProposal(e);
          const { message: r } = Q("EXPIRED", `proposal id: ${e}`);
          throw new Error(r);
        }
      }
    }
    class Poe extends Ca {
      constructor(e, r) {
        super(e, r, doe, By), (this.core = e), (this.logger = r);
      }
    }
    class Ooe extends Ca {
      constructor(e, r) {
        super(e, r, poe, By), (this.core = e), (this.logger = r);
      }
    }
    class Noe extends Ca {
      constructor(e, r) {
        super(e, r, goe, By, (i) => i.id), (this.core = e), (this.logger = r);
      }
    }
    class Toe extends Ca {
      constructor(e, r) {
        super(e, r, boe, Gf, () => Zf), (this.core = e), (this.logger = r);
      }
    }
    class koe extends Ca {
      constructor(e, r) {
        super(e, r, voe, Gf), (this.core = e), (this.logger = r);
      }
    }
    class Roe extends Ca {
      constructor(e, r) {
        super(e, r, Eoe, Gf, (i) => i.id), (this.core = e), (this.logger = r);
      }
    }
    var $oe = Object.defineProperty,
      Foe = (t, e, r) =>
        e in t
          ? $oe(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      jy = (t, e, r) => Foe(t, typeof e != "symbol" ? e + "" : e, r);
    class Boe {
      constructor(e, r) {
        (this.core = e),
          (this.logger = r),
          jy(this, "authKeys"),
          jy(this, "pairingTopics"),
          jy(this, "requests"),
          (this.authKeys = new Toe(this.core, this.logger)),
          (this.pairingTopics = new koe(this.core, this.logger)),
          (this.requests = new Roe(this.core, this.logger));
      }
      async init() {
        await this.authKeys.init(),
          await this.pairingTopics.init(),
          await this.requests.init();
      }
    }
    var Loe = Object.defineProperty,
      Uoe = (t, e, r) =>
        e in t
          ? Loe(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      ke = (t, e, r) => Uoe(t, typeof e != "symbol" ? e + "" : e, r);
    class My extends nX {
      constructor(e) {
        super(e),
          ke(this, "protocol", zx),
          ke(this, "version", qx),
          ke(this, "name", Ly.name),
          ke(this, "metadata"),
          ke(this, "core"),
          ke(this, "logger"),
          ke(this, "events", new rt.exports.EventEmitter()),
          ke(this, "engine"),
          ke(this, "session"),
          ke(this, "proposal"),
          ke(this, "pendingRequest"),
          ke(this, "auth"),
          ke(this, "signConfig"),
          ke(this, "on", (i, s) => this.events.on(i, s)),
          ke(this, "once", (i, s) => this.events.once(i, s)),
          ke(this, "off", (i, s) => this.events.off(i, s)),
          ke(this, "removeListener", (i, s) =>
            this.events.removeListener(i, s)
          ),
          ke(this, "removeAllListeners", (i) =>
            this.events.removeAllListeners(i)
          ),
          ke(this, "connect", async (i) => {
            try {
              return await this.engine.connect(i);
            } catch (s) {
              throw (this.logger.error(s.message), s);
            }
          }),
          ke(this, "pair", async (i) => {
            try {
              return await this.engine.pair(i);
            } catch (s) {
              throw (this.logger.error(s.message), s);
            }
          }),
          ke(this, "approve", async (i) => {
            try {
              return await this.engine.approve(i);
            } catch (s) {
              throw (this.logger.error(s.message), s);
            }
          }),
          ke(this, "reject", async (i) => {
            try {
              return await this.engine.reject(i);
            } catch (s) {
              throw (this.logger.error(s.message), s);
            }
          }),
          ke(this, "update", async (i) => {
            try {
              return await this.engine.update(i);
            } catch (s) {
              throw (this.logger.error(s.message), s);
            }
          }),
          ke(this, "extend", async (i) => {
            try {
              return await this.engine.extend(i);
            } catch (s) {
              throw (this.logger.error(s.message), s);
            }
          }),
          ke(this, "request", async (i) => {
            try {
              return await this.engine.request(i);
            } catch (s) {
              throw (this.logger.error(s.message), s);
            }
          }),
          ke(this, "respond", async (i) => {
            try {
              return await this.engine.respond(i);
            } catch (s) {
              throw (this.logger.error(s.message), s);
            }
          }),
          ke(this, "ping", async (i) => {
            try {
              return await this.engine.ping(i);
            } catch (s) {
              throw (this.logger.error(s.message), s);
            }
          }),
          ke(this, "emit", async (i) => {
            try {
              return await this.engine.emit(i);
            } catch (s) {
              throw (this.logger.error(s.message), s);
            }
          }),
          ke(this, "disconnect", async (i) => {
            try {
              return await this.engine.disconnect(i);
            } catch (s) {
              throw (this.logger.error(s.message), s);
            }
          }),
          ke(this, "find", (i) => {
            try {
              return this.engine.find(i);
            } catch (s) {
              throw (this.logger.error(s.message), s);
            }
          }),
          ke(this, "getPendingSessionRequests", () => {
            try {
              return this.engine.getPendingSessionRequests();
            } catch (i) {
              throw (this.logger.error(i.message), i);
            }
          }),
          ke(this, "authenticate", async (i, s) => {
            try {
              return await this.engine.authenticate(i, s);
            } catch (n) {
              throw (this.logger.error(n.message), n);
            }
          }),
          ke(this, "formatAuthMessage", (i) => {
            try {
              return this.engine.formatAuthMessage(i);
            } catch (s) {
              throw (this.logger.error(s.message), s);
            }
          }),
          ke(this, "approveSessionAuthenticate", async (i) => {
            try {
              return await this.engine.approveSessionAuthenticate(i);
            } catch (s) {
              throw (this.logger.error(s.message), s);
            }
          }),
          ke(this, "rejectSessionAuthenticate", async (i) => {
            try {
              return await this.engine.rejectSessionAuthenticate(i);
            } catch (s) {
              throw (this.logger.error(s.message), s);
            }
          }),
          (this.name = e?.name || Ly.name),
          (this.metadata = fQ(e?.metadata)),
          (this.signConfig = e?.signConfig);
        const r =
          typeof e?.logger < "u" && typeof e?.logger != "string"
            ? e.logger
            : li(tn({ level: e?.logger || Ly.logger }));
        (this.core = e?.core || new hoe(e)),
          (this.logger = Ve(r, this.name)),
          (this.session = new Ooe(this.core, this.logger)),
          (this.proposal = new Poe(this.core, this.logger)),
          (this.pendingRequest = new Noe(this.core, this.logger)),
          (this.engine = new Soe(this)),
          (this.auth = new Boe(this.core, this.logger));
      }
      static async init(e) {
        const r = new My(e);
        return await r.initialize(), r;
      }
      get context() {
        return it(this.logger);
      }
      get pairing() {
        return this.core.pairing.pairings;
      }
      async initialize() {
        this.logger.trace("Initialized");
        try {
          await this.core.start(),
            await this.session.init(),
            await this.proposal.init(),
            await this.pendingRequest.init(),
            await this.auth.init(),
            await this.engine.init(),
            this.logger.info("SignClient Initialization Success"),
            setTimeout(() => {
              this.engine.processRelayMessageCache();
            }, z.toMiliseconds(z.ONE_SECOND));
        } catch (e) {
          throw (
            (this.logger.info("SignClient Initialization Failure"),
            this.logger.error(e.message),
            e)
          );
        }
      }
    }
    const Zx = "error",
      Doe = "wss://relay.walletconnect.org",
      joe = "wc",
      Moe = "universal_provider",
      Yf = `${joe}@2:${Moe}:`,
      Yx = "https://rpc.walletconnect.org/v1/",
      Al = "generic",
      zoe = `${Yx}bundler`,
      Mi = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
    function qoe() {}
    function zy(t) {
      return t == null || (typeof t != "object" && typeof t != "function");
    }
    function qy(t) {
      return ArrayBuffer.isView(t) && !(t instanceof DataView);
    }
    function Hoe(t) {
      if (zy(t)) return t;
      if (
        Array.isArray(t) ||
        qy(t) ||
        t instanceof ArrayBuffer ||
        (typeof SharedArrayBuffer < "u" && t instanceof SharedArrayBuffer)
      )
        return t.slice(0);
      const e = Object.getPrototypeOf(t),
        r = e.constructor;
      if (t instanceof Date || t instanceof Map || t instanceof Set)
        return new r(t);
      if (t instanceof RegExp) {
        const i = new r(t);
        return (i.lastIndex = t.lastIndex), i;
      }
      if (t instanceof DataView) return new r(t.buffer.slice(0));
      if (t instanceof Error) {
        const i = new r(t.message);
        return (i.stack = t.stack), (i.name = t.name), (i.cause = t.cause), i;
      }
      if (typeof File < "u" && t instanceof File)
        return new r([t], t.name, {
          type: t.type,
          lastModified: t.lastModified,
        });
      if (typeof t == "object") {
        const i = Object.create(e);
        return Object.assign(i, t);
      }
      return t;
    }
    function Jx(t) {
      return typeof t == "object" && t !== null;
    }
    function Xx(t) {
      return Object.getOwnPropertySymbols(t).filter((e) =>
        Object.prototype.propertyIsEnumerable.call(t, e)
      );
    }
    function Qx(t) {
      return t == null
        ? t === void 0
          ? "[object Undefined]"
          : "[object Null]"
        : Object.prototype.toString.call(t);
    }
    const Voe = "[object RegExp]",
      eI = "[object String]",
      tI = "[object Number]",
      rI = "[object Boolean]",
      iI = "[object Arguments]",
      Woe = "[object Symbol]",
      Koe = "[object Date]",
      Goe = "[object Map]",
      Zoe = "[object Set]",
      Yoe = "[object Array]",
      Joe = "[object ArrayBuffer]",
      Xoe = "[object Object]",
      Qoe = "[object DataView]",
      eae = "[object Uint8Array]",
      tae = "[object Uint8ClampedArray]",
      rae = "[object Uint16Array]",
      iae = "[object Uint32Array]",
      sae = "[object Int8Array]",
      nae = "[object Int16Array]",
      oae = "[object Int32Array]",
      aae = "[object Float32Array]",
      cae = "[object Float64Array]";
    function lae(t, e) {
      return Sl(t, void 0, t, new Map(), e);
    }
    function Sl(t, e, r, i = new Map(), s = void 0) {
      const n = s?.(t, e, r, i);
      if (n != null) return n;
      if (zy(t)) return t;
      if (i.has(t)) return i.get(t);
      if (Array.isArray(t)) {
        const o = new Array(t.length);
        i.set(t, o);
        for (let a = 0; a < t.length; a++) o[a] = Sl(t[a], a, r, i, s);
        return (
          Object.hasOwn(t, "index") && (o.index = t.index),
          Object.hasOwn(t, "input") && (o.input = t.input),
          o
        );
      }
      if (t instanceof Date) return new Date(t.getTime());
      if (t instanceof RegExp) {
        const o = new RegExp(t.source, t.flags);
        return (o.lastIndex = t.lastIndex), o;
      }
      if (t instanceof Map) {
        const o = new Map();
        i.set(t, o);
        for (const [a, c] of t) o.set(a, Sl(c, a, r, i, s));
        return o;
      }
      if (t instanceof Set) {
        const o = new Set();
        i.set(t, o);
        for (const a of t) o.add(Sl(a, void 0, r, i, s));
        return o;
      }
      if (typeof Fe < "u" && Fe.isBuffer(t)) return t.subarray();
      if (qy(t)) {
        const o = new (Object.getPrototypeOf(t).constructor)(t.length);
        i.set(t, o);
        for (let a = 0; a < t.length; a++) o[a] = Sl(t[a], a, r, i, s);
        return o;
      }
      if (
        t instanceof ArrayBuffer ||
        (typeof SharedArrayBuffer < "u" && t instanceof SharedArrayBuffer)
      )
        return t.slice(0);
      if (t instanceof DataView) {
        const o = new DataView(t.buffer.slice(0), t.byteOffset, t.byteLength);
        return i.set(t, o), xa(o, t, r, i, s), o;
      }
      if (typeof File < "u" && t instanceof File) {
        const o = new File([t], t.name, { type: t.type });
        return i.set(t, o), xa(o, t, r, i, s), o;
      }
      if (t instanceof Blob) {
        const o = new Blob([t], { type: t.type });
        return i.set(t, o), xa(o, t, r, i, s), o;
      }
      if (t instanceof Error) {
        const o = new t.constructor();
        return (
          i.set(t, o),
          (o.message = t.message),
          (o.name = t.name),
          (o.stack = t.stack),
          (o.cause = t.cause),
          xa(o, t, r, i, s),
          o
        );
      }
      if (typeof t == "object" && uae(t)) {
        const o = Object.create(Object.getPrototypeOf(t));
        return i.set(t, o), xa(o, t, r, i, s), o;
      }
      return t;
    }
    function xa(t, e, r = t, i, s) {
      const n = [...Object.keys(e), ...Xx(e)];
      for (let o = 0; o < n.length; o++) {
        const a = n[o],
          c = Object.getOwnPropertyDescriptor(t, a);
        (c == null || c.writable) && (t[a] = Sl(e[a], a, r, i, s));
      }
    }
    function uae(t) {
      switch (Qx(t)) {
        case iI:
        case Yoe:
        case Joe:
        case Qoe:
        case rI:
        case Koe:
        case aae:
        case cae:
        case sae:
        case nae:
        case oae:
        case Goe:
        case tI:
        case Xoe:
        case Voe:
        case Zoe:
        case eI:
        case Woe:
        case eae:
        case tae:
        case rae:
        case iae:
          return !0;
        default:
          return !1;
      }
    }
    function hae(t, e) {
      return lae(t, (r, i, s, n) => {
        const o = e?.(r, i, s, n);
        if (o != null) return o;
        if (typeof t == "object")
          switch (Object.prototype.toString.call(t)) {
            case tI:
            case eI:
            case rI: {
              const a = new t.constructor(t?.valueOf());
              return xa(a, t), a;
            }
            case iI: {
              const a = {};
              return (
                xa(a, t),
                (a.length = t.length),
                (a[Symbol.iterator] = t[Symbol.iterator]),
                a
              );
            }
            default:
              return;
          }
      });
    }
    function sI(t) {
      return hae(t);
    }
    function nI(t) {
      return (
        t !== null && typeof t == "object" && Qx(t) === "[object Arguments]"
      );
    }
    function dae(t) {
      return qy(t);
    }
    function pae(t) {
      if (typeof t != "object" || t == null) return !1;
      if (Object.getPrototypeOf(t) === null) return !0;
      if (Object.prototype.toString.call(t) !== "[object Object]") {
        const r = t[Symbol.toStringTag];
        return r == null ||
          !Object.getOwnPropertyDescriptor(t, Symbol.toStringTag)?.writable
          ? !1
          : t.toString() === `[object ${r}]`;
      }
      let e = t;
      for (; Object.getPrototypeOf(e) !== null; ) e = Object.getPrototypeOf(e);
      return Object.getPrototypeOf(t) === e;
    }
    function fae(t, ...e) {
      const r = e.slice(0, -1),
        i = e[e.length - 1];
      let s = t;
      for (let n = 0; n < r.length; n++) {
        const o = r[n];
        s = Hy(s, o, i, new Map());
      }
      return s;
    }
    function Hy(t, e, r, i) {
      if ((zy(t) && (t = Object(t)), e == null || typeof e != "object"))
        return t;
      if (i.has(e)) return Hoe(i.get(e));
      if ((i.set(e, t), Array.isArray(e))) {
        e = e.slice();
        for (let n = 0; n < e.length; n++) e[n] = e[n] ?? void 0;
      }
      const s = [...Object.keys(e), ...Xx(e)];
      for (let n = 0; n < s.length; n++) {
        const o = s[n];
        let a = e[o],
          c = t[o];
        if (
          (nI(a) && (a = { ...a }),
          nI(c) && (c = { ...c }),
          typeof Fe < "u" && Fe.isBuffer(a) && (a = sI(a)),
          Array.isArray(a))
        )
          if (typeof c == "object" && c != null) {
            const u = [],
              h = Reflect.ownKeys(c);
            for (let d = 0; d < h.length; d++) {
              const g = h[d];
              u[g] = c[g];
            }
            c = u;
          } else c = [];
        const l = r(c, a, o, t, e, i);
        l != null
          ? (t[o] = l)
          : Array.isArray(a) || (Jx(c) && Jx(a))
          ? (t[o] = Hy(c, a, r, i))
          : c == null && pae(a)
          ? (t[o] = Hy({}, a, r, i))
          : c == null && dae(a)
          ? (t[o] = sI(a))
          : (c === void 0 || a !== void 0) && (t[o] = a);
      }
      return t;
    }
    function gae(t, ...e) {
      return fae(t, ...e, qoe);
    }
    var wae = Object.defineProperty,
      mae = Object.defineProperties,
      yae = Object.getOwnPropertyDescriptors,
      oI = Object.getOwnPropertySymbols,
      bae = Object.prototype.hasOwnProperty,
      vae = Object.prototype.propertyIsEnumerable,
      aI = (t, e, r) =>
        e in t
          ? wae(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Jf = (t, e) => {
        for (var r in e || (e = {})) bae.call(e, r) && aI(t, r, e[r]);
        if (oI) for (var r of oI(e)) vae.call(e, r) && aI(t, r, e[r]);
        return t;
      },
      Eae = (t, e) => mae(t, yae(e));
    function _i(t, e, r) {
      var i;
      const s = ul(t);
      return (
        ((i = e.rpcMap) == null ? void 0 : i[s.reference]) ||
        `${Yx}?chainId=${s.namespace}:${s.reference}&projectId=${r}`
      );
    }
    function Ia(t) {
      return t.includes(":") ? t.split(":")[1] : t;
    }
    function cI(t) {
      return t.map((e) => `${e.split(":")[0]}:${e.split(":")[1]}`);
    }
    function Cae(t, e) {
      const r = Object.keys(e.namespaces).filter((s) => s.includes(t));
      if (!r.length) return [];
      const i = [];
      return (
        r.forEach((s) => {
          const n = e.namespaces[s].accounts;
          i.push(...n);
        }),
        i
      );
    }
    function Vy(t = {}, e = {}) {
      const r = lI(t),
        i = lI(e);
      return gae(r, i);
    }
    function lI(t) {
      var e, r, i, s;
      const n = {};
      if (!Wh(t)) return n;
      for (const [o, a] of Object.entries(t)) {
        const c = my(o) ? [o] : a.chains,
          l = a.methods || [],
          u = a.events || [],
          h = a.rpcMap || {},
          d = Vh(o);
        n[d] = Eae(Jf(Jf({}, n[d]), a), {
          chains: Of(c, (e = n[d]) == null ? void 0 : e.chains),
          methods: Of(l, (r = n[d]) == null ? void 0 : r.methods),
          events: Of(u, (i = n[d]) == null ? void 0 : i.events),
          rpcMap: Jf(Jf({}, h), (s = n[d]) == null ? void 0 : s.rpcMap),
        });
      }
      return n;
    }
    function uI(t) {
      return t.includes(":") ? t.split(":")[2] : t;
    }
    function hI(t) {
      const e = {};
      for (const [r, i] of Object.entries(t)) {
        const s = i.methods || [],
          n = i.events || [],
          o = i.accounts || [],
          a = my(r) ? [r] : i.chains ? i.chains : cI(i.accounts);
        e[r] = { chains: a, methods: s, events: n, accounts: o };
      }
      return e;
    }
    function Wy(t) {
      return typeof t == "number"
        ? t
        : t.includes("0x")
        ? parseInt(t, 16)
        : ((t = t.includes(":") ? t.split(":")[1] : t),
          isNaN(Number(t)) ? t : Number(t));
    }
    const dI = {},
      ze = (t) => dI[t],
      Ky = (t, e) => {
        dI[t] = e;
      };
    var xae = Object.defineProperty,
      Iae = (t, e, r) =>
        e in t
          ? xae(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Pl = (t, e, r) => Iae(t, typeof e != "symbol" ? e + "" : e, r);
    class _ae {
      constructor(e) {
        Pl(this, "name", "polkadot"),
          Pl(this, "client"),
          Pl(this, "httpProviders"),
          Pl(this, "events"),
          Pl(this, "namespace"),
          Pl(this, "chainId"),
          (this.namespace = e.namespace),
          (this.events = ze("events")),
          (this.client = ze("client")),
          (this.chainId = this.getDefaultChain()),
          (this.httpProviders = this.createHttpProviders());
      }
      updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1];
      }
      request(e) {
        return this.namespace.methods.includes(e.request.method)
          ? this.client.request(e)
          : this.getHttpProvider().request(e.request);
      }
      setDefaultChain(e, r) {
        this.httpProviders[e] || this.setHttpProvider(e, r),
          (this.chainId = e),
          this.events.emit(Mi.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
      }
      getAccounts() {
        const e = this.namespace.accounts;
        return e
          ? e
              .filter((r) => r.split(":")[1] === this.chainId.toString())
              .map((r) => r.split(":")[2]) || []
          : [];
      }
      createHttpProviders() {
        const e = {};
        return (
          this.namespace.chains.forEach((r) => {
            var i;
            const s = Ia(r);
            e[s] = this.createHttpProvider(
              s,
              (i = this.namespace.rpcMap) == null ? void 0 : i[r]
            );
          }),
          e
        );
      }
      getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
          r = this.httpProviders[e];
        if (typeof r > "u")
          throw new Error(`JSON-RPC provider for ${e} not found`);
        return r;
      }
      setHttpProvider(e, r) {
        const i = this.createHttpProvider(e, r);
        i && (this.httpProviders[e] = i);
      }
      createHttpProvider(e, r) {
        const i = r || _i(e, this.namespace, this.client.core.projectId);
        if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new bt(new xt(i, ze("disableProviderPing")));
      }
    }
    var Aae = Object.defineProperty,
      Sae = Object.defineProperties,
      Pae = Object.getOwnPropertyDescriptors,
      pI = Object.getOwnPropertySymbols,
      Oae = Object.prototype.hasOwnProperty,
      Nae = Object.prototype.propertyIsEnumerable,
      Gy = (t, e, r) =>
        e in t
          ? Aae(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      fI = (t, e) => {
        for (var r in e || (e = {})) Oae.call(e, r) && Gy(t, r, e[r]);
        if (pI) for (var r of pI(e)) Nae.call(e, r) && Gy(t, r, e[r]);
        return t;
      },
      gI = (t, e) => Sae(t, Pae(e)),
      Ol = (t, e, r) => Gy(t, typeof e != "symbol" ? e + "" : e, r);
    class Tae {
      constructor(e) {
        Ol(this, "name", "eip155"),
          Ol(this, "client"),
          Ol(this, "chainId"),
          Ol(this, "namespace"),
          Ol(this, "httpProviders"),
          Ol(this, "events"),
          (this.namespace = e.namespace),
          (this.events = ze("events")),
          (this.client = ze("client")),
          (this.httpProviders = this.createHttpProviders()),
          (this.chainId = parseInt(this.getDefaultChain()));
      }
      async request(e) {
        switch (e.request.method) {
          case "eth_requestAccounts":
            return this.getAccounts();
          case "eth_accounts":
            return this.getAccounts();
          case "wallet_switchEthereumChain":
            return await this.handleSwitchChain(e);
          case "eth_chainId":
            return parseInt(this.getDefaultChain());
          case "wallet_getCapabilities":
            return await this.getCapabilities(e);
          case "wallet_getCallsStatus":
            return await this.getCallStatus(e);
        }
        return this.namespace.methods.includes(e.request.method)
          ? await this.client.request(e)
          : this.getHttpProvider().request(e.request);
      }
      updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e);
      }
      setDefaultChain(e, r) {
        this.httpProviders[e] || this.setHttpProvider(parseInt(e), r),
          (this.chainId = parseInt(e)),
          this.events.emit(Mi.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      getDefaultChain() {
        if (this.chainId) return this.chainId.toString();
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1];
      }
      createHttpProvider(e, r) {
        const i =
          r ||
          _i(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
        if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new bt(new xt(i, ze("disableProviderPing")));
      }
      setHttpProvider(e, r) {
        const i = this.createHttpProvider(e, r);
        i && (this.httpProviders[e] = i);
      }
      createHttpProviders() {
        const e = {};
        return (
          this.namespace.chains.forEach((r) => {
            var i;
            const s = parseInt(Ia(r));
            e[s] = this.createHttpProvider(
              s,
              (i = this.namespace.rpcMap) == null ? void 0 : i[r]
            );
          }),
          e
        );
      }
      getAccounts() {
        const e = this.namespace.accounts;
        return e
          ? [
              ...new Set(
                e
                  .filter((r) => r.split(":")[1] === this.chainId.toString())
                  .map((r) => r.split(":")[2])
              ),
            ]
          : [];
      }
      getHttpProvider() {
        const e = this.chainId,
          r = this.httpProviders[e];
        if (typeof r > "u")
          throw new Error(`JSON-RPC provider for ${e} not found`);
        return r;
      }
      async handleSwitchChain(e) {
        var r, i;
        let s = e.request.params
          ? (r = e.request.params[0]) == null
            ? void 0
            : r.chainId
          : "0x0";
        s = s.startsWith("0x") ? s : `0x${s}`;
        const n = parseInt(s, 16);
        if (this.isChainApproved(n)) this.setDefaultChain(`${n}`);
        else if (this.namespace.methods.includes("wallet_switchEthereumChain"))
          await this.client.request({
            topic: e.topic,
            request: { method: e.request.method, params: [{ chainId: s }] },
            chainId: (i = this.namespace.chains) == null ? void 0 : i[0],
          }),
            this.setDefaultChain(`${n}`);
        else
          throw new Error(
            `Failed to switch to chain 'eip155:${n}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`
          );
        return null;
      }
      isChainApproved(e) {
        return this.namespace.chains.includes(`${this.name}:${e}`);
      }
      async getCapabilities(e) {
        var r, i, s;
        const n =
          (i = (r = e.request) == null ? void 0 : r.params) == null
            ? void 0
            : i[0];
        if (!n)
          throw new Error(
            "Missing address parameter in `wallet_getCapabilities` request"
          );
        const o = this.client.session.get(e.topic),
          a =
            ((s = o?.sessionProperties) == null ? void 0 : s.capabilities) ||
            {};
        if (a != null && a[n]) return a?.[n];
        const c = await this.client.request(e);
        try {
          await this.client.session.update(e.topic, {
            sessionProperties: gI(fI({}, o.sessionProperties || {}), {
              capabilities: gI(fI({}, a || {}), { [n]: c }),
            }),
          });
        } catch (l) {
          console.warn("Failed to update session with capabilities", l);
        }
        return c;
      }
      async getCallStatus(e) {
        var r, i;
        const s = this.client.session.get(e.topic),
          n = (r = s.sessionProperties) == null ? void 0 : r.bundler_name;
        if (n) {
          const a = this.getBundlerUrl(e.chainId, n);
          try {
            return await this.getUserOperationReceipt(a, e);
          } catch (c) {
            console.warn("Failed to fetch call status from bundler", c, a);
          }
        }
        const o = (i = s.sessionProperties) == null ? void 0 : i.bundler_url;
        if (o)
          try {
            return await this.getUserOperationReceipt(o, e);
          } catch (a) {
            console.warn(
              "Failed to fetch call status from custom bundler",
              a,
              o
            );
          }
        if (this.namespace.methods.includes(e.request.method))
          return await this.client.request(e);
        throw new Error("Fetching call status not approved by the wallet.");
      }
      async getUserOperationReceipt(e, r) {
        var i;
        const s = new URL(e),
          n = await fetch(s, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(
              kr("eth_getUserOperationReceipt", [
                (i = r.request.params) == null ? void 0 : i[0],
              ])
            ),
          });
        if (!n.ok)
          throw new Error(
            `Failed to fetch user operation receipt - ${n.status}`
          );
        return await n.json();
      }
      getBundlerUrl(e, r) {
        return `${zoe}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${r}`;
      }
    }
    var kae = Object.defineProperty,
      Rae = (t, e, r) =>
        e in t
          ? kae(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Nl = (t, e, r) => Rae(t, typeof e != "symbol" ? e + "" : e, r);
    class $ae {
      constructor(e) {
        Nl(this, "name", "solana"),
          Nl(this, "client"),
          Nl(this, "httpProviders"),
          Nl(this, "events"),
          Nl(this, "namespace"),
          Nl(this, "chainId"),
          (this.namespace = e.namespace),
          (this.events = ze("events")),
          (this.client = ze("client")),
          (this.chainId = this.getDefaultChain()),
          (this.httpProviders = this.createHttpProviders());
      }
      updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      request(e) {
        return this.namespace.methods.includes(e.request.method)
          ? this.client.request(e)
          : this.getHttpProvider().request(e.request);
      }
      setDefaultChain(e, r) {
        this.httpProviders[e] || this.setHttpProvider(e, r),
          (this.chainId = e),
          this.events.emit(Mi.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
      }
      getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1];
      }
      getAccounts() {
        const e = this.namespace.accounts;
        return e
          ? [
              ...new Set(
                e
                  .filter((r) => r.split(":")[1] === this.chainId.toString())
                  .map((r) => r.split(":")[2])
              ),
            ]
          : [];
      }
      createHttpProviders() {
        const e = {};
        return (
          this.namespace.chains.forEach((r) => {
            var i;
            const s = Ia(r);
            e[s] = this.createHttpProvider(
              s,
              (i = this.namespace.rpcMap) == null ? void 0 : i[r]
            );
          }),
          e
        );
      }
      getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
          r = this.httpProviders[e];
        if (typeof r > "u")
          throw new Error(`JSON-RPC provider for ${e} not found`);
        return r;
      }
      setHttpProvider(e, r) {
        const i = this.createHttpProvider(e, r);
        i && (this.httpProviders[e] = i);
      }
      createHttpProvider(e, r) {
        const i = r || _i(e, this.namespace, this.client.core.projectId);
        if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new bt(new xt(i, ze("disableProviderPing")));
      }
    }
    var Fae = Object.defineProperty,
      Bae = (t, e, r) =>
        e in t
          ? Fae(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Tl = (t, e, r) => Bae(t, typeof e != "symbol" ? e + "" : e, r);
    class Lae {
      constructor(e) {
        Tl(this, "name", "cosmos"),
          Tl(this, "client"),
          Tl(this, "httpProviders"),
          Tl(this, "events"),
          Tl(this, "namespace"),
          Tl(this, "chainId"),
          (this.namespace = e.namespace),
          (this.events = ze("events")),
          (this.client = ze("client")),
          (this.chainId = this.getDefaultChain()),
          (this.httpProviders = this.createHttpProviders());
      }
      updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1];
      }
      request(e) {
        return this.namespace.methods.includes(e.request.method)
          ? this.client.request(e)
          : this.getHttpProvider().request(e.request);
      }
      setDefaultChain(e, r) {
        this.httpProviders[e] || this.setHttpProvider(e, r),
          (this.chainId = e),
          this.events.emit(
            Mi.DEFAULT_CHAIN_CHANGED,
            `${this.name}:${this.chainId}`
          );
      }
      getAccounts() {
        const e = this.namespace.accounts;
        return e
          ? [
              ...new Set(
                e
                  .filter((r) => r.split(":")[1] === this.chainId.toString())
                  .map((r) => r.split(":")[2])
              ),
            ]
          : [];
      }
      createHttpProviders() {
        const e = {};
        return (
          this.namespace.chains.forEach((r) => {
            var i;
            const s = Ia(r);
            e[s] = this.createHttpProvider(
              s,
              (i = this.namespace.rpcMap) == null ? void 0 : i[r]
            );
          }),
          e
        );
      }
      getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
          r = this.httpProviders[e];
        if (typeof r > "u")
          throw new Error(`JSON-RPC provider for ${e} not found`);
        return r;
      }
      setHttpProvider(e, r) {
        const i = this.createHttpProvider(e, r);
        i && (this.httpProviders[e] = i);
      }
      createHttpProvider(e, r) {
        const i = r || _i(e, this.namespace, this.client.core.projectId);
        if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new bt(new xt(i, ze("disableProviderPing")));
      }
    }
    var Uae = Object.defineProperty,
      Dae = (t, e, r) =>
        e in t
          ? Uae(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      kl = (t, e, r) => Dae(t, typeof e != "symbol" ? e + "" : e, r);
    class jae {
      constructor(e) {
        kl(this, "name", "algorand"),
          kl(this, "client"),
          kl(this, "httpProviders"),
          kl(this, "events"),
          kl(this, "namespace"),
          kl(this, "chainId"),
          (this.namespace = e.namespace),
          (this.events = ze("events")),
          (this.client = ze("client")),
          (this.chainId = this.getDefaultChain()),
          (this.httpProviders = this.createHttpProviders());
      }
      updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      request(e) {
        return this.namespace.methods.includes(e.request.method)
          ? this.client.request(e)
          : this.getHttpProvider().request(e.request);
      }
      setDefaultChain(e, r) {
        if (!this.httpProviders[e]) {
          const i =
            r ||
            _i(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
          if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);
          this.setHttpProvider(e, i);
        }
        (this.chainId = e),
          this.events.emit(
            Mi.DEFAULT_CHAIN_CHANGED,
            `${this.name}:${this.chainId}`
          );
      }
      getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1];
      }
      getAccounts() {
        const e = this.namespace.accounts;
        return e
          ? [
              ...new Set(
                e
                  .filter((r) => r.split(":")[1] === this.chainId.toString())
                  .map((r) => r.split(":")[2])
              ),
            ]
          : [];
      }
      createHttpProviders() {
        const e = {};
        return (
          this.namespace.chains.forEach((r) => {
            var i;
            e[r] = this.createHttpProvider(
              r,
              (i = this.namespace.rpcMap) == null ? void 0 : i[r]
            );
          }),
          e
        );
      }
      getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
          r = this.httpProviders[e];
        if (typeof r > "u")
          throw new Error(`JSON-RPC provider for ${e} not found`);
        return r;
      }
      setHttpProvider(e, r) {
        const i = this.createHttpProvider(e, r);
        i && (this.httpProviders[e] = i);
      }
      createHttpProvider(e, r) {
        const i = r || _i(e, this.namespace, this.client.core.projectId);
        return typeof i > "u"
          ? void 0
          : new bt(new xt(i, ze("disableProviderPing")));
      }
    }
    var Mae = Object.defineProperty,
      zae = (t, e, r) =>
        e in t
          ? Mae(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Rl = (t, e, r) => zae(t, typeof e != "symbol" ? e + "" : e, r);
    class qae {
      constructor(e) {
        Rl(this, "name", "cip34"),
          Rl(this, "client"),
          Rl(this, "httpProviders"),
          Rl(this, "events"),
          Rl(this, "namespace"),
          Rl(this, "chainId"),
          (this.namespace = e.namespace),
          (this.events = ze("events")),
          (this.client = ze("client")),
          (this.chainId = this.getDefaultChain()),
          (this.httpProviders = this.createHttpProviders());
      }
      updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1];
      }
      request(e) {
        return this.namespace.methods.includes(e.request.method)
          ? this.client.request(e)
          : this.getHttpProvider().request(e.request);
      }
      setDefaultChain(e, r) {
        this.httpProviders[e] || this.setHttpProvider(e, r),
          (this.chainId = e),
          this.events.emit(
            Mi.DEFAULT_CHAIN_CHANGED,
            `${this.name}:${this.chainId}`
          );
      }
      getAccounts() {
        const e = this.namespace.accounts;
        return e
          ? [
              ...new Set(
                e
                  .filter((r) => r.split(":")[1] === this.chainId.toString())
                  .map((r) => r.split(":")[2])
              ),
            ]
          : [];
      }
      createHttpProviders() {
        const e = {};
        return (
          this.namespace.chains.forEach((r) => {
            const i = this.getCardanoRPCUrl(r),
              s = Ia(r);
            e[s] = this.createHttpProvider(s, i);
          }),
          e
        );
      }
      getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
          r = this.httpProviders[e];
        if (typeof r > "u")
          throw new Error(`JSON-RPC provider for ${e} not found`);
        return r;
      }
      getCardanoRPCUrl(e) {
        const r = this.namespace.rpcMap;
        if (r) return r[e];
      }
      setHttpProvider(e, r) {
        const i = this.createHttpProvider(e, r);
        i && (this.httpProviders[e] = i);
      }
      createHttpProvider(e, r) {
        const i = r || this.getCardanoRPCUrl(e);
        if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new bt(new xt(i, ze("disableProviderPing")));
      }
    }
    var Hae = Object.defineProperty,
      Vae = (t, e, r) =>
        e in t
          ? Hae(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      $l = (t, e, r) => Vae(t, typeof e != "symbol" ? e + "" : e, r);
    class Wae {
      constructor(e) {
        $l(this, "name", "elrond"),
          $l(this, "client"),
          $l(this, "httpProviders"),
          $l(this, "events"),
          $l(this, "namespace"),
          $l(this, "chainId"),
          (this.namespace = e.namespace),
          (this.events = ze("events")),
          (this.client = ze("client")),
          (this.chainId = this.getDefaultChain()),
          (this.httpProviders = this.createHttpProviders());
      }
      updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      request(e) {
        return this.namespace.methods.includes(e.request.method)
          ? this.client.request(e)
          : this.getHttpProvider().request(e.request);
      }
      setDefaultChain(e, r) {
        this.httpProviders[e] || this.setHttpProvider(e, r),
          (this.chainId = e),
          this.events.emit(Mi.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
      }
      getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1];
      }
      getAccounts() {
        const e = this.namespace.accounts;
        return e
          ? [
              ...new Set(
                e
                  .filter((r) => r.split(":")[1] === this.chainId.toString())
                  .map((r) => r.split(":")[2])
              ),
            ]
          : [];
      }
      createHttpProviders() {
        const e = {};
        return (
          this.namespace.chains.forEach((r) => {
            var i;
            const s = Ia(r);
            e[s] = this.createHttpProvider(
              s,
              (i = this.namespace.rpcMap) == null ? void 0 : i[r]
            );
          }),
          e
        );
      }
      getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
          r = this.httpProviders[e];
        if (typeof r > "u")
          throw new Error(`JSON-RPC provider for ${e} not found`);
        return r;
      }
      setHttpProvider(e, r) {
        const i = this.createHttpProvider(e, r);
        i && (this.httpProviders[e] = i);
      }
      createHttpProvider(e, r) {
        const i = r || _i(e, this.namespace, this.client.core.projectId);
        if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new bt(new xt(i, ze("disableProviderPing")));
      }
    }
    var Kae = Object.defineProperty,
      Gae = (t, e, r) =>
        e in t
          ? Kae(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Fl = (t, e, r) => Gae(t, typeof e != "symbol" ? e + "" : e, r);
    class Zae {
      constructor(e) {
        Fl(this, "name", "multiversx"),
          Fl(this, "client"),
          Fl(this, "httpProviders"),
          Fl(this, "events"),
          Fl(this, "namespace"),
          Fl(this, "chainId"),
          (this.namespace = e.namespace),
          (this.events = ze("events")),
          (this.client = ze("client")),
          (this.chainId = this.getDefaultChain()),
          (this.httpProviders = this.createHttpProviders());
      }
      updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      request(e) {
        return this.namespace.methods.includes(e.request.method)
          ? this.client.request(e)
          : this.getHttpProvider().request(e.request);
      }
      setDefaultChain(e, r) {
        this.httpProviders[e] || this.setHttpProvider(e, r),
          (this.chainId = e),
          this.events.emit(Mi.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
      }
      getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1];
      }
      getAccounts() {
        const e = this.namespace.accounts;
        return e
          ? [
              ...new Set(
                e
                  .filter((r) => r.split(":")[1] === this.chainId.toString())
                  .map((r) => r.split(":")[2])
              ),
            ]
          : [];
      }
      createHttpProviders() {
        const e = {};
        return (
          this.namespace.chains.forEach((r) => {
            var i;
            const s = Ia(r);
            e[s] = this.createHttpProvider(
              s,
              (i = this.namespace.rpcMap) == null ? void 0 : i[r]
            );
          }),
          e
        );
      }
      getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
          r = this.httpProviders[e];
        if (typeof r > "u")
          throw new Error(`JSON-RPC provider for ${e} not found`);
        return r;
      }
      setHttpProvider(e, r) {
        const i = this.createHttpProvider(e, r);
        i && (this.httpProviders[e] = i);
      }
      createHttpProvider(e, r) {
        const i = r || _i(e, this.namespace, this.client.core.projectId);
        if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new bt(new xt(i, ze("disableProviderPing")));
      }
    }
    var Yae = Object.defineProperty,
      Jae = (t, e, r) =>
        e in t
          ? Yae(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Bl = (t, e, r) => Jae(t, typeof e != "symbol" ? e + "" : e, r);
    class Xae {
      constructor(e) {
        Bl(this, "name", "near"),
          Bl(this, "client"),
          Bl(this, "httpProviders"),
          Bl(this, "events"),
          Bl(this, "namespace"),
          Bl(this, "chainId"),
          (this.namespace = e.namespace),
          (this.events = ze("events")),
          (this.client = ze("client")),
          (this.chainId = this.getDefaultChain()),
          (this.httpProviders = this.createHttpProviders());
      }
      updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1];
      }
      request(e) {
        return this.namespace.methods.includes(e.request.method)
          ? this.client.request(e)
          : this.getHttpProvider().request(e.request);
      }
      setDefaultChain(e, r) {
        if (((this.chainId = e), !this.httpProviders[e])) {
          const i = r || _i(`${this.name}:${e}`, this.namespace);
          if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);
          this.setHttpProvider(e, i);
        }
        this.events.emit(
          Mi.DEFAULT_CHAIN_CHANGED,
          `${this.name}:${this.chainId}`
        );
      }
      getAccounts() {
        const e = this.namespace.accounts;
        return e
          ? e
              .filter((r) => r.split(":")[1] === this.chainId.toString())
              .map((r) => r.split(":")[2]) || []
          : [];
      }
      createHttpProviders() {
        const e = {};
        return (
          this.namespace.chains.forEach((r) => {
            var i;
            e[r] = this.createHttpProvider(
              r,
              (i = this.namespace.rpcMap) == null ? void 0 : i[r]
            );
          }),
          e
        );
      }
      getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
          r = this.httpProviders[e];
        if (typeof r > "u")
          throw new Error(`JSON-RPC provider for ${e} not found`);
        return r;
      }
      setHttpProvider(e, r) {
        const i = this.createHttpProvider(e, r);
        i && (this.httpProviders[e] = i);
      }
      createHttpProvider(e, r) {
        const i = r || _i(e, this.namespace);
        return typeof i > "u"
          ? void 0
          : new bt(new xt(i, ze("disableProviderPing")));
      }
    }
    var Qae = Object.defineProperty,
      ece = (t, e, r) =>
        e in t
          ? Qae(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Ll = (t, e, r) => ece(t, typeof e != "symbol" ? e + "" : e, r);
    class tce {
      constructor(e) {
        Ll(this, "name", "tezos"),
          Ll(this, "client"),
          Ll(this, "httpProviders"),
          Ll(this, "events"),
          Ll(this, "namespace"),
          Ll(this, "chainId"),
          (this.namespace = e.namespace),
          (this.events = ze("events")),
          (this.client = ze("client")),
          (this.chainId = this.getDefaultChain()),
          (this.httpProviders = this.createHttpProviders());
      }
      updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1];
      }
      request(e) {
        return this.namespace.methods.includes(e.request.method)
          ? this.client.request(e)
          : this.getHttpProvider().request(e.request);
      }
      setDefaultChain(e, r) {
        if (((this.chainId = e), !this.httpProviders[e])) {
          const i = r || _i(`${this.name}:${e}`, this.namespace);
          if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);
          this.setHttpProvider(e, i);
        }
        this.events.emit(
          Mi.DEFAULT_CHAIN_CHANGED,
          `${this.name}:${this.chainId}`
        );
      }
      getAccounts() {
        const e = this.namespace.accounts;
        return e
          ? e
              .filter((r) => r.split(":")[1] === this.chainId.toString())
              .map((r) => r.split(":")[2]) || []
          : [];
      }
      createHttpProviders() {
        const e = {};
        return (
          this.namespace.chains.forEach((r) => {
            e[r] = this.createHttpProvider(r);
          }),
          e
        );
      }
      getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
          r = this.httpProviders[e];
        if (typeof r > "u")
          throw new Error(`JSON-RPC provider for ${e} not found`);
        return r;
      }
      setHttpProvider(e, r) {
        const i = this.createHttpProvider(e, r);
        i && (this.httpProviders[e] = i);
      }
      createHttpProvider(e, r) {
        const i = r || _i(e, this.namespace);
        return typeof i > "u" ? void 0 : new bt(new xt(i));
      }
    }
    var rce = Object.defineProperty,
      ice = (t, e, r) =>
        e in t
          ? rce(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Ul = (t, e, r) => ice(t, typeof e != "symbol" ? e + "" : e, r);
    class sce {
      constructor(e) {
        Ul(this, "name", Al),
          Ul(this, "client"),
          Ul(this, "httpProviders"),
          Ul(this, "events"),
          Ul(this, "namespace"),
          Ul(this, "chainId"),
          (this.namespace = e.namespace),
          (this.events = ze("events")),
          (this.client = ze("client")),
          (this.chainId = this.getDefaultChain()),
          (this.httpProviders = this.createHttpProviders());
      }
      updateNamespace(e) {
        (this.namespace.chains = [
          ...new Set((this.namespace.chains || []).concat(e.chains || [])),
        ]),
          (this.namespace.accounts = [
            ...new Set(
              (this.namespace.accounts || []).concat(e.accounts || [])
            ),
          ]),
          (this.namespace.methods = [
            ...new Set((this.namespace.methods || []).concat(e.methods || [])),
          ]),
          (this.namespace.events = [
            ...new Set((this.namespace.events || []).concat(e.events || [])),
          ]),
          (this.httpProviders = this.createHttpProviders());
      }
      requestAccounts() {
        return this.getAccounts();
      }
      request(e) {
        return this.namespace.methods.includes(e.request.method)
          ? this.client.request(e)
          : this.getHttpProvider(e.chainId).request(e.request);
      }
      setDefaultChain(e, r) {
        this.httpProviders[e] || this.setHttpProvider(e, r),
          (this.chainId = e),
          this.events.emit(Mi.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
      }
      getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1];
      }
      getAccounts() {
        const e = this.namespace.accounts;
        return e
          ? [
              ...new Set(
                e
                  .filter((r) => r.split(":")[1] === this.chainId.toString())
                  .map((r) => r.split(":")[2])
              ),
            ]
          : [];
      }
      createHttpProviders() {
        var e, r;
        const i = {};
        return (
          (r = (e = this.namespace) == null ? void 0 : e.accounts) == null ||
            r.forEach((s) => {
              const n = ul(s);
              i[`${n.namespace}:${n.reference}`] = this.createHttpProvider(s);
            }),
          i
        );
      }
      getHttpProvider(e) {
        const r = this.httpProviders[e];
        if (typeof r > "u")
          throw new Error(`JSON-RPC provider for ${e} not found`);
        return r;
      }
      setHttpProvider(e, r) {
        const i = this.createHttpProvider(e, r);
        i && (this.httpProviders[e] = i);
      }
      createHttpProvider(e, r) {
        const i = r || _i(e, this.namespace, this.client.core.projectId);
        if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new bt(new xt(i, ze("disableProviderPing")));
      }
    }
    var nce = Object.defineProperty,
      oce = Object.defineProperties,
      ace = Object.getOwnPropertyDescriptors,
      wI = Object.getOwnPropertySymbols,
      cce = Object.prototype.hasOwnProperty,
      lce = Object.prototype.propertyIsEnumerable,
      Zy = (t, e, r) =>
        e in t
          ? nce(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      Xf = (t, e) => {
        for (var r in e || (e = {})) cce.call(e, r) && Zy(t, r, e[r]);
        if (wI) for (var r of wI(e)) lce.call(e, r) && Zy(t, r, e[r]);
        return t;
      },
      Yy = (t, e) => oce(t, ace(e)),
      zi = (t, e, r) => Zy(t, typeof e != "symbol" ? e + "" : e, r);
    class Jy {
      constructor(e) {
        zi(this, "client"),
          zi(this, "namespaces"),
          zi(this, "optionalNamespaces"),
          zi(this, "sessionProperties"),
          zi(this, "scopedProperties"),
          zi(this, "events", new rt.exports()),
          zi(this, "rpcProviders", {}),
          zi(this, "session"),
          zi(this, "providerOpts"),
          zi(this, "logger"),
          zi(this, "uri"),
          zi(this, "disableProviderPing", !1),
          (this.providerOpts = e),
          (this.logger =
            typeof e?.logger < "u" && typeof e?.logger != "string"
              ? e.logger
              : li(tn({ level: e?.logger || Zx }))),
          (this.disableProviderPing = e?.disableProviderPing || !1);
      }
      static async init(e) {
        const r = new Jy(e);
        return await r.initialize(), r;
      }
      async request(e, r, i) {
        const [s, n] = this.validateChain(r);
        if (!this.session)
          throw new Error("Please call connect() before request()");
        return await this.getProvider(s).request({
          request: Xf({}, e),
          chainId: `${s}:${n}`,
          topic: this.session.topic,
          expiry: i,
        });
      }
      sendAsync(e, r, i, s) {
        const n = new Date().getTime();
        this.request(e, i, s)
          .then((o) => r(null, Jn(n, o)))
          .catch((o) => r(o, void 0));
      }
      async enable() {
        if (!this.client) throw new Error("Sign Client not initialized");
        return (
          this.session ||
            (await this.connect({
              namespaces: this.namespaces,
              optionalNamespaces: this.optionalNamespaces,
              sessionProperties: this.sessionProperties,
              scopedProperties: this.scopedProperties,
            })),
          await this.requestAccounts()
        );
      }
      async disconnect() {
        var e;
        if (!this.session)
          throw new Error("Please call connect() before enable()");
        await this.client.disconnect({
          topic: (e = this.session) == null ? void 0 : e.topic,
          reason: tt("USER_DISCONNECTED"),
        }),
          await this.cleanup();
      }
      async connect(e) {
        if (!this.client) throw new Error("Sign Client not initialized");
        if (
          (this.setNamespaces(e),
          await this.cleanupPendingPairings(),
          !e.skipPairing)
        )
          return await this.pair(e.pairingTopic);
      }
      async authenticate(e, r) {
        if (!this.client) throw new Error("Sign Client not initialized");
        this.setNamespaces(e), await this.cleanupPendingPairings();
        const { uri: i, response: s } = await this.client.authenticate(e, r);
        i && ((this.uri = i), this.events.emit("display_uri", i));
        const n = await s();
        if (((this.session = n.session), this.session)) {
          const o = hI(this.session.namespaces);
          (this.namespaces = Vy(this.namespaces, o)),
            await this.persist("namespaces", this.namespaces),
            this.onConnect();
        }
        return n;
      }
      on(e, r) {
        this.events.on(e, r);
      }
      once(e, r) {
        this.events.once(e, r);
      }
      removeListener(e, r) {
        this.events.removeListener(e, r);
      }
      off(e, r) {
        this.events.off(e, r);
      }
      get isWalletConnect() {
        return !0;
      }
      async pair(e) {
        const { uri: r, approval: i } = await this.client.connect({
          pairingTopic: e,
          requiredNamespaces: this.namespaces,
          optionalNamespaces: this.optionalNamespaces,
          sessionProperties: this.sessionProperties,
          scopedProperties: this.scopedProperties,
        });
        r && ((this.uri = r), this.events.emit("display_uri", r));
        const s = await i();
        this.session = s;
        const n = hI(s.namespaces);
        return (
          (this.namespaces = Vy(this.namespaces, n)),
          await this.persist("namespaces", this.namespaces),
          await this.persist("optionalNamespaces", this.optionalNamespaces),
          this.onConnect(),
          this.session
        );
      }
      setDefaultChain(e, r) {
        try {
          if (!this.session) return;
          const [i, s] = this.validateChain(e),
            n = this.getProvider(i);
          n.name === Al
            ? n.setDefaultChain(`${i}:${s}`, r)
            : n.setDefaultChain(s, r);
        } catch (i) {
          if (!/Please call connect/.test(i.message)) throw i;
        }
      }
      async cleanupPendingPairings(e = {}) {
        this.logger.info("Cleaning up inactive pairings...");
        const r = this.client.pairing.getAll();
        if (yo(r)) {
          for (const i of r)
            e.deletePairings
              ? this.client.core.expirer.set(i.topic, 0)
              : await this.client.core.relayer.subscriber.unsubscribe(i.topic);
          this.logger.info(`Inactive pairings cleared: ${r.length}`);
        }
      }
      abortPairingAttempt() {
        this.logger.warn(
          "abortPairingAttempt is deprecated. This is now a no-op."
        );
      }
      async checkStorage() {
        (this.namespaces = (await this.getFromStore("namespaces")) || {}),
          (this.optionalNamespaces =
            (await this.getFromStore("optionalNamespaces")) || {}),
          this.session && this.createProviders();
      }
      async initialize() {
        this.logger.trace("Initialized"),
          await this.createClient(),
          await this.checkStorage(),
          this.registerEventListeners();
      }
      async createClient() {
        var e, r;
        if (
          ((this.client =
            this.providerOpts.client ||
            (await My.init({
              core: this.providerOpts.core,
              logger: this.providerOpts.logger || Zx,
              relayUrl: this.providerOpts.relayUrl || Doe,
              projectId: this.providerOpts.projectId,
              metadata: this.providerOpts.metadata,
              storageOptions: this.providerOpts.storageOptions,
              storage: this.providerOpts.storage,
              name: this.providerOpts.name,
              customStoragePrefix: this.providerOpts.customStoragePrefix,
              telemetryEnabled: this.providerOpts.telemetryEnabled,
            }))),
          this.providerOpts.session)
        )
          try {
            this.session = this.client.session.get(
              this.providerOpts.session.topic
            );
          } catch (i) {
            throw (
              (this.logger.error("Failed to get session", i),
              new Error(
                `The provided session: ${
                  (r = (e = this.providerOpts) == null ? void 0 : e.session) ==
                  null
                    ? void 0
                    : r.topic
                } doesn't exist in the Sign client`
              ))
            );
          }
        else {
          const i = this.client.session.getAll();
          this.session = i[0];
        }
        this.logger.trace("SignClient Initialized");
      }
      createProviders() {
        if (!this.client) throw new Error("Sign Client not initialized");
        if (!this.session)
          throw new Error(
            "Session not initialized. Please call connect() before enable()"
          );
        const e = [
          ...new Set(Object.keys(this.session.namespaces).map((r) => Vh(r))),
        ];
        Ky("client", this.client),
          Ky("events", this.events),
          Ky("disableProviderPing", this.disableProviderPing),
          e.forEach((r) => {
            if (!this.session) return;
            const i = Cae(r, this.session),
              s = cI(i),
              n = Vy(this.namespaces, this.optionalNamespaces),
              o = Yy(Xf({}, n[r]), { accounts: i, chains: s });
            switch (r) {
              case "eip155":
                this.rpcProviders[r] = new Tae({ namespace: o });
                break;
              case "algorand":
                this.rpcProviders[r] = new jae({ namespace: o });
                break;
              case "solana":
                this.rpcProviders[r] = new $ae({ namespace: o });
                break;
              case "cosmos":
                this.rpcProviders[r] = new Lae({ namespace: o });
                break;
              case "polkadot":
                this.rpcProviders[r] = new _ae({ namespace: o });
                break;
              case "cip34":
                this.rpcProviders[r] = new qae({ namespace: o });
                break;
              case "elrond":
                this.rpcProviders[r] = new Wae({ namespace: o });
                break;
              case "multiversx":
                this.rpcProviders[r] = new Zae({ namespace: o });
                break;
              case "near":
                this.rpcProviders[r] = new Xae({ namespace: o });
                break;
              case "tezos":
                this.rpcProviders[r] = new tce({ namespace: o });
                break;
              default:
                this.rpcProviders[Al]
                  ? this.rpcProviders[Al].updateNamespace(o)
                  : (this.rpcProviders[Al] = new sce({ namespace: o }));
            }
          });
      }
      registerEventListeners() {
        if (typeof this.client > "u")
          throw new Error("Sign Client is not initialized");
        this.client.on("session_ping", (e) => {
          var r;
          const { topic: i } = e;
          i === ((r = this.session) == null ? void 0 : r.topic) &&
            this.events.emit("session_ping", e);
        }),
          this.client.on("session_event", (e) => {
            var r;
            const { params: i, topic: s } = e;
            if (s !== ((r = this.session) == null ? void 0 : r.topic)) return;
            const { event: n } = i;
            if (n.name === "accountsChanged") {
              const o = n.data;
              o && yo(o) && this.events.emit("accountsChanged", o.map(uI));
            } else if (n.name === "chainChanged") {
              const o = i.chainId,
                a = i.event.data,
                c = Vh(o),
                l = Wy(o) !== Wy(a) ? `${c}:${Wy(a)}` : o;
              this.onChainChanged(l);
            } else this.events.emit(n.name, n.data);
            this.events.emit("session_event", e);
          }),
          this.client.on("session_update", ({ topic: e, params: r }) => {
            var i, s;
            if (e !== ((i = this.session) == null ? void 0 : i.topic)) return;
            const { namespaces: n } = r,
              o = (s = this.client) == null ? void 0 : s.session.get(e);
            (this.session = Yy(Xf({}, o), { namespaces: n })),
              this.onSessionUpdate(),
              this.events.emit("session_update", { topic: e, params: r });
          }),
          this.client.on("session_delete", async (e) => {
            var r;
            e.topic === ((r = this.session) == null ? void 0 : r.topic) &&
              (await this.cleanup(),
              this.events.emit("session_delete", e),
              this.events.emit(
                "disconnect",
                Yy(Xf({}, tt("USER_DISCONNECTED")), { data: e.topic })
              ));
          }),
          this.on(Mi.DEFAULT_CHAIN_CHANGED, (e) => {
            this.onChainChanged(e, !0);
          });
      }
      getProvider(e) {
        return this.rpcProviders[e] || this.rpcProviders[Al];
      }
      onSessionUpdate() {
        Object.keys(this.rpcProviders).forEach((e) => {
          var r;
          this.getProvider(e).updateNamespace(
            (r = this.session) == null ? void 0 : r.namespaces[e]
          );
        });
      }
      setNamespaces(e) {
        const {
          namespaces: r,
          optionalNamespaces: i,
          sessionProperties: s,
          scopedProperties: n,
        } = e;
        r && Object.keys(r).length && (this.namespaces = r),
          i && Object.keys(i).length && (this.optionalNamespaces = i),
          (this.sessionProperties = s),
          (this.scopedProperties = n);
      }
      validateChain(e) {
        const [r, i] = e?.split(":") || ["", ""];
        if (!this.namespaces || !Object.keys(this.namespaces).length)
          return [r, i];
        if (
          r &&
          !Object.keys(this.namespaces || {})
            .map((o) => Vh(o))
            .includes(r)
        )
          throw new Error(
            `Namespace '${r}' is not configured. Please call connect() first with namespace config.`
          );
        if (r && i) return [r, i];
        const s = Vh(Object.keys(this.namespaces)[0]),
          n = this.rpcProviders[s].getDefaultChain();
        return [s, n];
      }
      async requestAccounts() {
        const [e] = this.validateChain();
        return await this.getProvider(e).requestAccounts();
      }
      async onChainChanged(e, r = !1) {
        if (!this.namespaces) return;
        const [i, s] = this.validateChain(e);
        if (!s) return;
        this.updateNamespaceChain(i, s), this.events.emit("chainChanged", s);
        const n = this.getProvider(i).getDefaultChain();
        r || this.getProvider(i).setDefaultChain(s),
          this.emitAccountsChangedOnChainChange({
            namespace: i,
            previousChainId: n,
            newChainId: e,
          }),
          await this.persist("namespaces", this.namespaces);
      }
      emitAccountsChangedOnChainChange({
        namespace: e,
        previousChainId: r,
        newChainId: i,
      }) {
        var s, n;
        try {
          if (r === i) return;
          const o =
            (n = (s = this.session) == null ? void 0 : s.namespaces[e]) == null
              ? void 0
              : n.accounts;
          if (!o) return;
          const a = o.filter((c) => c.includes(`${i}:`)).map(uI);
          if (!yo(a)) return;
          this.events.emit("accountsChanged", a);
        } catch (o) {
          this.logger.warn("Failed to emit accountsChanged on chain change", o);
        }
      }
      updateNamespaceChain(e, r) {
        if (!this.namespaces) return;
        const i = this.namespaces[e] ? e : `${e}:${r}`,
          s = { chains: [], methods: [], events: [], defaultChain: r };
        this.namespaces[i]
          ? this.namespaces[i] && (this.namespaces[i].defaultChain = r)
          : (this.namespaces[i] = s);
      }
      onConnect() {
        this.createProviders(),
          this.events.emit("connect", { session: this.session });
      }
      async cleanup() {
        (this.namespaces = void 0),
          (this.optionalNamespaces = void 0),
          (this.sessionProperties = void 0),
          await this.deleteFromStore("namespaces"),
          await this.deleteFromStore("optionalNamespaces"),
          await this.deleteFromStore("sessionProperties"),
          (this.session = void 0),
          await this.cleanupPendingPairings({ deletePairings: !0 }),
          await this.cleanupStorage();
      }
      async persist(e, r) {
        var i;
        const s = ((i = this.session) == null ? void 0 : i.topic) || "";
        await this.client.core.storage.setItem(`${Yf}/${e}${s}`, r);
      }
      async getFromStore(e) {
        var r;
        const i = ((r = this.session) == null ? void 0 : r.topic) || "";
        return await this.client.core.storage.getItem(`${Yf}/${e}${i}`);
      }
      async deleteFromStore(e) {
        var r;
        const i = ((r = this.session) == null ? void 0 : r.topic) || "";
        await this.client.core.storage.removeItem(`${Yf}/${e}${i}`);
      }
      async cleanupStorage() {
        var e;
        try {
          if (((e = this.client) == null ? void 0 : e.session.length) > 0)
            return;
          const r = await this.client.core.storage.getKeys();
          for (const i of r)
            i.startsWith(Yf) && (await this.client.core.storage.removeItem(i));
        } catch (r) {
          this.logger.warn("Failed to cleanup storage", r);
        }
      }
    }
    const zt = {
        METMASK_CONNECTOR_NAME: "MetaMask",
        TRUST_CONNECTOR_NAME: "Trust Wallet",
        SOLFLARE_CONNECTOR_NAME: "Solflare",
        PHANTOM_CONNECTOR_NAME: "Phantom",
        COIN98_CONNECTOR_NAME: "Coin98",
        MAGIC_EDEN_CONNECTOR_NAME: "Magic Eden",
        BACKPACK_CONNECTOR_NAME: "Backpack",
        BITGET_CONNECTOR_NAME: "Bitget Wallet",
        FRONTIER_CONNECTOR_NAME: "Frontier",
        XVERSE_CONNECTOR_NAME: "Xverse Wallet",
        LEATHER_CONNECTOR_NAME: "Leather",
        EIP155: "eip155",
        ADD_CHAIN_METHOD: "wallet_addEthereumChain",
        EIP6963_ANNOUNCE_EVENT: "eip6963:announceProvider",
        EIP6963_REQUEST_EVENT: "eip6963:requestProvider",
        CONNECTOR_RDNS_MAP: {
          coinbaseWallet: "com.coinbase.wallet",
          coinbaseWalletSDK: "com.coinbase.wallet",
        },
        CONNECTOR_TYPE_EXTERNAL: "EXTERNAL",
        CONNECTOR_TYPE_WALLET_CONNECT: "WALLET_CONNECT",
        CONNECTOR_TYPE_INJECTED: "INJECTED",
        CONNECTOR_TYPE_ANNOUNCED: "ANNOUNCED",
        CONNECTOR_TYPE_AUTH: "AUTH",
        CONNECTOR_TYPE_MULTI_CHAIN: "MULTI_CHAIN",
        CONNECTOR_TYPE_W3M_AUTH: "ID_AUTH",
      },
      Qf = {
        ConnectorExplorerIds: {
          [he.CONNECTOR_ID.COINBASE]:
            "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
          [he.CONNECTOR_ID.COINBASE_SDK]:
            "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
          [he.CONNECTOR_ID.SAFE]:
            "225affb176778569276e484e1b92637ad061b01e13a048b35a9d280c3b58970f",
          [he.CONNECTOR_ID.LEDGER]:
            "19177a98252e07ddfc9af2083ba8e07ef627cb6103467ffebb3f8f4205fd7927",
          [he.CONNECTOR_ID.OKX]:
            "971e689d0a5be527bac79629b4ee9b925e82208e5168b733496a09c0faed0709",
          [zt.METMASK_CONNECTOR_NAME]:
            "c57ca95b47569778a828d19178114f4db188b89b763c899ba0be274e97267d96",
          [zt.TRUST_CONNECTOR_NAME]:
            "4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0",
          [zt.SOLFLARE_CONNECTOR_NAME]:
            "1ca0bdd4747578705b1939af023d120677c64fe6ca76add81fda36e350605e79",
          [zt.PHANTOM_CONNECTOR_NAME]:
            "a797aa35c0fadbfc1a53e7f675162ed5226968b44a19ee3d24385c64d1d3c393",
          [zt.COIN98_CONNECTOR_NAME]:
            "2a3c89040ac3b723a1972a33a125b1db11e258a6975d3a61252cd64e6ea5ea01",
          [zt.MAGIC_EDEN_CONNECTOR_NAME]:
            "8b830a2b724a9c3fbab63af6f55ed29c9dfa8a55e732dc88c80a196a2ba136c6",
          [zt.BACKPACK_CONNECTOR_NAME]:
            "2bd8c14e035c2d48f184aaa168559e86b0e3433228d3c4075900a221785019b0",
          [zt.BITGET_CONNECTOR_NAME]:
            "38f5d18bd8522c244bdd70cb4a68e0e718865155811c043f052fb9f1c51de662",
          [zt.FRONTIER_CONNECTOR_NAME]:
            "85db431492aa2e8672e93f4ea7acf10c88b97b867b0d373107af63dc4880f041",
          [zt.XVERSE_CONNECTOR_NAME]:
            "2a87d74ae02e10bdd1f51f7ce6c4e1cc53cd5f2c0b6b5ad0d7b3007d2b13de7b",
          [zt.LEATHER_CONNECTOR_NAME]:
            "483afe1df1df63daf313109971ff3ef8356ddf1cc4e45877d205eee0b7893a13",
        },
        NetworkImageIds: {
          1: "ba0ba0cd-17c6-4806-ad93-f9d174f17900",
          42161: "3bff954d-5cb0-47a0-9a23-d20192e74600",
          43114: "30c46e53-e989-45fb-4549-be3bd4eb3b00",
          56: "93564157-2e8e-4ce7-81df-b264dbee9b00",
          250: "06b26297-fe0c-4733-5d6b-ffa5498aac00",
          10: "ab9c186a-c52f-464b-2906-ca59d760a400",
          137: "41d04d42-da3b-4453-8506-668cc0727900",
          5e3: "e86fae9b-b770-4eea-e520-150e12c81100",
          295: "6a97d510-cac8-4e58-c7ce-e8681b044c00",
          11155111: "e909ea0a-f92a-4512-c8fc-748044ea6800",
          84532: "a18a7ecd-e307-4360-4746-283182228e00",
          1301: "4eeea7ef-0014-4649-5d1d-07271a80f600",
          130: "2257980a-3463-48c6-cbac-a42d2a956e00",
          10143: "0a728e83-bacb-46db-7844-948f05434900",
          100: "02b53f6a-e3d4-479e-1cb4-21178987d100",
          9001: "f926ff41-260d-4028-635e-91913fc28e00",
          324: "b310f07f-4ef7-49f3-7073-2a0a39685800",
          314: "5a73b3dd-af74-424e-cae0-0de859ee9400",
          4689: "34e68754-e536-40da-c153-6ef2e7188a00",
          1088: "3897a66d-40b9-4833-162f-a2c90531c900",
          1284: "161038da-44ae-4ec7-1208-0ea569454b00",
          1285: "f1d73bb6-5450-4e18-38f7-fb6484264a00",
          7777777: "845c60df-d429-4991-e687-91ae45791600",
          42220: "ab781bbc-ccc6-418d-d32d-789b15da1f00",
          8453: "7289c336-3981-4081-c5f4-efc26ac64a00",
          1313161554: "3ff73439-a619-4894-9262-4470c773a100",
          2020: "b8101fc0-9c19-4b6f-ec65-f6dfff106e00",
          2021: "b8101fc0-9c19-4b6f-ec65-f6dfff106e00",
          80094: "e329c2c9-59b0-4a02-83e4-212ff3779900",
          2741: "fc2427d1-5af9-4a9c-8da5-6f94627cd900",
          "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp":
            "a1b58899-f671-4276-6a5e-56ca5bd59700",
          "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z":
            "a1b58899-f671-4276-6a5e-56ca5bd59700",
          EtWTRABZaYq6iMfeYKouRu166VU2xqa1:
            "a1b58899-f671-4276-6a5e-56ca5bd59700",
          "000000000019d6689c085ae165831e93":
            "0b4838db-0161-4ffe-022d-532bf03dba00",
          "000000000933ea01ad0ee984209779ba":
            "39354064-d79b-420b-065d-f980c4b78200",
        },
        ConnectorImageIds: {
          [he.CONNECTOR_ID.COINBASE]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
          [he.CONNECTOR_ID.COINBASE_SDK]:
            "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
          [he.CONNECTOR_ID.SAFE]: "461db637-8616-43ce-035a-d89b8a1d5800",
          [he.CONNECTOR_ID.LEDGER]: "54a1aa77-d202-4f8d-0fb2-5d2bb6db0300",
          [he.CONNECTOR_ID.WALLET_CONNECT]:
            "ef1a1fcf-7fe8-4d69-bd6d-fda1345b4400",
          [he.CONNECTOR_ID.INJECTED]: "07ba87ed-43aa-4adf-4540-9e6a2b9cae00",
        },
        ConnectorNamesMap: {
          [he.CONNECTOR_ID.INJECTED]: "Browser Wallet",
          [he.CONNECTOR_ID.WALLET_CONNECT]: "WalletConnect",
          [he.CONNECTOR_ID.COINBASE]: "Coinbase",
          [he.CONNECTOR_ID.COINBASE_SDK]: "Coinbase",
          [he.CONNECTOR_ID.LEDGER]: "Ledger",
          [he.CONNECTOR_ID.SAFE]: "Safe",
        },
        ConnectorTypesMap: {
          [he.CONNECTOR_ID.INJECTED]: "INJECTED",
          [he.CONNECTOR_ID.WALLET_CONNECT]: "WALLET_CONNECT",
          [he.CONNECTOR_ID.EIP6963]: "ANNOUNCED",
          [he.CONNECTOR_ID.AUTH]: "AUTH",
        },
        WalletConnectRpcChainIds: [
          1, 5, 11155111, 10, 420, 42161, 421613, 137, 80001, 42220, 1313161554,
          1313161555, 56, 97, 43114, 43113, 100, 8453, 84531, 7777777, 999, 324,
          280,
        ],
      },
      Xy = {
        getCaipTokens(t) {
          if (!t) return;
          const e = {};
          return (
            Object.entries(t).forEach(([r, i]) => {
              e[`${zt.EIP155}:${r}`] = i;
            }),
            e
          );
        },
        isLowerCaseMatch(t, e) {
          return t?.toLowerCase() === e?.toLowerCase();
        },
      },
      e0 = {
        UniversalProviderErrors: {
          UNAUTHORIZED_DOMAIN_NOT_ALLOWED: {
            message: "Unauthorized: origin not allowed",
            alertErrorKey: "INVALID_APP_CONFIGURATION",
          },
          JWT_VALIDATION_ERROR: {
            message: "JWT validation error: JWT Token is not yet valid",
            alertErrorKey: "JWT_TOKEN_NOT_VALID",
          },
          INVALID_KEY: {
            message: "Unauthorized: invalid key",
            alertErrorKey: "INVALID_PROJECT_ID",
          },
        },
        ALERT_ERRORS: {
          SWITCH_NETWORK_NOT_FOUND: {
            shortMessage: "Network Not Found",
            longMessage:
              "Network not found - please make sure it is included in 'networks' array in createAppKit function",
          },
          INVALID_APP_CONFIGURATION: {
            shortMessage: "Invalid App Configuration",
            longMessage: () =>
              `Origin ${
                uce() ? window.origin : "unknown"
              } not found on Allowlist - update configuration on cloud.reown.com`,
          },
          SOCIALS_TIMEOUT: {
            shortMessage: "Invalid App Configuration",
            longMessage: () =>
              "There was an issue loading the embedded wallet. Please verify that your domain is allowed at cloud.reown.com",
          },
          JWT_TOKEN_NOT_VALID: {
            shortMessage: "Session Expired",
            longMessage:
              "Invalid session found on UniversalProvider - please check your time settings and connect again",
          },
          INVALID_PROJECT_ID: {
            shortMessage: "Invalid App Configuration",
            longMessage: "Invalid Project ID - update configuration",
          },
          PROJECT_ID_NOT_CONFIGURED: {
            shortMessage: "Project ID Not Configured",
            longMessage:
              "Project ID Not Configured - update configuration on cloud.reown.com",
          },
        },
      };
    function uce() {
      return typeof window < "u";
    }
    const hce = {
        createLogger(t, e = "error") {
          const r = tn({ level: e }),
            { logger: i } = J1({ opts: r });
          return (
            (i.error = (...s) => {
              for (const n of s)
                if (n instanceof Error) {
                  t(n, ...s);
                  return;
                }
              t(void 0, ...s);
            }),
            i
          );
        },
      },
      dce = "rpc.walletconnect.org";
    function mI(t, e) {
      const r = new URL("https://rpc.walletconnect.org/v1/");
      return (
        r.searchParams.set("chainId", t),
        r.searchParams.set("projectId", e),
        r.toString()
      );
    }
    const Qy = [
        "near:mainnet",
        "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
        "eip155:1101",
        "eip155:56",
        "eip155:42161",
        "eip155:7777777",
        "eip155:59144",
        "eip155:324",
        "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
        "eip155:5000",
        "solana:4sgjmw1sunhzsxgspuhpqldx6wiyjntz",
        "eip155:80084",
        "eip155:5003",
        "eip155:100",
        "eip155:8453",
        "eip155:42220",
        "eip155:1313161555",
        "eip155:17000",
        "eip155:1",
        "eip155:300",
        "eip155:1313161554",
        "eip155:1329",
        "eip155:84532",
        "eip155:421614",
        "eip155:11155111",
        "eip155:8217",
        "eip155:43114",
        "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
        "eip155:999999999",
        "eip155:11155420",
        "eip155:80002",
        "eip155:97",
        "eip155:43113",
        "eip155:137",
        "eip155:10",
        "eip155:1301",
        "bip122:000000000019d6689c085ae165831e93",
        "bip122:000000000933ea01ad0ee984209779ba",
      ],
      Dl = {
        extendRpcUrlWithProjectId(t, e) {
          let r = !1;
          try {
            r = new URL(t).host === dce;
          } catch {
            r = !1;
          }
          if (r) {
            const i = new URL(t);
            return (
              i.searchParams.has("projectId") ||
                i.searchParams.set("projectId", e),
              i.toString()
            );
          }
          return t;
        },
        isCaipNetwork(t) {
          return "chainNamespace" in t && "caipNetworkId" in t;
        },
        getChainNamespace(t) {
          return this.isCaipNetwork(t) ? t.chainNamespace : he.CHAIN.EVM;
        },
        getCaipNetworkId(t) {
          return this.isCaipNetwork(t)
            ? t.caipNetworkId
            : `${he.CHAIN.EVM}:${t.id}`;
        },
        getDefaultRpcUrl(t, e, r) {
          const i = t.rpcUrls?.default?.http?.[0];
          return Qy.includes(e) ? mI(e, r) : i || "";
        },
        extendCaipNetwork(
          t,
          { customNetworkImageUrls: e, projectId: r, customRpcUrls: i }
        ) {
          const s = this.getChainNamespace(t),
            n = this.getCaipNetworkId(t),
            o = t.rpcUrls.default.http?.[0],
            a = this.getDefaultRpcUrl(t, n, r),
            c = t?.rpcUrls?.chainDefault?.http?.[0] || o,
            l = i?.[n]?.map((d) => d.url) || [],
            u = [...l, a],
            h = [...l];
          return (
            c && !h.includes(c) && h.push(c),
            {
              ...t,
              chainNamespace: s,
              caipNetworkId: n,
              assets: {
                imageId: Qf.NetworkImageIds[t.id],
                imageUrl: e?.[t.id],
              },
              rpcUrls: {
                ...t.rpcUrls,
                default: { http: u },
                chainDefault: { http: h },
              },
            }
          );
        },
        extendCaipNetworks(
          t,
          { customNetworkImageUrls: e, projectId: r, customRpcUrls: i }
        ) {
          return t.map((s) =>
            Dl.extendCaipNetwork(s, {
              customNetworkImageUrls: e,
              customRpcUrls: i,
              projectId: r,
            })
          );
        },
        getViemTransport(t, e, r) {
          const i = [];
          return (
            r?.forEach((s) => {
              i.push(If(s.url, s.config));
            }),
            Qy.includes(t.caipNetworkId) &&
              i.push(
                If(mI(t.caipNetworkId, e), {
                  fetchOptions: { headers: { "Content-Type": "text/plain" } },
                })
              ),
            t?.rpcUrls?.default?.http?.forEach((s) => {
              i.push(If(s));
            }),
            V9(i)
          );
        },
        extendWagmiTransports(t, e, r) {
          if (Qy.includes(t.caipNetworkId)) {
            const i = this.getDefaultRpcUrl(t, t.caipNetworkId, e);
            return V9([r, If(i)]);
          }
          return r;
        },
        getUnsupportedNetwork(t) {
          return {
            id: t.split(":")[1],
            caipNetworkId: t,
            name: he.UNSUPPORTED_NETWORK_NAME,
            chainNamespace: t.split(":")[0],
            nativeCurrency: { name: "", decimals: 0, symbol: "" },
            rpcUrls: { default: { http: [] } },
          };
        },
        getCaipNetworkFromStorage(t) {
          const e = de.getActiveCaipNetworkId(),
            r = B.getAllRequestedCaipNetworks(),
            i = Array.from(B.state.chains?.keys() || []),
            s = e?.split(":")[0],
            n = s ? i.includes(s) : !1,
            o = r?.find((a) => a.caipNetworkId === e);
          return n && !o && e
            ? this.getUnsupportedNetwork(e)
            : o || t || r?.[0];
        },
      },
      t0 = { eip155: void 0, solana: void 0, polkadot: void 0, bip122: void 0 },
      ti = ot({ providers: { ...t0 }, providerIds: { ...t0 } }),
      Et = {
        state: ti,
        subscribeKey(t, e) {
          return Fr(ti, t, e);
        },
        subscribe(t) {
          return Sr(ti, () => {
            t(ti);
          });
        },
        subscribeProviders(t) {
          return Sr(ti.providers, () => t(ti.providers));
        },
        setProvider(t, e) {
          e && (ti.providers[t] = ta(e));
        },
        getProvider(t) {
          return ti.providers[t];
        },
        setProviderId(t, e) {
          e && (ti.providerIds[t] = e);
        },
        getProviderId(t) {
          if (t) return ti.providerIds[t];
        },
        reset() {
          (ti.providers = { ...t0 }), (ti.providerIds = { ...t0 });
        },
        resetChain(t) {
          (ti.providers[t] = void 0), (ti.providerIds[t] = void 0);
        },
      };
    var yI;
    (function (t) {
      (t.Google = "google"),
        (t.Github = "github"),
        (t.Apple = "apple"),
        (t.Facebook = "facebook"),
        (t.X = "x"),
        (t.Discord = "discord"),
        (t.Farcaster = "farcaster");
    })(yI || (yI = {}));
    const bo = {
        ACCOUNT_TABS: [
          { label: "Tokens" },
          { label: "NFTs" },
          { label: "Activity" },
        ],
        SECURE_SITE_ORIGIN:
          (typeof ut < "u" && typeof ut.env < "u"
            ? {}.NEXT_PUBLIC_SECURE_SITE_ORIGIN
            : void 0) || "https://secure.walletconnect.org",
        VIEW_DIRECTION: { Next: "next", Prev: "prev" },
        DEFAULT_CONNECT_METHOD_ORDER: ["email", "social", "wallet"],
        ANIMATION_DURATIONS: {
          HeaderText: 120,
          ModalHeight: 150,
          ViewTransition: 150,
        },
      },
      _a = {
        filterOutDuplicatesByRDNS(t) {
          const e = G.state.enableEIP6963 ? oe.state.connectors : [],
            r = de.getRecentWallets(),
            i = e.map((o) => o.info?.rdns).filter(Boolean),
            s = r.map((o) => o.rdns).filter(Boolean),
            n = i.concat(s);
          if (n.includes("io.metamask.mobile") && X.isMobile()) {
            const o = n.indexOf("io.metamask.mobile");
            n[o] = "io.metamask";
          }
          return t.filter((o) => !n.includes(String(o?.rdns)));
        },
        filterOutDuplicatesByIds(t) {
          const e = oe.state.connectors.filter(
              (o) => o.type === "ANNOUNCED" || o.type === "INJECTED"
            ),
            r = de.getRecentWallets(),
            i = e.map((o) => o.explorerId),
            s = r.map((o) => o.id),
            n = i.concat(s);
          return t.filter((o) => !n.includes(o?.id));
        },
        filterOutDuplicateWallets(t) {
          const e = this.filterOutDuplicatesByRDNS(t);
          return this.filterOutDuplicatesByIds(e);
        },
        markWalletsAsInstalled(t) {
          const { connectors: e } = oe.state,
            r = e
              .filter((i) => i.type === "ANNOUNCED")
              .reduce((i, s) => (s.info?.rdns && (i[s.info.rdns] = !0), i), {});
          return t
            .map((i) => ({ ...i, installed: !!i.rdns && !!r[i.rdns ?? ""] }))
            .sort((i, s) => Number(s.installed) - Number(i.installed));
        },
        getConnectOrderMethod(t, e) {
          const r =
              t?.connectMethodsOrder || G.state.features?.connectMethodsOrder,
            i = e || oe.state.connectors;
          if (r) return r;
          const { injected: s, announced: n } = Sn.getConnectorsByType(
              i,
              ne.state.recommended,
              ne.state.featured
            ),
            o = s.filter(Sn.showConnector),
            a = n.filter(Sn.showConnector);
          return o.length || a.length
            ? ["wallet", "email", "social"]
            : bo.DEFAULT_CONNECT_METHOD_ORDER;
        },
        isExcluded(t) {
          const e =
              !!t.rdns &&
              ne.state.excludedWallets.some((i) => i.rdns === t.rdns),
            r =
              !!t.name &&
              ne.state.excludedWallets.some((i) =>
                Xy.isLowerCaseMatch(i.name, t.name)
              );
          return e || r;
        },
      },
      Sn = {
        getConnectorsByType(t, e, r) {
          const { customWallets: i } = G.state,
            s = de.getRecentWallets(),
            n = _a.filterOutDuplicateWallets(e),
            o = _a.filterOutDuplicateWallets(r),
            a = t.filter((h) => h.type === "MULTI_CHAIN"),
            c = t.filter((h) => h.type === "ANNOUNCED"),
            l = t.filter((h) => h.type === "INJECTED"),
            u = t.filter((h) => h.type === "EXTERNAL");
          return {
            custom: i,
            recent: s,
            external: u,
            multiChain: a,
            announced: c,
            injected: l,
            recommended: n,
            featured: o,
          };
        },
        showConnector(t) {
          const e = t.info?.rdns,
            r =
              !!e &&
              ne.state.excludedWallets.some((s) => !!s.rdns && s.rdns === e),
            i =
              !!t.name &&
              ne.state.excludedWallets.some((s) =>
                Xy.isLowerCaseMatch(s.name, t.name)
              );
          return !(
            (t.type === "INJECTED" &&
              ((!X.isMobile() && t.name === "Browser Wallet") ||
                (!e && !pe.checkInstalled()) ||
                r ||
                i)) ||
            ((t.type === "ANNOUNCED" || t.type === "EXTERNAL") && (r || i))
          );
        },
        getIsConnectedWithWC() {
          return Array.from(B.state.chains.values()).some(
            (t) =>
              oe.getConnectorId(t.namespace) === he.CONNECTOR_ID.WALLET_CONNECT
          );
        },
        getConnectorTypeOrder({
          recommended: t,
          featured: e,
          custom: r,
          recent: i,
          announced: s,
          injected: n,
          multiChain: o,
          external: a,
          overriddenConnectors: c = G.state.features?.connectorTypeOrder ?? [],
        }) {
          const l = Sn.getIsConnectedWithWC(),
            u = [
              {
                type: "walletConnect",
                isEnabled: G.state.enableWalletConnect && !l,
              },
              { type: "recent", isEnabled: i.length > 0 },
              { type: "injected", isEnabled: [...n, ...s, ...o].length > 0 },
              { type: "featured", isEnabled: e.length > 0 },
              { type: "custom", isEnabled: r && r.length > 0 },
              { type: "external", isEnabled: a.length > 0 },
              { type: "recommended", isEnabled: t.length > 0 },
            ].filter((p) => p.isEnabled),
            h = new Set(u.map((p) => p.type)),
            d = c
              .filter((p) => h.has(p))
              .map((p) => ({ type: p, isEnabled: !0 })),
            g = u.filter(({ type: p }) => !d.some(({ type: w }) => w === p));
          return Array.from(new Set([...d, ...g].map(({ type: p }) => p)));
        },
      };
    /**
     * @license
     * Copyright 2019 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */ const r0 = globalThis,
      eb =
        r0.ShadowRoot &&
        (r0.ShadyCSS === void 0 || r0.ShadyCSS.nativeShadow) &&
        "adoptedStyleSheets" in Document.prototype &&
        "replace" in CSSStyleSheet.prototype,
      tb = Symbol(),
      bI = new WeakMap();
    class vI {
      constructor(e, r, i) {
        if (((this._$cssResult$ = !0), i !== tb))
          throw Error(
            "CSSResult is not constructable. Use `unsafeCSS` or `css` instead."
          );
        (this.cssText = e), (this.t = r);
      }
      get styleSheet() {
        let e = this.o;
        const r = this.t;
        if (eb && e === void 0) {
          const i = r !== void 0 && r.length === 1;
          i && (e = bI.get(r)),
            e === void 0 &&
              ((this.o = e = new CSSStyleSheet()).replaceSync(this.cssText),
              i && bI.set(r, e));
        }
        return e;
      }
      toString() {
        return this.cssText;
      }
    }
    const qi = (t) => new vI(typeof t == "string" ? t : t + "", void 0, tb),
      ge = (t, ...e) => {
        const r =
          t.length === 1
            ? t[0]
            : e.reduce(
                (i, s, n) =>
                  i +
                  ((o) => {
                    if (o._$cssResult$ === !0) return o.cssText;
                    if (typeof o == "number") return o;
                    throw Error(
                      "Value passed to 'css' function must be a 'css' function result: " +
                        o +
                        ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security."
                    );
                  })(s) +
                  t[n + 1],
                t[0]
              );
        return new vI(r, t, tb);
      },
      pce = (t, e) => {
        if (eb)
          t.adoptedStyleSheets = e.map((r) =>
            r instanceof CSSStyleSheet ? r : r.styleSheet
          );
        else
          for (const r of e) {
            const i = document.createElement("style"),
              s = r0.litNonce;
            s !== void 0 && i.setAttribute("nonce", s),
              (i.textContent = r.cssText),
              t.appendChild(i);
          }
      },
      EI = eb
        ? (t) => t
        : (t) =>
            t instanceof CSSStyleSheet
              ? ((e) => {
                  let r = "";
                  for (const i of e.cssRules) r += i.cssText;
                  return qi(r);
                })(t)
              : t;
    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */ const {
        is: fce,
        defineProperty: gce,
        getOwnPropertyDescriptor: wce,
        getOwnPropertyNames: mce,
        getOwnPropertySymbols: yce,
        getPrototypeOf: bce,
      } = Object,
      vo = globalThis,
      CI = vo.trustedTypes,
      vce = CI ? CI.emptyScript : "",
      Ece = vo.reactiveElementPolyfillSupport,
      rd = (t, e) => t,
      i0 = {
        toAttribute(t, e) {
          switch (e) {
            case Boolean:
              t = t ? vce : null;
              break;
            case Object:
            case Array:
              t = t == null ? t : JSON.stringify(t);
          }
          return t;
        },
        fromAttribute(t, e) {
          let r = t;
          switch (e) {
            case Boolean:
              r = t !== null;
              break;
            case Number:
              r = t === null ? null : Number(t);
              break;
            case Object:
            case Array:
              try {
                r = JSON.parse(t);
              } catch {
                r = null;
              }
          }
          return r;
        },
      },
      rb = (t, e) => !fce(t, e),
      xI = {
        attribute: !0,
        type: String,
        converter: i0,
        reflect: !1,
        useDefault: !1,
        hasChanged: rb,
      };
    Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")),
      vo.litPropertyMetadata ?? (vo.litPropertyMetadata = new WeakMap());
    class jl extends HTMLElement {
      static addInitializer(e) {
        this._$Ei(), (this.l ?? (this.l = [])).push(e);
      }
      static get observedAttributes() {
        return this.finalize(), this._$Eh && [...this._$Eh.keys()];
      }
      static createProperty(e, r = xI) {
        if (
          (r.state && (r.attribute = !1),
          this._$Ei(),
          this.prototype.hasOwnProperty(e) &&
            ((r = Object.create(r)).wrapped = !0),
          this.elementProperties.set(e, r),
          !r.noAccessor)
        ) {
          const i = Symbol(),
            s = this.getPropertyDescriptor(e, i, r);
          s !== void 0 && gce(this.prototype, e, s);
        }
      }
      static getPropertyDescriptor(e, r, i) {
        const { get: s, set: n } = wce(this.prototype, e) ?? {
          get() {
            return this[r];
          },
          set(o) {
            this[r] = o;
          },
        };
        return {
          get: s,
          set(o) {
            const a = s?.call(this);
            n?.call(this, o), this.requestUpdate(e, a, i);
          },
          configurable: !0,
          enumerable: !0,
        };
      }
      static getPropertyOptions(e) {
        return this.elementProperties.get(e) ?? xI;
      }
      static _$Ei() {
        if (this.hasOwnProperty(rd("elementProperties"))) return;
        const e = bce(this);
        e.finalize(),
          e.l !== void 0 && (this.l = [...e.l]),
          (this.elementProperties = new Map(e.elementProperties));
      }
      static finalize() {
        if (this.hasOwnProperty(rd("finalized"))) return;
        if (
          ((this.finalized = !0),
          this._$Ei(),
          this.hasOwnProperty(rd("properties")))
        ) {
          const r = this.properties,
            i = [...mce(r), ...yce(r)];
          for (const s of i) this.createProperty(s, r[s]);
        }
        const e = this[Symbol.metadata];
        if (e !== null) {
          const r = litPropertyMetadata.get(e);
          if (r !== void 0)
            for (const [i, s] of r) this.elementProperties.set(i, s);
        }
        this._$Eh = new Map();
        for (const [r, i] of this.elementProperties) {
          const s = this._$Eu(r, i);
          s !== void 0 && this._$Eh.set(s, r);
        }
        this.elementStyles = this.finalizeStyles(this.styles);
      }
      static finalizeStyles(e) {
        const r = [];
        if (Array.isArray(e)) {
          const i = new Set(e.flat(1 / 0).reverse());
          for (const s of i) r.unshift(EI(s));
        } else e !== void 0 && r.push(EI(e));
        return r;
      }
      static _$Eu(e, r) {
        const i = r.attribute;
        return i === !1
          ? void 0
          : typeof i == "string"
          ? i
          : typeof e == "string"
          ? e.toLowerCase()
          : void 0;
      }
      constructor() {
        super(),
          (this._$Ep = void 0),
          (this.isUpdatePending = !1),
          (this.hasUpdated = !1),
          (this._$Em = null),
          this._$Ev();
      }
      _$Ev() {
        (this._$ES = new Promise((e) => (this.enableUpdating = e))),
          (this._$AL = new Map()),
          this._$E_(),
          this.requestUpdate(),
          this.constructor.l?.forEach((e) => e(this));
      }
      addController(e) {
        (this._$EO ?? (this._$EO = new Set())).add(e),
          this.renderRoot !== void 0 && this.isConnected && e.hostConnected?.();
      }
      removeController(e) {
        this._$EO?.delete(e);
      }
      _$E_() {
        const e = new Map(),
          r = this.constructor.elementProperties;
        for (const i of r.keys())
          this.hasOwnProperty(i) && (e.set(i, this[i]), delete this[i]);
        e.size > 0 && (this._$Ep = e);
      }
      createRenderRoot() {
        const e =
          this.shadowRoot ??
          this.attachShadow(this.constructor.shadowRootOptions);
        return pce(e, this.constructor.elementStyles), e;
      }
      connectedCallback() {
        this.renderRoot ?? (this.renderRoot = this.createRenderRoot()),
          this.enableUpdating(!0),
          this._$EO?.forEach((e) => e.hostConnected?.());
      }
      enableUpdating(e) {}
      disconnectedCallback() {
        this._$EO?.forEach((e) => e.hostDisconnected?.());
      }
      attributeChangedCallback(e, r, i) {
        this._$AK(e, i);
      }
      _$ET(e, r) {
        const i = this.constructor.elementProperties.get(e),
          s = this.constructor._$Eu(e, i);
        if (s !== void 0 && i.reflect === !0) {
          const n = (
            i.converter?.toAttribute !== void 0 ? i.converter : i0
          ).toAttribute(r, i.type);
          (this._$Em = e),
            n == null ? this.removeAttribute(s) : this.setAttribute(s, n),
            (this._$Em = null);
        }
      }
      _$AK(e, r) {
        const i = this.constructor,
          s = i._$Eh.get(e);
        if (s !== void 0 && this._$Em !== s) {
          const n = i.getPropertyOptions(s),
            o =
              typeof n.converter == "function"
                ? { fromAttribute: n.converter }
                : n.converter?.fromAttribute !== void 0
                ? n.converter
                : i0;
          (this._$Em = s),
            (this[s] = o.fromAttribute(r, n.type) ?? this._$Ej?.get(s) ?? null),
            (this._$Em = null);
        }
      }
      requestUpdate(e, r, i) {
        if (e !== void 0) {
          const s = this.constructor,
            n = this[e];
          if (
            (i ?? (i = s.getPropertyOptions(e)),
            !(
              (i.hasChanged ?? rb)(n, r) ||
              (i.useDefault &&
                i.reflect &&
                n === this._$Ej?.get(e) &&
                !this.hasAttribute(s._$Eu(e, i)))
            ))
          )
            return;
          this.C(e, r, i);
        }
        this.isUpdatePending === !1 && (this._$ES = this._$EP());
      }
      C(e, r, { useDefault: i, reflect: s, wrapped: n }, o) {
        (i &&
          !(this._$Ej ?? (this._$Ej = new Map())).has(e) &&
          (this._$Ej.set(e, o ?? r ?? this[e]), n !== !0 || o !== void 0)) ||
          (this._$AL.has(e) ||
            (this.hasUpdated || i || (r = void 0), this._$AL.set(e, r)),
          s === !0 &&
            this._$Em !== e &&
            (this._$Eq ?? (this._$Eq = new Set())).add(e));
      }
      async _$EP() {
        this.isUpdatePending = !0;
        try {
          await this._$ES;
        } catch (r) {
          Promise.reject(r);
        }
        const e = this.scheduleUpdate();
        return e != null && (await e), !this.isUpdatePending;
      }
      scheduleUpdate() {
        return this.performUpdate();
      }
      performUpdate() {
        if (!this.isUpdatePending) return;
        if (!this.hasUpdated) {
          if (
            (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()),
            this._$Ep)
          ) {
            for (const [s, n] of this._$Ep) this[s] = n;
            this._$Ep = void 0;
          }
          const i = this.constructor.elementProperties;
          if (i.size > 0)
            for (const [s, n] of i) {
              const { wrapped: o } = n,
                a = this[s];
              o !== !0 ||
                this._$AL.has(s) ||
                a === void 0 ||
                this.C(s, void 0, n, a);
            }
        }
        let e = !1;
        const r = this._$AL;
        try {
          (e = this.shouldUpdate(r)),
            e
              ? (this.willUpdate(r),
                this._$EO?.forEach((i) => i.hostUpdate?.()),
                this.update(r))
              : this._$EM();
        } catch (i) {
          throw ((e = !1), this._$EM(), i);
        }
        e && this._$AE(r);
      }
      willUpdate(e) {}
      _$AE(e) {
        this._$EO?.forEach((r) => r.hostUpdated?.()),
          this.hasUpdated || ((this.hasUpdated = !0), this.firstUpdated(e)),
          this.updated(e);
      }
      _$EM() {
        (this._$AL = new Map()), (this.isUpdatePending = !1);
      }
      get updateComplete() {
        return this.getUpdateComplete();
      }
      getUpdateComplete() {
        return this._$ES;
      }
      shouldUpdate(e) {
        return !0;
      }
      update(e) {
        this._$Eq &&
          (this._$Eq = this._$Eq.forEach((r) => this._$ET(r, this[r]))),
          this._$EM();
      }
      updated(e) {}
      firstUpdated(e) {}
    }
    (jl.elementStyles = []),
      (jl.shadowRootOptions = { mode: "open" }),
      (jl[rd("elementProperties")] = new Map()),
      (jl[rd("finalized")] = new Map()),
      Ece?.({ ReactiveElement: jl }),
      (vo.reactiveElementVersions ?? (vo.reactiveElementVersions = [])).push(
        "2.1.0"
      );
    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */ const id = globalThis,
      s0 = id.trustedTypes,
      II = s0 ? s0.createPolicy("lit-html", { createHTML: (t) => t }) : void 0,
      _I = "$lit$",
      Eo = `lit$${Math.random().toFixed(9).slice(2)}$`,
      AI = "?" + Eo,
      Cce = `<${AI}>`,
      Aa = document,
      sd = () => Aa.createComment(""),
      nd = (t) =>
        t === null || (typeof t != "object" && typeof t != "function"),
      ib = Array.isArray,
      xce = (t) => ib(t) || typeof t?.[Symbol.iterator] == "function",
      sb = `[ 	
\f\r]`,
      od = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,
      SI = /-->/g,
      PI = />/g,
      Sa = RegExp(
        `>|${sb}(?:([^\\s"'>=/]+)(${sb}*=${sb}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`,
        "g"
      ),
      OI = /'/g,
      NI = /"/g,
      TI = /^(?:script|style|textarea|title)$/i,
      kI =
        (t) =>
        (e, ...r) => ({ _$litType$: t, strings: e, values: r }),
      L = kI(1),
      ee = kI(2),
      Pn = Symbol.for("lit-noChange"),
      Ot = Symbol.for("lit-nothing"),
      RI = new WeakMap(),
      Pa = Aa.createTreeWalker(Aa, 129);
    function $I(t, e) {
      if (!ib(t) || !t.hasOwnProperty("raw"))
        throw Error("invalid template strings array");
      return II !== void 0 ? II.createHTML(e) : e;
    }
    const Ice = (t, e) => {
      const r = t.length - 1,
        i = [];
      let s,
        n = e === 2 ? "<svg>" : e === 3 ? "<math>" : "",
        o = od;
      for (let a = 0; a < r; a++) {
        const c = t[a];
        let l,
          u,
          h = -1,
          d = 0;
        for (
          ;
          d < c.length && ((o.lastIndex = d), (u = o.exec(c)), u !== null);

        )
          (d = o.lastIndex),
            o === od
              ? u[1] === "!--"
                ? (o = SI)
                : u[1] !== void 0
                ? (o = PI)
                : u[2] !== void 0
                ? (TI.test(u[2]) && (s = RegExp("</" + u[2], "g")), (o = Sa))
                : u[3] !== void 0 && (o = Sa)
              : o === Sa
              ? u[0] === ">"
                ? ((o = s ?? od), (h = -1))
                : u[1] === void 0
                ? (h = -2)
                : ((h = o.lastIndex - u[2].length),
                  (l = u[1]),
                  (o = u[3] === void 0 ? Sa : u[3] === '"' ? NI : OI))
              : o === NI || o === OI
              ? (o = Sa)
              : o === SI || o === PI
              ? (o = od)
              : ((o = Sa), (s = void 0));
        const g = o === Sa && t[a + 1].startsWith("/>") ? " " : "";
        n +=
          o === od
            ? c + Cce
            : h >= 0
            ? (i.push(l), c.slice(0, h) + _I + c.slice(h) + Eo + g)
            : c + Eo + (h === -2 ? a : g);
      }
      return [
        $I(
          t,
          n + (t[r] || "<?>") + (e === 2 ? "</svg>" : e === 3 ? "</math>" : "")
        ),
        i,
      ];
    };
    class ad {
      constructor({ strings: e, _$litType$: r }, i) {
        let s;
        this.parts = [];
        let n = 0,
          o = 0;
        const a = e.length - 1,
          c = this.parts,
          [l, u] = Ice(e, r);
        if (
          ((this.el = ad.createElement(l, i)),
          (Pa.currentNode = this.el.content),
          r === 2 || r === 3)
        ) {
          const h = this.el.content.firstChild;
          h.replaceWith(...h.childNodes);
        }
        for (; (s = Pa.nextNode()) !== null && c.length < a; ) {
          if (s.nodeType === 1) {
            if (s.hasAttributes())
              for (const h of s.getAttributeNames())
                if (h.endsWith(_I)) {
                  const d = u[o++],
                    g = s.getAttribute(h).split(Eo),
                    p = /([.?@])?(.*)/.exec(d);
                  c.push({
                    type: 1,
                    index: n,
                    name: p[2],
                    strings: g,
                    ctor:
                      p[1] === "."
                        ? Ace
                        : p[1] === "?"
                        ? Sce
                        : p[1] === "@"
                        ? Pce
                        : n0,
                  }),
                    s.removeAttribute(h);
                } else
                  h.startsWith(Eo) &&
                    (c.push({ type: 6, index: n }), s.removeAttribute(h));
            if (TI.test(s.tagName)) {
              const h = s.textContent.split(Eo),
                d = h.length - 1;
              if (d > 0) {
                s.textContent = s0 ? s0.emptyScript : "";
                for (let g = 0; g < d; g++)
                  s.append(h[g], sd()),
                    Pa.nextNode(),
                    c.push({ type: 2, index: ++n });
                s.append(h[d], sd());
              }
            }
          } else if (s.nodeType === 8)
            if (s.data === AI) c.push({ type: 2, index: n });
            else {
              let h = -1;
              for (; (h = s.data.indexOf(Eo, h + 1)) !== -1; )
                c.push({ type: 7, index: n }), (h += Eo.length - 1);
            }
          n++;
        }
      }
      static createElement(e, r) {
        const i = Aa.createElement("template");
        return (i.innerHTML = e), i;
      }
    }
    function Ml(t, e, r = t, i) {
      if (e === Pn) return e;
      let s = i !== void 0 ? r._$Co?.[i] : r._$Cl;
      const n = nd(e) ? void 0 : e._$litDirective$;
      return (
        s?.constructor !== n &&
          (s?._$AO?.(!1),
          n === void 0 ? (s = void 0) : ((s = new n(t)), s._$AT(t, r, i)),
          i !== void 0 ? ((r._$Co ?? (r._$Co = []))[i] = s) : (r._$Cl = s)),
        s !== void 0 && (e = Ml(t, s._$AS(t, e.values), s, i)),
        e
      );
    }
    class _ce {
      constructor(e, r) {
        (this._$AV = []),
          (this._$AN = void 0),
          (this._$AD = e),
          (this._$AM = r);
      }
      get parentNode() {
        return this._$AM.parentNode;
      }
      get _$AU() {
        return this._$AM._$AU;
      }
      u(e) {
        const {
            el: { content: r },
            parts: i,
          } = this._$AD,
          s = (e?.creationScope ?? Aa).importNode(r, !0);
        Pa.currentNode = s;
        let n = Pa.nextNode(),
          o = 0,
          a = 0,
          c = i[0];
        for (; c !== void 0; ) {
          if (o === c.index) {
            let l;
            c.type === 2
              ? (l = new cd(n, n.nextSibling, this, e))
              : c.type === 1
              ? (l = new c.ctor(n, c.name, c.strings, this, e))
              : c.type === 6 && (l = new Oce(n, this, e)),
              this._$AV.push(l),
              (c = i[++a]);
          }
          o !== c?.index && ((n = Pa.nextNode()), o++);
        }
        return (Pa.currentNode = Aa), s;
      }
      p(e) {
        let r = 0;
        for (const i of this._$AV)
          i !== void 0 &&
            (i.strings !== void 0
              ? (i._$AI(e, i, r), (r += i.strings.length - 2))
              : i._$AI(e[r])),
            r++;
      }
    }
    class cd {
      get _$AU() {
        return this._$AM?._$AU ?? this._$Cv;
      }
      constructor(e, r, i, s) {
        (this.type = 2),
          (this._$AH = Ot),
          (this._$AN = void 0),
          (this._$AA = e),
          (this._$AB = r),
          (this._$AM = i),
          (this.options = s),
          (this._$Cv = s?.isConnected ?? !0);
      }
      get parentNode() {
        let e = this._$AA.parentNode;
        const r = this._$AM;
        return r !== void 0 && e?.nodeType === 11 && (e = r.parentNode), e;
      }
      get startNode() {
        return this._$AA;
      }
      get endNode() {
        return this._$AB;
      }
      _$AI(e, r = this) {
        (e = Ml(this, e, r)),
          nd(e)
            ? e === Ot || e == null || e === ""
              ? (this._$AH !== Ot && this._$AR(), (this._$AH = Ot))
              : e !== this._$AH && e !== Pn && this._(e)
            : e._$litType$ !== void 0
            ? this.$(e)
            : e.nodeType !== void 0
            ? this.T(e)
            : xce(e)
            ? this.k(e)
            : this._(e);
      }
      O(e) {
        return this._$AA.parentNode.insertBefore(e, this._$AB);
      }
      T(e) {
        this._$AH !== e && (this._$AR(), (this._$AH = this.O(e)));
      }
      _(e) {
        this._$AH !== Ot && nd(this._$AH)
          ? (this._$AA.nextSibling.data = e)
          : this.T(Aa.createTextNode(e)),
          (this._$AH = e);
      }
      $(e) {
        const { values: r, _$litType$: i } = e,
          s =
            typeof i == "number"
              ? this._$AC(e)
              : (i.el === void 0 &&
                  (i.el = ad.createElement($I(i.h, i.h[0]), this.options)),
                i);
        if (this._$AH?._$AD === s) this._$AH.p(r);
        else {
          const n = new _ce(s, this),
            o = n.u(this.options);
          n.p(r), this.T(o), (this._$AH = n);
        }
      }
      _$AC(e) {
        let r = RI.get(e.strings);
        return r === void 0 && RI.set(e.strings, (r = new ad(e))), r;
      }
      k(e) {
        ib(this._$AH) || ((this._$AH = []), this._$AR());
        const r = this._$AH;
        let i,
          s = 0;
        for (const n of e)
          s === r.length
            ? r.push(
                (i = new cd(this.O(sd()), this.O(sd()), this, this.options))
              )
            : (i = r[s]),
            i._$AI(n),
            s++;
        s < r.length && (this._$AR(i && i._$AB.nextSibling, s), (r.length = s));
      }
      _$AR(e = this._$AA.nextSibling, r) {
        for (this._$AP?.(!1, !0, r); e && e !== this._$AB; ) {
          const i = e.nextSibling;
          e.remove(), (e = i);
        }
      }
      setConnected(e) {
        this._$AM === void 0 && ((this._$Cv = e), this._$AP?.(e));
      }
    }
    class n0 {
      get tagName() {
        return this.element.tagName;
      }
      get _$AU() {
        return this._$AM._$AU;
      }
      constructor(e, r, i, s, n) {
        (this.type = 1),
          (this._$AH = Ot),
          (this._$AN = void 0),
          (this.element = e),
          (this.name = r),
          (this._$AM = s),
          (this.options = n),
          i.length > 2 || i[0] !== "" || i[1] !== ""
            ? ((this._$AH = Array(i.length - 1).fill(new String())),
              (this.strings = i))
            : (this._$AH = Ot);
      }
      _$AI(e, r = this, i, s) {
        const n = this.strings;
        let o = !1;
        if (n === void 0)
          (e = Ml(this, e, r, 0)),
            (o = !nd(e) || (e !== this._$AH && e !== Pn)),
            o && (this._$AH = e);
        else {
          const a = e;
          let c, l;
          for (e = n[0], c = 0; c < n.length - 1; c++)
            (l = Ml(this, a[i + c], r, c)),
              l === Pn && (l = this._$AH[c]),
              o || (o = !nd(l) || l !== this._$AH[c]),
              l === Ot ? (e = Ot) : e !== Ot && (e += (l ?? "") + n[c + 1]),
              (this._$AH[c] = l);
        }
        o && !s && this.j(e);
      }
      j(e) {
        e === Ot
          ? this.element.removeAttribute(this.name)
          : this.element.setAttribute(this.name, e ?? "");
      }
    }
    class Ace extends n0 {
      constructor() {
        super(...arguments), (this.type = 3);
      }
      j(e) {
        this.element[this.name] = e === Ot ? void 0 : e;
      }
    }
    class Sce extends n0 {
      constructor() {
        super(...arguments), (this.type = 4);
      }
      j(e) {
        this.element.toggleAttribute(this.name, !!e && e !== Ot);
      }
    }
    class Pce extends n0 {
      constructor(e, r, i, s, n) {
        super(e, r, i, s, n), (this.type = 5);
      }
      _$AI(e, r = this) {
        if ((e = Ml(this, e, r, 0) ?? Ot) === Pn) return;
        const i = this._$AH,
          s =
            (e === Ot && i !== Ot) ||
            e.capture !== i.capture ||
            e.once !== i.once ||
            e.passive !== i.passive,
          n = e !== Ot && (i === Ot || s);
        s && this.element.removeEventListener(this.name, this, i),
          n && this.element.addEventListener(this.name, this, e),
          (this._$AH = e);
      }
      handleEvent(e) {
        typeof this._$AH == "function"
          ? this._$AH.call(this.options?.host ?? this.element, e)
          : this._$AH.handleEvent(e);
      }
    }
    class Oce {
      constructor(e, r, i) {
        (this.element = e),
          (this.type = 6),
          (this._$AN = void 0),
          (this._$AM = r),
          (this.options = i);
      }
      get _$AU() {
        return this._$AM._$AU;
      }
      _$AI(e) {
        Ml(this, e);
      }
    }
    const Nce = id.litHtmlPolyfillSupport;
    Nce?.(ad, cd),
      (id.litHtmlVersions ?? (id.litHtmlVersions = [])).push("3.3.0");
    const Tce = (t, e, r) => {
      const i = r?.renderBefore ?? e;
      let s = i._$litPart$;
      if (s === void 0) {
        const n = r?.renderBefore ?? null;
        i._$litPart$ = s = new cd(e.insertBefore(sd(), n), n, void 0, r ?? {});
      }
      return s._$AI(t), s;
    };
    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */ const ld = globalThis;
    class ue extends jl {
      constructor() {
        super(...arguments),
          (this.renderOptions = { host: this }),
          (this._$Do = void 0);
      }
      createRenderRoot() {
        var r;
        const e = super.createRenderRoot();
        return (
          (r = this.renderOptions).renderBefore ??
            (r.renderBefore = e.firstChild),
          e
        );
      }
      update(e) {
        const r = this.render();
        this.hasUpdated || (this.renderOptions.isConnected = this.isConnected),
          super.update(e),
          (this._$Do = Tce(r, this.renderRoot, this.renderOptions));
      }
      connectedCallback() {
        super.connectedCallback(), this._$Do?.setConnected(!0);
      }
      disconnectedCallback() {
        super.disconnectedCallback(), this._$Do?.setConnected(!1);
      }
      render() {
        return Pn;
      }
    }
    (ue._$litElement$ = !0),
      (ue.finalized = !0),
      ld.litElementHydrateSupport?.({ LitElement: ue });
    const kce = ld.litElementPolyfillSupport;
    kce?.({ LitElement: ue }),
      (ld.litElementVersions ?? (ld.litElementVersions = [])).push("4.2.0");
    let ud, Co, xo;
    function Rce(t, e) {
      (ud = document.createElement("style")),
        (Co = document.createElement("style")),
        (xo = document.createElement("style")),
        (ud.textContent = zl(t).core.cssText),
        (Co.textContent = zl(t).dark.cssText),
        (xo.textContent = zl(t).light.cssText),
        document.head.appendChild(ud),
        document.head.appendChild(Co),
        document.head.appendChild(xo),
        FI(e);
    }
    function FI(t) {
      Co &&
        xo &&
        (t === "light"
          ? (Co.removeAttribute("media"), (xo.media = "enabled"))
          : (xo.removeAttribute("media"), (Co.media = "enabled")));
    }
    function $ce(t) {
      ud &&
        Co &&
        xo &&
        ((ud.textContent = zl(t).core.cssText),
        (Co.textContent = zl(t).dark.cssText),
        (xo.textContent = zl(t).light.cssText));
    }
    function zl(t) {
      return {
        core: ge`
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
      @keyframes w3m-shake {
        0% {
          transform: scale(1) rotate(0deg);
        }
        20% {
          transform: scale(1) rotate(-1deg);
        }
        40% {
          transform: scale(1) rotate(1.5deg);
        }
        60% {
          transform: scale(1) rotate(-1.5deg);
        }
        80% {
          transform: scale(1) rotate(1deg);
        }
        100% {
          transform: scale(1) rotate(0deg);
        }
      }
      @keyframes w3m-iframe-fade-out {
        0% {
          opacity: 1;
        }
        100% {
          opacity: 0;
        }
      }
      @keyframes w3m-iframe-zoom-in {
        0% {
          transform: translateY(50px);
          opacity: 0;
        }
        100% {
          transform: translateY(0px);
          opacity: 1;
        }
      }
      @keyframes w3m-iframe-zoom-in-mobile {
        0% {
          transform: scale(0.95);
          opacity: 0;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
      :root {
        --w3m-modal-width: 360px;
        --w3m-color-mix-strength: ${qi(
          t?.["--w3m-color-mix-strength"]
            ? `${t["--w3m-color-mix-strength"]}%`
            : "0%"
        )};
        --w3m-font-family: ${qi(
          t?.["--w3m-font-family"] ||
            "Inter, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;"
        )};
        --w3m-font-size-master: ${qi(t?.["--w3m-font-size-master"] || "10px")};
        --w3m-border-radius-master: ${qi(
          t?.["--w3m-border-radius-master"] || "4px"
        )};
        --w3m-z-index: ${qi(t?.["--w3m-z-index"] || 999)};

        --wui-font-family: var(--w3m-font-family);

        --wui-font-size-mini: calc(var(--w3m-font-size-master) * 0.8);
        --wui-font-size-micro: var(--w3m-font-size-master);
        --wui-font-size-tiny: calc(var(--w3m-font-size-master) * 1.2);
        --wui-font-size-small: calc(var(--w3m-font-size-master) * 1.4);
        --wui-font-size-paragraph: calc(var(--w3m-font-size-master) * 1.6);
        --wui-font-size-medium: calc(var(--w3m-font-size-master) * 1.8);
        --wui-font-size-large: calc(var(--w3m-font-size-master) * 2);
        --wui-font-size-title-6: calc(var(--w3m-font-size-master) * 2.2);
        --wui-font-size-medium-title: calc(var(--w3m-font-size-master) * 2.4);
        --wui-font-size-2xl: calc(var(--w3m-font-size-master) * 4);

        --wui-border-radius-5xs: var(--w3m-border-radius-master);
        --wui-border-radius-4xs: calc(var(--w3m-border-radius-master) * 1.5);
        --wui-border-radius-3xs: calc(var(--w3m-border-radius-master) * 2);
        --wui-border-radius-xxs: calc(var(--w3m-border-radius-master) * 3);
        --wui-border-radius-xs: calc(var(--w3m-border-radius-master) * 4);
        --wui-border-radius-s: calc(var(--w3m-border-radius-master) * 5);
        --wui-border-radius-m: calc(var(--w3m-border-radius-master) * 7);
        --wui-border-radius-l: calc(var(--w3m-border-radius-master) * 9);
        --wui-border-radius-3xl: calc(var(--w3m-border-radius-master) * 20);

        --wui-font-weight-light: 400;
        --wui-font-weight-regular: 500;
        --wui-font-weight-medium: 600;
        --wui-font-weight-bold: 700;

        --wui-letter-spacing-2xl: -1.6px;
        --wui-letter-spacing-medium-title: -0.96px;
        --wui-letter-spacing-title-6: -0.88px;
        --wui-letter-spacing-large: -0.8px;
        --wui-letter-spacing-medium: -0.72px;
        --wui-letter-spacing-paragraph: -0.64px;
        --wui-letter-spacing-small: -0.56px;
        --wui-letter-spacing-tiny: -0.48px;
        --wui-letter-spacing-micro: -0.2px;
        --wui-letter-spacing-mini: -0.16px;

        --wui-spacing-0: 0px;
        --wui-spacing-4xs: 2px;
        --wui-spacing-3xs: 4px;
        --wui-spacing-xxs: 6px;
        --wui-spacing-2xs: 7px;
        --wui-spacing-xs: 8px;
        --wui-spacing-1xs: 10px;
        --wui-spacing-s: 12px;
        --wui-spacing-m: 14px;
        --wui-spacing-l: 16px;
        --wui-spacing-2l: 18px;
        --wui-spacing-xl: 20px;
        --wui-spacing-xxl: 24px;
        --wui-spacing-2xl: 32px;
        --wui-spacing-3xl: 40px;
        --wui-spacing-4xl: 90px;
        --wui-spacing-5xl: 95px;

        --wui-icon-box-size-xxs: 14px;
        --wui-icon-box-size-xs: 20px;
        --wui-icon-box-size-sm: 24px;
        --wui-icon-box-size-md: 32px;
        --wui-icon-box-size-mdl: 36px;
        --wui-icon-box-size-lg: 40px;
        --wui-icon-box-size-2lg: 48px;
        --wui-icon-box-size-xl: 64px;

        --wui-icon-size-inherit: inherit;
        --wui-icon-size-xxs: 10px;
        --wui-icon-size-xs: 12px;
        --wui-icon-size-sm: 14px;
        --wui-icon-size-md: 16px;
        --wui-icon-size-mdl: 18px;
        --wui-icon-size-lg: 20px;
        --wui-icon-size-xl: 24px;
        --wui-icon-size-xxl: 28px;

        --wui-wallet-image-size-inherit: inherit;
        --wui-wallet-image-size-sm: 40px;
        --wui-wallet-image-size-md: 56px;
        --wui-wallet-image-size-lg: 80px;

        --wui-visual-size-size-inherit: inherit;
        --wui-visual-size-sm: 40px;
        --wui-visual-size-md: 55px;
        --wui-visual-size-lg: 80px;

        --wui-box-size-md: 100px;
        --wui-box-size-lg: 120px;

        --wui-ease-out-power-2: cubic-bezier(0, 0, 0.22, 1);
        --wui-ease-out-power-1: cubic-bezier(0, 0, 0.55, 1);

        --wui-ease-in-power-3: cubic-bezier(0.66, 0, 1, 1);
        --wui-ease-in-power-2: cubic-bezier(0.45, 0, 1, 1);
        --wui-ease-in-power-1: cubic-bezier(0.3, 0, 1, 1);

        --wui-ease-inout-power-1: cubic-bezier(0.45, 0, 0.55, 1);

        --wui-duration-lg: 200ms;
        --wui-duration-md: 125ms;
        --wui-duration-sm: 75ms;

        --wui-path-network-sm: path(
          'M15.4 2.1a5.21 5.21 0 0 1 5.2 0l11.61 6.7a5.21 5.21 0 0 1 2.61 4.52v13.4c0 1.87-1 3.59-2.6 4.52l-11.61 6.7c-1.62.93-3.6.93-5.22 0l-11.6-6.7a5.21 5.21 0 0 1-2.61-4.51v-13.4c0-1.87 1-3.6 2.6-4.52L15.4 2.1Z'
        );

        --wui-path-network-md: path(
          'M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z'
        );

        --wui-path-network-lg: path(
          'M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z'
        );

        --wui-width-network-sm: 36px;
        --wui-width-network-md: 48px;
        --wui-width-network-lg: 86px;

        --wui-height-network-sm: 40px;
        --wui-height-network-md: 54px;
        --wui-height-network-lg: 96px;

        --wui-icon-size-network-xs: 12px;
        --wui-icon-size-network-sm: 16px;
        --wui-icon-size-network-md: 24px;
        --wui-icon-size-network-lg: 42px;

        --wui-color-inherit: inherit;

        --wui-color-inverse-100: #fff;
        --wui-color-inverse-000: #000;

        --wui-cover: rgba(20, 20, 20, 0.8);

        --wui-color-modal-bg: var(--wui-color-modal-bg-base);

        --wui-color-accent-100: var(--wui-color-accent-base-100);
        --wui-color-accent-090: var(--wui-color-accent-base-090);
        --wui-color-accent-080: var(--wui-color-accent-base-080);

        --wui-color-success-100: var(--wui-color-success-base-100);
        --wui-color-success-125: var(--wui-color-success-base-125);

        --wui-color-warning-100: var(--wui-color-warning-base-100);

        --wui-color-error-100: var(--wui-color-error-base-100);
        --wui-color-error-125: var(--wui-color-error-base-125);

        --wui-color-blue-100: var(--wui-color-blue-base-100);
        --wui-color-blue-90: var(--wui-color-blue-base-90);

        --wui-icon-box-bg-error-100: var(--wui-icon-box-bg-error-base-100);
        --wui-icon-box-bg-blue-100: var(--wui-icon-box-bg-blue-base-100);
        --wui-icon-box-bg-success-100: var(--wui-icon-box-bg-success-base-100);
        --wui-icon-box-bg-inverse-100: var(--wui-icon-box-bg-inverse-base-100);

        --wui-all-wallets-bg-100: var(--wui-all-wallets-bg-100);

        --wui-avatar-border: var(--wui-avatar-border-base);

        --wui-thumbnail-border: var(--wui-thumbnail-border-base);

        --wui-wallet-button-bg: var(--wui-wallet-button-bg-base);

        --wui-box-shadow-blue: var(--wui-color-accent-glass-020);
      }

      @supports (background: color-mix(in srgb, white 50%, black)) {
        :root {
          --wui-color-modal-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-modal-bg-base)
          );

          --wui-box-shadow-blue: color-mix(in srgb, var(--wui-color-accent-100) 20%, transparent);

          --wui-color-accent-100: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 100%,
            transparent
          );
          --wui-color-accent-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-color-accent-glass-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-glass-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-color-accent-glass-020: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 20%,
            transparent
          );
          --wui-color-accent-glass-015: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 15%,
            transparent
          );
          --wui-color-accent-glass-010: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 10%,
            transparent
          );
          --wui-color-accent-glass-005: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 5%,
            transparent
          );
          --wui-color-accent-002: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 2%,
            transparent
          );

          --wui-color-fg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-100)
          );
          --wui-color-fg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-125)
          );
          --wui-color-fg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-150)
          );
          --wui-color-fg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-175)
          );
          --wui-color-fg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-200)
          );
          --wui-color-fg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-225)
          );
          --wui-color-fg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-250)
          );
          --wui-color-fg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-275)
          );
          --wui-color-fg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-300)
          );
          --wui-color-fg-325: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-325)
          );
          --wui-color-fg-350: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-350)
          );

          --wui-color-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-100)
          );
          --wui-color-bg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-125)
          );
          --wui-color-bg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-150)
          );
          --wui-color-bg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-175)
          );
          --wui-color-bg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-200)
          );
          --wui-color-bg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-225)
          );
          --wui-color-bg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-250)
          );
          --wui-color-bg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-275)
          );
          --wui-color-bg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-300)
          );
          --wui-color-bg-325: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-325)
          );
          --wui-color-bg-350: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-350)
          );

          --wui-color-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-100)
          );
          --wui-color-success-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-125)
          );

          --wui-color-warning-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-warning-base-100)
          );

          --wui-color-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-100)
          );
          --wui-color-blue-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-blue-base-100)
          );
          --wui-color-blue-90: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-blue-base-90)
          );
          --wui-color-error-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-125)
          );

          --wui-icon-box-bg-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-error-base-100)
          );
          --wui-icon-box-bg-accent-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-blue-base-100)
          );
          --wui-icon-box-bg-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-success-base-100)
          );
          --wui-icon-box-bg-inverse-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-inverse-base-100)
          );

          --wui-all-wallets-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-all-wallets-bg-100)
          );

          --wui-avatar-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-avatar-border-base)
          );

          --wui-thumbnail-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-thumbnail-border-base)
          );

          --wui-wallet-button-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-wallet-button-bg-base)
          );
        }
      }
    `,
        light: ge`
      :root {
        --w3m-color-mix: ${qi(t?.["--w3m-color-mix"] || "#fff")};
        --w3m-accent: ${qi(Qn(t, "dark")["--w3m-accent"])};
        --w3m-default: #fff;

        --wui-color-modal-bg-base: ${qi(Qn(t, "dark")["--w3m-background"])};
        --wui-color-accent-base-100: var(--w3m-accent);

        --wui-color-blueberry-100: hsla(230, 100%, 67%, 1);
        --wui-color-blueberry-090: hsla(231, 76%, 61%, 1);
        --wui-color-blueberry-080: hsla(230, 59%, 55%, 1);
        --wui-color-blueberry-050: hsla(231, 100%, 70%, 0.1);

        --wui-color-fg-100: #e4e7e7;
        --wui-color-fg-125: #d0d5d5;
        --wui-color-fg-150: #a8b1b1;
        --wui-color-fg-175: #a8b0b0;
        --wui-color-fg-200: #949e9e;
        --wui-color-fg-225: #868f8f;
        --wui-color-fg-250: #788080;
        --wui-color-fg-275: #788181;
        --wui-color-fg-300: #6e7777;
        --wui-color-fg-325: #9a9a9a;
        --wui-color-fg-350: #363636;

        --wui-color-bg-100: #141414;
        --wui-color-bg-125: #191a1a;
        --wui-color-bg-150: #1e1f1f;
        --wui-color-bg-175: #222525;
        --wui-color-bg-200: #272a2a;
        --wui-color-bg-225: #2c3030;
        --wui-color-bg-250: #313535;
        --wui-color-bg-275: #363b3b;
        --wui-color-bg-300: #3b4040;
        --wui-color-bg-325: #252525;
        --wui-color-bg-350: #ffffff;

        --wui-color-success-base-100: #26d962;
        --wui-color-success-base-125: #30a46b;

        --wui-color-warning-base-100: #f3a13f;

        --wui-color-error-base-100: #f25a67;
        --wui-color-error-base-125: #df4a34;

        --wui-color-blue-base-100: rgba(102, 125, 255, 1);
        --wui-color-blue-base-90: rgba(102, 125, 255, 0.9);

        --wui-color-success-glass-001: rgba(38, 217, 98, 0.01);
        --wui-color-success-glass-002: rgba(38, 217, 98, 0.02);
        --wui-color-success-glass-005: rgba(38, 217, 98, 0.05);
        --wui-color-success-glass-010: rgba(38, 217, 98, 0.1);
        --wui-color-success-glass-015: rgba(38, 217, 98, 0.15);
        --wui-color-success-glass-020: rgba(38, 217, 98, 0.2);
        --wui-color-success-glass-025: rgba(38, 217, 98, 0.25);
        --wui-color-success-glass-030: rgba(38, 217, 98, 0.3);
        --wui-color-success-glass-060: rgba(38, 217, 98, 0.6);
        --wui-color-success-glass-080: rgba(38, 217, 98, 0.8);

        --wui-color-success-glass-reown-020: rgba(48, 164, 107, 0.2);

        --wui-color-warning-glass-reown-020: rgba(243, 161, 63, 0.2);

        --wui-color-error-glass-001: rgba(242, 90, 103, 0.01);
        --wui-color-error-glass-002: rgba(242, 90, 103, 0.02);
        --wui-color-error-glass-005: rgba(242, 90, 103, 0.05);
        --wui-color-error-glass-010: rgba(242, 90, 103, 0.1);
        --wui-color-error-glass-015: rgba(242, 90, 103, 0.15);
        --wui-color-error-glass-020: rgba(242, 90, 103, 0.2);
        --wui-color-error-glass-025: rgba(242, 90, 103, 0.25);
        --wui-color-error-glass-030: rgba(242, 90, 103, 0.3);
        --wui-color-error-glass-060: rgba(242, 90, 103, 0.6);
        --wui-color-error-glass-080: rgba(242, 90, 103, 0.8);

        --wui-color-error-glass-reown-020: rgba(223, 74, 52, 0.2);

        --wui-color-gray-glass-001: rgba(255, 255, 255, 0.01);
        --wui-color-gray-glass-002: rgba(255, 255, 255, 0.02);
        --wui-color-gray-glass-005: rgba(255, 255, 255, 0.05);
        --wui-color-gray-glass-010: rgba(255, 255, 255, 0.1);
        --wui-color-gray-glass-015: rgba(255, 255, 255, 0.15);
        --wui-color-gray-glass-020: rgba(255, 255, 255, 0.2);
        --wui-color-gray-glass-025: rgba(255, 255, 255, 0.25);
        --wui-color-gray-glass-030: rgba(255, 255, 255, 0.3);
        --wui-color-gray-glass-060: rgba(255, 255, 255, 0.6);
        --wui-color-gray-glass-080: rgba(255, 255, 255, 0.8);
        --wui-color-gray-glass-090: rgba(255, 255, 255, 0.9);

        --wui-color-dark-glass-100: rgba(42, 42, 42, 1);

        --wui-icon-box-bg-error-base-100: #3c2426;
        --wui-icon-box-bg-blue-base-100: #20303f;
        --wui-icon-box-bg-success-base-100: #1f3a28;
        --wui-icon-box-bg-inverse-base-100: #243240;

        --wui-all-wallets-bg-100: #222b35;

        --wui-avatar-border-base: #252525;

        --wui-thumbnail-border-base: #252525;

        --wui-wallet-button-bg-base: var(--wui-color-bg-125);

        --w3m-card-embedded-shadow-color: rgb(17 17 18 / 25%);
      }
    `,
        dark: ge`
      :root {
        --w3m-color-mix: ${qi(t?.["--w3m-color-mix"] || "#000")};
        --w3m-accent: ${qi(Qn(t, "light")["--w3m-accent"])};
        --w3m-default: #000;

        --wui-color-modal-bg-base: ${qi(Qn(t, "light")["--w3m-background"])};
        --wui-color-accent-base-100: var(--w3m-accent);

        --wui-color-blueberry-100: hsla(231, 100%, 70%, 1);
        --wui-color-blueberry-090: hsla(231, 97%, 72%, 1);
        --wui-color-blueberry-080: hsla(231, 92%, 74%, 1);

        --wui-color-fg-100: #141414;
        --wui-color-fg-125: #2d3131;
        --wui-color-fg-150: #474d4d;
        --wui-color-fg-175: #636d6d;
        --wui-color-fg-200: #798686;
        --wui-color-fg-225: #828f8f;
        --wui-color-fg-250: #8b9797;
        --wui-color-fg-275: #95a0a0;
        --wui-color-fg-300: #9ea9a9;
        --wui-color-fg-325: #9a9a9a;
        --wui-color-fg-350: #d0d0d0;

        --wui-color-bg-100: #ffffff;
        --wui-color-bg-125: #f5fafa;
        --wui-color-bg-150: #f3f8f8;
        --wui-color-bg-175: #eef4f4;
        --wui-color-bg-200: #eaf1f1;
        --wui-color-bg-225: #e5eded;
        --wui-color-bg-250: #e1e9e9;
        --wui-color-bg-275: #dce7e7;
        --wui-color-bg-300: #d8e3e3;
        --wui-color-bg-325: #f3f3f3;
        --wui-color-bg-350: #202020;

        --wui-color-success-base-100: #26b562;
        --wui-color-success-base-125: #30a46b;

        --wui-color-warning-base-100: #f3a13f;

        --wui-color-error-base-100: #f05142;
        --wui-color-error-base-125: #df4a34;

        --wui-color-blue-base-100: rgba(102, 125, 255, 1);
        --wui-color-blue-base-90: rgba(102, 125, 255, 0.9);

        --wui-color-success-glass-001: rgba(38, 181, 98, 0.01);
        --wui-color-success-glass-002: rgba(38, 181, 98, 0.02);
        --wui-color-success-glass-005: rgba(38, 181, 98, 0.05);
        --wui-color-success-glass-010: rgba(38, 181, 98, 0.1);
        --wui-color-success-glass-015: rgba(38, 181, 98, 0.15);
        --wui-color-success-glass-020: rgba(38, 181, 98, 0.2);
        --wui-color-success-glass-025: rgba(38, 181, 98, 0.25);
        --wui-color-success-glass-030: rgba(38, 181, 98, 0.3);
        --wui-color-success-glass-060: rgba(38, 181, 98, 0.6);
        --wui-color-success-glass-080: rgba(38, 181, 98, 0.8);

        --wui-color-success-glass-reown-020: rgba(48, 164, 107, 0.2);

        --wui-color-warning-glass-reown-020: rgba(243, 161, 63, 0.2);

        --wui-color-error-glass-001: rgba(240, 81, 66, 0.01);
        --wui-color-error-glass-002: rgba(240, 81, 66, 0.02);
        --wui-color-error-glass-005: rgba(240, 81, 66, 0.05);
        --wui-color-error-glass-010: rgba(240, 81, 66, 0.1);
        --wui-color-error-glass-015: rgba(240, 81, 66, 0.15);
        --wui-color-error-glass-020: rgba(240, 81, 66, 0.2);
        --wui-color-error-glass-025: rgba(240, 81, 66, 0.25);
        --wui-color-error-glass-030: rgba(240, 81, 66, 0.3);
        --wui-color-error-glass-060: rgba(240, 81, 66, 0.6);
        --wui-color-error-glass-080: rgba(240, 81, 66, 0.8);

        --wui-color-error-glass-reown-020: rgba(223, 74, 52, 0.2);

        --wui-icon-box-bg-error-base-100: #f4dfdd;
        --wui-icon-box-bg-blue-base-100: #d9ecfb;
        --wui-icon-box-bg-success-base-100: #daf0e4;
        --wui-icon-box-bg-inverse-base-100: #dcecfc;

        --wui-all-wallets-bg-100: #e8f1fa;

        --wui-avatar-border-base: #f3f4f4;

        --wui-thumbnail-border-base: #eaefef;

        --wui-wallet-button-bg-base: var(--wui-color-bg-125);

        --wui-color-gray-glass-001: rgba(0, 0, 0, 0.01);
        --wui-color-gray-glass-002: rgba(0, 0, 0, 0.02);
        --wui-color-gray-glass-005: rgba(0, 0, 0, 0.05);
        --wui-color-gray-glass-010: rgba(0, 0, 0, 0.1);
        --wui-color-gray-glass-015: rgba(0, 0, 0, 0.15);
        --wui-color-gray-glass-020: rgba(0, 0, 0, 0.2);
        --wui-color-gray-glass-025: rgba(0, 0, 0, 0.25);
        --wui-color-gray-glass-030: rgba(0, 0, 0, 0.3);
        --wui-color-gray-glass-060: rgba(0, 0, 0, 0.6);
        --wui-color-gray-glass-080: rgba(0, 0, 0, 0.8);
        --wui-color-gray-glass-090: rgba(0, 0, 0, 0.9);

        --wui-color-dark-glass-100: rgba(233, 233, 233, 1);

        --w3m-card-embedded-shadow-color: rgb(224 225 233 / 25%);
      }
    `,
      };
    }
    const qe = ge`
  *,
  *::after,
  *::before,
  :host {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-style: normal;
    text-rendering: optimizeSpeed;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    font-family: var(--wui-font-family);
    backface-visibility: hidden;
  }
`,
      Cr = ge`
  button,
  a {
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    transition:
      color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      background-color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      border var(--wui-duration-lg) var(--wui-ease-out-power-1),
      border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1),
      box-shadow var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: background-color, color, border, box-shadow, border-radius;
    outline: none;
    border: none;
    column-gap: var(--wui-spacing-3xs);
    background-color: transparent;
    text-decoration: none;
  }

  wui-flex {
    transition: border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: border-radius;
  }

  button:disabled > wui-wallet-image,
  button:disabled > wui-all-wallets-image,
  button:disabled > wui-network-image,
  button:disabled > wui-image,
  button:disabled > wui-transaction-visual,
  button:disabled > wui-logo {
    filter: grayscale(1);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-gray-glass-005);
    }

    button:active:enabled {
      background-color: var(--wui-color-gray-glass-010);
    }
  }

  button:disabled > wui-icon-box {
    opacity: 0.5;
  }

  input {
    border: none;
    outline: none;
    appearance: none;
  }
`,
      hd = ge`
  .wui-color-inherit {
    color: var(--wui-color-inherit);
  }

  .wui-color-accent-100 {
    color: var(--wui-color-accent-100);
  }

  .wui-color-error-100 {
    color: var(--wui-color-error-100);
  }

  .wui-color-blue-100 {
    color: var(--wui-color-blue-100);
  }

  .wui-color-blue-90 {
    color: var(--wui-color-blue-90);
  }

  .wui-color-error-125 {
    color: var(--wui-color-error-125);
  }

  .wui-color-success-100 {
    color: var(--wui-color-success-100);
  }

  .wui-color-success-125 {
    color: var(--wui-color-success-125);
  }

  .wui-color-inverse-100 {
    color: var(--wui-color-inverse-100);
  }

  .wui-color-inverse-000 {
    color: var(--wui-color-inverse-000);
  }

  .wui-color-fg-100 {
    color: var(--wui-color-fg-100);
  }

  .wui-color-fg-200 {
    color: var(--wui-color-fg-200);
  }

  .wui-color-fg-300 {
    color: var(--wui-color-fg-300);
  }

  .wui-color-fg-325 {
    color: var(--wui-color-fg-325);
  }

  .wui-color-fg-350 {
    color: var(--wui-color-fg-350);
  }

  .wui-bg-color-inherit {
    background-color: var(--wui-color-inherit);
  }

  .wui-bg-color-blue-100 {
    background-color: var(--wui-color-accent-100);
  }

  .wui-bg-color-error-100 {
    background-color: var(--wui-color-error-100);
  }

  .wui-bg-color-error-125 {
    background-color: var(--wui-color-error-125);
  }

  .wui-bg-color-success-100 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-success-125 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-inverse-100 {
    background-color: var(--wui-color-inverse-100);
  }

  .wui-bg-color-inverse-000 {
    background-color: var(--wui-color-inverse-000);
  }

  .wui-bg-color-fg-100 {
    background-color: var(--wui-color-fg-100);
  }

  .wui-bg-color-fg-200 {
    background-color: var(--wui-color-fg-200);
  }

  .wui-bg-color-fg-300 {
    background-color: var(--wui-color-fg-300);
  }

  .wui-color-fg-325 {
    background-color: var(--wui-color-fg-325);
  }

  .wui-color-fg-350 {
    background-color: var(--wui-color-fg-350);
  }
`,
      ar = {
        getSpacingStyles(t, e) {
          if (Array.isArray(t))
            return t[e] ? `var(--wui-spacing-${t[e]})` : void 0;
          if (typeof t == "string") return `var(--wui-spacing-${t})`;
        },
        getFormattedDate(t) {
          return new Intl.DateTimeFormat("en-US", {
            month: "short",
            day: "numeric",
          }).format(t);
        },
        getHostName(t) {
          try {
            return new URL(t).hostname;
          } catch {
            return "";
          }
        },
        getTruncateString({
          string: t,
          charsStart: e,
          charsEnd: r,
          truncate: i,
        }) {
          return t.length <= e + r
            ? t
            : i === "end"
            ? `${t.substring(0, e)}...`
            : i === "start"
            ? `...${t.substring(t.length - r)}`
            : `${t.substring(0, Math.floor(e))}...${t.substring(
                t.length - Math.floor(r)
              )}`;
        },
        generateAvatarColors(t) {
          const e = t
              .toLowerCase()
              .replace(/^0x/iu, "")
              .replace(/[^a-f0-9]/gu, "")
              .substring(0, 6)
              .padEnd(6, "0"),
            r = this.hexToRgb(e),
            i = getComputedStyle(document.documentElement).getPropertyValue(
              "--w3m-border-radius-master"
            ),
            s = 100 - 3 * Number(i?.replace("px", "")),
            n = `${s}% ${s}% at 65% 40%`,
            o = [];
          for (let a = 0; a < 5; a += 1) {
            const c = this.tintColor(r, 0.15 * a);
            o.push(`rgb(${c[0]}, ${c[1]}, ${c[2]})`);
          }
          return `
    --local-color-1: ${o[0]};
    --local-color-2: ${o[1]};
    --local-color-3: ${o[2]};
    --local-color-4: ${o[3]};
    --local-color-5: ${o[4]};
    --local-radial-circle: ${n}
   `;
        },
        hexToRgb(t) {
          const e = parseInt(t, 16),
            r = (e >> 16) & 255,
            i = (e >> 8) & 255,
            s = e & 255;
          return [r, i, s];
        },
        tintColor(t, e) {
          const [r, i, s] = t,
            n = Math.round(r + (255 - r) * e),
            o = Math.round(i + (255 - i) * e),
            a = Math.round(s + (255 - s) * e);
          return [n, o, a];
        },
        isNumber(t) {
          return /^[0-9]+$/u.test(t);
        },
        getColorTheme(t) {
          return (
            t ||
            (typeof window < "u" && window.matchMedia
              ? window.matchMedia("(prefers-color-scheme: dark)")?.matches
                ? "dark"
                : "light"
              : "dark")
          );
        },
        splitBalance(t) {
          const e = t.split(".");
          return e.length === 2 ? [e[0], e[1]] : ["0", "00"];
        },
        roundNumber(t, e, r) {
          return t.toString().length >= e ? Number(t).toFixed(r) : t;
        },
        formatNumberToLocalString(t, e = 2) {
          return t === void 0
            ? "0.00"
            : typeof t == "number"
            ? t.toLocaleString("en-US", {
                maximumFractionDigits: e,
                minimumFractionDigits: e,
              })
            : parseFloat(t).toLocaleString("en-US", {
                maximumFractionDigits: e,
                minimumFractionDigits: e,
              });
        },
      };
    function Fce(t, e) {
      const { kind: r, elements: i } = e;
      return {
        kind: r,
        elements: i,
        finisher(s) {
          customElements.get(t) || customElements.define(t, s);
        },
      };
    }
    function Bce(t, e) {
      return customElements.get(t) || customElements.define(t, e), e;
    }
    function ce(t) {
      return function (e) {
        return typeof e == "function" ? Bce(t, e) : Fce(t, e);
      };
    }
    const o0 = {
        ERROR_CODE_UNRECOGNIZED_CHAIN_ID: 4902,
        ERROR_CODE_DEFAULT: 5e3,
        ERROR_INVALID_CHAIN_ID: 32603,
      },
      BI = {
        gasPriceOracle: {
          address: "0x420000000000000000000000000000000000000F",
        },
        l1Block: { address: "0x4200000000000000000000000000000000000015" },
        l2CrossDomainMessenger: {
          address: "0x4200000000000000000000000000000000000007",
        },
        l2Erc721Bridge: {
          address: "0x4200000000000000000000000000000000000014",
        },
        l2StandardBridge: {
          address: "0x4200000000000000000000000000000000000010",
        },
        l2ToL1MessagePasser: {
          address: "0x4200000000000000000000000000000000000016",
        },
      },
      Lce = {
        block: $9({
          format(t) {
            return {
              transactions: t.transactions?.map((e) => {
                if (typeof e == "string") return e;
                const r = vf(e);
                return (
                  r.typeHex === "0x7e" &&
                    ((r.isSystemTx = e.isSystemTx),
                    (r.mint = e.mint ? fn(e.mint) : void 0),
                    (r.sourceHash = e.sourceHash),
                    (r.type = "deposit")),
                  r
                );
              }),
              stateRoot: t.stateRoot,
            };
          },
        }),
        transaction: R9({
          format(t) {
            const e = {};
            return (
              t.type === "0x7e" &&
                ((e.isSystemTx = t.isSystemTx),
                (e.mint = t.mint ? fn(t.mint) : void 0),
                (e.sourceHash = t.sourceHash),
                (e.type = "deposit")),
              e
            );
          },
        }),
        transactionReceipt: nJ({
          format(t) {
            return {
              l1GasPrice: t.l1GasPrice ? fn(t.l1GasPrice) : null,
              l1GasUsed: t.l1GasUsed ? fn(t.l1GasUsed) : null,
              l1Fee: t.l1Fee ? fn(t.l1Fee) : null,
              l1FeeScalar: t.l1FeeScalar ? Number(t.l1FeeScalar) : null,
            };
          },
        }),
      };
    function LI(t, e) {
      return jce(t) ? Dce(t) : YY(t, e);
    }
    const Uce = { transaction: LI };
    function Dce(t) {
      Mce(t);
      const {
          sourceHash: e,
          data: r,
          from: i,
          gas: s,
          isSystemTx: n,
          mint: o,
          to: a,
          value: c,
        } = t,
        l = [
          e,
          i,
          a ?? "0x",
          o ? ye(o) : "0x",
          c ? ye(c) : "0x",
          s ? ye(s) : "0x",
          n ? "0x1" : "0x",
          r ?? "0x",
        ];
      return rl(["0x7e", ua(l)]);
    }
    function jce(t) {
      return t.type === "deposit" || typeof t.sourceHash < "u";
    }
    function Mce(t) {
      const { from: e, to: r } = t;
      if (e && !mn(e)) throw new lo({ address: e });
      if (r && !mn(r)) throw new lo({ address: r });
    }
    const Z = { contracts: BI, formatters: Lce, serializers: Uce },
      nb = 1;
    ({
      ...Z,
      contracts: {
        ...Z.contracts,
        l2OutputOracle: nb + "",
        portal: nb + "",
        l1StandardBridge: nb + "",
      },
    });
    const ob = 11155111;
    ({
      ...Z,
      contracts: {
        ...Z.contracts,
        l2OutputOracle: ob + "",
        portal: ob + "",
        l1StandardBridge: ob + "",
      },
    });
    const a0 = 1;
    ({
      ...Z,
      contracts: {
        ...Z.contracts,
        disputeGameFactory: a0 + "",
        l2OutputOracle: a0 + "",
        portal: a0 + "",
        l1StandardBridge: a0 + "",
      },
    });
    const ab = 5;
    ({
      ...Z,
      contracts: {
        ...Z.contracts,
        l2OutputOracle: ab + "",
        portal: ab + "",
        l1StandardBridge: ab + "",
      },
    });
    const c0 = 11155111;
    (({
      ...Z,
      contracts: {
        ...Z.contracts,
        disputeGameFactory: c0 + "",
        l2OutputOracle: c0 + "",
        portal: c0 + "",
        l1StandardBridge: c0 + "",
      },
    },
    ss({
      id: 53456,
      name: "BirdLayer",
      nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
      rpcUrls: {
        default: {
          http: ["https://rpc.birdlayer.xyz", "https://rpc1.birdlayer.xyz"],
          webSocket: ["wss://rpc.birdlayer.xyz/ws"],
        },
      },
      blockExplorers: {
        default: {
          name: "BirdLayer Explorer",
          url: "https://scan.birdlayer.xyz",
        },
      },
    })),
      { ...Z, contracts: { ...Z.contracts } });
    const cb = 1;
    ss({
      ...Z,
      id: 60808,
      name: "BOB",
      nativeCurrency: { decimals: 18, name: "ETH", symbol: "ETH" },
      rpcUrls: {
        default: {
          http: ["https://rpc.gobob.xyz"],
          webSocket: ["wss://rpc.gobob.xyz"],
        },
      },
      blockExplorers: {
        default: { name: "BOB Explorer", url: "https://explorer.gobob.xyz" },
      },
      contracts: {
        ...Z.contracts,
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 23131,
        },
        l2OutputOracle: {
          [cb]: {
            address: "0xdDa53E23f8a32640b04D7256e651C1db98dB11C1",
            blockCreated: 4462615,
          },
        },
        portal: {
          [cb]: {
            address: "0x8AdeE124447435fE03e3CD24dF3f4cAE32E65a3E",
            blockCreated: 4462615,
          },
        },
      },
      sourceId: cb,
    });
    const lb = 11155111;
    ss({
      ...Z,
      id: 808813,
      name: "BOB Sepolia",
      nativeCurrency: { decimals: 18, name: "ETH", symbol: "ETH" },
      rpcUrls: {
        default: {
          http: ["https://bob-sepolia.rpc.gobob.xyz"],
          webSocket: ["wss://bob-sepolia.rpc.gobob.xyz"],
        },
      },
      blockExplorers: {
        default: {
          name: "BOB Sepolia Explorer",
          url: "https://bob-sepolia.explorer.gobob.xyz",
        },
      },
      contracts: {
        ...Z.contracts,
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 35677,
        },
        l2OutputOracle: {
          [lb]: {
            address: "0x14D0069452b4AE2b250B395b8adAb771E4267d2f",
            blockCreated: 4462615,
          },
        },
        portal: {
          [lb]: {
            address: "0x867B1Aa872b9C8cB5E9F7755feDC45BB24Ad0ae4",
            blockCreated: 4462615,
          },
        },
      },
      testnet: !0,
      sourceId: lb,
    });
    const zce = {
      estimateFeesPerGas: async (t) => {
        if (!t.request?.feeCurrency) return null;
        const [e, r] = await Promise.all([
          qce(t.client, t.request.feeCurrency),
          Hce(t.client, t.request.feeCurrency),
        ]);
        return { maxFeePerGas: t.multiply(e - r) + r, maxPriorityFeePerGas: r };
      },
    };
    async function qce(t, e) {
      const r = await t.request({ method: "eth_gasPrice", params: [e] });
      return BigInt(r);
    }
    async function Hce(t, e) {
      const r = await t.request({
        method: "eth_maxPriorityFeePerGas",
        params: [e],
      });
      return BigInt(r);
    }
    function UI(t) {
      return (
        t === 0 ||
        t === 0n ||
        t === void 0 ||
        t === null ||
        t === "0" ||
        t === "" ||
        (typeof t == "string" &&
          (el(t).toLowerCase() === "0x" || el(t).toLowerCase() === "0x00"))
      );
    }
    function dd(t) {
      return !UI(t);
    }
    function Vce(t) {
      return typeof t.maxFeePerGas < "u" && typeof t.maxPriorityFeePerGas < "u";
    }
    function DI(t) {
      return t.type === "cip64" ? !0 : Vce(t) && dd(t.feeCurrency);
    }
    const Wce = {
      block: $9({
        format(t) {
          return {
            transactions: t.transactions?.map((e) =>
              typeof e == "string"
                ? e
                : {
                    ...vf(e),
                    ...(e.gatewayFee
                      ? {
                          gatewayFee: fn(e.gatewayFee),
                          gatewayFeeRecipient: e.gatewayFeeRecipient,
                        }
                      : {}),
                    feeCurrency: e.feeCurrency,
                  }
            ),
            ...(t.randomness ? { randomness: t.randomness } : {}),
          };
        },
      }),
      transaction: R9({
        format(t) {
          if (t.type === "0x7e")
            return {
              isSystemTx: t.isSystemTx,
              mint: t.mint ? fn(t.mint) : void 0,
              sourceHash: t.sourceHash,
              type: "deposit",
            };
          const e = { feeCurrency: t.feeCurrency };
          return (
            t.type === "0x7b"
              ? (e.type = "cip64")
              : (t.type === "0x7c" && (e.type = "cip42"),
                (e.gatewayFee = t.gatewayFee ? fn(t.gatewayFee) : null),
                (e.gatewayFeeRecipient = t.gatewayFeeRecipient)),
            e
          );
        },
      }),
      transactionRequest: bY({
        format(t) {
          const e = {};
          return (
            t.feeCurrency && (e.feeCurrency = t.feeCurrency),
            DI(t) && (e.type = "0x7b"),
            e
          );
        },
      }),
    };
    function Kce(t, e) {
      return DI(t) ? Zce(t, e) : LI(t, e);
    }
    const Gce = { transaction: Kce };
    function Zce(t, e) {
      Jce(t);
      const {
          chainId: r,
          gas: i,
          nonce: s,
          to: n,
          value: o,
          maxFeePerGas: a,
          maxPriorityFeePerGas: c,
          accessList: l,
          feeCurrency: u,
          data: h,
        } = t,
        d = [
          ye(r),
          s ? ye(s) : "0x",
          c ? ye(c) : "0x",
          a ? ye(a) : "0x",
          i ? ye(i) : "0x",
          n ?? "0x",
          o ? ye(o) : "0x",
          h ?? "0x",
          Ph(l),
          u,
          ...ol(t, e),
        ];
      return rl(["0x7b", ua(d)]);
    }
    const Yce = bf;
    function Jce(t) {
      const {
        chainId: e,
        maxPriorityFeePerGas: r,
        gasPrice: i,
        maxFeePerGas: s,
        to: n,
        feeCurrency: o,
      } = t;
      if (e <= 0) throw new Sh({ chainId: e });
      if (n && !mn(n)) throw new lo({ address: n });
      if (i)
        throw new Ne("`gasPrice` is not a valid CIP-64 Transaction attribute.");
      if (dd(s) && s > Yce) throw new Ah({ maxFeePerGas: s });
      if (dd(r) && dd(s) && r > s)
        throw new vm({ maxFeePerGas: s, maxPriorityFeePerGas: r });
      if (dd(o) && !mn(o))
        throw new Ne(
          "`feeCurrency` MUST be a token address for CIP-64 transactions."
        );
      if (UI(o))
        throw new Ne("`feeCurrency` must be provided for CIP-64 transactions.");
    }
    const jI = { contracts: BI, formatters: Wce, serializers: Gce, fees: zce },
      l0 = 17e3;
    (({
      ...jI,
      contracts: {
        ...jI.contracts,
        portal: l0 + "",
        disputeGameFactory: l0 + "",
        l2OutputOracle: l0 + "",
        l1StandardBridge: l0 + "",
      },
    },
    ss({
      id: 44,
      name: "Crab Network",
      nativeCurrency: {
        decimals: 18,
        name: "Crab Network Native Token",
        symbol: "CRAB",
      },
      rpcUrls: {
        default: {
          http: ["https://crab-rpc.darwinia.network"],
          webSocket: ["wss://crab-rpc.darwinia.network"],
        },
      },
      blockExplorers: {
        default: {
          name: "Blockscout",
          url: "https://crab-scan.darwinia.network",
        },
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 3032593,
        },
      },
    })),
      ss({
        id: 66665,
        name: "Creator",
        nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
        rpcUrls: { default: { http: ["https://rpc.creatorchain.io"] } },
        blockExplorers: {
          default: {
            name: "Explorer",
            url: "https://explorer.creatorchain.io",
          },
        },
        contracts: {
          multicall3: { address: "0xcA11bde05977b3631167028862bE2a173976CA11" },
        },
        testnet: !0,
      }),
      { ...Z, contracts: { ...Z.contracts } },
      { ...Z, contracts: { ...Z.contracts } },
      ss({
        id: 53457,
        name: "DODOchain Testnet",
        nativeCurrency: { decimals: 18, name: "DODO", symbol: "DODO" },
        rpcUrls: {
          default: {
            http: ["https://dodochain-testnet.alt.technology"],
            webSocket: ["wss://dodochain-testnet.alt.technology/ws"],
          },
        },
        blockExplorers: {
          default: {
            name: "DODOchain Testnet (Sepolia) Explorer",
            url: "https://testnet-scan.dodochain.com",
          },
        },
        testnet: !0,
      }));
    const pd = 1;
    ({
      ...Z.contracts,
      addressManager: pd + "",
      l1CrossDomainMessenger: pd + "",
      l2OutputOracle: pd + "",
      portal: pd + "",
      l1StandardBridge: pd + "",
    });
    const fd = 11155111;
    ({
      ...Z.contracts,
      addressManager: fd + "",
      l1CrossDomainMessenger: fd + "",
      l2OutputOracle: fd + "",
      portal: fd + "",
      l1StandardBridge: fd + "",
    });
    const ub = 1;
    ({
      ...Z,
      contracts: {
        ...Z.contracts,
        l2OutputOracle: ub + "",
        portal: ub + "",
        l1StandardBridge: ub + "",
      },
    });
    const hb = 17e3;
    ({
      ...Z,
      contracts: {
        ...Z.contracts,
        l2OutputOracle: hb + "",
        portal: hb + "",
        l1StandardBridge: hb + "",
      },
    },
      { ...Z, contracts: { ...Z.contracts } },
      ss({
        ...Z,
        id: 3397901,
        network: "funkiSepolia",
        name: "Funki Sepolia Sandbox",
        nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
        rpcUrls: {
          default: { http: ["https://funki-testnet.alt.technology"] },
        },
        blockExplorers: {
          default: {
            name: "Funki Sepolia Sandbox Explorer",
            url: "https://sepolia-sandbox.funkichain.com/",
          },
        },
        testnet: !0,
        contracts: {
          ...Z.contracts,
          multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 1620204,
          },
        },
        sourceId: 11155111,
      }));
    const u0 = 17e3;
    ss({
      ...Z,
      name: "Garnet Testnet",
      testnet: !0,
      id: 17069,
      sourceId: u0,
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc.garnetchain.com"],
          webSocket: ["wss://rpc.garnetchain.com"],
        },
      },
      blockExplorers: {
        default: {
          name: "Blockscout",
          url: "https://explorer.garnetchain.com",
        },
      },
      contracts: {
        ...Z.contracts,
        multicall3: { address: "0xca11bde05977b3631167028862be2a173976ca11" },
        portal: {
          [u0]: {
            address: "0x57ee40586fbE286AfC75E67cb69511A6D9aF5909",
            blockCreated: 1274684,
          },
        },
        l2OutputOracle: {
          [u0]: {
            address: "0xCb8E7AC561b8EF04F2a15865e9fbc0766FEF569B",
            blockCreated: 1274684,
          },
        },
        l1StandardBridge: {
          [u0]: {
            address: "0x09bcDd311FE398F80a78BE37E489f5D440DB95DE",
            blockCreated: 1274684,
          },
        },
      },
    });
    const db = 1;
    ({
      ...Z,
      contracts: {
        ...Z.contracts,
        disputeGameFactory: db + "",
        portal: db + "",
        l1StandardBridge: db + "",
      },
    });
    const pb = 11155111;
    ({
      ...Z,
      contracts: {
        ...Z.contracts,
        disputeGameFactory: pb + "",
        portal: pb + "",
        l1StandardBridge: pb + "",
      },
    },
      ss({
        id: 701,
        name: "Koi Network",
        nativeCurrency: {
          decimals: 18,
          name: "Koi Network Native Token",
          symbol: "KRING",
        },
        rpcUrls: {
          default: {
            http: ["https://koi-rpc.darwinia.network"],
            webSocket: ["wss://koi-rpc.darwinia.network"],
          },
        },
        blockExplorers: {
          default: {
            name: "Blockscout",
            url: "https://koi-scan.darwinia.network",
          },
        },
        contracts: {
          multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 180001,
          },
        },
        testnet: !0,
      }));
    const fb = 1;
    ({
      ...Z,
      contracts: {
        ...Z.contracts,
        l2OutputOracle: fb + "",
        portal: fb + "",
        l1StandardBridge: fb + "",
      },
    });
    const gb = 11155111;
    ({
      ...Z,
      contracts: {
        ...Z.contracts,
        l2OutputOracle: gb + "",
        portal: gb + "",
        l1StandardBridge: gb + "",
      },
    });
    const wb = 1;
    ({
      ...Z,
      contracts: {
        ...Z.contracts,
        l2OutputOracle: wb + "",
        portal: wb + "",
        l1StandardBridge: wb + "",
      },
    });
    const mb = 1;
    ({
      ...Z,
      contracts: {
        ...Z.contracts,
        l2OutputOracle: mb + "",
        portal: mb + "",
        l1StandardBridge: mb + "",
      },
    });
    const yb = 11155111;
    ({
      ...Z,
      contracts: {
        ...Z.contracts,
        l2OutputOracle: yb + "",
        portal: yb + "",
        l1StandardBridge: yb + "",
      },
    });
    const bb = 56;
    ({
      ...Z.contracts,
      l2OutputOracle: bb + "",
      portal: bb + "",
      l1StandardBridge: bb + "",
    });
    const vb = 97;
    ({
      ...Z.contracts,
      l2OutputOracle: vb + "",
      portal: vb + "",
      l1StandardBridge: vb + "",
    });
    const h0 = 1;
    ({
      ...Z,
      contracts: {
        ...Z.contracts,
        disputeGameFactory: h0 + "",
        l2OutputOracle: h0 + "",
        portal: h0 + "",
        l1StandardBridge: h0 + "",
      },
    });
    const Eb = 5;
    ({
      ...Z,
      contracts: {
        ...Z.contracts,
        l2OutputOracle: Eb + "",
        portal: Eb + "",
        l1StandardBridge: Eb + "",
      },
    });
    const d0 = 11155111;
    ({
      ...Z,
      contracts: {
        ...Z.contracts,
        disputeGameFactory: d0 + "",
        l2OutputOracle: d0 + "",
        portal: d0 + "",
        l1StandardBridge: d0 + "",
      },
    });
    const MI = 11155111;
    ss({
      ...Z,
      name: "Pyrope Testnet",
      testnet: !0,
      id: 695569,
      sourceId: MI,
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc.pyropechain.com"],
          webSocket: ["wss://rpc.pyropechain.com"],
        },
      },
      blockExplorers: {
        default: { name: "Blockscout", url: "https://pyrope.blockscout.com" },
      },
      contracts: {
        ...Z.contracts,
        l1StandardBridge: {
          [MI]: { address: "0xC24932c31D9621aE9e792576152B7ef010cFC2F8" },
        },
      },
    });
    const p0 = 1;
    ss({
      ...Z,
      name: "Redstone",
      id: 690,
      sourceId: p0,
      nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
      rpcUrls: {
        default: {
          http: ["https://rpc.redstonechain.com"],
          webSocket: ["wss://rpc.redstonechain.com"],
        },
      },
      blockExplorers: {
        default: { name: "Blockscout", url: "https://explorer.redstone.xyz" },
      },
      contracts: {
        ...Z.contracts,
        multicall3: { address: "0xca11bde05977b3631167028862be2a173976ca11" },
        portal: {
          [p0]: {
            address: "0xC7bCb0e8839a28A1cFadd1CF716de9016CdA51ae",
            blockCreated: 19578329,
          },
        },
        l2OutputOracle: {
          [p0]: {
            address: "0xa426A052f657AEEefc298b3B5c35a470e4739d69",
            blockCreated: 19578337,
          },
        },
        l1StandardBridge: {
          [p0]: {
            address: "0xc473ca7E02af24c129c2eEf51F2aDf0411c1Df69",
            blockCreated: 19578331,
          },
        },
      },
    });
    const Cb = 1;
    ({
      ...Z,
      contracts: {
        ...Z.contracts,
        l2OutputOracle: Cb + "",
        portal: Cb + "",
        l1StandardBridge: Cb + "",
      },
    });
    const xb = 11155111;
    ({
      ...Z,
      contracts: {
        ...Z.contracts,
        l2OutputOracle: xb + "",
        portal: xb + "",
        l1StandardBridge: xb + "",
      },
    });
    const Ib = 1;
    ({
      ...Z,
      contracts: {
        ...Z.contracts,
        l2OutputOracle: Ib + "",
        portal: Ib + "",
        l1StandardBridge: Ib + "",
      },
    },
      { ...Z, contracts: { ...Z.contracts } });
    const f0 = 1;
    ({
      ...Z,
      contracts: {
        ...Z.contracts,
        disputeGameFactory: f0 + "",
        l2OutputOracle: f0 + "",
        portal: f0 + "",
        l1StandardBridge: f0 + "",
      },
    });
    const g0 = 11155111;
    ({
      ...Z,
      contracts: {
        ...Z.contracts,
        disputeGameFactory: g0 + "",
        l2OutputOracle: g0 + "",
        portal: g0 + "",
        l1StandardBridge: g0 + "",
      },
    });
    const w0 = 1;
    ({
      ...Z,
      contracts: {
        ...Z.contracts,
        disputeGameFactory: w0 + "",
        l2OutputOracle: w0 + "",
        portal: w0 + "",
        l1StandardBridge: w0 + "",
      },
    });
    const m0 = 11155111;
    ({
      ...Z,
      contracts: {
        ...Z.contracts,
        disputeGameFactory: m0 + "",
        l2OutputOracle: m0 + "",
        portal: m0 + "",
        l1StandardBridge: m0 + "",
      },
    });
    const y0 = 1;
    ({
      ...Z,
      contracts: {
        ...Z.contracts,
        disputeGameFactory: y0 + "",
        l2OutputOracle: y0 + "",
        portal: y0 + "",
        l1StandardBridge: y0 + "",
      },
    });
    const zI = 11155111;
    (({
      ...Z,
      contracts: { ...Z.contracts, portal: zI + "", l1StandardBridge: zI + "" },
    },
    { ...Z, contracts: { ...Z.contracts } }),
      { ...Z, contracts: { ...Z.contracts } });
    const _b = 1;
    ({
      ...Z,
      contracts: {
        ...Z.contracts,
        disputeGameFactory: _b + "",
        portal: _b + "",
        l1StandardBridge: _b + "",
      },
    });
    const Ab = 11155111;
    ({
      ...Z,
      contracts: {
        ...Z.contracts,
        portal: Ab + "",
        l1StandardBridge: Ab + "",
        disputeGameFactory: Ab + "",
      },
    });
    const b0 = 1;
    ({
      ...Z,
      contracts: {
        ...Z.contracts,
        disputeGameFactory: b0 + "",
        l2OutputOracle: b0 + "",
        portal: b0 + "",
        l1StandardBridge: b0 + "",
      },
    });
    const v0 = 11155111;
    ({
      ...Z,
      contracts: {
        ...Z.contracts,
        disputeGameFactory: v0 + "",
        l2OutputOracle: v0 + "",
        portal: v0 + "",
        l1StandardBridge: v0 + "",
      },
    });
    const Sb = 1;
    ({
      ...Z,
      contracts: {
        ...Z.contracts,
        l2OutputOracle: Sb + "",
        portal: Sb + "",
        l1StandardBridge: Sb + "",
      },
    });
    const Pb = 11155111;
    ({
      ...Z,
      contracts: {
        ...Z.contracts,
        l2OutputOracle: Pb + "",
        portal: Pb + "",
        l1StandardBridge: Pb + "",
      },
    });
    const Xce = 5;
    ({ ...Z, contracts: { ...Z.contracts, portal: Xce + "" } });
    function gd(t) {
      return { formatters: void 0, fees: void 0, serializers: void 0, ...t };
    }
    const qI = gd({
        id: "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
        name: "Solana",
        network: "solana-mainnet",
        nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
        rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
        blockExplorers: {
          default: { name: "Solscan", url: "https://solscan.io" },
        },
        testnet: !1,
        chainNamespace: "solana",
        caipNetworkId: "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
        deprecatedCaipNetworkId: "solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ",
      }),
      HI = gd({
        id: "EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
        name: "Solana Devnet",
        network: "solana-devnet",
        nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
        rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
        blockExplorers: {
          default: { name: "Solscan", url: "https://solscan.io" },
        },
        testnet: !0,
        chainNamespace: "solana",
        caipNetworkId: "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
        deprecatedCaipNetworkId: "solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K",
      });
    gd({
      id: "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
      name: "Solana Testnet",
      network: "solana-testnet",
      nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
      rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
      blockExplorers: {
        default: { name: "Solscan", url: "https://solscan.io" },
      },
      testnet: !0,
      chainNamespace: "solana",
      caipNetworkId: "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
    }),
      gd({
        id: "000000000019d6689c085ae165831e93",
        caipNetworkId: "bip122:000000000019d6689c085ae165831e93",
        chainNamespace: "bip122",
        name: "Bitcoin",
        nativeCurrency: { name: "Bitcoin", symbol: "BTC", decimals: 8 },
        rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
      }),
      gd({
        id: "000000000933ea01ad0ee984209779ba",
        caipNetworkId: "bip122:000000000933ea01ad0ee984209779ba",
        chainNamespace: "bip122",
        name: "Bitcoin Testnet",
        nativeCurrency: { name: "Bitcoin", symbol: "BTC", decimals: 8 },
        rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
        testnet: !0,
      });
    const Qce = {
        solana: [
          "solana_signMessage",
          "solana_signTransaction",
          "solana_requestAccounts",
          "solana_getAccounts",
          "solana_signAllTransactions",
          "solana_signAndSendTransaction",
        ],
        eip155: [
          "eth_accounts",
          "eth_requestAccounts",
          "eth_sendRawTransaction",
          "eth_sign",
          "eth_signTransaction",
          "eth_signTypedData",
          "eth_signTypedData_v3",
          "eth_signTypedData_v4",
          "eth_sendTransaction",
          "personal_sign",
          "wallet_switchEthereumChain",
          "wallet_addEthereumChain",
          "wallet_getPermissions",
          "wallet_requestPermissions",
          "wallet_registerOnboarding",
          "wallet_watchAsset",
          "wallet_scanQRCode",
          "wallet_getCallsStatus",
          "wallet_showCallsStatus",
          "wallet_sendCalls",
          "wallet_getCapabilities",
          "wallet_grantPermissions",
          "wallet_revokePermissions",
          "wallet_getAssets",
        ],
        bip122: [
          "sendTransfer",
          "signMessage",
          "signPsbt",
          "getAccountAddresses",
        ],
      },
      VI = {
        getMethodsByChainNamespace(t) {
          return Qce[t] || [];
        },
        createDefaultNamespace(t) {
          return {
            methods: this.getMethodsByChainNamespace(t),
            events: ["accountsChanged", "chainChanged"],
            chains: [],
            rpcMap: {},
          };
        },
        applyNamespaceOverrides(t, e) {
          if (!e) return { ...t };
          const r = { ...t },
            i = new Set();
          if (
            (e.methods && Object.keys(e.methods).forEach((s) => i.add(s)),
            e.chains && Object.keys(e.chains).forEach((s) => i.add(s)),
            e.events && Object.keys(e.events).forEach((s) => i.add(s)),
            e.rpcMap &&
              Object.keys(e.rpcMap).forEach((s) => {
                const [n] = s.split(":");
                n && i.add(n);
              }),
            i.forEach((s) => {
              r[s] || (r[s] = this.createDefaultNamespace(s));
            }),
            e.methods &&
              Object.entries(e.methods).forEach(([s, n]) => {
                r[s] && (r[s].methods = n);
              }),
            e.chains &&
              Object.entries(e.chains).forEach(([s, n]) => {
                r[s] && (r[s].chains = n);
              }),
            e.events &&
              Object.entries(e.events).forEach(([s, n]) => {
                r[s] && (r[s].events = n);
              }),
            e.rpcMap)
          ) {
            const s = new Set();
            Object.entries(e.rpcMap).forEach(([n, o]) => {
              const [a, c] = n.split(":");
              !a ||
                !c ||
                !r[a] ||
                (r[a].rpcMap || (r[a].rpcMap = {}),
                s.has(a) || ((r[a].rpcMap = {}), s.add(a)),
                (r[a].rpcMap[c] = o));
            });
          }
          return r;
        },
        createNamespaces(t, e) {
          const r = t.reduce((i, s) => {
            const { id: n, chainNamespace: o, rpcUrls: a } = s,
              c = a.default.http[0];
            i[o] || (i[o] = this.createDefaultNamespace(o));
            const l = `${o}:${n}`,
              u = i[o];
            switch ((u.chains.push(l), l)) {
              case qI.caipNetworkId:
                u.chains.push(qI.deprecatedCaipNetworkId);
                break;
              case HI.caipNetworkId:
                u.chains.push(HI.deprecatedCaipNetworkId);
                break;
            }
            return u?.rpcMap && c && (u.rpcMap[n] = c), i;
          }, {});
          return this.applyNamespaceOverrides(r, e);
        },
        resolveReownName: async (t) => {
          const e = await oC.resolveName(t);
          return (Object.values(e?.addresses) || [])[0]?.address || !1;
        },
        getChainsFromNamespaces(t = {}) {
          return Object.values(t).flatMap((e) => {
            const r = e.chains || [],
              i = e.accounts.map((s) => {
                const [n, o] = s.split(":");
                return `${n}:${o}`;
              });
            return Array.from(new Set([...r, ...i]));
          });
        },
        isSessionEventData(t) {
          return (
            typeof t == "object" &&
            t !== null &&
            "id" in t &&
            "topic" in t &&
            "params" in t &&
            typeof t.params == "object" &&
            t.params !== null &&
            "chainId" in t.params &&
            "event" in t.params &&
            typeof t.params.event == "object" &&
            t.params.event !== null
          );
        },
      };
    class WI {
      constructor({ provider: e, namespace: r }) {
        (this.id = he.CONNECTOR_ID.WALLET_CONNECT),
          (this.name = Qf.ConnectorNamesMap[he.CONNECTOR_ID.WALLET_CONNECT]),
          (this.type = "WALLET_CONNECT"),
          (this.imageId = Qf.ConnectorImageIds[he.CONNECTOR_ID.WALLET_CONNECT]),
          (this.getCaipNetworks = B.getCaipNetworks.bind(B)),
          (this.caipNetworks = this.getCaipNetworks()),
          (this.provider = e),
          (this.chain = r);
      }
      get chains() {
        return this.getCaipNetworks();
      }
      async connectWalletConnect() {
        if (!(await this.authenticate())) {
          const e = this.getCaipNetworks(),
            r = G.state.universalProviderConfigOverride,
            i = VI.createNamespaces(e, r);
          await this.provider.connect({ optionalNamespaces: i });
        }
        return {
          clientId: await this.provider.client.core.crypto.getClientId(),
          session: this.provider.session,
        };
      }
      async disconnect() {
        await this.provider.disconnect();
      }
      async authenticate() {
        const e = this.chains.map((r) => r.caipNetworkId);
        return ao.universalProviderAuthenticate({
          universalProvider: this.provider,
          chains: e,
          methods: ele,
        });
      }
    }
    const ele = [
      "eth_accounts",
      "eth_requestAccounts",
      "eth_sendRawTransaction",
      "eth_sign",
      "eth_signTransaction",
      "eth_signTypedData",
      "eth_signTypedData_v3",
      "eth_signTypedData_v4",
      "eth_sendTransaction",
      "personal_sign",
      "wallet_switchEthereumChain",
      "wallet_addEthereumChain",
      "wallet_getPermissions",
      "wallet_requestPermissions",
      "wallet_registerOnboarding",
      "wallet_watchAsset",
      "wallet_scanQRCode",
      "wallet_getCallsStatus",
      "wallet_sendCalls",
      "wallet_getCapabilities",
      "wallet_grantPermissions",
      "wallet_revokePermissions",
      "wallet_getAssets",
    ];
    class tle {
      constructor(e) {
        (this.availableConnectors = []),
          (this.eventListeners = new Map()),
          (this.getCaipNetworks = (r) => B.getCaipNetworks(r)),
          e && this.construct(e);
      }
      construct(e) {
        (this.projectId = e.projectId),
          (this.namespace = e.namespace),
          (this.adapterType = e.adapterType);
      }
      get connectors() {
        return this.availableConnectors;
      }
      get networks() {
        return this.getCaipNetworks(this.namespace);
      }
      setAuthProvider(e) {
        this.addConnector({
          id: he.CONNECTOR_ID.AUTH,
          type: "AUTH",
          name: he.CONNECTOR_NAMES.AUTH,
          provider: e,
          imageId: Qf.ConnectorImageIds[he.CONNECTOR_ID.AUTH],
          chain: this.namespace,
          chains: [],
        });
      }
      addConnector(...e) {
        const r = new Set();
        (this.availableConnectors = [...e, ...this.availableConnectors].filter(
          (i) => (r.has(i.id) ? !1 : (r.add(i.id), !0))
        )),
          this.emit("connectors", this.availableConnectors);
      }
      setStatus(e, r) {
        fe.setStatus(e, r);
      }
      on(e, r) {
        this.eventListeners.has(e) || this.eventListeners.set(e, new Set()),
          this.eventListeners.get(e)?.add(r);
      }
      off(e, r) {
        const i = this.eventListeners.get(e);
        i && i.delete(r);
      }
      removeAllEventListeners() {
        this.eventListeners.forEach((e) => {
          e.clear();
        });
      }
      emit(e, r) {
        const i = this.eventListeners.get(e);
        i && i.forEach((s) => s(r));
      }
      async connectWalletConnect(e) {
        return {
          clientId: (
            await this.getWalletConnectConnector().connectWalletConnect()
          ).clientId,
        };
      }
      async switchNetwork(e) {
        const { caipNetwork: r, providerType: i } = e;
        if (!e.provider) return;
        const s = "provider" in e.provider ? e.provider.provider : e.provider;
        if (i === "WALLET_CONNECT") {
          s.setDefaultChain(r.caipNetworkId);
          return;
        }
        if (s && i === "AUTH") {
          const n = s,
            o = fe.state.preferredAccountTypes?.[r.chainNamespace];
          await n.switchNetwork(r.caipNetworkId);
          const a = await n.getUser({
            chainId: r.caipNetworkId,
            preferredAccountType: o,
          });
          this.emit("switchNetwork", a);
        }
      }
      getWalletConnectConnector() {
        const e = this.connectors.find((r) => r instanceof WI);
        if (!e) throw new Error("WalletConnectConnector not found");
        return e;
      }
    }
    class rle extends tle {
      setUniversalProvider(e) {
        this.addConnector(
          new WI({
            provider: e,
            caipNetworks: this.getCaipNetworks(),
            namespace: this.namespace,
          })
        );
      }
      async connect(e) {
        return Promise.resolve({
          id: "WALLET_CONNECT",
          type: "WALLET_CONNECT",
          chainId: Number(e.chainId),
          provider: this.provider,
          address: "",
        });
      }
      async disconnect() {
        try {
          await this.getWalletConnectConnector().disconnect();
        } catch (e) {
          console.warn("UniversalAdapter:disconnect - error", e);
        }
      }
      async getAccounts({ namespace: e }) {
        const r =
          this.provider?.session?.namespaces?.[e]?.accounts
            ?.map((i) => {
              const [, , s] = i.split(":");
              return s;
            })
            .filter((i, s, n) => n.indexOf(i) === s) || [];
        return Promise.resolve({
          accounts: r.map((i) =>
            X.createAccount(e, i, e === "bip122" ? "payment" : "eoa")
          ),
        });
      }
      async syncConnectors() {
        return Promise.resolve();
      }
      async getBalance(e) {
        if (
          !(
            e.caipNetwork &&
            Lt.BALANCE_SUPPORTED_CHAINS.includes(e.caipNetwork?.chainNamespace)
          ) ||
          e.caipNetwork?.testnet
        )
          return {
            balance: "0.00",
            symbol: e.caipNetwork?.nativeCurrency.symbol || "",
          };
        if (
          fe.state.balanceLoading &&
          e.chainId === B.state.activeCaipNetwork?.id
        )
          return {
            balance: fe.state.balance || "0.00",
            symbol: fe.state.balanceSymbol || "",
          };
        const r = (await fe.fetchTokenBalance()).find(
          (i) =>
            i.chainId === `${e.caipNetwork?.chainNamespace}:${e.chainId}` &&
            i.symbol === e.caipNetwork?.nativeCurrency.symbol
        );
        return {
          balance: r?.quantity.numeric || "0.00",
          symbol: r?.symbol || e.caipNetwork?.nativeCurrency.symbol || "",
        };
      }
      async signMessage(e) {
        const { provider: r, message: i, address: s } = e;
        if (!r)
          throw new Error(
            "UniversalAdapter:signMessage - provider is undefined"
          );
        let n = "";
        return (
          B.state.activeCaipNetwork?.chainNamespace === he.CHAIN.SOLANA
            ? (n = (
                await r.request(
                  {
                    method: "solana_signMessage",
                    params: {
                      message: Dg.encode(new TextEncoder().encode(i)),
                      pubkey: s,
                    },
                  },
                  B.state.activeCaipNetwork?.caipNetworkId
                )
              ).signature)
            : (n = await r.request(
                { method: "personal_sign", params: [i, s] },
                B.state.activeCaipNetwork?.caipNetworkId
              )),
          { signature: n }
        );
      }
      async estimateGas() {
        return Promise.resolve({ gas: BigInt(0) });
      }
      async getProfile() {
        return Promise.resolve({ profileImage: "", profileName: "" });
      }
      async sendTransaction() {
        return Promise.resolve({ hash: "" });
      }
      walletGetAssets(e) {
        return Promise.resolve({});
      }
      async writeContract() {
        return Promise.resolve({ hash: "" });
      }
      async getEnsAddress() {
        return Promise.resolve({ address: !1 });
      }
      parseUnits() {
        return 0n;
      }
      formatUnits() {
        return "0";
      }
      async getCapabilities() {
        return Promise.resolve({});
      }
      async grantPermissions() {
        return Promise.resolve({});
      }
      async revokePermissions() {
        return Promise.resolve("0x");
      }
      async syncConnection() {
        return Promise.resolve({
          id: "WALLET_CONNECT",
          type: "WALLET_CONNECT",
          chainId: 1,
          provider: this.provider,
          address: "",
        });
      }
      async switchNetwork(e) {
        const { caipNetwork: r } = e,
          i = this.getWalletConnectConnector();
        if (r.chainNamespace === he.CHAIN.EVM)
          try {
            await i.provider?.request({
              method: "wallet_switchEthereumChain",
              params: [{ chainId: ye(r.id) }],
            });
          } catch (s) {
            if (
              s.code === o0.ERROR_CODE_UNRECOGNIZED_CHAIN_ID ||
              s.code === o0.ERROR_INVALID_CHAIN_ID ||
              s.code === o0.ERROR_CODE_DEFAULT ||
              s?.data?.originalError?.code ===
                o0.ERROR_CODE_UNRECOGNIZED_CHAIN_ID
            )
              try {
                await i.provider?.request({
                  method: "wallet_addEthereumChain",
                  params: [
                    {
                      chainId: ye(r.id),
                      rpcUrls: [r?.rpcUrls.chainDefault?.http],
                      chainName: r.name,
                      nativeCurrency: r.nativeCurrency,
                      blockExplorerUrls: [r.blockExplorers?.default.url],
                    },
                  ],
                });
              } catch {
                throw new Error("Chain is not supported");
              }
          }
        i.provider.setDefaultChain(r.caipNetworkId);
      }
      getWalletConnectProvider() {
        return this.connectors.find(
          (e) => e.type === "WALLET_CONNECT"
        )?.provider;
      }
    }
    class ile {
      constructor(e) {
        (this.chainNamespaces = []),
          (this.reportedAlertErrors = {}),
          (this.getCaipNetwork = (r, i) => {
            if (r) {
              const s = B.getNetworkData(r)?.requestedCaipNetworks?.find(
                (o) => o.id === i
              );
              return (
                s ||
                B.getNetworkData(r)?.caipNetwork ||
                B.getRequestedCaipNetworks(r).filter(
                  (o) => o.chainNamespace === r
                )?.[0]
              );
            }
            return B.state.activeCaipNetwork || this.defaultCaipNetwork;
          }),
          (this.getCaipNetworkId = () => {
            const r = this.getCaipNetwork();
            if (r) return r.id;
          }),
          (this.getCaipNetworks = (r) => B.getCaipNetworks(r)),
          (this.getActiveChainNamespace = () => B.state.activeChain),
          (this.setRequestedCaipNetworks = (r, i) => {
            B.setRequestedCaipNetworks(r, i);
          }),
          (this.getApprovedCaipNetworkIds = () =>
            B.getAllApprovedCaipNetworkIds()),
          (this.getCaipAddress = (r) =>
            B.state.activeChain === r || !r
              ? B.state.activeCaipAddress
              : B.getAccountProp("caipAddress", r)),
          (this.setClientId = (r) => {
            be.setClientId(r);
          }),
          (this.getProvider = (r) => Et.getProvider(r)),
          (this.getProviderType = (r) => Et.getProviderId(r)),
          (this.getPreferredAccountType = (r) =>
            fe.state.preferredAccountTypes?.[r]),
          (this.setCaipAddress = (r, i) => {
            fe.setCaipAddress(r, i);
          }),
          (this.setBalance = (r, i, s) => {
            fe.setBalance(r, i, s);
          }),
          (this.setProfileName = (r, i) => {
            fe.setProfileName(r, i);
          }),
          (this.setProfileImage = (r, i) => {
            fe.setProfileImage(r, i);
          }),
          (this.setUser = (r, i) => {
            fe.setUser(r, i), G.state.enableEmbedded && $e.close();
          }),
          (this.resetAccount = (r) => {
            fe.resetAccount(r);
          }),
          (this.setCaipNetwork = (r) => {
            B.setActiveCaipNetwork(r);
          }),
          (this.setCaipNetworkOfNamespace = (r, i) => {
            B.setChainNetworkData(i, { caipNetwork: r });
          }),
          (this.setAllAccounts = (r, i) => {
            fe.setAllAccounts(r, i), G.setHasMultipleAddresses(r?.length > 1);
          }),
          (this.setStatus = (r, i) => {
            fe.setStatus(r, i),
              oe.isConnected()
                ? de.setConnectionStatus("connected")
                : de.setConnectionStatus("disconnected");
          }),
          (this.getAddressByChainNamespace = (r) =>
            B.getAccountProp("address", r)),
          (this.setConnectors = (r) => {
            const i = [...oe.state.allConnectors, ...r];
            oe.setConnectors(i);
          }),
          (this.fetchIdentity = (r) => be.fetchIdentity(r)),
          (this.getReownName = (r) => oC.getNamesForAddress(r)),
          (this.getConnectors = () => oe.getConnectors()),
          (this.getConnectorImage = (r) => Ut.getConnectorImage(r)),
          (this.setConnectedWalletInfo = (r, i) => {
            const s = Et.getProviderId(i),
              n = r ? { ...r, type: s } : void 0;
            fe.setConnectedWalletInfo(n, i);
          }),
          (this.getIsConnectedState = () => !!B.state.activeCaipAddress),
          (this.addAddressLabel = (r, i, s) => {
            fe.addAddressLabel(r, i, s);
          }),
          (this.removeAddressLabel = (r, i) => {
            fe.removeAddressLabel(r, i);
          }),
          (this.getAddress = (r) =>
            B.state.activeChain === r || !r
              ? fe.state.address
              : B.getAccountProp("address", r)),
          (this.setApprovedCaipNetworksData = (r) =>
            B.setApprovedCaipNetworksData(r)),
          (this.resetNetwork = (r) => {
            B.resetNetwork(r);
          }),
          (this.addConnector = (r) => {
            oe.addConnector(r);
          }),
          (this.resetWcConnection = () => {
            pe.resetWcConnection();
          }),
          (this.setAddressExplorerUrl = (r, i) => {
            fe.setAddressExplorerUrl(r, i);
          }),
          (this.setSmartAccountDeployed = (r, i) => {
            fe.setSmartAccountDeployed(r, i);
          }),
          (this.setSmartAccountEnabledNetworks = (r, i) => {
            B.setSmartAccountEnabledNetworks(r, i);
          }),
          (this.setPreferredAccountType = (r, i) => {
            fe.setPreferredAccountType(r, i);
          }),
          (this.setEIP6963Enabled = (r) => {
            G.setEIP6963Enabled(r);
          }),
          (this.handleUnsafeRPCRequest = () => {
            if (this.isOpen()) {
              if (this.isTransactionStackEmpty()) return;
              this.redirect("ApproveTransaction");
            } else this.open({ view: "ApproveTransaction" });
          }),
          (this.options = e),
          (this.version = e.sdkVersion),
          (this.caipNetworks = this.extendCaipNetworks(e)),
          (this.chainNamespaces = this.getChainNamespacesSet(
            e.adapters,
            this.caipNetworks
          )),
          (this.defaultCaipNetwork = this.extendDefaultCaipNetwork(e)),
          (this.chainAdapters = this.createAdapters(e.adapters)),
          this.initialize(e);
      }
      getChainNamespacesSet(e, r) {
        const i = e?.map((n) => n.namespace).filter((n) => !!n);
        if (i?.length) return [...new Set(i)];
        const s = r?.map((n) => n.chainNamespace);
        return [...new Set(s)];
      }
      async initialize(e) {
        this.initControllers(e),
          await this.initChainAdapters(),
          await this.injectModalUi(),
          this.sendInitializeEvent(e),
          pn.set({ initialized: !0 }),
          await this.syncExistingConnection();
      }
      sendInitializeEvent(e) {
        const { ...r } = e;
        delete r.adapters,
          delete r.universalProvider,
          Se.sendEvent({
            type: "track",
            event: "INITIALIZE",
            properties: {
              ...r,
              networks: e.networks.map((i) => i.id),
              siweConfig: { options: e.siweConfig?.options || {} },
            },
          });
      }
      initControllers(e) {
        this.initializeOptionsController(e),
          this.initializeChainController(e),
          this.initializeThemeController(e),
          this.initializeConnectionController(e),
          this.initializeConnectorController();
      }
      initializeThemeController(e) {
        e.themeMode && Dt.setThemeMode(e.themeMode),
          e.themeVariables && Dt.setThemeVariables(e.themeVariables);
      }
      initializeChainController(e) {
        if (!this.connectionControllerClient || !this.networkControllerClient)
          throw new Error(
            "ConnectionControllerClient and NetworkControllerClient must be set"
          );
        B.initialize(e.adapters ?? [], this.caipNetworks, {
          connectionControllerClient: this.connectionControllerClient,
          networkControllerClient: this.networkControllerClient,
        });
        const r = this.getDefaultNetwork();
        r && B.setActiveCaipNetwork(r);
      }
      initializeConnectionController(e) {
        pe.setWcBasic(e.basic ?? !1);
      }
      initializeConnectorController() {
        oe.initialize(this.chainNamespaces);
      }
      initializeOptionsController(e) {
        G.setDebug(e.debug !== !1),
          G.setEnableWalletConnect(e.enableWalletConnect !== !1),
          G.setEnableWalletGuide(e.enableWalletGuide !== !1),
          G.setEnableWallets(e.enableWallets !== !1),
          G.setEIP6963Enabled(e.enableEIP6963 !== !1),
          G.setEnableNetworkSwitch(e.enableNetworkSwitch !== !1),
          G.setEnableAuthLogger(e.enableAuthLogger !== !1),
          G.setCustomRpcUrls(e.customRpcUrls),
          G.setSdkVersion(e.sdkVersion),
          G.setProjectId(e.projectId),
          G.setEnableEmbedded(e.enableEmbedded),
          G.setAllWallets(e.allWallets),
          G.setIncludeWalletIds(e.includeWalletIds),
          G.setExcludeWalletIds(e.excludeWalletIds),
          G.setFeaturedWalletIds(e.featuredWalletIds),
          G.setTokens(e.tokens),
          G.setTermsConditionsUrl(e.termsConditionsUrl),
          G.setPrivacyPolicyUrl(e.privacyPolicyUrl),
          G.setCustomWallets(e.customWallets),
          G.setFeatures(e.features),
          G.setAllowUnsupportedChain(e.allowUnsupportedChain),
          G.setUniversalProviderConfigOverride(
            e.universalProviderConfigOverride
          ),
          G.setDefaultAccountTypes(e.defaultAccountTypes);
        const r = de.getPreferredAccountTypes(),
          i = { ...G.state.defaultAccountTypes, ...r };
        fe.setPreferredAccountTypes(i);
        const s = this.getDefaultMetaData();
        if (
          (!e.metadata && s && (e.metadata = s),
          G.setMetadata(e.metadata),
          G.setDisableAppend(e.disableAppend),
          G.setEnableEmbedded(e.enableEmbedded),
          G.setSIWX(e.siwx),
          !e.projectId)
        ) {
          ro.open(e0.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, "error");
          return;
        }
        if (
          e.adapters?.find((n) => n.namespace === he.CHAIN.EVM) &&
          e.siweConfig
        ) {
          if (e.siwx)
            throw new Error("Cannot set both `siweConfig` and `siwx` options");
          G.setSIWX(e.siweConfig.mapToSIWX());
        }
      }
      getDefaultMetaData() {
        return typeof window < "u" && typeof document < "u"
          ? {
              name:
                document.getElementsByTagName("title")?.[0]?.textContent || "",
              description:
                document.querySelector('meta[property="og:description"]')
                  ?.content || "",
              url: window.location.origin,
              icons: [document.querySelector('link[rel~="icon"]')?.href || ""],
            }
          : null;
      }
      setUnsupportedNetwork(e) {
        const r = this.getActiveChainNamespace();
        if (r) {
          const i = Dl.getUnsupportedNetwork(`${r}:${e}`);
          B.setActiveCaipNetwork(i);
        }
      }
      getDefaultNetwork() {
        return Dl.getCaipNetworkFromStorage(this.defaultCaipNetwork);
      }
      extendCaipNetwork(e, r) {
        return Dl.extendCaipNetwork(e, {
          customNetworkImageUrls: r.chainImages,
          projectId: r.projectId,
        });
      }
      extendCaipNetworks(e) {
        return Dl.extendCaipNetworks(e.networks, {
          customNetworkImageUrls: e.chainImages,
          customRpcUrls: e.customRpcUrls,
          projectId: e.projectId,
        });
      }
      extendDefaultCaipNetwork(e) {
        const r = e.networks.find((i) => i.id === e.defaultNetwork?.id);
        return r
          ? Dl.extendCaipNetwork(r, {
              customNetworkImageUrls: e.chainImages,
              customRpcUrls: e.customRpcUrls,
              projectId: e.projectId,
            })
          : void 0;
      }
      createClients() {
        (this.connectionControllerClient = {
          connectWalletConnect: async () => {
            const e = B.state.activeChain,
              r = this.getAdapter(e),
              i = this.getCaipNetwork(e)?.id;
            if (!r) throw new Error("Adapter not found");
            const s = await r.connectWalletConnect(i);
            this.close(),
              this.setClientId(s?.clientId || null),
              de.setConnectedNamespaces([...B.state.chains.keys()]),
              this.chainNamespaces.forEach((n) => {
                oe.setConnectorId(zt.CONNECTOR_TYPE_WALLET_CONNECT, n);
              }),
              await this.syncWalletConnectAccount();
          },
          connectExternal: async ({
            id: e,
            info: r,
            type: i,
            provider: s,
            chain: n,
            caipNetwork: o,
          }) => {
            const a = B.state.activeChain,
              c = n || a,
              l = this.getAdapter(c);
            if (n && n !== a && !o) {
              const g = this.getCaipNetworks().find(
                (p) => p.chainNamespace === n
              );
              g && this.setCaipNetwork(g);
            }
            if (!l) throw new Error("Adapter not found");
            const u = this.getCaipNetwork(c),
              h = await l.connect({
                id: e,
                info: r,
                type: i,
                provider: s,
                chainId: o?.id || u?.id,
                rpcUrl:
                  o?.rpcUrls?.default?.http?.[0] ||
                  u?.rpcUrls?.default?.http?.[0],
              });
            if (!h) return;
            de.addConnectedNamespace(c),
              this.syncProvider({ ...h, chainNamespace: c });
            const { accounts: d } = await l.getAccounts({
              namespace: c,
              id: e,
            });
            this.setAllAccounts(d, c), this.setStatus("connected", c);
          },
          reconnectExternal: async ({
            id: e,
            info: r,
            type: i,
            provider: s,
          }) => {
            const n = B.state.activeChain,
              o = this.getAdapter(n);
            o?.reconnect &&
              (await o?.reconnect({
                id: e,
                info: r,
                type: i,
                provider: s,
                chainId: this.getCaipNetwork()?.id,
              }),
              de.addConnectedNamespace(n));
          },
          disconnect: async (e) => {
            const r = e || B.state.activeChain,
              i = this.getAdapter(r),
              s = Et.getProvider(r),
              n = Et.getProviderId(r);
            await i?.disconnect({ provider: s, providerType: n }),
              de.removeConnectedNamespace(r),
              Et.resetChain(r),
              this.setUser(void 0, r),
              this.setStatus("disconnected", r);
          },
          checkInstalled: (e) =>
            e
              ? e.some((r) => !!window.ethereum?.[String(r)])
              : !!window.ethereum,
          signMessage: async (e) =>
            (
              await this.getAdapter(B.state.activeChain)?.signMessage({
                message: e,
                address: fe.state.address,
                provider: Et.getProvider(B.state.activeChain),
              })
            )?.signature || "",
          sendTransaction: async (e) => {
            if (e.chainNamespace === he.CHAIN.EVM) {
              const r = this.getAdapter(B.state.activeChain),
                i = Et.getProvider(B.state.activeChain);
              return (
                (
                  await r?.sendTransaction({
                    ...e,
                    caipNetwork: this.getCaipNetwork(),
                    provider: i,
                  })
                )?.hash || ""
              );
            }
            return "";
          },
          estimateGas: async (e) => {
            if (e.chainNamespace === he.CHAIN.EVM) {
              const r = this.getAdapter(B.state.activeChain),
                i = Et.getProvider(B.state.activeChain),
                s = this.getCaipNetwork();
              if (!s) throw new Error("CaipNetwork is undefined");
              return (
                (await r?.estimateGas({ ...e, provider: i, caipNetwork: s }))
                  ?.gas || 0n
              );
            }
            return 0n;
          },
          getEnsAvatar: async () =>
            (
              await this.getAdapter(B.state.activeChain)?.getProfile({
                address: fe.state.address,
                chainId: Number(this.getCaipNetwork()?.id),
              })
            )?.profileImage || !1,
          getEnsAddress: async (e) => {
            const r = this.getAdapter(B.state.activeChain),
              i = this.getCaipNetwork();
            return (
              (i &&
                (await r?.getEnsAddress({ name: e, caipNetwork: i }))
                  ?.address) ||
              !1
            );
          },
          writeContract: async (e) => {
            const r = this.getAdapter(B.state.activeChain),
              i = this.getCaipNetwork(),
              s = this.getCaipAddress(),
              n = Et.getProvider(B.state.activeChain);
            if (!i || !s)
              throw new Error("CaipNetwork or CaipAddress is undefined");
            return (
              await r?.writeContract({
                ...e,
                caipNetwork: i,
                provider: n,
                caipAddress: s,
              })
            )?.hash;
          },
          parseUnits: (e, r) =>
            this.getAdapter(B.state.activeChain)?.parseUnits({
              value: e,
              decimals: r,
            }) ?? 0n,
          formatUnits: (e, r) =>
            this.getAdapter(B.state.activeChain)?.formatUnits({
              value: e,
              decimals: r,
            }) ?? "0",
          getCapabilities: async (e) =>
            await this.getAdapter(B.state.activeChain)?.getCapabilities(e),
          grantPermissions: async (e) =>
            await this.getAdapter(B.state.activeChain)?.grantPermissions(e),
          revokePermissions: async (e) => {
            const r = this.getAdapter(B.state.activeChain);
            return r?.revokePermissions ? await r.revokePermissions(e) : "0x";
          },
          walletGetAssets: async (e) =>
            (await this.getAdapter(B.state.activeChain)?.walletGetAssets(e)) ??
            {},
        }),
          (this.networkControllerClient = {
            switchCaipNetwork: async (e) => await this.switchCaipNetwork(e),
            getApprovedCaipNetworksData: async () =>
              this.getApprovedCaipNetworksData(),
          }),
          pe.setClient(this.connectionControllerClient);
      }
      getApprovedCaipNetworksData() {
        if (
          Et.getProviderId(B.state.activeChain) ===
          zt.CONNECTOR_TYPE_WALLET_CONNECT
        ) {
          const e = this.universalProvider?.session?.namespaces;
          return {
            supportsAllNetworks:
              this.universalProvider?.session?.peer?.metadata.name ===
              "MetaMask Wallet",
            approvedCaipNetworkIds: this.getChainsFromNamespaces(e),
          };
        }
        return { supportsAllNetworks: !0, approvedCaipNetworkIds: [] };
      }
      async switchCaipNetwork(e) {
        if (!e) return;
        const r = e.chainNamespace;
        if (this.getAddressByChainNamespace(e.chainNamespace)) {
          const i = Et.getProvider(r),
            s = Et.getProviderId(r);
          if (e.chainNamespace === B.state.activeChain)
            await this.getAdapter(r)?.switchNetwork({
              caipNetwork: e,
              provider: i,
              providerType: s,
            });
          else if (
            (this.setCaipNetwork(e), s === zt.CONNECTOR_TYPE_WALLET_CONNECT)
          )
            this.syncWalletConnectAccount();
          else {
            const n = this.getAddressByChainNamespace(r);
            n &&
              this.syncAccount({
                address: n,
                chainId: e.id,
                chainNamespace: r,
              });
          }
        } else this.setCaipNetwork(e);
      }
      getChainsFromNamespaces(e = {}) {
        return Object.values(e).flatMap((r) => {
          const i = r.chains || [],
            s = r.accounts.map((n) => {
              const { chainId: o, chainNamespace: a } = Xn.parseCaipAddress(n);
              return `${a}:${o}`;
            });
          return Array.from(new Set([...i, ...s]));
        });
      }
      createAdapters(e) {
        return (
          this.createClients(),
          this.chainNamespaces.reduce((r, i) => {
            const s = e?.find((n) => n.namespace === i);
            return (
              s
                ? (s.construct({
                    namespace: i,
                    projectId: this.options?.projectId,
                    networks: this.getCaipNetworks(),
                  }),
                  (r[i] = s))
                : (r[i] = new rle({
                    namespace: i,
                    networks: this.getCaipNetworks(),
                  })),
              r
            );
          }, {})
        );
      }
      async initChainAdapter(e) {
        this.onConnectors(e),
          this.listenAdapter(e),
          this.chainAdapters?.[e].syncConnectors(this.options, this),
          await this.createUniversalProviderForAdapter(e);
      }
      async initChainAdapters() {
        await Promise.all(
          this.chainNamespaces.map(async (e) => {
            await this.initChainAdapter(e);
          })
        );
      }
      onConnectors(e) {
        this.getAdapter(e)?.on("connectors", this.setConnectors.bind(this));
      }
      listenAdapter(e) {
        const r = this.getAdapter(e);
        if (!r) return;
        const i = de.getConnectionStatus();
        i === "connected"
          ? this.setStatus("connecting", e)
          : i === "disconnected"
          ? (de.clearAddressCache(), this.setStatus(i, e))
          : this.setStatus(i, e),
          r.on("switchNetwork", ({ address: s, chainId: n }) => {
            const o = this.getCaipNetworks().find(
                (l) => l.id === n || l.caipNetworkId === n
              ),
              a = B.state.activeChain === e,
              c = B.getAccountProp("address", e);
            if (o) {
              const l = a && s ? s : c;
              l &&
                this.syncAccount({
                  address: l,
                  chainId: o.id,
                  chainNamespace: e,
                });
            } else this.setUnsupportedNetwork(n);
          }),
          r.on("disconnect", this.disconnect.bind(this, e)),
          r.on("pendingTransactions", () => {
            const s = fe.state.address,
              n = B.state.activeCaipNetwork;
            !s || !n?.id || this.updateNativeBalance(s, n.id, n.chainNamespace);
          }),
          r.on("accountChanged", ({ address: s, chainId: n }) => {
            const o = B.state.activeChain === e;
            o && n
              ? this.syncAccount({ address: s, chainId: n, chainNamespace: e })
              : o && B.state.activeCaipNetwork?.id
              ? this.syncAccount({
                  address: s,
                  chainId: B.state.activeCaipNetwork?.id,
                  chainNamespace: e,
                })
              : this.syncAccountInfo(s, n, e);
          });
      }
      async createUniversalProviderForAdapter(e) {
        await this.getUniversalProvider(),
          this.universalProvider &&
            this.chainAdapters?.[e]?.setUniversalProvider?.(
              this.universalProvider
            );
      }
      async syncExistingConnection() {
        await Promise.allSettled(
          this.chainNamespaces.map((e) => this.syncNamespaceConnection(e))
        );
      }
      async syncNamespaceConnection(e) {
        try {
          const r = oe.getConnectorId(e);
          switch ((this.setStatus("connecting", e), r)) {
            case he.CONNECTOR_ID.WALLET_CONNECT:
              await this.syncWalletConnectAccount();
              break;
            case he.CONNECTOR_ID.AUTH:
              break;
            default:
              await this.syncAdapterConnection(e);
          }
        } catch (r) {
          console.warn("AppKit couldn't sync existing connection", r),
            this.setStatus("disconnected", e);
        }
      }
      async syncAdapterConnection(e) {
        const r = this.getAdapter(e),
          i = oe.getConnectorId(e),
          s = this.getCaipNetwork(e),
          n = oe.getConnectors(e).find((o) => o.id === i);
        try {
          if (!r || !n)
            throw new Error(
              `Adapter or connector not found for namespace ${e}`
            );
          if (!s?.id) throw new Error("CaipNetwork not found");
          const o = await r?.syncConnection({
            namespace: e,
            id: n.id,
            chainId: s.id,
            rpcUrl: s?.rpcUrls?.default?.http?.[0],
          });
          if (o) {
            const a = await r?.getAccounts({ namespace: e, id: n.id });
            a && a.accounts.length > 0
              ? this.setAllAccounts(a.accounts, e)
              : this.setAllAccounts([X.createAccount(e, o.address, "eoa")], e),
              this.syncProvider({ ...o, chainNamespace: e }),
              await this.syncAccount({ ...o, chainNamespace: e }),
              this.setStatus("connected", e);
          } else this.setStatus("disconnected", e);
        } catch {
          this.setStatus("disconnected", e);
        }
      }
      async syncWalletConnectAccount() {
        const e = this.chainNamespaces.map(async (r) => {
          const i = this.getAdapter(r),
            s =
              this.universalProvider?.session?.namespaces?.[r]?.accounts || [],
            n = B.state.activeCaipNetwork?.id,
            o =
              s.find((a) => {
                const { chainId: c } = Xn.parseCaipAddress(a);
                return c === n?.toString();
              }) || s[0];
          if (o) {
            const a = Xn.validateCaipAddress(o),
              { chainId: c, address: l } = Xn.parseCaipAddress(a);
            if (
              (Et.setProviderId(r, zt.CONNECTOR_TYPE_WALLET_CONNECT),
              this.caipNetworks &&
                B.state.activeCaipNetwork &&
                i?.namespace !== he.CHAIN.EVM)
            ) {
              const u = i?.getWalletConnectProvider({
                caipNetworks: this.getCaipNetworks(),
                provider: this.universalProvider,
                activeCaipNetwork: B.state.activeCaipNetwork,
              });
              Et.setProvider(r, u);
            } else Et.setProvider(r, this.universalProvider);
            oe.setConnectorId(he.CONNECTOR_ID.WALLET_CONNECT, r),
              de.addConnectedNamespace(r),
              this.syncWalletConnectAccounts(r),
              await this.syncAccount({
                address: l,
                chainId: c,
                chainNamespace: r,
              });
          } else this.setStatus("disconnected", r);
          await B.setApprovedCaipNetworksData(r);
        });
        await Promise.all(e);
      }
      syncWalletConnectAccounts(e) {
        const r = this.universalProvider?.session?.namespaces?.[e]?.accounts
          ?.map((i) => {
            const { address: s } = Xn.parseCaipAddress(i);
            return s;
          })
          .filter((i, s, n) => n.indexOf(i) === s);
        r &&
          this.setAllAccounts(
            r.map((i) =>
              X.createAccount(e, i, e === "bip122" ? "payment" : "eoa")
            ),
            e
          );
      }
      syncProvider({ type: e, provider: r, id: i, chainNamespace: s }) {
        Et.setProviderId(s, e), Et.setProvider(s, r), oe.setConnectorId(i, s);
      }
      async syncAccount(e) {
        const r = e.chainNamespace === B.state.activeChain,
          i = B.getCaipNetworkByNamespace(e.chainNamespace, e.chainId),
          { address: s, chainId: n, chainNamespace: o } = e,
          { chainId: a } = de.getActiveNetworkProps(),
          c = n || a,
          l = B.state.activeCaipNetwork?.name === he.UNSUPPORTED_NETWORK_NAME,
          u = B.getNetworkProp("supportsAllNetworks", o);
        if ((this.setStatus("connected", o), !(l && !u) && c)) {
          let h = this.getCaipNetworks().find(
              (p) => p.id.toString() === c.toString()
            ),
            d = this.getCaipNetworks().find((p) => p.chainNamespace === o);
          if (!u && !h && !d) {
            const p = this.getApprovedCaipNetworkIds() || [],
              w = p.find(
                (m) => Xn.parseCaipNetworkId(m)?.chainId === c.toString()
              ),
              f = p.find((m) => Xn.parseCaipNetworkId(m)?.chainNamespace === o);
            (h = this.getCaipNetworks().find((m) => m.caipNetworkId === w)),
              (d = this.getCaipNetworks().find(
                (m) =>
                  m.caipNetworkId === f ||
                  ("deprecatedCaipNetworkId" in m &&
                    m.deprecatedCaipNetworkId === f)
              ));
          }
          const g = h || d;
          g?.chainNamespace === B.state.activeChain
            ? G.state.enableNetworkSwitch &&
              !G.state.allowUnsupportedChain &&
              B.state.activeCaipNetwork?.name === he.UNSUPPORTED_NETWORK_NAME
              ? B.showUnsupportedChainUI()
              : this.setCaipNetwork(g)
            : r || (i && this.setCaipNetworkOfNamespace(i, o)),
            this.syncConnectedWalletInfo(o),
            Xy.isLowerCaseMatch(s, fe.state.address) ||
              this.syncAccountInfo(s, g?.id, o),
            r
              ? await this.syncBalance({
                  address: s,
                  chainId: g?.id,
                  chainNamespace: o,
                })
              : await this.syncBalance({
                  address: s,
                  chainId: i?.id,
                  chainNamespace: o,
                });
        }
      }
      async syncAccountInfo(e, r, i) {
        const s = this.getCaipAddress(i),
          n = r || s?.split(":")[1];
        if (!n) return;
        const o = `${i}:${n}:${e}`;
        this.setCaipAddress(o, i),
          await this.syncIdentity({
            address: e,
            chainId: n,
            chainNamespace: i,
          });
      }
      async syncReownName(e, r) {
        try {
          const i = await this.getReownName(e);
          if (i[0]) {
            const s = i[0];
            this.setProfileName(s.name, r);
          } else this.setProfileName(null, r);
        } catch {
          this.setProfileName(null, r);
        }
      }
      syncConnectedWalletInfo(e) {
        const r = oe.getConnectorId(e),
          i = Et.getProviderId(e);
        if (
          i === zt.CONNECTOR_TYPE_ANNOUNCED ||
          i === zt.CONNECTOR_TYPE_INJECTED
        ) {
          if (r) {
            const s = this.getConnectors().find((n) => n.id === r);
            if (s) {
              const { info: n, name: o, imageUrl: a } = s,
                c = a || this.getConnectorImage(s);
              this.setConnectedWalletInfo({ name: o, icon: c, ...n }, e);
            }
          }
        } else if (i === zt.CONNECTOR_TYPE_WALLET_CONNECT) {
          const s = Et.getProvider(e);
          s?.session &&
            this.setConnectedWalletInfo(
              {
                ...s.session.peer.metadata,
                name: s.session.peer.metadata.name,
                icon: s.session.peer.metadata.icons?.[0],
              },
              e
            );
        } else if (r)
          if (r === he.CONNECTOR_ID.COINBASE) {
            const s = this.getConnectors().find(
              (n) => n.id === he.CONNECTOR_ID.COINBASE
            );
            this.setConnectedWalletInfo(
              { name: "Coinbase Wallet", icon: this.getConnectorImage(s) },
              e
            );
          } else this.setConnectedWalletInfo({ name: r }, e);
      }
      async syncBalance(e) {
        !X8.getNetworksByNamespace(
          this.getCaipNetworks(),
          e.chainNamespace
        ).find((r) => r.id.toString() === e.chainId?.toString()) ||
          !e.chainId ||
          (await this.updateNativeBalance(
            e.address,
            e.chainId,
            e.chainNamespace
          ));
      }
      async updateNativeBalance(e, r, i) {
        const s = this.getAdapter(i),
          n = B.getCaipNetworkByNamespace(i, r);
        if (s) {
          const o = await s.getBalance({
            address: e,
            chainId: r,
            caipNetwork: n,
            tokens: this.options.tokens,
          });
          this.setBalance(o.balance, o.symbol, i);
        }
      }
      async initializeUniversalAdapter() {
        const e = hce.createLogger((i, ...s) => {
            i && this.handleAlertError(i), console.error(...s);
          }),
          r = {
            projectId: this.options?.projectId,
            metadata: {
              name: this.options?.metadata ? this.options?.metadata.name : "",
              description: this.options?.metadata
                ? this.options?.metadata.description
                : "",
              url: this.options?.metadata ? this.options?.metadata.url : "",
              icons: this.options?.metadata
                ? this.options?.metadata.icons
                : [""],
            },
            logger: e,
          };
        G.setManualWCControl(!!this.options?.manualWCControl),
          (this.universalProvider =
            this.options.universalProvider ?? (await Jy.init(r))),
          this.listenWalletConnect();
      }
      listenWalletConnect() {
        this.universalProvider &&
          (this.universalProvider.on("display_uri", (e) => {
            pe.setUri(e);
          }),
          this.universalProvider.on("connect", pe.finalizeWcConnection),
          this.universalProvider.on("disconnect", () => {
            this.chainNamespaces.forEach((e) => {
              this.resetAccount(e);
            }),
              pe.resetWcConnection();
          }),
          this.universalProvider.on("chainChanged", (e) => {
            const r = this.getCaipNetworks().find((s) => s.id == e),
              i = this.getCaipNetwork();
            if (!r) {
              this.setUnsupportedNetwork(e);
              return;
            }
            i?.id !== r?.id && this.setCaipNetwork(r);
          }),
          this.universalProvider.on("session_event", (e) => {
            if (VI.isSessionEventData(e)) {
              const { name: r, data: i } = e.params.event;
              r === "accountsChanged" &&
                Array.isArray(i) &&
                X.isCaipAddress(i[0]) &&
                this.syncAccount(Xn.parseCaipAddress(i[0]));
            }
          }));
      }
      createUniversalProvider() {
        return (
          !this.universalProviderInitPromise &&
            X.isClient() &&
            this.options?.projectId &&
            (this.universalProviderInitPromise =
              this.initializeUniversalAdapter()),
          this.universalProviderInitPromise
        );
      }
      async getUniversalProvider() {
        if (!this.universalProvider)
          try {
            await this.createUniversalProvider();
          } catch (e) {
            Se.sendEvent({
              type: "error",
              event: "INTERNAL_SDK_ERROR",
              properties: {
                errorType: "UniversalProviderInitError",
                errorMessage: e instanceof Error ? e.message : "Unknown",
                uncaught: !1,
              },
            }),
              console.error(
                "AppKit:getUniversalProvider - Cannot create provider",
                e
              );
          }
        return this.universalProvider;
      }
      handleAlertError(e) {
        const r = Object.entries(e0.UniversalProviderErrors).find(
            ([, { message: a }]) => e.message.includes(a)
          ),
          [i, s] = r ?? [],
          { message: n, alertErrorKey: o } = s ?? {};
        if (i && n && !this.reportedAlertErrors[i]) {
          const a = e0.ALERT_ERRORS[o];
          a && (ro.open(a, "error"), (this.reportedAlertErrors[i] = !0));
        }
      }
      getAdapter(e) {
        if (e) return this.chainAdapters?.[e];
      }
      createAdapter(e) {
        if (!e) return;
        const r = e.namespace;
        if (!r) return;
        this.createClients();
        const i = e;
        (i.namespace = r),
          i.construct({
            namespace: r,
            projectId: this.options?.projectId,
            networks: this.getCaipNetworks(),
          }),
          this.chainNamespaces.includes(r) || this.chainNamespaces.push(r),
          this.chainAdapters && (this.chainAdapters[r] = i);
      }
      async open(e) {
        if (
          (await this.injectModalUi(), e?.uri && pe.setUri(e.uri), e?.arguments)
        )
          switch (e?.view) {
            case "Swap":
              return $e.open({ ...e, data: { swap: e.arguments } });
          }
        return $e.open(e);
      }
      async close() {
        await this.injectModalUi(), $e.close();
      }
      setLoading(e, r) {
        $e.setLoading(e, r);
      }
      async disconnect(e) {
        await pe.disconnect(e);
      }
      getError() {
        return "";
      }
      getChainId() {
        return B.state.activeCaipNetwork?.id;
      }
      async switchNetwork(e) {
        const r = this.getCaipNetworks().find((i) => i.id === e.id);
        if (!r) {
          ro.open(e0.ALERT_ERRORS.SWITCH_NETWORK_NOT_FOUND, "error");
          return;
        }
        await B.switchActiveNetwork(r);
      }
      getWalletProvider() {
        return B.state.activeChain
          ? Et.state.providers[B.state.activeChain]
          : null;
      }
      getWalletProviderType() {
        return Et.getProviderId(B.state.activeChain);
      }
      subscribeProviders(e) {
        return Et.subscribeProviders(e);
      }
      getThemeMode() {
        return Dt.state.themeMode;
      }
      getThemeVariables() {
        return Dt.state.themeVariables;
      }
      setThemeMode(e) {
        Dt.setThemeMode(e), FI(Dt.state.themeMode);
      }
      setTermsConditionsUrl(e) {
        G.setTermsConditionsUrl(e);
      }
      setPrivacyPolicyUrl(e) {
        G.setPrivacyPolicyUrl(e);
      }
      setThemeVariables(e) {
        Dt.setThemeVariables(e), $ce(Dt.state.themeVariables);
      }
      subscribeTheme(e) {
        return Dt.subscribe(e);
      }
      getWalletInfo() {
        return fe.state.connectedWalletInfo;
      }
      getAccount(e) {
        const r = oe.getAuthConnector(e),
          i = B.getAccountData(e),
          s = B.state.activeChain;
        if (i)
          return {
            allAccounts: i.allAccounts,
            caipAddress: i.caipAddress,
            address: X.getPlainAddress(i.caipAddress),
            isConnected: !!i.caipAddress,
            status: i.status,
            embeddedWalletInfo: r
              ? {
                  user: i.user
                    ? { ...i.user, username: de.getConnectedSocialUsername() }
                    : void 0,
                  authProvider: i.socialProvider || "email",
                  accountType: i.preferredAccountTypes?.[e || s],
                  isSmartAccountDeployed: !!i.smartAccountDeployed,
                }
              : void 0,
          };
      }
      subscribeAccount(e, r) {
        const i = () => {
          const s = this.getAccount(r);
          s && e(s);
        };
        r ? B.subscribeChainProp("accountState", i, r) : B.subscribe(i),
          oe.subscribe(i);
      }
      subscribeNetwork(e) {
        return B.subscribe(({ activeCaipNetwork: r }) => {
          e({
            caipNetwork: r,
            chainId: r?.id,
            caipNetworkId: r?.caipNetworkId,
          });
        });
      }
      subscribeWalletInfo(e) {
        return fe.subscribeKey("connectedWalletInfo", e);
      }
      subscribeShouldUpdateToAddress(e) {
        fe.subscribeKey("shouldUpdateToAddress", e);
      }
      subscribeCaipNetworkChange(e) {
        B.subscribeKey("activeCaipNetwork", e);
      }
      getState() {
        return pn.state;
      }
      subscribeState(e) {
        return pn.subscribe(e);
      }
      showErrorMessage(e) {
        at.showError(e);
      }
      showSuccessMessage(e) {
        at.showSuccess(e);
      }
      getEvent() {
        return { ...Se.state };
      }
      subscribeEvents(e) {
        return Se.subscribe(e);
      }
      replace(e) {
        ie.replace(e);
      }
      redirect(e) {
        ie.push(e);
      }
      popTransactionStack(e) {
        ie.popTransactionStack(e);
      }
      isOpen() {
        return $e.state.open;
      }
      isTransactionStackEmpty() {
        return ie.state.transactionStack.length === 0;
      }
      isTransactionShouldReplaceView() {
        return ie
          .state.transactionStack[ie.state.transactionStack.length - 1]?.replace;
      }
      static getInstance() {
        return this.instance;
      }
      updateFeatures(e) {
        G.setFeatures(e);
      }
      updateOptions(e) {
        const r = { ...(G.state || {}), ...e };
        G.setOptions(r);
      }
      setConnectMethodsOrder(e) {
        G.setConnectMethodsOrder(e);
      }
      setWalletFeaturesOrder(e) {
        G.setWalletFeaturesOrder(e);
      }
      setCollapseWallets(e) {
        G.setCollapseWallets(e);
      }
      setSocialsOrder(e) {
        G.setSocialsOrder(e);
      }
      getConnectMethodsOrder() {
        return _a.getConnectOrderMethod(G.state.features, oe.getConnectors());
      }
      addNetwork(e, r) {
        if (this.chainAdapters && !this.chainAdapters[e])
          throw new Error(`Adapter for namespace ${e} doesn't exist`);
        const i = this.extendCaipNetwork(r, this.options);
        this.getCaipNetworks().find((s) => s.id === i.id) || B.addNetwork(i);
      }
      removeNetwork(e, r) {
        if (this.chainAdapters && !this.chainAdapters[e])
          throw new Error(`Adapter for namespace ${e} doesn't exist`);
        this.getCaipNetworks().find((i) => i.id === r) && B.removeNetwork(e, r);
      }
    }
    let KI = !1;
    class GI extends ile {
      async open(e) {
        oe.isConnected() || (await super.open(e));
      }
      async close() {
        await super.close(),
          this.options.manualWCControl && pe.finalizeWcConnection();
      }
      async syncIdentity(e) {
        return Promise.resolve();
      }
      async syncBalance(e) {
        return Promise.resolve();
      }
      async injectModalUi() {
        if (!KI && X.isClient()) {
          if (
            (await Promise.resolve().then(function () {
              return fhe;
            }),
            await Promise.resolve().then(function () {
              return Nhe;
            }),
            !document.querySelector("w3m-modal"))
          ) {
            const e = document.createElement("w3m-modal");
            !G.state.disableAppend &&
              !G.state.enableEmbedded &&
              document.body.insertAdjacentElement("beforeend", e);
          }
          KI = !0;
        }
      }
    }
    const sle = "1.7.3";
    function nle(t) {
      return new GI({ ...t, basic: !0, sdkVersion: `html-core-${sle}` });
    }
    var ole = Object.freeze({ __proto__: null, createAppKit: nle, AppKit: GI }),
      ale = Object.defineProperty,
      cle = Object.defineProperties,
      lle = Object.getOwnPropertyDescriptors,
      ZI = Object.getOwnPropertySymbols,
      ule = Object.prototype.hasOwnProperty,
      hle = Object.prototype.propertyIsEnumerable,
      YI = (t, e, r) =>
        e in t
          ? ale(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (t[e] = r),
      JI = (t, e) => {
        for (var r in e || (e = {})) ule.call(e, r) && YI(t, r, e[r]);
        if (ZI) for (var r of ZI(e)) hle.call(e, r) && YI(t, r, e[r]);
        return t;
      },
      dle = (t, e) => cle(t, lle(e));
    function ple(t) {
      if (t)
        return {
          "--w3m-font-family": t["--wcm-font-family"],
          "--w3m-accent": t["--wcm-accent-color"],
          "--w3m-color-mix": t["--wcm-background-color"],
          "--w3m-z-index": t["--wcm-z-index"]
            ? Number(t["--wcm-z-index"])
            : void 0,
          "--w3m-qr-color": t["--wcm-accent-color"],
          "--w3m-font-size-master": t["--wcm-text-medium-regular-size"],
          "--w3m-border-radius-master": t["--wcm-container-border-radius"],
          "--w3m-color-mix-strength": 0,
        };
    }
    const fle = (t) => {
      const [e, r] = t.split(":");
      return XI({
        id: r,
        caipNetworkId: t,
        chainNamespace: e,
        name: "",
        nativeCurrency: { name: "", symbol: "", decimals: 8 },
        rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
      });
    };
    function gle(t) {
      var e, r, i, s, n, o, a;
      const c = (e = t.chains) == null ? void 0 : e.map(fle).filter(Boolean);
      if (c.length === 0)
        throw new Error("At least one chain must be specified");
      const l = c.find((h) => {
          var d;
          return h.id === ((d = t.defaultChain) == null ? void 0 : d.id);
        }),
        u = {
          projectId: t.projectId,
          networks: c,
          themeMode: t.themeMode,
          themeVariables: ple(t.themeVariables),
          chainImages: t.chainImages,
          connectorImages: t.walletImages,
          defaultNetwork: l,
          metadata: dle(JI({}, t.metadata), {
            name:
              ((r = t.metadata) == null ? void 0 : r.name) || "WalletConnect",
            description:
              ((i = t.metadata) == null ? void 0 : i.description) ||
              "Connect to WalletConnect-compatible wallets",
            url:
              ((s = t.metadata) == null ? void 0 : s.url) ||
              "https://walletconnect.org",
            icons: ((n = t.metadata) == null ? void 0 : n.icons) || [
              "https://walletconnect.org/walletconnect-logo.png",
            ],
          }),
          showWallets: !0,
          featuredWalletIds:
            t.explorerRecommendedWalletIds === "NONE"
              ? []
              : Array.isArray(t.explorerRecommendedWalletIds)
              ? t.explorerRecommendedWalletIds
              : [],
          excludeWalletIds:
            t.explorerExcludedWalletIds === "ALL"
              ? []
              : Array.isArray(t.explorerExcludedWalletIds)
              ? t.explorerExcludedWalletIds
              : [],
          enableEIP6963: !1,
          enableInjected: !1,
          enableCoinbase: !0,
          enableWalletConnect: !0,
          features: { email: !1, socials: !1 },
        };
      if (
        ((o = t.mobileWallets) != null && o.length) ||
        ((a = t.desktopWallets) != null && a.length)
      ) {
        const h = [
            ...(t.mobileWallets || []).map((p) => ({
              id: p.id,
              name: p.name,
              links: p.links,
            })),
            ...(t.desktopWallets || []).map((p) => ({
              id: p.id,
              name: p.name,
              links: { native: p.links.native, universal: p.links.universal },
            })),
          ],
          d = [...(u.featuredWalletIds || []), ...(u.excludeWalletIds || [])],
          g = h.filter((p) => !d.includes(p.id));
        g.length && (u.customWallets = g);
      }
      return u;
    }
    function XI(t) {
      return JI({ formatters: void 0, fees: void 0, serializers: void 0 }, t);
    }
    var wle = Object.freeze({
      __proto__: null,
      convertWCMToAppKitOptions: gle,
      defineChain: XI,
    });
    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */ const mle = {
        attribute: !0,
        type: String,
        converter: i0,
        reflect: !1,
        hasChanged: rb,
      },
      yle = (t = mle, e, r) => {
        const { kind: i, metadata: s } = r;
        let n = globalThis.litPropertyMetadata.get(s);
        if (
          (n === void 0 &&
            globalThis.litPropertyMetadata.set(s, (n = new Map())),
          i === "setter" && ((t = Object.create(t)).wrapped = !0),
          n.set(r.name, t),
          i === "accessor")
        ) {
          const { name: o } = r;
          return {
            set(a) {
              const c = e.get.call(this);
              e.set.call(this, a), this.requestUpdate(o, c, t);
            },
            init(a) {
              return a !== void 0 && this.C(o, void 0, t, a), a;
            },
          };
        }
        if (i === "setter") {
          const { name: o } = r;
          return function (a) {
            const c = this[o];
            e.call(this, a), this.requestUpdate(o, c, t);
          };
        }
        throw Error("Unsupported decorator location: " + i);
      };
    function M(t) {
      return (e, r) =>
        typeof r == "object"
          ? yle(t, e, r)
          : ((i, s, n) => {
              const o = s.hasOwnProperty(n);
              return (
                s.constructor.createProperty(n, i),
                o ? Object.getOwnPropertyDescriptor(s, n) : void 0
              );
            })(t, e, r);
    }
    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */ function le(t) {
      return M({ ...t, state: !0, attribute: !1 });
    }
    var ble = ge`
  :host {
    display: flex;
    width: inherit;
    height: inherit;
  }
`,
      Ai = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let zr = class extends ue {
      render() {
        return (
          (this.style.cssText = `
      flex-direction: ${this.flexDirection};
      flex-wrap: ${this.flexWrap};
      flex-basis: ${this.flexBasis};
      flex-grow: ${this.flexGrow};
      flex-shrink: ${this.flexShrink};
      align-items: ${this.alignItems};
      justify-content: ${this.justifyContent};
      column-gap: ${this.columnGap && `var(--wui-spacing-${this.columnGap})`};
      row-gap: ${this.rowGap && `var(--wui-spacing-${this.rowGap})`};
      gap: ${this.gap && `var(--wui-spacing-${this.gap})`};
      padding-top: ${this.padding && ar.getSpacingStyles(this.padding, 0)};
      padding-right: ${this.padding && ar.getSpacingStyles(this.padding, 1)};
      padding-bottom: ${this.padding && ar.getSpacingStyles(this.padding, 2)};
      padding-left: ${this.padding && ar.getSpacingStyles(this.padding, 3)};
      margin-top: ${this.margin && ar.getSpacingStyles(this.margin, 0)};
      margin-right: ${this.margin && ar.getSpacingStyles(this.margin, 1)};
      margin-bottom: ${this.margin && ar.getSpacingStyles(this.margin, 2)};
      margin-left: ${this.margin && ar.getSpacingStyles(this.margin, 3)};
    `),
          L`<slot></slot>`
        );
      }
    };
    (zr.styles = [qe, ble]),
      Ai([M()], zr.prototype, "flexDirection", void 0),
      Ai([M()], zr.prototype, "flexWrap", void 0),
      Ai([M()], zr.prototype, "flexBasis", void 0),
      Ai([M()], zr.prototype, "flexGrow", void 0),
      Ai([M()], zr.prototype, "flexShrink", void 0),
      Ai([M()], zr.prototype, "alignItems", void 0),
      Ai([M()], zr.prototype, "justifyContent", void 0),
      Ai([M()], zr.prototype, "columnGap", void 0),
      Ai([M()], zr.prototype, "rowGap", void 0),
      Ai([M()], zr.prototype, "gap", void 0),
      Ai([M()], zr.prototype, "padding", void 0),
      Ai([M()], zr.prototype, "margin", void 0),
      (zr = Ai([ce("wui-flex")], zr));
    /**
     * @license
     * Copyright 2018 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */ const we = (t) => t ?? Ot;
    /**
     * @license
     * Copyright 2020 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */ const vle = (t) =>
        t === null || (typeof t != "object" && typeof t != "function"),
      Ele = (t) => t.strings === void 0;
    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */ const QI = {
        ATTRIBUTE: 1,
        CHILD: 2,
        PROPERTY: 3,
        BOOLEAN_ATTRIBUTE: 4,
        EVENT: 5,
        ELEMENT: 6,
      },
      Ob =
        (t) =>
        (...e) => ({ _$litDirective$: t, values: e });
    class e_ {
      constructor(e) {}
      get _$AU() {
        return this._$AM._$AU;
      }
      _$AT(e, r, i) {
        (this._$Ct = e), (this._$AM = r), (this._$Ci = i);
      }
      _$AS(e, r) {
        return this.update(e, r);
      }
      update(e, r) {
        return this.render(...r);
      }
    }
    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */ const wd = (t, e) => {
        const r = t._$AN;
        if (r === void 0) return !1;
        for (const i of r) i._$AO?.(e, !1), wd(i, e);
        return !0;
      },
      E0 = (t) => {
        let e, r;
        do {
          if ((e = t._$AM) === void 0) break;
          (r = e._$AN), r.delete(t), (t = e);
        } while (r?.size === 0);
      },
      t_ = (t) => {
        for (let e; (e = t._$AM); t = e) {
          let r = e._$AN;
          if (r === void 0) e._$AN = r = new Set();
          else if (r.has(t)) break;
          r.add(t), Ile(e);
        }
      };
    function Cle(t) {
      this._$AN !== void 0
        ? (E0(this), (this._$AM = t), t_(this))
        : (this._$AM = t);
    }
    function xle(t, e = !1, r = 0) {
      const i = this._$AH,
        s = this._$AN;
      if (s !== void 0 && s.size !== 0)
        if (e)
          if (Array.isArray(i))
            for (let n = r; n < i.length; n++) wd(i[n], !1), E0(i[n]);
          else i != null && (wd(i, !1), E0(i));
        else wd(this, t);
    }
    const Ile = (t) => {
      t.type == QI.CHILD &&
        (t._$AP ?? (t._$AP = xle), t._$AQ ?? (t._$AQ = Cle));
    };
    class r_ extends e_ {
      constructor() {
        super(...arguments), (this._$AN = void 0);
      }
      _$AT(e, r, i) {
        super._$AT(e, r, i), t_(this), (this.isConnected = e._$AU);
      }
      _$AO(e, r = !0) {
        e !== this.isConnected &&
          ((this.isConnected = e),
          e ? this.reconnected?.() : this.disconnected?.()),
          r && (wd(this, e), E0(this));
      }
      setValue(e) {
        if (Ele(this._$Ct)) this._$Ct._$AI(e, this);
        else {
          const r = [...this._$Ct._$AH];
          (r[this._$Ci] = e), this._$Ct._$AI(r, this, 0);
        }
      }
      disconnected() {}
      reconnected() {}
    }
    /**
     * @license
     * Copyright 2021 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */ class _le {
      constructor(e) {
        this.G = e;
      }
      disconnect() {
        this.G = void 0;
      }
      reconnect(e) {
        this.G = e;
      }
      deref() {
        return this.G;
      }
    }
    class Ale {
      constructor() {
        (this.Y = void 0), (this.Z = void 0);
      }
      get() {
        return this.Y;
      }
      pause() {
        this.Y ?? (this.Y = new Promise((e) => (this.Z = e)));
      }
      resume() {
        this.Z?.(), (this.Y = this.Z = void 0);
      }
    }
    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */ const i_ = (t) => !vle(t) && typeof t.then == "function",
      s_ = 1073741823;
    class Sle extends r_ {
      constructor() {
        super(...arguments),
          (this._$Cwt = s_),
          (this._$Cbt = []),
          (this._$CK = new _le(this)),
          (this._$CX = new Ale());
      }
      render(...e) {
        return e.find((r) => !i_(r)) ?? Pn;
      }
      update(e, r) {
        const i = this._$Cbt;
        let s = i.length;
        this._$Cbt = r;
        const n = this._$CK,
          o = this._$CX;
        this.isConnected || this.disconnected();
        for (let a = 0; a < r.length && !(a > this._$Cwt); a++) {
          const c = r[a];
          if (!i_(c)) return (this._$Cwt = a), c;
          (a < s && c === i[a]) ||
            ((this._$Cwt = s_),
            (s = 0),
            Promise.resolve(c).then(async (l) => {
              for (; o.get(); ) await o.get();
              const u = n.deref();
              if (u !== void 0) {
                const h = u._$Cbt.indexOf(c);
                h > -1 && h < u._$Cwt && ((u._$Cwt = h), u.setValue(l));
              }
            }));
        }
        return Pn;
      }
      disconnected() {
        this._$CK.disconnect(), this._$CX.pause();
      }
      reconnected() {
        this._$CK.reconnect(this), this._$CX.resume();
      }
    }
    const Ple = Ob(Sle);
    class Ole {
      constructor() {
        this.cache = new Map();
      }
      set(e, r) {
        this.cache.set(e, r);
      }
      get(e) {
        return this.cache.get(e);
      }
      has(e) {
        return this.cache.has(e);
      }
      delete(e) {
        this.cache.delete(e);
      }
      clear() {
        this.cache.clear();
      }
    }
    const Nb = new Ole();
    var Nle = ge`
  :host {
    display: flex;
    aspect-ratio: var(--local-aspect-ratio);
    color: var(--local-color);
    width: var(--local-width);
  }

  svg {
    width: inherit;
    height: inherit;
    object-fit: contain;
    object-position: center;
  }

  .fallback {
    width: var(--local-width);
    height: var(--local-height);
  }
`,
      md = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    const n_ = {
      add: async () =>
        (
          await Promise.resolve().then(function () {
            return khe;
          })
        ).addSvg,
      allWallets: async () =>
        (
          await Promise.resolve().then(function () {
            return $he;
          })
        ).allWalletsSvg,
      arrowBottomCircle: async () =>
        (
          await Promise.resolve().then(function () {
            return Bhe;
          })
        ).arrowBottomCircleSvg,
      appStore: async () =>
        (
          await Promise.resolve().then(function () {
            return Uhe;
          })
        ).appStoreSvg,
      apple: async () =>
        (
          await Promise.resolve().then(function () {
            return jhe;
          })
        ).appleSvg,
      arrowBottom: async () =>
        (
          await Promise.resolve().then(function () {
            return zhe;
          })
        ).arrowBottomSvg,
      arrowLeft: async () =>
        (
          await Promise.resolve().then(function () {
            return Hhe;
          })
        ).arrowLeftSvg,
      arrowRight: async () =>
        (
          await Promise.resolve().then(function () {
            return Whe;
          })
        ).arrowRightSvg,
      arrowTop: async () =>
        (
          await Promise.resolve().then(function () {
            return Ghe;
          })
        ).arrowTopSvg,
      bank: async () =>
        (
          await Promise.resolve().then(function () {
            return Yhe;
          })
        ).bankSvg,
      browser: async () =>
        (
          await Promise.resolve().then(function () {
            return Xhe;
          })
        ).browserSvg,
      card: async () =>
        (
          await Promise.resolve().then(function () {
            return ede;
          })
        ).cardSvg,
      checkmark: async () =>
        (
          await Promise.resolve().then(function () {
            return rde;
          })
        ).checkmarkSvg,
      checkmarkBold: async () =>
        (
          await Promise.resolve().then(function () {
            return sde;
          })
        ).checkmarkBoldSvg,
      chevronBottom: async () =>
        (
          await Promise.resolve().then(function () {
            return ode;
          })
        ).chevronBottomSvg,
      chevronLeft: async () =>
        (
          await Promise.resolve().then(function () {
            return cde;
          })
        ).chevronLeftSvg,
      chevronRight: async () =>
        (
          await Promise.resolve().then(function () {
            return ude;
          })
        ).chevronRightSvg,
      chevronTop: async () =>
        (
          await Promise.resolve().then(function () {
            return dde;
          })
        ).chevronTopSvg,
      chromeStore: async () =>
        (
          await Promise.resolve().then(function () {
            return fde;
          })
        ).chromeStoreSvg,
      clock: async () =>
        (
          await Promise.resolve().then(function () {
            return wde;
          })
        ).clockSvg,
      close: async () =>
        (
          await Promise.resolve().then(function () {
            return yde;
          })
        ).closeSvg,
      compass: async () =>
        (
          await Promise.resolve().then(function () {
            return vde;
          })
        ).compassSvg,
      coinPlaceholder: async () =>
        (
          await Promise.resolve().then(function () {
            return Cde;
          })
        ).coinPlaceholderSvg,
      copy: async () =>
        (
          await Promise.resolve().then(function () {
            return Ide;
          })
        ).copySvg,
      cursor: async () =>
        (
          await Promise.resolve().then(function () {
            return Ade;
          })
        ).cursorSvg,
      cursorTransparent: async () =>
        (
          await Promise.resolve().then(function () {
            return Pde;
          })
        ).cursorTransparentSvg,
      desktop: async () =>
        (
          await Promise.resolve().then(function () {
            return Nde;
          })
        ).desktopSvg,
      disconnect: async () =>
        (
          await Promise.resolve().then(function () {
            return kde;
          })
        ).disconnectSvg,
      discord: async () =>
        (
          await Promise.resolve().then(function () {
            return $de;
          })
        ).discordSvg,
      etherscan: async () =>
        (
          await Promise.resolve().then(function () {
            return Bde;
          })
        ).etherscanSvg,
      extension: async () =>
        (
          await Promise.resolve().then(function () {
            return Ude;
          })
        ).extensionSvg,
      externalLink: async () =>
        (
          await Promise.resolve().then(function () {
            return jde;
          })
        ).externalLinkSvg,
      facebook: async () =>
        (
          await Promise.resolve().then(function () {
            return zde;
          })
        ).facebookSvg,
      farcaster: async () =>
        (
          await Promise.resolve().then(function () {
            return Hde;
          })
        ).farcasterSvg,
      filters: async () =>
        (
          await Promise.resolve().then(function () {
            return Wde;
          })
        ).filtersSvg,
      github: async () =>
        (
          await Promise.resolve().then(function () {
            return Gde;
          })
        ).githubSvg,
      google: async () =>
        (
          await Promise.resolve().then(function () {
            return Yde;
          })
        ).googleSvg,
      helpCircle: async () =>
        (
          await Promise.resolve().then(function () {
            return Xde;
          })
        ).helpCircleSvg,
      image: async () =>
        (
          await Promise.resolve().then(function () {
            return epe;
          })
        ).imageSvg,
      id: async () =>
        (
          await Promise.resolve().then(function () {
            return rpe;
          })
        ).idSvg,
      infoCircle: async () =>
        (
          await Promise.resolve().then(function () {
            return spe;
          })
        ).infoCircleSvg,
      lightbulb: async () =>
        (
          await Promise.resolve().then(function () {
            return ope;
          })
        ).lightbulbSvg,
      mail: async () =>
        (
          await Promise.resolve().then(function () {
            return cpe;
          })
        ).mailSvg,
      mobile: async () =>
        (
          await Promise.resolve().then(function () {
            return upe;
          })
        ).mobileSvg,
      more: async () =>
        (
          await Promise.resolve().then(function () {
            return dpe;
          })
        ).moreSvg,
      networkPlaceholder: async () =>
        (
          await Promise.resolve().then(function () {
            return fpe;
          })
        ).networkPlaceholderSvg,
      nftPlaceholder: async () =>
        (
          await Promise.resolve().then(function () {
            return wpe;
          })
        ).nftPlaceholderSvg,
      off: async () =>
        (
          await Promise.resolve().then(function () {
            return ype;
          })
        ).offSvg,
      playStore: async () =>
        (
          await Promise.resolve().then(function () {
            return vpe;
          })
        ).playStoreSvg,
      plus: async () =>
        (
          await Promise.resolve().then(function () {
            return Cpe;
          })
        ).plusSvg,
      qrCode: async () =>
        (
          await Promise.resolve().then(function () {
            return Ipe;
          })
        ).qrCodeIcon,
      recycleHorizontal: async () =>
        (
          await Promise.resolve().then(function () {
            return Ape;
          })
        ).recycleHorizontalSvg,
      refresh: async () =>
        (
          await Promise.resolve().then(function () {
            return Ppe;
          })
        ).refreshSvg,
      search: async () =>
        (
          await Promise.resolve().then(function () {
            return Npe;
          })
        ).searchSvg,
      send: async () =>
        (
          await Promise.resolve().then(function () {
            return kpe;
          })
        ).sendSvg,
      swapHorizontal: async () =>
        (
          await Promise.resolve().then(function () {
            return $pe;
          })
        ).swapHorizontalSvg,
      swapHorizontalMedium: async () =>
        (
          await Promise.resolve().then(function () {
            return Bpe;
          })
        ).swapHorizontalMediumSvg,
      swapHorizontalBold: async () =>
        (
          await Promise.resolve().then(function () {
            return Upe;
          })
        ).swapHorizontalBoldSvg,
      swapHorizontalRoundedBold: async () =>
        (
          await Promise.resolve().then(function () {
            return jpe;
          })
        ).swapHorizontalRoundedBoldSvg,
      swapVertical: async () =>
        (
          await Promise.resolve().then(function () {
            return zpe;
          })
        ).swapVerticalSvg,
      telegram: async () =>
        (
          await Promise.resolve().then(function () {
            return Hpe;
          })
        ).telegramSvg,
      threeDots: async () =>
        (
          await Promise.resolve().then(function () {
            return Wpe;
          })
        ).threeDotsSvg,
      twitch: async () =>
        (
          await Promise.resolve().then(function () {
            return Gpe;
          })
        ).twitchSvg,
      twitter: async () =>
        (
          await Promise.resolve().then(function () {
            return W_;
          })
        ).xSvg,
      twitterIcon: async () =>
        (
          await Promise.resolve().then(function () {
            return Jpe;
          })
        ).twitterIconSvg,
      verify: async () =>
        (
          await Promise.resolve().then(function () {
            return Qpe;
          })
        ).verifySvg,
      verifyFilled: async () =>
        (
          await Promise.resolve().then(function () {
            return tfe;
          })
        ).verifyFilledSvg,
      wallet: async () =>
        (
          await Promise.resolve().then(function () {
            return ife;
          })
        ).walletSvg,
      walletConnect: async () =>
        (
          await Promise.resolve().then(function () {
            return dv;
          })
        ).walletConnectSvg,
      walletConnectLightBrown: async () =>
        (
          await Promise.resolve().then(function () {
            return dv;
          })
        ).walletConnectLightBrownSvg,
      walletConnectBrown: async () =>
        (
          await Promise.resolve().then(function () {
            return dv;
          })
        ).walletConnectBrownSvg,
      walletPlaceholder: async () =>
        (
          await Promise.resolve().then(function () {
            return cfe;
          })
        ).walletPlaceholderSvg,
      warningCircle: async () =>
        (
          await Promise.resolve().then(function () {
            return ufe;
          })
        ).warningCircleSvg,
      x: async () =>
        (
          await Promise.resolve().then(function () {
            return W_;
          })
        ).xSvg,
      info: async () =>
        (
          await Promise.resolve().then(function () {
            return dfe;
          })
        ).infoSvg,
      exclamationTriangle: async () =>
        (
          await Promise.resolve().then(function () {
            return ffe;
          })
        ).exclamationTriangleSvg,
      reown: async () =>
        (
          await Promise.resolve().then(function () {
            return wfe;
          })
        ).reownSvg,
    };
    async function Tle(t) {
      if (Nb.has(t)) return Nb.get(t);
      const e = (n_[t] ?? n_.copy)();
      return Nb.set(t, e), e;
    }
    let Oa = class extends ue {
      constructor() {
        super(...arguments),
          (this.size = "md"),
          (this.name = "copy"),
          (this.color = "fg-300"),
          (this.aspectRatio = "1 / 1");
      }
      render() {
        return (
          (this.style.cssText = `
      --local-color: ${`var(--wui-color-${this.color});`}
      --local-width: ${`var(--wui-icon-size-${this.size});`}
      --local-aspect-ratio: ${this.aspectRatio}
    `),
          L`${Ple(Tle(this.name), L`<div class="fallback"></div>`)}`
        );
      }
    };
    (Oa.styles = [qe, hd, Nle]),
      md([M()], Oa.prototype, "size", void 0),
      md([M()], Oa.prototype, "name", void 0),
      md([M()], Oa.prototype, "color", void 0),
      md([M()], Oa.prototype, "aspectRatio", void 0),
      (Oa = md([ce("wui-icon")], Oa));
    /**
     * @license
     * Copyright 2018 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */ const o_ = Ob(
      class extends e_ {
        constructor(t) {
          if (
            (super(t),
            t.type !== QI.ATTRIBUTE ||
              t.name !== "class" ||
              t.strings?.length > 2)
          )
            throw Error(
              "`classMap()` can only be used in the `class` attribute and must be the only part in the attribute."
            );
        }
        render(t) {
          return (
            " " +
            Object.keys(t)
              .filter((e) => t[e])
              .join(" ") +
            " "
          );
        }
        update(t, [e]) {
          if (this.st === void 0) {
            (this.st = new Set()),
              t.strings !== void 0 &&
                (this.nt = new Set(
                  t.strings
                    .join(" ")
                    .split(/\s/)
                    .filter((i) => i !== "")
                ));
            for (const i in e) e[i] && !this.nt?.has(i) && this.st.add(i);
            return this.render(e);
          }
          const r = t.element.classList;
          for (const i of this.st) i in e || (r.remove(i), this.st.delete(i));
          for (const i in e) {
            const s = !!e[i];
            s === this.st.has(i) ||
              this.nt?.has(i) ||
              (s
                ? (r.add(i), this.st.add(i))
                : (r.remove(i), this.st.delete(i)));
          }
          return Pn;
        }
      }
    );
    var kle = ge`
  :host {
    display: inline-flex !important;
  }

  slot {
    width: 100%;
    display: inline-block;
    font-style: normal;
    font-family: var(--wui-font-family);
    font-feature-settings:
      'tnum' on,
      'lnum' on,
      'case' on;
    line-height: 130%;
    font-weight: var(--wui-font-weight-regular);
    overflow: inherit;
    text-overflow: inherit;
    text-align: var(--local-align);
    color: var(--local-color);
  }

  .wui-line-clamp-1 {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 1;
  }

  .wui-line-clamp-2 {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 2;
  }

  .wui-font-medium-400 {
    font-size: var(--wui-font-size-medium);
    font-weight: var(--wui-font-weight-light);
    letter-spacing: var(--wui-letter-spacing-medium);
  }

  .wui-font-medium-600 {
    font-size: var(--wui-font-size-medium);
    letter-spacing: var(--wui-letter-spacing-medium);
  }

  .wui-font-title-600 {
    font-size: var(--wui-font-size-title);
    letter-spacing: var(--wui-letter-spacing-title);
  }

  .wui-font-title-6-600 {
    font-size: var(--wui-font-size-title-6);
    letter-spacing: var(--wui-letter-spacing-title-6);
  }

  .wui-font-mini-700 {
    font-size: var(--wui-font-size-mini);
    letter-spacing: var(--wui-letter-spacing-mini);
    text-transform: uppercase;
  }

  .wui-font-large-500,
  .wui-font-large-600,
  .wui-font-large-700 {
    font-size: var(--wui-font-size-large);
    letter-spacing: var(--wui-letter-spacing-large);
  }

  .wui-font-2xl-500,
  .wui-font-2xl-600,
  .wui-font-2xl-700 {
    font-size: var(--wui-font-size-2xl);
    letter-spacing: var(--wui-letter-spacing-2xl);
  }

  .wui-font-paragraph-400,
  .wui-font-paragraph-500,
  .wui-font-paragraph-600,
  .wui-font-paragraph-700 {
    font-size: var(--wui-font-size-paragraph);
    letter-spacing: var(--wui-letter-spacing-paragraph);
  }

  .wui-font-small-400,
  .wui-font-small-500,
  .wui-font-small-600 {
    font-size: var(--wui-font-size-small);
    letter-spacing: var(--wui-letter-spacing-small);
  }

  .wui-font-tiny-400,
  .wui-font-tiny-500,
  .wui-font-tiny-600 {
    font-size: var(--wui-font-size-tiny);
    letter-spacing: var(--wui-letter-spacing-tiny);
  }

  .wui-font-micro-700,
  .wui-font-micro-600 {
    font-size: var(--wui-font-size-micro);
    letter-spacing: var(--wui-letter-spacing-micro);
    text-transform: uppercase;
  }

  .wui-font-tiny-400,
  .wui-font-small-400,
  .wui-font-medium-400,
  .wui-font-paragraph-400 {
    font-weight: var(--wui-font-weight-light);
  }

  .wui-font-large-700,
  .wui-font-paragraph-700,
  .wui-font-micro-700,
  .wui-font-mini-700 {
    font-weight: var(--wui-font-weight-bold);
  }

  .wui-font-medium-600,
  .wui-font-medium-title-600,
  .wui-font-title-6-600,
  .wui-font-large-600,
  .wui-font-paragraph-600,
  .wui-font-small-600,
  .wui-font-tiny-600,
  .wui-font-micro-600 {
    font-weight: var(--wui-font-weight-medium);
  }

  :host([disabled]) {
    opacity: 0.4;
  }
`,
      yd = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let Na = class extends ue {
      constructor() {
        super(...arguments),
          (this.variant = "paragraph-500"),
          (this.color = "fg-300"),
          (this.align = "left"),
          (this.lineClamp = void 0);
      }
      render() {
        const t = {
          [`wui-font-${this.variant}`]: !0,
          [`wui-color-${this.color}`]: !0,
          [`wui-line-clamp-${this.lineClamp}`]: !!this.lineClamp,
        };
        return (
          (this.style.cssText = `
      --local-align: ${this.align};
      --local-color: var(--wui-color-${this.color});
    `),
          L`<slot class=${o_(t)}></slot>`
        );
      }
    };
    (Na.styles = [qe, kle]),
      yd([M()], Na.prototype, "variant", void 0),
      yd([M()], Na.prototype, "color", void 0),
      yd([M()], Na.prototype, "align", void 0),
      yd([M()], Na.prototype, "lineClamp", void 0),
      (Na = yd([ce("wui-text")], Na));
    var Rle = ge`
  :host {
    display: inline-flex;
    justify-content: center;
    align-items: center;
    position: relative;
    overflow: hidden;
    background-color: var(--wui-color-gray-glass-020);
    border-radius: var(--local-border-radius);
    border: var(--local-border);
    box-sizing: content-box;
    width: var(--local-size);
    height: var(--local-size);
    min-height: var(--local-size);
    min-width: var(--local-size);
  }

  @supports (background: color-mix(in srgb, white 50%, black)) {
    :host {
      background-color: color-mix(in srgb, var(--local-bg-value) var(--local-bg-mix), transparent);
    }
  }
`,
      On = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let hs = class extends ue {
      constructor() {
        super(...arguments),
          (this.size = "md"),
          (this.backgroundColor = "accent-100"),
          (this.iconColor = "accent-100"),
          (this.background = "transparent"),
          (this.border = !1),
          (this.borderColor = "wui-color-bg-125"),
          (this.icon = "copy");
      }
      render() {
        const t = this.iconSize || this.size,
          e = this.size === "lg",
          r = this.size === "xl",
          i = e ? "12%" : "16%",
          s = e ? "xxs" : r ? "s" : "3xl",
          n = this.background === "gray",
          o = this.background === "opaque",
          a =
            (this.backgroundColor === "accent-100" && o) ||
            (this.backgroundColor === "success-100" && o) ||
            (this.backgroundColor === "error-100" && o) ||
            (this.backgroundColor === "inverse-100" && o);
        let c = `var(--wui-color-${this.backgroundColor})`;
        return (
          a
            ? (c = `var(--wui-icon-box-bg-${this.backgroundColor})`)
            : n && (c = `var(--wui-color-gray-${this.backgroundColor})`),
          (this.style.cssText = `
       --local-bg-value: ${c};
       --local-bg-mix: ${a || n ? "100%" : i};
       --local-border-radius: var(--wui-border-radius-${s});
       --local-size: var(--wui-icon-box-size-${this.size});
       --local-border: ${
         this.borderColor === "wui-color-bg-125" ? "2px" : "1px"
       } solid ${this.border ? `var(--${this.borderColor})` : "transparent"}
   `),
          L` <wui-icon color=${this.iconColor} size=${t} name=${this.icon}></wui-icon> `
        );
      }
    };
    (hs.styles = [qe, Cr, Rle]),
      On([M()], hs.prototype, "size", void 0),
      On([M()], hs.prototype, "backgroundColor", void 0),
      On([M()], hs.prototype, "iconColor", void 0),
      On([M()], hs.prototype, "iconSize", void 0),
      On([M()], hs.prototype, "background", void 0),
      On([M({ type: Boolean })], hs.prototype, "border", void 0),
      On([M()], hs.prototype, "borderColor", void 0),
      On([M()], hs.prototype, "icon", void 0),
      (hs = On([ce("wui-icon-box")], hs));
    var $le = ge`
  :host {
    display: block;
    width: var(--local-width);
    height: var(--local-height);
  }

  img {
    display: block;
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center center;
    border-radius: inherit;
  }
`,
      C0 = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let ql = class extends ue {
      constructor() {
        super(...arguments),
          (this.src = "./path/to/image.jpg"),
          (this.alt = "Image"),
          (this.size = void 0);
      }
      render() {
        return (
          (this.style.cssText = `
      --local-width: ${
        this.size ? `var(--wui-icon-size-${this.size});` : "100%"
      };
      --local-height: ${
        this.size ? `var(--wui-icon-size-${this.size});` : "100%"
      };
      `),
          L`<img src=${this.src} alt=${this.alt} @error=${this.handleImageError} />`
        );
      }
      handleImageError() {
        this.dispatchEvent(
          new CustomEvent("onLoadError", { bubbles: !0, composed: !0 })
        );
      }
    };
    (ql.styles = [qe, hd, $le]),
      C0([M()], ql.prototype, "src", void 0),
      C0([M()], ql.prototype, "alt", void 0),
      C0([M()], ql.prototype, "size", void 0),
      (ql = C0([ce("wui-image")], ql));
    var Fle = ge`
  :host {
    position: relative;
    background-color: var(--wui-color-gray-glass-002);
    display: flex;
    justify-content: center;
    align-items: center;
    width: var(--local-size);
    height: var(--local-size);
    border-radius: inherit;
    border-radius: var(--local-border-radius);
  }

  :host > wui-flex {
    overflow: hidden;
    border-radius: inherit;
    border-radius: var(--local-border-radius);
  }

  :host::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-color-gray-glass-010);
    pointer-events: none;
  }

  :host([name='Extension'])::after {
    border: 1px solid var(--wui-color-accent-glass-010);
  }

  :host([data-wallet-icon='allWallets']) {
    background-color: var(--wui-all-wallets-bg-100);
  }

  :host([data-wallet-icon='allWallets'])::after {
    border: 1px solid var(--wui-color-accent-glass-010);
  }

  wui-icon[data-parent-size='inherit'] {
    width: 75%;
    height: 75%;
    align-items: center;
  }

  wui-icon[data-parent-size='sm'] {
    width: 18px;
    height: 18px;
  }

  wui-icon[data-parent-size='md'] {
    width: 24px;
    height: 24px;
  }

  wui-icon[data-parent-size='lg'] {
    width: 42px;
    height: 42px;
  }

  wui-icon[data-parent-size='full'] {
    width: 100%;
    height: 100%;
  }

  :host > wui-icon-box {
    position: absolute;
    overflow: hidden;
    right: -1px;
    bottom: -2px;
    z-index: 1;
    border: 2px solid var(--wui-color-bg-150, #1e1f1f);
    padding: 1px;
  }
`,
      Ta = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let Nn = class extends ue {
      constructor() {
        super(...arguments),
          (this.size = "md"),
          (this.name = ""),
          (this.installed = !1),
          (this.badgeSize = "xs");
      }
      render() {
        let t = "xxs";
        return (
          this.size === "lg"
            ? (t = "m")
            : this.size === "md"
            ? (t = "xs")
            : (t = "xxs"),
          (this.style.cssText = `
       --local-border-radius: var(--wui-border-radius-${t});
       --local-size: var(--wui-wallet-image-size-${this.size});
   `),
          this.walletIcon && (this.dataset.walletIcon = this.walletIcon),
          L`
      <wui-flex justifyContent="center" alignItems="center"> ${this.templateVisual()} </wui-flex>
    `
        );
      }
      templateVisual() {
        return this.imageSrc
          ? L`<wui-image src=${this.imageSrc} alt=${this.name}></wui-image>`
          : this.walletIcon
          ? L`<wui-icon
        data-parent-size="md"
        size="md"
        color="inherit"
        name=${this.walletIcon}
      ></wui-icon>`
          : L`<wui-icon
      data-parent-size=${this.size}
      size="inherit"
      color="inherit"
      name="walletPlaceholder"
    ></wui-icon>`;
      }
    };
    (Nn.styles = [Cr, qe, Fle]),
      Ta([M()], Nn.prototype, "size", void 0),
      Ta([M()], Nn.prototype, "name", void 0),
      Ta([M()], Nn.prototype, "imageSrc", void 0),
      Ta([M()], Nn.prototype, "walletIcon", void 0),
      Ta([M({ type: Boolean })], Nn.prototype, "installed", void 0),
      Ta([M()], Nn.prototype, "badgeSize", void 0),
      (Nn = Ta([ce("wui-wallet-image")], Nn));
    var Ble = ge`
  :host {
    position: relative;
    border-radius: var(--wui-border-radius-xxs);
    width: 40px;
    height: 40px;
    overflow: hidden;
    background: var(--wui-color-gray-glass-002);
    display: flex;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap;
    gap: var(--wui-spacing-4xs);
    padding: 3.75px !important;
  }

  :host::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-color-gray-glass-010);
    pointer-events: none;
  }

  :host > wui-wallet-image {
    width: 14px;
    height: 14px;
    border-radius: var(--wui-border-radius-5xs);
  }

  :host > wui-flex {
    padding: 2px;
    position: fixed;
    overflow: hidden;
    left: 34px;
    bottom: 8px;
    background: var(--dark-background-150, #1e1f1f);
    border-radius: 50%;
    z-index: 2;
    display: flex;
  }
`,
      a_ = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    const Tb = 4;
    let x0 = class extends ue {
      constructor() {
        super(...arguments), (this.walletImages = []);
      }
      render() {
        const t = this.walletImages.length < Tb;
        return L`${this.walletImages.slice(0, Tb).map(
          ({ src: e, walletName: r }) => L`
            <wui-wallet-image
              size="inherit"
              imageSrc=${e}
              name=${we(r)}
            ></wui-wallet-image>
          `
        )}
      ${
        t
          ? [...Array(Tb - this.walletImages.length)].map(
              () =>
                L` <wui-wallet-image size="inherit" name=""></wui-wallet-image>`
            )
          : null
      }
      <wui-flex>
        <wui-icon-box
          size="xxs"
          iconSize="xxs"
          iconcolor="success-100"
          backgroundcolor="success-100"
          icon="checkmark"
          background="opaque"
        ></wui-icon-box>
      </wui-flex>`;
      }
    };
    (x0.styles = [qe, Ble]),
      a_([M({ type: Array })], x0.prototype, "walletImages", void 0),
      (x0 = a_([ce("wui-all-wallets-image")], x0));
    var Lle = ge`
  :host {
    display: flex;
    justify-content: center;
    align-items: center;
    height: var(--wui-spacing-m);
    padding: 0 var(--wui-spacing-3xs) !important;
    border-radius: var(--wui-border-radius-5xs);
    transition:
      border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1),
      background-color var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: border-radius, background-color;
  }

  :host > wui-text {
    transform: translateY(5%);
  }

  :host([data-variant='main']) {
    background-color: var(--wui-color-accent-glass-015);
    color: var(--wui-color-accent-100);
  }

  :host([data-variant='shade']) {
    background-color: var(--wui-color-gray-glass-010);
    color: var(--wui-color-fg-200);
  }

  :host([data-variant='success']) {
    background-color: var(--wui-icon-box-bg-success-100);
    color: var(--wui-color-success-100);
  }

  :host([data-variant='error']) {
    background-color: var(--wui-icon-box-bg-error-100);
    color: var(--wui-color-error-100);
  }

  :host([data-size='lg']) {
    padding: 11px 5px !important;
  }

  :host([data-size='lg']) > wui-text {
    transform: translateY(2%);
  }
`,
      kb = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let bd = class extends ue {
      constructor() {
        super(...arguments), (this.variant = "main"), (this.size = "lg");
      }
      render() {
        (this.dataset.variant = this.variant), (this.dataset.size = this.size);
        const t = this.size === "md" ? "mini-700" : "micro-700";
        return L`
      <wui-text data-variant=${this.variant} variant=${t} color="inherit">
        <slot></slot>
      </wui-text>
    `;
      }
    };
    (bd.styles = [qe, Lle]),
      kb([M()], bd.prototype, "variant", void 0),
      kb([M()], bd.prototype, "size", void 0),
      (bd = kb([ce("wui-tag")], bd));
    var Ule = ge`
  button {
    column-gap: var(--wui-spacing-s);
    padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
    width: 100%;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-100);
  }

  button > wui-text:nth-child(2) {
    display: flex;
    flex: 1;
  }

  button:disabled {
    background-color: var(--wui-color-gray-glass-015);
    color: var(--wui-color-gray-glass-015);
  }

  button:disabled > wui-tag {
    background-color: var(--wui-color-gray-glass-010);
    color: var(--wui-color-fg-300);
  }

  wui-icon {
    color: var(--wui-color-fg-200) !important;
  }
`,
      ri = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let Or = class extends ue {
      constructor() {
        super(...arguments),
          (this.walletImages = []),
          (this.imageSrc = ""),
          (this.name = ""),
          (this.tabIdx = void 0),
          (this.installed = !1),
          (this.disabled = !1),
          (this.showAllWallets = !1),
          (this.loading = !1),
          (this.loadingSpinnerColor = "accent-100");
      }
      render() {
        return L`
      <button ?disabled=${this.disabled} tabindex=${we(this.tabIdx)}>
        ${this.templateAllWallets()} ${this.templateWalletImage()}
        <wui-text variant="paragraph-500" color="inherit">${
          this.name
        }</wui-text>
        ${this.templateStatus()}
      </button>
    `;
      }
      templateAllWallets() {
        return this.showAllWallets && this.imageSrc
          ? L` <wui-all-wallets-image .imageeSrc=${this.imageSrc}> </wui-all-wallets-image> `
          : this.showAllWallets && this.walletIcon
          ? L` <wui-wallet-image .walletIcon=${this.walletIcon} size="sm"> </wui-wallet-image> `
          : null;
      }
      templateWalletImage() {
        return !this.showAllWallets && this.imageSrc
          ? L`<wui-wallet-image
        size="sm"
        imageSrc=${this.imageSrc}
        name=${this.name}
        .installed=${this.installed}
      ></wui-wallet-image>`
          : !this.showAllWallets && !this.imageSrc
          ? L`<wui-wallet-image size="sm" name=${this.name}></wui-wallet-image>`
          : null;
      }
      templateStatus() {
        return this.loading
          ? L`<wui-loading-spinner
        size="lg"
        color=${this.loadingSpinnerColor}
      ></wui-loading-spinner>`
          : this.tagLabel && this.tagVariant
          ? L`<wui-tag variant=${this.tagVariant}>${this.tagLabel}</wui-tag>`
          : this.icon
          ? L`<wui-icon color="inherit" size="sm" name=${this.icon}></wui-icon>`
          : null;
      }
    };
    (Or.styles = [qe, Cr, Ule]),
      ri([M({ type: Array })], Or.prototype, "walletImages", void 0),
      ri([M()], Or.prototype, "imageSrc", void 0),
      ri([M()], Or.prototype, "name", void 0),
      ri([M()], Or.prototype, "tagLabel", void 0),
      ri([M()], Or.prototype, "tagVariant", void 0),
      ri([M()], Or.prototype, "icon", void 0),
      ri([M()], Or.prototype, "walletIcon", void 0),
      ri([M()], Or.prototype, "tabIdx", void 0),
      ri([M({ type: Boolean })], Or.prototype, "installed", void 0),
      ri([M({ type: Boolean })], Or.prototype, "disabled", void 0),
      ri([M({ type: Boolean })], Or.prototype, "showAllWallets", void 0),
      ri([M({ type: Boolean })], Or.prototype, "loading", void 0),
      ri([M({ type: String })], Or.prototype, "loadingSpinnerColor", void 0),
      (Or = ri([ce("wui-list-wallet")], Or));
    var vd = function (t, e, r, i) {
      var s = arguments.length,
        n =
          s < 3
            ? e
            : i === null
            ? (i = Object.getOwnPropertyDescriptor(e, r))
            : i,
        o;
      if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        n = Reflect.decorate(t, e, r, i);
      else
        for (var a = t.length - 1; a >= 0; a--)
          (o = t[a]) &&
            (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
      return s > 3 && n && Object.defineProperty(e, r, n), n;
    };
    let Hl = class extends ue {
      constructor() {
        super(),
          (this.unsubscribe = []),
          (this.tabIdx = void 0),
          (this.connectors = oe.state.connectors),
          (this.count = ne.state.count),
          (this.isFetchingRecommendedWallets =
            ne.state.isFetchingRecommendedWallets),
          this.unsubscribe.push(
            oe.subscribeKey("connectors", (t) => (this.connectors = t)),
            ne.subscribeKey("count", (t) => (this.count = t)),
            ne.subscribeKey(
              "isFetchingRecommendedWallets",
              (t) => (this.isFetchingRecommendedWallets = t)
            )
          );
      }
      disconnectedCallback() {
        this.unsubscribe.forEach((t) => t());
      }
      render() {
        const t = this.connectors.find((o) => o.id === "walletConnect"),
          { allWallets: e } = G.state;
        if (!t || e === "HIDE" || (e === "ONLY_MOBILE" && !X.isMobile()))
          return null;
        const r = ne.state.featured.length,
          i = this.count + r,
          s = i < 10 ? i : Math.floor(i / 10) * 10,
          n = s < i ? `${s}+` : `${s}`;
        return L`
      <wui-list-wallet
        name="All Wallets"
        walletIcon="allWallets"
        showAllWallets
        @click=${this.onAllWallets.bind(this)}
        tagLabel=${n}
        tagVariant="shade"
        data-testid="all-wallets"
        tabIdx=${we(this.tabIdx)}
        .loading=${this.isFetchingRecommendedWallets}
        loadingSpinnerColor=${
          this.isFetchingRecommendedWallets ? "fg-300" : "accent-100"
        }
      ></wui-list-wallet>
    `;
      }
      onAllWallets() {
        Se.sendEvent({ type: "track", event: "CLICK_ALL_WALLETS" }),
          ie.push("AllWallets");
      }
    };
    vd([M()], Hl.prototype, "tabIdx", void 0),
      vd([le()], Hl.prototype, "connectors", void 0),
      vd([le()], Hl.prototype, "count", void 0),
      vd([le()], Hl.prototype, "isFetchingRecommendedWallets", void 0),
      (Hl = vd([ce("w3m-all-wallets-widget")], Hl));
    var Rb = function (t, e, r, i) {
      var s = arguments.length,
        n =
          s < 3
            ? e
            : i === null
            ? (i = Object.getOwnPropertyDescriptor(e, r))
            : i,
        o;
      if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        n = Reflect.decorate(t, e, r, i);
      else
        for (var a = t.length - 1; a >= 0; a--)
          (o = t[a]) &&
            (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
      return s > 3 && n && Object.defineProperty(e, r, n), n;
    };
    let I0 = class extends ue {
      constructor() {
        super(),
          (this.unsubscribe = []),
          (this.tabIdx = void 0),
          (this.connectors = oe.state.connectors),
          this.unsubscribe.push(
            oe.subscribeKey("connectors", (t) => (this.connectors = t))
          );
      }
      disconnectedCallback() {
        this.unsubscribe.forEach((t) => t());
      }
      render() {
        const t = this.connectors.filter((e) => e.type === "ANNOUNCED");
        return t?.length
          ? L`
      <wui-flex flexDirection="column" gap="xs">
        ${t.filter(Sn.showConnector).map(
          (e) => L`
              <wui-list-wallet
                imageSrc=${we(Ut.getConnectorImage(e))}
                name=${e.name ?? "Unknown"}
                @click=${() => this.onConnector(e)}
                tagVariant="success"
                tagLabel="installed"
                data-testid=${`wallet-selector-${e.id}`}
                .installed=${!0}
                tabIdx=${we(this.tabIdx)}
              >
              </wui-list-wallet>
            `
        )}
      </wui-flex>
    `
          : ((this.style.cssText = "display: none"), null);
      }
      onConnector(t) {
        t.id === "walletConnect"
          ? X.isMobile()
            ? ie.push("AllWallets")
            : ie.push("ConnectingWalletConnect")
          : ie.push("ConnectingExternal", { connector: t });
      }
    };
    Rb([M()], I0.prototype, "tabIdx", void 0),
      Rb([le()], I0.prototype, "connectors", void 0),
      (I0 = Rb([ce("w3m-connect-announced-widget")], I0));
    var _0 = function (t, e, r, i) {
      var s = arguments.length,
        n =
          s < 3
            ? e
            : i === null
            ? (i = Object.getOwnPropertyDescriptor(e, r))
            : i,
        o;
      if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        n = Reflect.decorate(t, e, r, i);
      else
        for (var a = t.length - 1; a >= 0; a--)
          (o = t[a]) &&
            (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
      return s > 3 && n && Object.defineProperty(e, r, n), n;
    };
    let Ed = class extends ue {
      constructor() {
        super(),
          (this.unsubscribe = []),
          (this.tabIdx = void 0),
          (this.connectors = oe.state.connectors),
          (this.loading = !1),
          this.unsubscribe.push(
            oe.subscribeKey("connectors", (t) => (this.connectors = t))
          ),
          X.isTelegram() &&
            X.isIos() &&
            ((this.loading = !pe.state.wcUri),
            this.unsubscribe.push(
              pe.subscribeKey("wcUri", (t) => (this.loading = !t))
            ));
      }
      disconnectedCallback() {
        this.unsubscribe.forEach((t) => t());
      }
      render() {
        const { customWallets: t } = G.state;
        if (!t?.length) return (this.style.cssText = "display: none"), null;
        const e = this.filterOutDuplicateWallets(t);
        return L`<wui-flex flexDirection="column" gap="xs">
      ${e.map(
        (r) => L`
          <wui-list-wallet
            imageSrc=${we(Ut.getWalletImage(r))}
            name=${r.name ?? "Unknown"}
            @click=${() => this.onConnectWallet(r)}
            data-testid=${`wallet-selector-${r.id}`}
            tabIdx=${we(this.tabIdx)}
            ?loading=${this.loading}
          >
          </wui-list-wallet>
        `
      )}
    </wui-flex>`;
      }
      filterOutDuplicateWallets(t) {
        const e = de.getRecentWallets(),
          r = this.connectors.map((n) => n.info?.rdns).filter(Boolean),
          i = e.map((n) => n.rdns).filter(Boolean),
          s = r.concat(i);
        if (s.includes("io.metamask.mobile") && X.isMobile()) {
          const n = s.indexOf("io.metamask.mobile");
          s[n] = "io.metamask";
        }
        return t.filter((n) => !s.includes(String(n?.rdns)));
      }
      onConnectWallet(t) {
        this.loading || ie.push("ConnectingWalletConnect", { wallet: t });
      }
    };
    _0([M()], Ed.prototype, "tabIdx", void 0),
      _0([le()], Ed.prototype, "connectors", void 0),
      _0([le()], Ed.prototype, "loading", void 0),
      (Ed = _0([ce("w3m-connect-custom-widget")], Ed));
    var $b = function (t, e, r, i) {
      var s = arguments.length,
        n =
          s < 3
            ? e
            : i === null
            ? (i = Object.getOwnPropertyDescriptor(e, r))
            : i,
        o;
      if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        n = Reflect.decorate(t, e, r, i);
      else
        for (var a = t.length - 1; a >= 0; a--)
          (o = t[a]) &&
            (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
      return s > 3 && n && Object.defineProperty(e, r, n), n;
    };
    let A0 = class extends ue {
      constructor() {
        super(),
          (this.unsubscribe = []),
          (this.tabIdx = void 0),
          (this.connectors = oe.state.connectors),
          this.unsubscribe.push(
            oe.subscribeKey("connectors", (t) => (this.connectors = t))
          );
      }
      disconnectedCallback() {
        this.unsubscribe.forEach((t) => t());
      }
      render() {
        const t = this.connectors
          .filter((e) => e.type === "EXTERNAL")
          .filter(Sn.showConnector)
          .filter((e) => e.id !== he.CONNECTOR_ID.COINBASE_SDK);
        return t?.length
          ? L`
      <wui-flex flexDirection="column" gap="xs">
        ${t.map(
          (e) => L`
            <wui-list-wallet
              imageSrc=${we(Ut.getConnectorImage(e))}
              .installed=${!0}
              name=${e.name ?? "Unknown"}
              data-testid=${`wallet-selector-external-${e.id}`}
              @click=${() => this.onConnector(e)}
              tabIdx=${we(this.tabIdx)}
            >
            </wui-list-wallet>
          `
        )}
      </wui-flex>
    `
          : ((this.style.cssText = "display: none"), null);
      }
      onConnector(t) {
        ie.push("ConnectingExternal", { connector: t });
      }
    };
    $b([M()], A0.prototype, "tabIdx", void 0),
      $b([le()], A0.prototype, "connectors", void 0),
      (A0 = $b([ce("w3m-connect-external-widget")], A0));
    var Fb = function (t, e, r, i) {
      var s = arguments.length,
        n =
          s < 3
            ? e
            : i === null
            ? (i = Object.getOwnPropertyDescriptor(e, r))
            : i,
        o;
      if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        n = Reflect.decorate(t, e, r, i);
      else
        for (var a = t.length - 1; a >= 0; a--)
          (o = t[a]) &&
            (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
      return s > 3 && n && Object.defineProperty(e, r, n), n;
    };
    let S0 = class extends ue {
      constructor() {
        super(...arguments), (this.tabIdx = void 0), (this.wallets = []);
      }
      render() {
        return this.wallets.length
          ? L`
      <wui-flex flexDirection="column" gap="xs">
        ${this.wallets.map(
          (t) => L`
            <wui-list-wallet
              data-testid=${`wallet-selector-featured-${t.id}`}
              imageSrc=${we(Ut.getWalletImage(t))}
              name=${t.name ?? "Unknown"}
              @click=${() => this.onConnectWallet(t)}
              tabIdx=${we(this.tabIdx)}
            >
            </wui-list-wallet>
          `
        )}
      </wui-flex>
    `
          : ((this.style.cssText = "display: none"), null);
      }
      onConnectWallet(t) {
        oe.selectWalletConnector(t);
      }
    };
    Fb([M()], S0.prototype, "tabIdx", void 0),
      Fb([M()], S0.prototype, "wallets", void 0),
      (S0 = Fb([ce("w3m-connect-featured-widget")], S0));
    var Bb = function (t, e, r, i) {
      var s = arguments.length,
        n =
          s < 3
            ? e
            : i === null
            ? (i = Object.getOwnPropertyDescriptor(e, r))
            : i,
        o;
      if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        n = Reflect.decorate(t, e, r, i);
      else
        for (var a = t.length - 1; a >= 0; a--)
          (o = t[a]) &&
            (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
      return s > 3 && n && Object.defineProperty(e, r, n), n;
    };
    let P0 = class extends ue {
      constructor() {
        super(...arguments), (this.tabIdx = void 0), (this.connectors = []);
      }
      render() {
        const t = this.connectors;
        return !t?.length ||
          (t.length === 1 && t[0]?.name === "Browser Wallet" && !X.isMobile())
          ? ((this.style.cssText = "display: none"), null)
          : L`
      <wui-flex flexDirection="column" gap="xs">
        ${t.map((e) => {
          const r = e.info?.rdns;
          return !X.isMobile() && e.name === "Browser Wallet"
            ? null
            : !r && !pe.checkInstalled()
            ? ((this.style.cssText = "display: none"), null)
            : Sn.showConnector(e)
            ? L`
            <wui-list-wallet
              imageSrc=${we(Ut.getConnectorImage(e))}
              .installed=${!0}
              name=${e.name ?? "Unknown"}
              tagVariant="success"
              tagLabel="installed"
              data-testid=${`wallet-selector-${e.id}`}
              @click=${() => this.onConnector(e)}
              tabIdx=${we(this.tabIdx)}
            >
            </wui-list-wallet>
          `
            : null;
        })}
      </wui-flex>
    `;
      }
      onConnector(t) {
        oe.setActiveConnector(t),
          ie.push("ConnectingExternal", { connector: t });
      }
    };
    Bb([M()], P0.prototype, "tabIdx", void 0),
      Bb([M()], P0.prototype, "connectors", void 0),
      (P0 = Bb([ce("w3m-connect-injected-widget")], P0));
    var Lb = function (t, e, r, i) {
      var s = arguments.length,
        n =
          s < 3
            ? e
            : i === null
            ? (i = Object.getOwnPropertyDescriptor(e, r))
            : i,
        o;
      if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        n = Reflect.decorate(t, e, r, i);
      else
        for (var a = t.length - 1; a >= 0; a--)
          (o = t[a]) &&
            (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
      return s > 3 && n && Object.defineProperty(e, r, n), n;
    };
    let O0 = class extends ue {
      constructor() {
        super(),
          (this.unsubscribe = []),
          (this.tabIdx = void 0),
          (this.connectors = oe.state.connectors),
          this.unsubscribe.push(
            oe.subscribeKey("connectors", (t) => (this.connectors = t))
          );
      }
      disconnectedCallback() {
        this.unsubscribe.forEach((t) => t());
      }
      render() {
        const t = this.connectors.filter(
          (e) => e.type === "MULTI_CHAIN" && e.name !== "WalletConnect"
        );
        return t?.length
          ? L`
      <wui-flex flexDirection="column" gap="xs">
        ${t.map(
          (e) => L`
            <wui-list-wallet
              imageSrc=${we(Ut.getConnectorImage(e))}
              .installed=${!0}
              name=${e.name ?? "Unknown"}
              tagVariant="shade"
              tagLabel="multichain"
              data-testid=${`wallet-selector-${e.id}`}
              @click=${() => this.onConnector(e)}
              tabIdx=${we(this.tabIdx)}
            >
            </wui-list-wallet>
          `
        )}
      </wui-flex>
    `
          : ((this.style.cssText = "display: none"), null);
      }
      onConnector(t) {
        oe.setActiveConnector(t), ie.push("ConnectingMultiChain");
      }
    };
    Lb([M()], O0.prototype, "tabIdx", void 0),
      Lb([le()], O0.prototype, "connectors", void 0),
      (O0 = Lb([ce("w3m-connect-multi-chain-widget")], O0));
    var N0 = function (t, e, r, i) {
      var s = arguments.length,
        n =
          s < 3
            ? e
            : i === null
            ? (i = Object.getOwnPropertyDescriptor(e, r))
            : i,
        o;
      if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        n = Reflect.decorate(t, e, r, i);
      else
        for (var a = t.length - 1; a >= 0; a--)
          (o = t[a]) &&
            (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
      return s > 3 && n && Object.defineProperty(e, r, n), n;
    };
    let Cd = class extends ue {
      constructor() {
        super(),
          (this.unsubscribe = []),
          (this.tabIdx = void 0),
          (this.connectors = oe.state.connectors),
          (this.loading = !1),
          this.unsubscribe.push(
            oe.subscribeKey("connectors", (t) => (this.connectors = t))
          ),
          X.isTelegram() &&
            X.isIos() &&
            ((this.loading = !pe.state.wcUri),
            this.unsubscribe.push(
              pe.subscribeKey("wcUri", (t) => (this.loading = !t))
            ));
      }
      render() {
        const t = de
          .getRecentWallets()
          .filter((e) => !_a.isExcluded(e))
          .filter((e) => !this.hasWalletConnector(e))
          .filter((e) => this.isWalletCompatibleWithCurrentChain(e));
        return t.length
          ? L`
      <wui-flex flexDirection="column" gap="xs">
        ${t.map(
          (e) => L`
            <wui-list-wallet
              imageSrc=${we(Ut.getWalletImage(e))}
              name=${e.name ?? "Unknown"}
              @click=${() => this.onConnectWallet(e)}
              tagLabel="recent"
              tagVariant="shade"
              tabIdx=${we(this.tabIdx)}
              ?loading=${this.loading}
            >
            </wui-list-wallet>
          `
        )}
      </wui-flex>
    `
          : ((this.style.cssText = "display: none"), null);
      }
      onConnectWallet(t) {
        this.loading || oe.selectWalletConnector(t);
      }
      hasWalletConnector(t) {
        return this.connectors.some((e) => e.id === t.id || e.name === t.name);
      }
      isWalletCompatibleWithCurrentChain(t) {
        const e = B.state.activeChain;
        return e && t.chains
          ? t.chains.some((r) => {
              const i = r.split(":")[0];
              return e === i;
            })
          : !0;
      }
    };
    N0([M()], Cd.prototype, "tabIdx", void 0),
      N0([le()], Cd.prototype, "connectors", void 0),
      N0([le()], Cd.prototype, "loading", void 0),
      (Cd = N0([ce("w3m-connect-recent-widget")], Cd));
    var T0 = function (t, e, r, i) {
      var s = arguments.length,
        n =
          s < 3
            ? e
            : i === null
            ? (i = Object.getOwnPropertyDescriptor(e, r))
            : i,
        o;
      if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        n = Reflect.decorate(t, e, r, i);
      else
        for (var a = t.length - 1; a >= 0; a--)
          (o = t[a]) &&
            (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
      return s > 3 && n && Object.defineProperty(e, r, n), n;
    };
    let xd = class extends ue {
      constructor() {
        super(),
          (this.unsubscribe = []),
          (this.tabIdx = void 0),
          (this.wallets = []),
          (this.loading = !1),
          X.isTelegram() &&
            X.isIos() &&
            ((this.loading = !pe.state.wcUri),
            this.unsubscribe.push(
              pe.subscribeKey("wcUri", (t) => (this.loading = !t))
            ));
      }
      render() {
        const { connectors: t } = oe.state,
          { customWallets: e, featuredWalletIds: r } = G.state,
          i = de.getRecentWallets(),
          s = t.find((l) => l.id === "walletConnect"),
          n = t
            .filter(
              (l) =>
                l.type === "INJECTED" ||
                l.type === "ANNOUNCED" ||
                l.type === "MULTI_CHAIN"
            )
            .filter((l) => l.name !== "Browser Wallet");
        if (!s) return null;
        if (r || e || !this.wallets.length)
          return (this.style.cssText = "display: none"), null;
        const o = n.length + i.length,
          a = Math.max(0, 2 - o),
          c = _a.filterOutDuplicateWallets(this.wallets).slice(0, a);
        return c.length
          ? L`
      <wui-flex flexDirection="column" gap="xs">
        ${c.map(
          (l) => L`
            <wui-list-wallet
              imageSrc=${we(Ut.getWalletImage(l))}
              name=${l?.name ?? "Unknown"}
              @click=${() => this.onConnectWallet(l)}
              tabIdx=${we(this.tabIdx)}
              ?loading=${this.loading}
            >
            </wui-list-wallet>
          `
        )}
      </wui-flex>
    `
          : ((this.style.cssText = "display: none"), null);
      }
      onConnectWallet(t) {
        if (this.loading) return;
        const e = oe.getConnector(t.id, t.rdns);
        e
          ? ie.push("ConnectingExternal", { connector: e })
          : ie.push("ConnectingWalletConnect", { wallet: t });
      }
    };
    T0([M()], xd.prototype, "tabIdx", void 0),
      T0([M()], xd.prototype, "wallets", void 0),
      T0([le()], xd.prototype, "loading", void 0),
      (xd = T0([ce("w3m-connect-recommended-widget")], xd));
    var k0 = function (t, e, r, i) {
      var s = arguments.length,
        n =
          s < 3
            ? e
            : i === null
            ? (i = Object.getOwnPropertyDescriptor(e, r))
            : i,
        o;
      if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        n = Reflect.decorate(t, e, r, i);
      else
        for (var a = t.length - 1; a >= 0; a--)
          (o = t[a]) &&
            (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
      return s > 3 && n && Object.defineProperty(e, r, n), n;
    };
    let Id = class extends ue {
      constructor() {
        super(),
          (this.unsubscribe = []),
          (this.tabIdx = void 0),
          (this.connectors = oe.state.connectors),
          (this.connectorImages = Gr.state.connectorImages),
          this.unsubscribe.push(
            oe.subscribeKey("connectors", (t) => (this.connectors = t)),
            Gr.subscribeKey(
              "connectorImages",
              (t) => (this.connectorImages = t)
            )
          );
      }
      disconnectedCallback() {
        this.unsubscribe.forEach((t) => t());
      }
      render() {
        if (X.isMobile()) return (this.style.cssText = "display: none"), null;
        const t = this.connectors.find((r) => r.id === "walletConnect");
        if (!t) return (this.style.cssText = "display: none"), null;
        const e = t.imageUrl || this.connectorImages[t?.imageId ?? ""];
        return L`
      <wui-list-wallet
        imageSrc=${we(e)}
        name=${t.name ?? "Unknown"}
        @click=${() => this.onConnector(t)}
        tagLabel="qr code"
        tagVariant="main"
        tabIdx=${we(this.tabIdx)}
        data-testid="wallet-selector-walletconnect"
      >
      </wui-list-wallet>
    `;
      }
      onConnector(t) {
        oe.setActiveConnector(t), ie.push("ConnectingWalletConnect");
      }
    };
    k0([M()], Id.prototype, "tabIdx", void 0),
      k0([le()], Id.prototype, "connectors", void 0),
      k0([le()], Id.prototype, "connectorImages", void 0),
      (Id = k0([ce("w3m-connect-walletconnect-widget")], Id));
    var Dle = ge`
  :host {
    margin-top: var(--wui-spacing-3xs);
  }
  wui-separator {
    margin: var(--wui-spacing-m) calc(var(--wui-spacing-m) * -1) var(--wui-spacing-xs)
      calc(var(--wui-spacing-m) * -1);
    width: calc(100% + var(--wui-spacing-s) * 2);
  }
`,
      _d = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let ka = class extends ue {
      constructor() {
        super(),
          (this.unsubscribe = []),
          (this.tabIdx = void 0),
          (this.connectors = oe.state.connectors),
          (this.recommended = ne.state.recommended),
          (this.featured = ne.state.featured),
          this.unsubscribe.push(
            oe.subscribeKey("connectors", (t) => (this.connectors = t)),
            ne.subscribeKey("recommended", (t) => (this.recommended = t)),
            ne.subscribeKey("featured", (t) => (this.featured = t))
          );
      }
      disconnectedCallback() {
        this.unsubscribe.forEach((t) => t());
      }
      render() {
        return L`
      <wui-flex flexDirection="column" gap="xs"> ${this.connectorListTemplate()} </wui-flex>
    `;
      }
      connectorListTemplate() {
        const {
          custom: t,
          recent: e,
          announced: r,
          injected: i,
          multiChain: s,
          recommended: n,
          featured: o,
          external: a,
        } = Sn.getConnectorsByType(
          this.connectors,
          this.recommended,
          this.featured
        );
        return Sn.getConnectorTypeOrder({
          custom: t,
          recent: e,
          announced: r,
          injected: i,
          multiChain: s,
          recommended: n,
          featured: o,
          external: a,
        }).map((c) => {
          switch (c) {
            case "injected":
              return L`
            ${
              s.length
                ? L`<w3m-connect-multi-chain-widget
                  tabIdx=${we(this.tabIdx)}
                ></w3m-connect-multi-chain-widget>`
                : null
            }
            ${
              r.length
                ? L`<w3m-connect-announced-widget
                  tabIdx=${we(this.tabIdx)}
                ></w3m-connect-announced-widget>`
                : null
            }
            ${
              i.length
                ? L`<w3m-connect-injected-widget
                  .connectors=${i}
                  tabIdx=${we(this.tabIdx)}
                ></w3m-connect-injected-widget>`
                : null
            }
          `;
            case "walletConnect":
              return L`<w3m-connect-walletconnect-widget
            tabIdx=${we(this.tabIdx)}
          ></w3m-connect-walletconnect-widget>`;
            case "recent":
              return L`<w3m-connect-recent-widget
            tabIdx=${we(this.tabIdx)}
          ></w3m-connect-recent-widget>`;
            case "featured":
              return L`<w3m-connect-featured-widget
            .wallets=${o}
            tabIdx=${we(this.tabIdx)}
          ></w3m-connect-featured-widget>`;
            case "custom":
              return L`<w3m-connect-custom-widget
            tabIdx=${we(this.tabIdx)}
          ></w3m-connect-custom-widget>`;
            case "external":
              return L`<w3m-connect-external-widget
            tabIdx=${we(this.tabIdx)}
          ></w3m-connect-external-widget>`;
            case "recommended":
              return L`<w3m-connect-recommended-widget
            .wallets=${n}
            tabIdx=${we(this.tabIdx)}
          ></w3m-connect-recommended-widget>`;
            default:
              return console.warn(`Unknown connector type: ${c}`), null;
          }
        });
      }
    };
    (ka.styles = Dle),
      _d([M()], ka.prototype, "tabIdx", void 0),
      _d([le()], ka.prototype, "connectors", void 0),
      _d([le()], ka.prototype, "recommended", void 0),
      _d([le()], ka.prototype, "featured", void 0),
      (ka = _d([ce("w3m-connector-list")], ka));
    var jle = ge`
  :host {
    display: inline-flex;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-3xl);
    padding: var(--wui-spacing-3xs);
    position: relative;
    height: 36px;
    min-height: 36px;
    overflow: hidden;
  }

  :host::before {
    content: '';
    position: absolute;
    pointer-events: none;
    top: 4px;
    left: 4px;
    display: block;
    width: var(--local-tab-width);
    height: 28px;
    border-radius: var(--wui-border-radius-3xl);
    background-color: var(--wui-color-gray-glass-002);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
    transform: translateX(calc(var(--local-tab) * var(--local-tab-width)));
    transition: transform var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: background-color, opacity;
  }

  :host([data-type='flex'])::before {
    left: 3px;
    transform: translateX(calc((var(--local-tab) * 34px) + (var(--local-tab) * 4px)));
  }

  :host([data-type='flex']) {
    display: flex;
    padding: 0px 0px 0px 12px;
    gap: 4px;
  }

  :host([data-type='flex']) > button > wui-text {
    position: absolute;
    left: 18px;
    opacity: 0;
  }

  button[data-active='true'] > wui-icon,
  button[data-active='true'] > wui-text {
    color: var(--wui-color-fg-100);
  }

  button[data-active='false'] > wui-icon,
  button[data-active='false'] > wui-text {
    color: var(--wui-color-fg-200);
  }

  button[data-active='true']:disabled,
  button[data-active='false']:disabled {
    background-color: transparent;
    opacity: 0.5;
    cursor: not-allowed;
  }

  button[data-active='true']:disabled > wui-text {
    color: var(--wui-color-fg-200);
  }

  button[data-active='false']:disabled > wui-text {
    color: var(--wui-color-fg-300);
  }

  button > wui-icon,
  button > wui-text {
    pointer-events: none;
    transition: color var(--wui-e ase-out-power-1) var(--wui-duration-md);
    will-change: color;
  }

  button {
    width: var(--local-tab-width);
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: background-color;
  }

  :host([data-type='flex']) > button {
    width: 34px;
    position: relative;
    display: flex;
    justify-content: flex-start;
  }

  button:hover:enabled,
  button:active:enabled {
    background-color: transparent !important;
  }

  button:hover:enabled > wui-icon,
  button:active:enabled > wui-icon {
    transition: all var(--wui-ease-out-power-1) var(--wui-duration-lg);
    color: var(--wui-color-fg-125);
  }

  button:hover:enabled > wui-text,
  button:active:enabled > wui-text {
    transition: all var(--wui-ease-out-power-1) var(--wui-duration-lg);
    color: var(--wui-color-fg-125);
  }

  button {
    border-radius: var(--wui-border-radius-3xl);
  }
`,
      Io = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let Bs = class extends ue {
      constructor() {
        super(...arguments),
          (this.tabs = []),
          (this.onTabChange = () => null),
          (this.buttons = []),
          (this.disabled = !1),
          (this.localTabWidth = "100px"),
          (this.activeTab = 0),
          (this.isDense = !1);
      }
      render() {
        return (
          (this.isDense = this.tabs.length > 3),
          (this.style.cssText = `
      --local-tab: ${this.activeTab};
      --local-tab-width: ${this.localTabWidth};
    `),
          (this.dataset.type = this.isDense ? "flex" : "block"),
          this.tabs.map((t, e) => {
            const r = e === this.activeTab;
            return L`
        <button
          ?disabled=${this.disabled}
          @click=${() => this.onTabClick(e)}
          data-active=${r}
          data-testid="tab-${t.label?.toLowerCase()}"
        >
          ${this.iconTemplate(t)}
          <wui-text variant="small-600" color="inherit"> ${t.label} </wui-text>
        </button>
      `;
          })
        );
      }
      firstUpdated() {
        this.shadowRoot &&
          this.isDense &&
          ((this.buttons = [...this.shadowRoot.querySelectorAll("button")]),
          setTimeout(() => {
            this.animateTabs(0, !0);
          }, 0));
      }
      iconTemplate(t) {
        return t.icon
          ? L`<wui-icon size="xs" color="inherit" name=${t.icon}></wui-icon>`
          : null;
      }
      onTabClick(t) {
        this.buttons && this.animateTabs(t, !1),
          (this.activeTab = t),
          this.onTabChange(t);
      }
      animateTabs(t, e) {
        const r = this.buttons[this.activeTab],
          i = this.buttons[t],
          s = r?.querySelector("wui-text"),
          n = i?.querySelector("wui-text"),
          o = i?.getBoundingClientRect(),
          a = n?.getBoundingClientRect();
        r &&
          s &&
          !e &&
          t !== this.activeTab &&
          (s.animate([{ opacity: 0 }], {
            duration: 50,
            easing: "ease",
            fill: "forwards",
          }),
          r.animate([{ width: "34px" }], {
            duration: 500,
            easing: "ease",
            fill: "forwards",
          })),
          i &&
            o &&
            a &&
            n &&
            (t !== this.activeTab || e) &&
            ((this.localTabWidth = `${Math.round(o.width + a.width) + 6}px`),
            i.animate([{ width: `${o.width + a.width}px` }], {
              duration: e ? 0 : 500,
              fill: "forwards",
              easing: "ease",
            }),
            n.animate([{ opacity: 1 }], {
              duration: e ? 0 : 125,
              delay: e ? 0 : 200,
              fill: "forwards",
              easing: "ease",
            }));
      }
    };
    (Bs.styles = [qe, Cr, jle]),
      Io([M({ type: Array })], Bs.prototype, "tabs", void 0),
      Io([M()], Bs.prototype, "onTabChange", void 0),
      Io([M({ type: Array })], Bs.prototype, "buttons", void 0),
      Io([M({ type: Boolean })], Bs.prototype, "disabled", void 0),
      Io([M()], Bs.prototype, "localTabWidth", void 0),
      Io([le()], Bs.prototype, "activeTab", void 0),
      Io([le()], Bs.prototype, "isDense", void 0),
      (Bs = Io([ce("wui-tabs")], Bs));
    var R0 = function (t, e, r, i) {
      var s = arguments.length,
        n =
          s < 3
            ? e
            : i === null
            ? (i = Object.getOwnPropertyDescriptor(e, r))
            : i,
        o;
      if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        n = Reflect.decorate(t, e, r, i);
      else
        for (var a = t.length - 1; a >= 0; a--)
          (o = t[a]) &&
            (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
      return s > 3 && n && Object.defineProperty(e, r, n), n;
    };
    let Ad = class extends ue {
      constructor() {
        super(),
          (this.platformTabs = []),
          (this.unsubscribe = []),
          (this.platforms = []),
          (this.onSelectPlatfrom = void 0),
          (this.buffering = !1),
          this.unsubscribe.push(
            pe.subscribeKey("buffering", (t) => (this.buffering = t))
          );
      }
      disconnectCallback() {
        this.unsubscribe.forEach((t) => t());
      }
      render() {
        const t = this.generateTabs();
        return L`
      <wui-flex justifyContent="center" .padding=${["0", "0", "l", "0"]}>
        <wui-tabs
          ?disabled=${this.buffering}
          .tabs=${t}
          .onTabChange=${this.onTabChange.bind(this)}
        ></wui-tabs>
      </wui-flex>
    `;
      }
      generateTabs() {
        const t = this.platforms.map((e) =>
          e === "browser"
            ? { label: "Browser", icon: "extension", platform: "browser" }
            : e === "mobile"
            ? { label: "Mobile", icon: "mobile", platform: "mobile" }
            : e === "qrcode"
            ? { label: "Mobile", icon: "mobile", platform: "qrcode" }
            : e === "web"
            ? { label: "Webapp", icon: "browser", platform: "web" }
            : e === "desktop"
            ? { label: "Desktop", icon: "desktop", platform: "desktop" }
            : { label: "Browser", icon: "extension", platform: "unsupported" }
        );
        return (this.platformTabs = t.map(({ platform: e }) => e)), t;
      }
      onTabChange(t) {
        const e = this.platformTabs[t];
        e && this.onSelectPlatfrom?.(e);
      }
    };
    R0([M({ type: Array })], Ad.prototype, "platforms", void 0),
      R0([M()], Ad.prototype, "onSelectPlatfrom", void 0),
      R0([le()], Ad.prototype, "buffering", void 0),
      (Ad = R0([ce("w3m-connecting-header")], Ad));
    var Mle = ge`
  :host {
    display: flex;
  }

  :host([data-size='sm']) > svg {
    width: 12px;
    height: 12px;
  }

  :host([data-size='md']) > svg {
    width: 16px;
    height: 16px;
  }

  :host([data-size='lg']) > svg {
    width: 24px;
    height: 24px;
  }

  :host([data-size='xl']) > svg {
    width: 32px;
    height: 32px;
  }

  svg {
    animation: rotate 2s linear infinite;
  }

  circle {
    fill: none;
    stroke: var(--local-color);
    stroke-width: 4px;
    stroke-dasharray: 1, 124;
    stroke-dashoffset: 0;
    stroke-linecap: round;
    animation: dash 1.5s ease-in-out infinite;
  }

  :host([data-size='md']) > svg > circle {
    stroke-width: 6px;
  }

  :host([data-size='sm']) > svg > circle {
    stroke-width: 8px;
  }

  @keyframes rotate {
    100% {
      transform: rotate(360deg);
    }
  }

  @keyframes dash {
    0% {
      stroke-dasharray: 1, 124;
      stroke-dashoffset: 0;
    }

    50% {
      stroke-dasharray: 90, 124;
      stroke-dashoffset: -35;
    }

    100% {
      stroke-dashoffset: -125;
    }
  }
`,
      Ub = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let Sd = class extends ue {
      constructor() {
        super(...arguments), (this.color = "accent-100"), (this.size = "lg");
      }
      render() {
        return (
          (this.style.cssText = `--local-color: ${
            this.color === "inherit"
              ? "inherit"
              : `var(--wui-color-${this.color})`
          }`),
          (this.dataset.size = this.size),
          L`<svg viewBox="25 25 50 50">
      <circle r="20" cy="50" cx="50"></circle>
    </svg>`
        );
      }
    };
    (Sd.styles = [qe, Mle]),
      Ub([M()], Sd.prototype, "color", void 0),
      Ub([M()], Sd.prototype, "size", void 0),
      (Sd = Ub([ce("wui-loading-spinner")], Sd));
    var zle = ge`
  :host {
    width: var(--local-width);
    position: relative;
  }

  button {
    border: none;
    border-radius: var(--local-border-radius);
    width: var(--local-width);
    white-space: nowrap;
  }

  /* -- Sizes --------------------------------------------------- */
  button[data-size='md'] {
    padding: 8.2px var(--wui-spacing-l) 9px var(--wui-spacing-l);
    height: 36px;
  }

  button[data-size='md'][data-icon-left='true'][data-icon-right='false'] {
    padding: 8.2px var(--wui-spacing-l) 9px var(--wui-spacing-s);
  }

  button[data-size='md'][data-icon-right='true'][data-icon-left='false'] {
    padding: 8.2px var(--wui-spacing-s) 9px var(--wui-spacing-l);
  }

  button[data-size='lg'] {
    padding: var(--wui-spacing-m) var(--wui-spacing-2l);
    height: 48px;
  }

  /* -- Variants --------------------------------------------------------- */
  button[data-variant='main'] {
    background-color: var(--wui-color-accent-100);
    color: var(--wui-color-inverse-100);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  button[data-variant='inverse'] {
    background-color: var(--wui-color-inverse-100);
    color: var(--wui-color-inverse-000);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  button[data-variant='accent'] {
    background-color: var(--wui-color-accent-glass-010);
    color: var(--wui-color-accent-100);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  button[data-variant='accent-error'] {
    background: var(--wui-color-error-glass-015);
    color: var(--wui-color-error-100);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-error-glass-010);
  }

  button[data-variant='accent-success'] {
    background: var(--wui-color-success-glass-015);
    color: var(--wui-color-success-100);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-success-glass-010);
  }

  button[data-variant='neutral'] {
    background: transparent;
    color: var(--wui-color-fg-100);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  /* -- Focus states --------------------------------------------------- */
  button[data-variant='main']:focus-visible:enabled {
    background-color: var(--wui-color-accent-090);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-accent-100),
      0 0 0 4px var(--wui-color-accent-glass-020);
  }
  button[data-variant='inverse']:focus-visible:enabled {
    background-color: var(--wui-color-inverse-100);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-gray-glass-010),
      0 0 0 4px var(--wui-color-accent-glass-020);
  }
  button[data-variant='accent']:focus-visible:enabled {
    background-color: var(--wui-color-accent-glass-010);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-accent-100),
      0 0 0 4px var(--wui-color-accent-glass-020);
  }
  button[data-variant='accent-error']:focus-visible:enabled {
    background: var(--wui-color-error-glass-015);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-error-100),
      0 0 0 4px var(--wui-color-error-glass-020);
  }
  button[data-variant='accent-success']:focus-visible:enabled {
    background: var(--wui-color-success-glass-015);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-success-100),
      0 0 0 4px var(--wui-color-success-glass-020);
  }
  button[data-variant='neutral']:focus-visible:enabled {
    background: var(--wui-color-gray-glass-005);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-gray-glass-010),
      0 0 0 4px var(--wui-color-gray-glass-002);
  }

  /* -- Hover & Active states ----------------------------------------------------------- */
  @media (hover: hover) and (pointer: fine) {
    button[data-variant='main']:hover:enabled {
      background-color: var(--wui-color-accent-090);
    }

    button[data-variant='main']:active:enabled {
      background-color: var(--wui-color-accent-080);
    }

    button[data-variant='accent']:hover:enabled {
      background-color: var(--wui-color-accent-glass-015);
    }

    button[data-variant='accent']:active:enabled {
      background-color: var(--wui-color-accent-glass-020);
    }

    button[data-variant='accent-error']:hover:enabled {
      background: var(--wui-color-error-glass-020);
      color: var(--wui-color-error-100);
    }

    button[data-variant='accent-error']:active:enabled {
      background: var(--wui-color-error-glass-030);
      color: var(--wui-color-error-100);
    }

    button[data-variant='accent-success']:hover:enabled {
      background: var(--wui-color-success-glass-020);
      color: var(--wui-color-success-100);
    }

    button[data-variant='accent-success']:active:enabled {
      background: var(--wui-color-success-glass-030);
      color: var(--wui-color-success-100);
    }

    button[data-variant='neutral']:hover:enabled {
      background: var(--wui-color-gray-glass-002);
    }

    button[data-variant='neutral']:active:enabled {
      background: var(--wui-color-gray-glass-005);
    }

    button[data-size='lg'][data-icon-left='true'][data-icon-right='false'] {
      padding-left: var(--wui-spacing-m);
    }

    button[data-size='lg'][data-icon-right='true'][data-icon-left='false'] {
      padding-right: var(--wui-spacing-m);
    }
  }

  /* -- Disabled state --------------------------------------------------- */
  button:disabled {
    background-color: var(--wui-color-gray-glass-002);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
    color: var(--wui-color-gray-glass-020);
    cursor: not-allowed;
  }

  button > wui-text {
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: opacity;
    opacity: var(--local-opacity-100);
  }

  ::slotted(*) {
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: opacity;
    opacity: var(--local-opacity-100);
  }

  wui-loading-spinner {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    opacity: var(--local-opacity-000);
  }
`,
      Ls = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    const c_ = {
        main: "inverse-100",
        inverse: "inverse-000",
        accent: "accent-100",
        "accent-error": "error-100",
        "accent-success": "success-100",
        neutral: "fg-100",
        disabled: "gray-glass-020",
      },
      qle = { lg: "paragraph-600", md: "small-600" },
      Hle = { lg: "md", md: "md" };
    let Hi = class extends ue {
      constructor() {
        super(...arguments),
          (this.size = "lg"),
          (this.disabled = !1),
          (this.fullWidth = !1),
          (this.loading = !1),
          (this.variant = "main"),
          (this.hasIconLeft = !1),
          (this.hasIconRight = !1),
          (this.borderRadius = "m");
      }
      render() {
        this.style.cssText = `
    --local-width: ${this.fullWidth ? "100%" : "auto"};
    --local-opacity-100: ${this.loading ? 0 : 1};
    --local-opacity-000: ${this.loading ? 1 : 0};
    --local-border-radius: var(--wui-border-radius-${this.borderRadius});
    `;
        const t = this.textVariant ?? qle[this.size];
        return L`
      <button
        data-variant=${this.variant}
        data-icon-left=${this.hasIconLeft}
        data-icon-right=${this.hasIconRight}
        data-size=${this.size}
        ?disabled=${this.disabled}
      >
        ${this.loadingTemplate()}
        <slot name="iconLeft" @slotchange=${() =>
          this.handleSlotLeftChange()}></slot>
        <wui-text variant=${t} color="inherit">
          <slot></slot>
        </wui-text>
        <slot name="iconRight" @slotchange=${() =>
          this.handleSlotRightChange()}></slot>
      </button>
    `;
      }
      handleSlotLeftChange() {
        this.hasIconLeft = !0;
      }
      handleSlotRightChange() {
        this.hasIconRight = !0;
      }
      loadingTemplate() {
        if (this.loading) {
          const t = Hle[this.size],
            e = this.disabled ? c_.disabled : c_[this.variant];
          return L`<wui-loading-spinner color=${e} size=${t}></wui-loading-spinner>`;
        }
        return L``;
      }
    };
    (Hi.styles = [qe, Cr, zle]),
      Ls([M()], Hi.prototype, "size", void 0),
      Ls([M({ type: Boolean })], Hi.prototype, "disabled", void 0),
      Ls([M({ type: Boolean })], Hi.prototype, "fullWidth", void 0),
      Ls([M({ type: Boolean })], Hi.prototype, "loading", void 0),
      Ls([M()], Hi.prototype, "variant", void 0),
      Ls([M({ type: Boolean })], Hi.prototype, "hasIconLeft", void 0),
      Ls([M({ type: Boolean })], Hi.prototype, "hasIconRight", void 0),
      Ls([M()], Hi.prototype, "borderRadius", void 0),
      Ls([M()], Hi.prototype, "textVariant", void 0),
      (Hi = Ls([ce("wui-button")], Hi));
    var Vle = ge`
  button {
    padding: var(--wui-spacing-4xs) var(--wui-spacing-xxs);
    border-radius: var(--wui-border-radius-3xs);
    background-color: transparent;
    color: var(--wui-color-accent-100);
  }

  button:disabled {
    background-color: transparent;
    color: var(--wui-color-gray-glass-015);
  }

  button:hover {
    background-color: var(--wui-color-gray-glass-005);
  }
`,
      $0 = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let Vl = class extends ue {
      constructor() {
        super(...arguments),
          (this.tabIdx = void 0),
          (this.disabled = !1),
          (this.color = "inherit");
      }
      render() {
        return L`
      <button ?disabled=${this.disabled} tabindex=${we(this.tabIdx)}>
        <slot name="iconLeft"></slot>
        <wui-text variant="small-600" color=${this.color}>
          <slot></slot>
        </wui-text>
        <slot name="iconRight"></slot>
      </button>
    `;
      }
    };
    (Vl.styles = [qe, Cr, Vle]),
      $0([M()], Vl.prototype, "tabIdx", void 0),
      $0([M({ type: Boolean })], Vl.prototype, "disabled", void 0),
      $0([M()], Vl.prototype, "color", void 0),
      (Vl = $0([ce("wui-link")], Vl));
    var Wle = ge`
  :host {
    display: block;
    width: var(--wui-box-size-md);
    height: var(--wui-box-size-md);
  }

  svg {
    width: var(--wui-box-size-md);
    height: var(--wui-box-size-md);
  }

  rect {
    fill: none;
    stroke: var(--wui-color-accent-100);
    stroke-width: 4px;
    stroke-linecap: round;
    animation: dash 1s linear infinite;
  }

  @keyframes dash {
    to {
      stroke-dashoffset: 0px;
    }
  }
`,
      l_ = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let F0 = class extends ue {
      constructor() {
        super(...arguments), (this.radius = 36);
      }
      render() {
        return this.svgLoaderTemplate();
      }
      svgLoaderTemplate() {
        const t = this.radius > 50 ? 50 : this.radius,
          e = 36 - t,
          r = 116 + e,
          i = 245 + e,
          s = 360 + e * 1.75;
        return L`
      <svg viewBox="0 0 110 110" width="110" height="110">
        <rect
          x="2"
          y="2"
          width="106"
          height="106"
          rx=${t}
          stroke-dasharray="${r} ${i}"
          stroke-dashoffset=${s}
        />
      </svg>
    `;
      }
    };
    (F0.styles = [qe, Wle]),
      l_([M({ type: Number })], F0.prototype, "radius", void 0),
      (F0 = l_([ce("wui-loading-thumbnail")], F0));
    var Kle = ge`
  button {
    border: none;
    border-radius: var(--wui-border-radius-3xl);
  }

  button[data-variant='main'] {
    background-color: var(--wui-color-accent-100);
    color: var(--wui-color-inverse-100);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  button[data-variant='accent'] {
    background-color: var(--wui-color-accent-glass-010);
    color: var(--wui-color-accent-100);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  button[data-variant='gray'] {
    background-color: transparent;
    color: var(--wui-color-fg-200);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  button[data-variant='shade'] {
    background-color: transparent;
    color: var(--wui-color-accent-100);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  button[data-size='sm'] {
    height: 32px;
    padding: 0 var(--wui-spacing-s);
  }

  button[data-size='md'] {
    height: 40px;
    padding: 0 var(--wui-spacing-l);
  }

  button[data-size='sm'] > wui-image {
    width: 16px;
    height: 16px;
  }

  button[data-size='md'] > wui-image {
    width: 24px;
    height: 24px;
  }

  button[data-size='sm'] > wui-icon {
    width: 12px;
    height: 12px;
  }

  button[data-size='md'] > wui-icon {
    width: 14px;
    height: 14px;
  }

  wui-image {
    border-radius: var(--wui-border-radius-3xl);
    overflow: hidden;
  }

  button.disabled > wui-icon,
  button.disabled > wui-image {
    filter: grayscale(1);
  }

  button[data-variant='main'] > wui-image {
    box-shadow: inset 0 0 0 1px var(--wui-color-accent-090);
  }

  button[data-variant='shade'] > wui-image,
  button[data-variant='gray'] > wui-image {
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  @media (hover: hover) and (pointer: fine) {
    button[data-variant='main']:focus-visible {
      background-color: var(--wui-color-accent-090);
    }

    button[data-variant='main']:hover:enabled {
      background-color: var(--wui-color-accent-090);
    }

    button[data-variant='main']:active:enabled {
      background-color: var(--wui-color-accent-080);
    }

    button[data-variant='accent']:hover:enabled {
      background-color: var(--wui-color-accent-glass-015);
    }

    button[data-variant='accent']:active:enabled {
      background-color: var(--wui-color-accent-glass-020);
    }

    button[data-variant='shade']:focus-visible,
    button[data-variant='gray']:focus-visible,
    button[data-variant='shade']:hover,
    button[data-variant='gray']:hover {
      background-color: var(--wui-color-gray-glass-002);
    }

    button[data-variant='gray']:active,
    button[data-variant='shade']:active {
      background-color: var(--wui-color-gray-glass-005);
    }
  }

  button.disabled {
    color: var(--wui-color-gray-glass-020);
    background-color: var(--wui-color-gray-glass-002);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
    pointer-events: none;
  }
`,
      Ra = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let Tn = class extends ue {
      constructor() {
        super(...arguments),
          (this.variant = "accent"),
          (this.imageSrc = ""),
          (this.disabled = !1),
          (this.icon = "externalLink"),
          (this.size = "md"),
          (this.text = "");
      }
      render() {
        const t = this.size === "sm" ? "small-600" : "paragraph-600";
        return L`
      <button
        class=${this.disabled ? "disabled" : ""}
        data-variant=${this.variant}
        data-size=${this.size}
      >
        ${
          this.imageSrc ? L`<wui-image src=${this.imageSrc}></wui-image>` : null
        }
        <wui-text variant=${t} color="inherit"> ${this.text} </wui-text>
        <wui-icon name=${this.icon} color="inherit" size="inherit"></wui-icon>
      </button>
    `;
      }
    };
    (Tn.styles = [qe, Cr, Kle]),
      Ra([M()], Tn.prototype, "variant", void 0),
      Ra([M()], Tn.prototype, "imageSrc", void 0),
      Ra([M({ type: Boolean })], Tn.prototype, "disabled", void 0),
      Ra([M()], Tn.prototype, "icon", void 0),
      Ra([M()], Tn.prototype, "size", void 0),
      Ra([M()], Tn.prototype, "text", void 0),
      (Tn = Ra([ce("wui-chip-button")], Tn));
    var Gle = ge`
  wui-flex {
    width: 100%;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
  }
`,
      B0 = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let Wl = class extends ue {
      constructor() {
        super(...arguments),
          (this.disabled = !1),
          (this.label = ""),
          (this.buttonLabel = "");
      }
      render() {
        return L`
      <wui-flex
        justifyContent="space-between"
        alignItems="center"
        .padding=${["1xs", "2l", "1xs", "2l"]}
      >
        <wui-text variant="paragraph-500" color="fg-200">${
          this.label
        }</wui-text>
        <wui-chip-button size="sm" variant="shade" text=${
          this.buttonLabel
        } icon="chevronRight">
        </wui-chip-button>
      </wui-flex>
    `;
      }
    };
    (Wl.styles = [qe, Cr, Gle]),
      B0([M({ type: Boolean })], Wl.prototype, "disabled", void 0),
      B0([M()], Wl.prototype, "label", void 0),
      B0([M()], Wl.prototype, "buttonLabel", void 0),
      (Wl = B0([ce("wui-cta-button")], Wl));
    var Zle = ge`
  :host {
    display: block;
    padding: 0 var(--wui-spacing-xl) var(--wui-spacing-xl);
  }
`,
      u_ = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let L0 = class extends ue {
      constructor() {
        super(...arguments), (this.wallet = void 0);
      }
      render() {
        if (!this.wallet) return (this.style.display = "none"), null;
        const {
            name: t,
            app_store: e,
            play_store: r,
            chrome_store: i,
            homepage: s,
          } = this.wallet,
          n = X.isMobile(),
          o = X.isIos(),
          a = X.isAndroid(),
          c = [e, r, s, i].filter(Boolean).length > 1,
          l = ar.getTruncateString({
            string: t,
            charsStart: 12,
            charsEnd: 0,
            truncate: "end",
          });
        return c && !n
          ? L`
        <wui-cta-button
          label=${`Don't have ${l}?`}
          buttonLabel="Get"
          @click=${() => ie.push("Downloads", { wallet: this.wallet })}
        ></wui-cta-button>
      `
          : !c && s
          ? L`
        <wui-cta-button
          label=${`Don't have ${l}?`}
          buttonLabel="Get"
          @click=${this.onHomePage.bind(this)}
        ></wui-cta-button>
      `
          : e && o
          ? L`
        <wui-cta-button
          label=${`Don't have ${l}?`}
          buttonLabel="Get"
          @click=${this.onAppStore.bind(this)}
        ></wui-cta-button>
      `
          : r && a
          ? L`
        <wui-cta-button
          label=${`Don't have ${l}?`}
          buttonLabel="Get"
          @click=${this.onPlayStore.bind(this)}
        ></wui-cta-button>
      `
          : ((this.style.display = "none"), null);
      }
      onAppStore() {
        this.wallet?.app_store && X.openHref(this.wallet.app_store, "_blank");
      }
      onPlayStore() {
        this.wallet?.play_store && X.openHref(this.wallet.play_store, "_blank");
      }
      onHomePage() {
        this.wallet?.homepage && X.openHref(this.wallet.homepage, "_blank");
      }
    };
    (L0.styles = [Zle]),
      u_([M({ type: Object })], L0.prototype, "wallet", void 0),
      (L0 = u_([ce("w3m-mobile-download-links")], L0));
    var Yle = ge`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-thumbnail {
    position: absolute;
  }

  wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition-property: opacity, transform;
    transition-duration: var(--wui-duration-lg);
    transition-timing-function: var(--wui-ease-out-power-2);
    will-change: opacity, transform;
  }

  wui-text[align='center'] {
    width: 100%;
    padding: 0px var(--wui-spacing-l);
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  [data-retry='false'] wui-link {
    display: none;
  }

  [data-retry='true'] wui-link {
    display: block;
    opacity: 1;
  }
`,
      ds = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    class xr extends ue {
      constructor() {
        super(),
          (this.wallet = ie.state.data?.wallet),
          (this.connector = ie.state.data?.connector),
          (this.timeout = void 0),
          (this.secondaryBtnIcon = "refresh"),
          (this.onConnect = void 0),
          (this.onRender = void 0),
          (this.onAutoConnect = void 0),
          (this.isWalletConnect = !0),
          (this.unsubscribe = []),
          (this.imageSrc =
            Ut.getWalletImage(this.wallet) ??
            Ut.getConnectorImage(this.connector)),
          (this.name = this.wallet?.name ?? this.connector?.name ?? "Wallet"),
          (this.isRetrying = !1),
          (this.uri = pe.state.wcUri),
          (this.error = pe.state.wcError),
          (this.ready = !1),
          (this.showRetry = !1),
          (this.secondaryBtnLabel = "Try again"),
          (this.secondaryLabel = "Accept connection request in the wallet"),
          (this.buffering = !1),
          (this.isLoading = !1),
          (this.isMobile = !1),
          (this.onRetry = void 0),
          this.unsubscribe.push(
            pe.subscribeKey("wcUri", (e) => {
              (this.uri = e),
                this.isRetrying &&
                  this.onRetry &&
                  ((this.isRetrying = !1), this.onConnect?.());
            }),
            pe.subscribeKey("wcError", (e) => (this.error = e)),
            pe.subscribeKey("buffering", (e) => (this.buffering = e))
          ),
          (X.isTelegram() || X.isSafari()) &&
            X.isIos() &&
            pe.state.wcUri &&
            this.onConnect?.();
      }
      firstUpdated() {
        this.onAutoConnect?.(), (this.showRetry = !this.onAutoConnect);
      }
      disconnectedCallback() {
        this.unsubscribe.forEach((e) => e()), clearTimeout(this.timeout);
      }
      render() {
        this.onRender?.(), this.onShowRetry();
        const e = this.error
          ? "Connection can be declined if a previous request is still active"
          : this.secondaryLabel;
        let r = `Continue in ${this.name}`;
        return (
          this.buffering && (r = "Connecting..."),
          this.error && (r = "Connection declined"),
          L`
      <wui-flex
        data-error=${we(this.error)}
        data-retry=${this.showRetry}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-wallet-image size="lg" imageSrc=${we(
            this.imageSrc
          )}></wui-wallet-image>

          ${this.error ? null : this.loaderTemplate()}

          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            border
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text variant="paragraph-500" color=${
            this.error ? "error-100" : "fg-100"
          }>
            ${r}
          </wui-text>
          <wui-text align="center" variant="small-500" color="fg-200">${e}</wui-text>
        </wui-flex>

        ${
          this.secondaryBtnLabel
            ? L`
              <wui-button
                variant="accent"
                size="md"
                ?disabled=${
                  this.isRetrying ||
                  (!this.error && this.buffering) ||
                  this.isLoading
                }
                @click=${this.onTryAgain.bind(this)}
                data-testid="w3m-connecting-widget-secondary-button"
              >
                <wui-icon color="inherit" slot="iconLeft" name=${
                  this.secondaryBtnIcon
                }></wui-icon>
                ${this.secondaryBtnLabel}
              </wui-button>
            `
            : null
        }
      </wui-flex>

      ${
        this.isWalletConnect
          ? L`
            <wui-flex .padding=${[
              "0",
              "xl",
              "xl",
              "xl",
            ]} justifyContent="center">
              <wui-link @click=${
                this.onCopyUri
              } color="fg-200" data-testid="wui-link-copy">
                <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
                Copy link
              </wui-link>
            </wui-flex>
          `
          : null
      }

      <w3m-mobile-download-links .wallet=${
        this.wallet
      }></w3m-mobile-download-links>
    `
        );
      }
      onShowRetry() {
        this.error &&
          !this.showRetry &&
          ((this.showRetry = !0),
          this.shadowRoot
            ?.querySelector("wui-button")
            ?.animate([{ opacity: 0 }, { opacity: 1 }], {
              fill: "forwards",
              easing: "ease",
            }));
      }
      onTryAgain() {
        this.buffering ||
          (pe.setWcError(!1),
          this.onRetry
            ? ((this.isRetrying = !0), this.onRetry?.())
            : this.onConnect?.());
      }
      loaderTemplate() {
        const e = Dt.state.themeVariables["--w3m-border-radius-master"],
          r = e ? parseInt(e.replace("px", ""), 10) : 4;
        return L`<wui-loading-thumbnail radius=${
          r * 9
        }></wui-loading-thumbnail>`;
      }
      onCopyUri() {
        try {
          this.uri &&
            (X.copyToClopboard(this.uri), at.showSuccess("Link copied"));
        } catch {
          at.showError("Failed to copy");
        }
      }
    }
    (xr.styles = Yle),
      ds([le()], xr.prototype, "isRetrying", void 0),
      ds([le()], xr.prototype, "uri", void 0),
      ds([le()], xr.prototype, "error", void 0),
      ds([le()], xr.prototype, "ready", void 0),
      ds([le()], xr.prototype, "showRetry", void 0),
      ds([le()], xr.prototype, "secondaryBtnLabel", void 0),
      ds([le()], xr.prototype, "secondaryLabel", void 0),
      ds([le()], xr.prototype, "buffering", void 0),
      ds([le()], xr.prototype, "isLoading", void 0),
      ds([M({ type: Boolean })], xr.prototype, "isMobile", void 0),
      ds([M()], xr.prototype, "onRetry", void 0);
    var Jle = function (t, e, r, i) {
      var s = arguments.length,
        n =
          s < 3
            ? e
            : i === null
            ? (i = Object.getOwnPropertyDescriptor(e, r))
            : i,
        o;
      if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        n = Reflect.decorate(t, e, r, i);
      else
        for (var a = t.length - 1; a >= 0; a--)
          (o = t[a]) &&
            (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
      return s > 3 && n && Object.defineProperty(e, r, n), n;
    };
    let h_ = class extends xr {
      constructor() {
        if ((super(), !this.wallet))
          throw new Error("w3m-connecting-wc-browser: No wallet provided");
        (this.onConnect = this.onConnectProxy.bind(this)),
          (this.onAutoConnect = this.onConnectProxy.bind(this)),
          Se.sendEvent({
            type: "track",
            event: "SELECT_WALLET",
            properties: { name: this.wallet.name, platform: "browser" },
          });
      }
      async onConnectProxy() {
        try {
          this.error = !1;
          const { connectors: t } = oe.state,
            e = t.find(
              (r) =>
                (r.type === "ANNOUNCED" &&
                  r.info?.rdns === this.wallet?.rdns) ||
                r.type === "INJECTED" ||
                r.name === this.wallet?.name
            );
          if (e) await pe.connectExternal(e, e.chain);
          else throw new Error("w3m-connecting-wc-browser: No connector found");
          $e.close(),
            Se.sendEvent({
              type: "track",
              event: "CONNECT_SUCCESS",
              properties: {
                method: "browser",
                name: this.wallet?.name || "Unknown",
              },
            });
        } catch (t) {
          Se.sendEvent({
            type: "track",
            event: "CONNECT_ERROR",
            properties: { message: t?.message ?? "Unknown" },
          }),
            (this.error = !0);
        }
      }
    };
    h_ = Jle([ce("w3m-connecting-wc-browser")], h_);
    var Xle = function (t, e, r, i) {
      var s = arguments.length,
        n =
          s < 3
            ? e
            : i === null
            ? (i = Object.getOwnPropertyDescriptor(e, r))
            : i,
        o;
      if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        n = Reflect.decorate(t, e, r, i);
      else
        for (var a = t.length - 1; a >= 0; a--)
          (o = t[a]) &&
            (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
      return s > 3 && n && Object.defineProperty(e, r, n), n;
    };
    let d_ = class extends xr {
      constructor() {
        if ((super(), !this.wallet))
          throw new Error("w3m-connecting-wc-desktop: No wallet provided");
        (this.onConnect = this.onConnectProxy.bind(this)),
          (this.onRender = this.onRenderProxy.bind(this)),
          Se.sendEvent({
            type: "track",
            event: "SELECT_WALLET",
            properties: { name: this.wallet.name, platform: "desktop" },
          });
      }
      onRenderProxy() {
        !this.ready && this.uri && ((this.ready = !0), this.onConnect?.());
      }
      onConnectProxy() {
        if (this.wallet?.desktop_link && this.uri)
          try {
            this.error = !1;
            const { desktop_link: t, name: e } = this.wallet,
              { redirect: r, href: i } = X.formatNativeUrl(t, this.uri);
            pe.setWcLinking({ name: e, href: i }),
              pe.setRecentWallet(this.wallet),
              X.openHref(r, "_blank");
          } catch {
            this.error = !0;
          }
      }
    };
    d_ = Xle([ce("w3m-connecting-wc-desktop")], d_);
    var Qle = function (t, e, r, i) {
      var s = arguments.length,
        n =
          s < 3
            ? e
            : i === null
            ? (i = Object.getOwnPropertyDescriptor(e, r))
            : i,
        o;
      if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        n = Reflect.decorate(t, e, r, i);
      else
        for (var a = t.length - 1; a >= 0; a--)
          (o = t[a]) &&
            (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
      return s > 3 && n && Object.defineProperty(e, r, n), n;
    };
    let p_ = class extends xr {
      constructor() {
        if (
          (super(),
          (this.btnLabelTimeout = void 0),
          (this.labelTimeout = void 0),
          (this.onRender = () => {
            !this.ready && this.uri && ((this.ready = !0), this.onConnect?.());
          }),
          (this.onConnect = () => {
            if (this.wallet?.mobile_link && this.uri)
              try {
                this.error = !1;
                const { mobile_link: t, name: e } = this.wallet,
                  { redirect: r, href: i } = X.formatNativeUrl(t, this.uri);
                pe.setWcLinking({ name: e, href: i }),
                  pe.setRecentWallet(this.wallet);
                const s = X.isIframe() ? "_top" : "_self";
                X.openHref(r, s),
                  clearTimeout(this.labelTimeout),
                  (this.secondaryLabel = Lt.CONNECT_LABELS.MOBILE);
              } catch (t) {
                Se.sendEvent({
                  type: "track",
                  event: "CONNECT_PROXY_ERROR",
                  properties: {
                    message:
                      t instanceof Error
                        ? t.message
                        : "Error parsing the deeplink",
                    uri: this.uri,
                    mobile_link: this.wallet.mobile_link,
                    name: this.wallet.name,
                  },
                }),
                  (this.error = !0);
              }
          }),
          !this.wallet)
        )
          throw new Error("w3m-connecting-wc-mobile: No wallet provided");
        this.initializeStateAndTimers(),
          document.addEventListener(
            "visibilitychange",
            this.onBuffering.bind(this)
          ),
          Se.sendEvent({
            type: "track",
            event: "SELECT_WALLET",
            properties: { name: this.wallet.name, platform: "mobile" },
          });
      }
      disconnectedCallback() {
        super.disconnectedCallback(),
          document.removeEventListener(
            "visibilitychange",
            this.onBuffering.bind(this)
          ),
          clearTimeout(this.btnLabelTimeout),
          clearTimeout(this.labelTimeout);
      }
      initializeStateAndTimers() {
        (this.secondaryBtnLabel = void 0),
          (this.secondaryLabel = Lt.CONNECT_LABELS.MOBILE),
          (this.btnLabelTimeout = setTimeout(() => {
            (this.secondaryBtnLabel = "Try again"),
              (this.secondaryLabel = Lt.CONNECT_LABELS.MOBILE);
          }, Lt.FIVE_SEC_MS)),
          (this.labelTimeout = setTimeout(() => {
            this.secondaryLabel =
              "Hold tight... it's taking longer than expected";
          }, Lt.THREE_SEC_MS));
      }
      onBuffering() {
        const t = X.isIos();
        document?.visibilityState === "visible" &&
          !this.error &&
          t &&
          (pe.setBuffering(!0),
          setTimeout(() => {
            pe.setBuffering(!1);
          }, 5e3));
      }
      onTryAgain() {
        this.buffering ||
          (clearTimeout(this.btnLabelTimeout),
          clearTimeout(this.labelTimeout),
          this.initializeStateAndTimers(),
          pe.setWcError(!1),
          this.onConnect());
      }
    };
    p_ = Qle([ce("w3m-connecting-wc-mobile")], p_);
    var Pd = {},
      eue = function () {
        return (
          typeof Promise == "function" &&
          Promise.prototype &&
          Promise.prototype.then
        );
      },
      f_ = {},
      Si = {};
    let Db;
    const tue = [
      0, 26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655,
      733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921,
      2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706,
    ];
    (Si.getSymbolSize = function (t) {
      if (!t) throw new Error('"version" cannot be null or undefined');
      if (t < 1 || t > 40)
        throw new Error('"version" should be in range from 1 to 40');
      return t * 4 + 17;
    }),
      (Si.getSymbolTotalCodewords = function (t) {
        return tue[t];
      }),
      (Si.getBCHDigit = function (t) {
        let e = 0;
        for (; t !== 0; ) e++, (t >>>= 1);
        return e;
      }),
      (Si.setToSJISFunction = function (t) {
        if (typeof t != "function")
          throw new Error('"toSJISFunc" is not a valid function.');
        Db = t;
      }),
      (Si.isKanjiModeEnabled = function () {
        return typeof Db < "u";
      }),
      (Si.toSJIS = function (t) {
        return Db(t);
      });
    var U0 = {};
    (function (t) {
      (t.L = { bit: 1 }),
        (t.M = { bit: 0 }),
        (t.Q = { bit: 3 }),
        (t.H = { bit: 2 });
      function e(r) {
        if (typeof r != "string") throw new Error("Param is not a string");
        switch (r.toLowerCase()) {
          case "l":
          case "low":
            return t.L;
          case "m":
          case "medium":
            return t.M;
          case "q":
          case "quartile":
            return t.Q;
          case "h":
          case "high":
            return t.H;
          default:
            throw new Error("Unknown EC Level: " + r);
        }
      }
      (t.isValid = function (r) {
        return r && typeof r.bit < "u" && r.bit >= 0 && r.bit < 4;
      }),
        (t.from = function (r, i) {
          if (t.isValid(r)) return r;
          try {
            return e(r);
          } catch {
            return i;
          }
        });
    })(U0);
    function g_() {
      (this.buffer = []), (this.length = 0);
    }
    g_.prototype = {
      get: function (t) {
        const e = Math.floor(t / 8);
        return ((this.buffer[e] >>> (7 - (t % 8))) & 1) === 1;
      },
      put: function (t, e) {
        for (let r = 0; r < e; r++)
          this.putBit(((t >>> (e - r - 1)) & 1) === 1);
      },
      getLengthInBits: function () {
        return this.length;
      },
      putBit: function (t) {
        const e = Math.floor(this.length / 8);
        this.buffer.length <= e && this.buffer.push(0),
          t && (this.buffer[e] |= 128 >>> this.length % 8),
          this.length++;
      },
    };
    var rue = g_;
    function Od(t) {
      if (!t || t < 1)
        throw new Error("BitMatrix size must be defined and greater than 0");
      (this.size = t),
        (this.data = new Uint8Array(t * t)),
        (this.reservedBit = new Uint8Array(t * t));
    }
    (Od.prototype.set = function (t, e, r, i) {
      const s = t * this.size + e;
      (this.data[s] = r), i && (this.reservedBit[s] = !0);
    }),
      (Od.prototype.get = function (t, e) {
        return this.data[t * this.size + e];
      }),
      (Od.prototype.xor = function (t, e, r) {
        this.data[t * this.size + e] ^= r;
      }),
      (Od.prototype.isReserved = function (t, e) {
        return this.reservedBit[t * this.size + e];
      });
    var iue = Od,
      w_ = {};
    (function (t) {
      const e = Si.getSymbolSize;
      (t.getRowColCoords = function (r) {
        if (r === 1) return [];
        const i = Math.floor(r / 7) + 2,
          s = e(r),
          n = s === 145 ? 26 : Math.ceil((s - 13) / (2 * i - 2)) * 2,
          o = [s - 7];
        for (let a = 1; a < i - 1; a++) o[a] = o[a - 1] - n;
        return o.push(6), o.reverse();
      }),
        (t.getPositions = function (r) {
          const i = [],
            s = t.getRowColCoords(r),
            n = s.length;
          for (let o = 0; o < n; o++)
            for (let a = 0; a < n; a++)
              (o === 0 && a === 0) ||
                (o === 0 && a === n - 1) ||
                (o === n - 1 && a === 0) ||
                i.push([s[o], s[a]]);
          return i;
        });
    })(w_);
    var m_ = {};
    const sue = Si.getSymbolSize,
      y_ = 7;
    m_.getPositions = function (t) {
      const e = sue(t);
      return [
        [0, 0],
        [e - y_, 0],
        [0, e - y_],
      ];
    };
    var b_ = {};
    (function (t) {
      t.Patterns = {
        PATTERN000: 0,
        PATTERN001: 1,
        PATTERN010: 2,
        PATTERN011: 3,
        PATTERN100: 4,
        PATTERN101: 5,
        PATTERN110: 6,
        PATTERN111: 7,
      };
      const e = { N1: 3, N2: 3, N3: 40, N4: 10 };
      (t.isValid = function (i) {
        return i != null && i !== "" && !isNaN(i) && i >= 0 && i <= 7;
      }),
        (t.from = function (i) {
          return t.isValid(i) ? parseInt(i, 10) : void 0;
        }),
        (t.getPenaltyN1 = function (i) {
          const s = i.size;
          let n = 0,
            o = 0,
            a = 0,
            c = null,
            l = null;
          for (let u = 0; u < s; u++) {
            (o = a = 0), (c = l = null);
            for (let h = 0; h < s; h++) {
              let d = i.get(u, h);
              d === c
                ? o++
                : (o >= 5 && (n += e.N1 + (o - 5)), (c = d), (o = 1)),
                (d = i.get(h, u)),
                d === l
                  ? a++
                  : (a >= 5 && (n += e.N1 + (a - 5)), (l = d), (a = 1));
            }
            o >= 5 && (n += e.N1 + (o - 5)), a >= 5 && (n += e.N1 + (a - 5));
          }
          return n;
        }),
        (t.getPenaltyN2 = function (i) {
          const s = i.size;
          let n = 0;
          for (let o = 0; o < s - 1; o++)
            for (let a = 0; a < s - 1; a++) {
              const c =
                i.get(o, a) +
                i.get(o, a + 1) +
                i.get(o + 1, a) +
                i.get(o + 1, a + 1);
              (c === 4 || c === 0) && n++;
            }
          return n * e.N2;
        }),
        (t.getPenaltyN3 = function (i) {
          const s = i.size;
          let n = 0,
            o = 0,
            a = 0;
          for (let c = 0; c < s; c++) {
            o = a = 0;
            for (let l = 0; l < s; l++)
              (o = ((o << 1) & 2047) | i.get(c, l)),
                l >= 10 && (o === 1488 || o === 93) && n++,
                (a = ((a << 1) & 2047) | i.get(l, c)),
                l >= 10 && (a === 1488 || a === 93) && n++;
          }
          return n * e.N3;
        }),
        (t.getPenaltyN4 = function (i) {
          let s = 0;
          const n = i.data.length;
          for (let o = 0; o < n; o++) s += i.data[o];
          return Math.abs(Math.ceil((s * 100) / n / 5) - 10) * e.N4;
        });
      function r(i, s, n) {
        switch (i) {
          case t.Patterns.PATTERN000:
            return (s + n) % 2 === 0;
          case t.Patterns.PATTERN001:
            return s % 2 === 0;
          case t.Patterns.PATTERN010:
            return n % 3 === 0;
          case t.Patterns.PATTERN011:
            return (s + n) % 3 === 0;
          case t.Patterns.PATTERN100:
            return (Math.floor(s / 2) + Math.floor(n / 3)) % 2 === 0;
          case t.Patterns.PATTERN101:
            return ((s * n) % 2) + ((s * n) % 3) === 0;
          case t.Patterns.PATTERN110:
            return (((s * n) % 2) + ((s * n) % 3)) % 2 === 0;
          case t.Patterns.PATTERN111:
            return (((s * n) % 3) + ((s + n) % 2)) % 2 === 0;
          default:
            throw new Error("bad maskPattern:" + i);
        }
      }
      (t.applyMask = function (i, s) {
        const n = s.size;
        for (let o = 0; o < n; o++)
          for (let a = 0; a < n; a++)
            s.isReserved(a, o) || s.xor(a, o, r(i, a, o));
      }),
        (t.getBestMask = function (i, s) {
          const n = Object.keys(t.Patterns).length;
          let o = 0,
            a = 1 / 0;
          for (let c = 0; c < n; c++) {
            s(c), t.applyMask(c, i);
            const l =
              t.getPenaltyN1(i) +
              t.getPenaltyN2(i) +
              t.getPenaltyN3(i) +
              t.getPenaltyN4(i);
            t.applyMask(c, i), l < a && ((a = l), (o = c));
          }
          return o;
        });
    })(b_);
    var D0 = {};
    const _o = U0,
      j0 = [
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 4, 4, 2, 4, 4, 4,
        2, 4, 6, 5, 2, 4, 6, 6, 2, 5, 8, 8, 4, 5, 8, 8, 4, 5, 8, 11, 4, 8, 10,
        11, 4, 9, 12, 16, 4, 9, 16, 16, 6, 10, 12, 18, 6, 10, 17, 16, 6, 11, 16,
        19, 6, 13, 18, 21, 7, 14, 21, 25, 8, 16, 20, 25, 8, 17, 23, 25, 9, 17,
        23, 34, 9, 18, 25, 30, 10, 20, 27, 32, 12, 21, 29, 35, 12, 23, 34, 37,
        12, 25, 34, 40, 13, 26, 35, 42, 14, 28, 38, 45, 15, 29, 40, 48, 16, 31,
        43, 51, 17, 33, 45, 54, 18, 35, 48, 57, 19, 37, 51, 60, 19, 38, 53, 63,
        20, 40, 56, 66, 21, 43, 59, 70, 22, 45, 62, 74, 24, 47, 65, 77, 25, 49,
        68, 81,
      ],
      M0 = [
        7, 10, 13, 17, 10, 16, 22, 28, 15, 26, 36, 44, 20, 36, 52, 64, 26, 48,
        72, 88, 36, 64, 96, 112, 40, 72, 108, 130, 48, 88, 132, 156, 60, 110,
        160, 192, 72, 130, 192, 224, 80, 150, 224, 264, 96, 176, 260, 308, 104,
        198, 288, 352, 120, 216, 320, 384, 132, 240, 360, 432, 144, 280, 408,
        480, 168, 308, 448, 532, 180, 338, 504, 588, 196, 364, 546, 650, 224,
        416, 600, 700, 224, 442, 644, 750, 252, 476, 690, 816, 270, 504, 750,
        900, 300, 560, 810, 960, 312, 588, 870, 1050, 336, 644, 952, 1110, 360,
        700, 1020, 1200, 390, 728, 1050, 1260, 420, 784, 1140, 1350, 450, 812,
        1200, 1440, 480, 868, 1290, 1530, 510, 924, 1350, 1620, 540, 980, 1440,
        1710, 570, 1036, 1530, 1800, 570, 1064, 1590, 1890, 600, 1120, 1680,
        1980, 630, 1204, 1770, 2100, 660, 1260, 1860, 2220, 720, 1316, 1950,
        2310, 750, 1372, 2040, 2430,
      ];
    (D0.getBlocksCount = function (t, e) {
      switch (e) {
        case _o.L:
          return j0[(t - 1) * 4 + 0];
        case _o.M:
          return j0[(t - 1) * 4 + 1];
        case _o.Q:
          return j0[(t - 1) * 4 + 2];
        case _o.H:
          return j0[(t - 1) * 4 + 3];
        default:
          return;
      }
    }),
      (D0.getTotalCodewordsCount = function (t, e) {
        switch (e) {
          case _o.L:
            return M0[(t - 1) * 4 + 0];
          case _o.M:
            return M0[(t - 1) * 4 + 1];
          case _o.Q:
            return M0[(t - 1) * 4 + 2];
          case _o.H:
            return M0[(t - 1) * 4 + 3];
          default:
            return;
        }
      });
    var v_ = {},
      z0 = {};
    const Nd = new Uint8Array(512),
      q0 = new Uint8Array(256);
    (function () {
      let t = 1;
      for (let e = 0; e < 255; e++)
        (Nd[e] = t), (q0[t] = e), (t <<= 1), t & 256 && (t ^= 285);
      for (let e = 255; e < 512; e++) Nd[e] = Nd[e - 255];
    })(),
      (z0.log = function (t) {
        if (t < 1) throw new Error("log(" + t + ")");
        return q0[t];
      }),
      (z0.exp = function (t) {
        return Nd[t];
      }),
      (z0.mul = function (t, e) {
        return t === 0 || e === 0 ? 0 : Nd[q0[t] + q0[e]];
      }),
      (function (t) {
        const e = z0;
        (t.mul = function (r, i) {
          const s = new Uint8Array(r.length + i.length - 1);
          for (let n = 0; n < r.length; n++)
            for (let o = 0; o < i.length; o++) s[n + o] ^= e.mul(r[n], i[o]);
          return s;
        }),
          (t.mod = function (r, i) {
            let s = new Uint8Array(r);
            for (; s.length - i.length >= 0; ) {
              const n = s[0];
              for (let a = 0; a < i.length; a++) s[a] ^= e.mul(i[a], n);
              let o = 0;
              for (; o < s.length && s[o] === 0; ) o++;
              s = s.slice(o);
            }
            return s;
          }),
          (t.generateECPolynomial = function (r) {
            let i = new Uint8Array([1]);
            for (let s = 0; s < r; s++)
              i = t.mul(i, new Uint8Array([1, e.exp(s)]));
            return i;
          });
      })(v_);
    const E_ = v_;
    function jb(t) {
      (this.genPoly = void 0),
        (this.degree = t),
        this.degree && this.initialize(this.degree);
    }
    (jb.prototype.initialize = function (t) {
      (this.degree = t), (this.genPoly = E_.generateECPolynomial(this.degree));
    }),
      (jb.prototype.encode = function (t) {
        if (!this.genPoly) throw new Error("Encoder not initialized");
        const e = new Uint8Array(t.length + this.degree);
        e.set(t);
        const r = E_.mod(e, this.genPoly),
          i = this.degree - r.length;
        if (i > 0) {
          const s = new Uint8Array(this.degree);
          return s.set(r, i), s;
        }
        return r;
      });
    var nue = jb,
      C_ = {},
      Ao = {},
      Mb = {};
    Mb.isValid = function (t) {
      return !isNaN(t) && t >= 1 && t <= 40;
    };
    var Us = {};
    const x_ = "[0-9]+",
      oue = "[A-Z $%*+\\-./:]+";
    let Td =
      "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
    Td = Td.replace(/u/g, "\\u");
    const aue =
      "(?:(?![A-Z0-9 $%*+\\-./:]|" +
      Td +
      `)(?:.|[\r
]))+`;
    (Us.KANJI = new RegExp(Td, "g")),
      (Us.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g")),
      (Us.BYTE = new RegExp(aue, "g")),
      (Us.NUMERIC = new RegExp(x_, "g")),
      (Us.ALPHANUMERIC = new RegExp(oue, "g"));
    const cue = new RegExp("^" + Td + "$"),
      lue = new RegExp("^" + x_ + "$"),
      uue = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
    (Us.testKanji = function (t) {
      return cue.test(t);
    }),
      (Us.testNumeric = function (t) {
        return lue.test(t);
      }),
      (Us.testAlphanumeric = function (t) {
        return uue.test(t);
      }),
      (function (t) {
        const e = Mb,
          r = Us;
        (t.NUMERIC = { id: "Numeric", bit: 1, ccBits: [10, 12, 14] }),
          (t.ALPHANUMERIC = {
            id: "Alphanumeric",
            bit: 2,
            ccBits: [9, 11, 13],
          }),
          (t.BYTE = { id: "Byte", bit: 4, ccBits: [8, 16, 16] }),
          (t.KANJI = { id: "Kanji", bit: 8, ccBits: [8, 10, 12] }),
          (t.MIXED = { bit: -1 }),
          (t.getCharCountIndicator = function (s, n) {
            if (!s.ccBits) throw new Error("Invalid mode: " + s);
            if (!e.isValid(n)) throw new Error("Invalid version: " + n);
            return n >= 1 && n < 10
              ? s.ccBits[0]
              : n < 27
              ? s.ccBits[1]
              : s.ccBits[2];
          }),
          (t.getBestModeForData = function (s) {
            return r.testNumeric(s)
              ? t.NUMERIC
              : r.testAlphanumeric(s)
              ? t.ALPHANUMERIC
              : r.testKanji(s)
              ? t.KANJI
              : t.BYTE;
          }),
          (t.toString = function (s) {
            if (s && s.id) return s.id;
            throw new Error("Invalid mode");
          }),
          (t.isValid = function (s) {
            return s && s.bit && s.ccBits;
          });
        function i(s) {
          if (typeof s != "string") throw new Error("Param is not a string");
          switch (s.toLowerCase()) {
            case "numeric":
              return t.NUMERIC;
            case "alphanumeric":
              return t.ALPHANUMERIC;
            case "kanji":
              return t.KANJI;
            case "byte":
              return t.BYTE;
            default:
              throw new Error("Unknown mode: " + s);
          }
        }
        t.from = function (s, n) {
          if (t.isValid(s)) return s;
          try {
            return i(s);
          } catch {
            return n;
          }
        };
      })(Ao),
      (function (t) {
        const e = Si,
          r = D0,
          i = U0,
          s = Ao,
          n = Mb,
          o = 7973,
          a = e.getBCHDigit(o);
        function c(d, g, p) {
          for (let w = 1; w <= 40; w++)
            if (g <= t.getCapacity(w, p, d)) return w;
        }
        function l(d, g) {
          return s.getCharCountIndicator(d, g) + 4;
        }
        function u(d, g) {
          let p = 0;
          return (
            d.forEach(function (w) {
              const f = l(w.mode, g);
              p += f + w.getBitsLength();
            }),
            p
          );
        }
        function h(d, g) {
          for (let p = 1; p <= 40; p++)
            if (u(d, p) <= t.getCapacity(p, g, s.MIXED)) return p;
        }
        (t.from = function (d, g) {
          return n.isValid(d) ? parseInt(d, 10) : g;
        }),
          (t.getCapacity = function (d, g, p) {
            if (!n.isValid(d)) throw new Error("Invalid QR Code version");
            typeof p > "u" && (p = s.BYTE);
            const w = e.getSymbolTotalCodewords(d),
              f = r.getTotalCodewordsCount(d, g),
              m = (w - f) * 8;
            if (p === s.MIXED) return m;
            const y = m - l(p, d);
            switch (p) {
              case s.NUMERIC:
                return Math.floor((y / 10) * 3);
              case s.ALPHANUMERIC:
                return Math.floor((y / 11) * 2);
              case s.KANJI:
                return Math.floor(y / 13);
              case s.BYTE:
              default:
                return Math.floor(y / 8);
            }
          }),
          (t.getBestVersionForData = function (d, g) {
            let p;
            const w = i.from(g, i.M);
            if (Array.isArray(d)) {
              if (d.length > 1) return h(d, w);
              if (d.length === 0) return 1;
              p = d[0];
            } else p = d;
            return c(p.mode, p.getLength(), w);
          }),
          (t.getEncodedBits = function (d) {
            if (!n.isValid(d) || d < 7)
              throw new Error("Invalid QR Code version");
            let g = d << 12;
            for (; e.getBCHDigit(g) - a >= 0; )
              g ^= o << (e.getBCHDigit(g) - a);
            return (d << 12) | g;
          });
      })(C_);
    var I_ = {};
    const zb = Si,
      __ = 1335,
      hue = 21522,
      A_ = zb.getBCHDigit(__);
    I_.getEncodedBits = function (t, e) {
      const r = (t.bit << 3) | e;
      let i = r << 10;
      for (; zb.getBCHDigit(i) - A_ >= 0; ) i ^= __ << (zb.getBCHDigit(i) - A_);
      return ((r << 10) | i) ^ hue;
    };
    var S_ = {};
    const due = Ao;
    function Kl(t) {
      (this.mode = due.NUMERIC), (this.data = t.toString());
    }
    (Kl.getBitsLength = function (t) {
      return 10 * Math.floor(t / 3) + (t % 3 ? (t % 3) * 3 + 1 : 0);
    }),
      (Kl.prototype.getLength = function () {
        return this.data.length;
      }),
      (Kl.prototype.getBitsLength = function () {
        return Kl.getBitsLength(this.data.length);
      }),
      (Kl.prototype.write = function (t) {
        let e, r, i;
        for (e = 0; e + 3 <= this.data.length; e += 3)
          (r = this.data.substr(e, 3)), (i = parseInt(r, 10)), t.put(i, 10);
        const s = this.data.length - e;
        s > 0 &&
          ((r = this.data.substr(e)),
          (i = parseInt(r, 10)),
          t.put(i, s * 3 + 1));
      });
    var pue = Kl;
    const fue = Ao,
      qb = [
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        "I",
        "J",
        "K",
        "L",
        "M",
        "N",
        "O",
        "P",
        "Q",
        "R",
        "S",
        "T",
        "U",
        "V",
        "W",
        "X",
        "Y",
        "Z",
        " ",
        "$",
        "%",
        "*",
        "+",
        "-",
        ".",
        "/",
        ":",
      ];
    function Gl(t) {
      (this.mode = fue.ALPHANUMERIC), (this.data = t);
    }
    (Gl.getBitsLength = function (t) {
      return 11 * Math.floor(t / 2) + 6 * (t % 2);
    }),
      (Gl.prototype.getLength = function () {
        return this.data.length;
      }),
      (Gl.prototype.getBitsLength = function () {
        return Gl.getBitsLength(this.data.length);
      }),
      (Gl.prototype.write = function (t) {
        let e;
        for (e = 0; e + 2 <= this.data.length; e += 2) {
          let r = qb.indexOf(this.data[e]) * 45;
          (r += qb.indexOf(this.data[e + 1])), t.put(r, 11);
        }
        this.data.length % 2 && t.put(qb.indexOf(this.data[e]), 6);
      });
    var gue = Gl,
      wue = function (t) {
        for (var e = [], r = t.length, i = 0; i < r; i++) {
          var s = t.charCodeAt(i);
          if (s >= 55296 && s <= 56319 && r > i + 1) {
            var n = t.charCodeAt(i + 1);
            n >= 56320 &&
              n <= 57343 &&
              ((s = (s - 55296) * 1024 + n - 56320 + 65536), (i += 1));
          }
          if (s < 128) {
            e.push(s);
            continue;
          }
          if (s < 2048) {
            e.push((s >> 6) | 192), e.push((s & 63) | 128);
            continue;
          }
          if (s < 55296 || (s >= 57344 && s < 65536)) {
            e.push((s >> 12) | 224),
              e.push(((s >> 6) & 63) | 128),
              e.push((s & 63) | 128);
            continue;
          }
          if (s >= 65536 && s <= 1114111) {
            e.push((s >> 18) | 240),
              e.push(((s >> 12) & 63) | 128),
              e.push(((s >> 6) & 63) | 128),
              e.push((s & 63) | 128);
            continue;
          }
          e.push(239, 191, 189);
        }
        return new Uint8Array(e).buffer;
      };
    const mue = wue,
      yue = Ao;
    function Zl(t) {
      (this.mode = yue.BYTE),
        typeof t == "string" && (t = mue(t)),
        (this.data = new Uint8Array(t));
    }
    (Zl.getBitsLength = function (t) {
      return t * 8;
    }),
      (Zl.prototype.getLength = function () {
        return this.data.length;
      }),
      (Zl.prototype.getBitsLength = function () {
        return Zl.getBitsLength(this.data.length);
      }),
      (Zl.prototype.write = function (t) {
        for (let e = 0, r = this.data.length; e < r; e++)
          t.put(this.data[e], 8);
      });
    var bue = Zl;
    const vue = Ao,
      Eue = Si;
    function Yl(t) {
      (this.mode = vue.KANJI), (this.data = t);
    }
    (Yl.getBitsLength = function (t) {
      return t * 13;
    }),
      (Yl.prototype.getLength = function () {
        return this.data.length;
      }),
      (Yl.prototype.getBitsLength = function () {
        return Yl.getBitsLength(this.data.length);
      }),
      (Yl.prototype.write = function (t) {
        let e;
        for (e = 0; e < this.data.length; e++) {
          let r = Eue.toSJIS(this.data[e]);
          if (r >= 33088 && r <= 40956) r -= 33088;
          else if (r >= 57408 && r <= 60351) r -= 49472;
          else
            throw new Error(
              "Invalid SJIS character: " +
                this.data[e] +
                `
Make sure your charset is UTF-8`
            );
          (r = ((r >>> 8) & 255) * 192 + (r & 255)), t.put(r, 13);
        }
      });
    var Cue = Yl,
      P_ = { exports: {} };
    (function (t) {
      var e = {
        single_source_shortest_paths: function (r, i, s) {
          var n = {},
            o = {};
          o[i] = 0;
          var a = e.PriorityQueue.make();
          a.push(i, 0);
          for (var c, l, u, h, d, g, p, w, f; !a.empty(); ) {
            (c = a.pop()), (l = c.value), (h = c.cost), (d = r[l] || {});
            for (u in d)
              d.hasOwnProperty(u) &&
                ((g = d[u]),
                (p = h + g),
                (w = o[u]),
                (f = typeof o[u] > "u"),
                (f || w > p) && ((o[u] = p), a.push(u, p), (n[u] = l)));
          }
          if (typeof s < "u" && typeof o[s] > "u") {
            var m = ["Could not find a path from ", i, " to ", s, "."].join("");
            throw new Error(m);
          }
          return n;
        },
        extract_shortest_path_from_predecessor_list: function (r, i) {
          for (var s = [], n = i; n; ) s.push(n), r[n], (n = r[n]);
          return s.reverse(), s;
        },
        find_path: function (r, i, s) {
          var n = e.single_source_shortest_paths(r, i, s);
          return e.extract_shortest_path_from_predecessor_list(n, s);
        },
        PriorityQueue: {
          make: function (r) {
            var i = e.PriorityQueue,
              s = {},
              n;
            r = r || {};
            for (n in i) i.hasOwnProperty(n) && (s[n] = i[n]);
            return (s.queue = []), (s.sorter = r.sorter || i.default_sorter), s;
          },
          default_sorter: function (r, i) {
            return r.cost - i.cost;
          },
          push: function (r, i) {
            var s = { value: r, cost: i };
            this.queue.push(s), this.queue.sort(this.sorter);
          },
          pop: function () {
            return this.queue.shift();
          },
          empty: function () {
            return this.queue.length === 0;
          },
        },
      };
      t.exports = e;
    })(P_),
      (function (t) {
        const e = Ao,
          r = pue,
          i = gue,
          s = bue,
          n = Cue,
          o = Us,
          a = Si,
          c = P_.exports;
        function l(m) {
          return unescape(encodeURIComponent(m)).length;
        }
        function u(m, y, E) {
          const C = [];
          let O;
          for (; (O = m.exec(E)) !== null; )
            C.push({
              data: O[0],
              index: O.index,
              mode: y,
              length: O[0].length,
            });
          return C;
        }
        function h(m) {
          const y = u(o.NUMERIC, e.NUMERIC, m),
            E = u(o.ALPHANUMERIC, e.ALPHANUMERIC, m);
          let C, O;
          return (
            a.isKanjiModeEnabled()
              ? ((C = u(o.BYTE, e.BYTE, m)), (O = u(o.KANJI, e.KANJI, m)))
              : ((C = u(o.BYTE_KANJI, e.BYTE, m)), (O = [])),
            y
              .concat(E, C, O)
              .sort(function (A, P) {
                return A.index - P.index;
              })
              .map(function (A) {
                return { data: A.data, mode: A.mode, length: A.length };
              })
          );
        }
        function d(m, y) {
          switch (y) {
            case e.NUMERIC:
              return r.getBitsLength(m);
            case e.ALPHANUMERIC:
              return i.getBitsLength(m);
            case e.KANJI:
              return n.getBitsLength(m);
            case e.BYTE:
              return s.getBitsLength(m);
          }
        }
        function g(m) {
          return m.reduce(function (y, E) {
            const C = y.length - 1 >= 0 ? y[y.length - 1] : null;
            return C && C.mode === E.mode
              ? ((y[y.length - 1].data += E.data), y)
              : (y.push(E), y);
          }, []);
        }
        function p(m) {
          const y = [];
          for (let E = 0; E < m.length; E++) {
            const C = m[E];
            switch (C.mode) {
              case e.NUMERIC:
                y.push([
                  C,
                  { data: C.data, mode: e.ALPHANUMERIC, length: C.length },
                  { data: C.data, mode: e.BYTE, length: C.length },
                ]);
                break;
              case e.ALPHANUMERIC:
                y.push([C, { data: C.data, mode: e.BYTE, length: C.length }]);
                break;
              case e.KANJI:
                y.push([C, { data: C.data, mode: e.BYTE, length: l(C.data) }]);
                break;
              case e.BYTE:
                y.push([{ data: C.data, mode: e.BYTE, length: l(C.data) }]);
            }
          }
          return y;
        }
        function w(m, y) {
          const E = {},
            C = { start: {} };
          let O = ["start"];
          for (let A = 0; A < m.length; A++) {
            const P = m[A],
              N = [];
            for (let x = 0; x < P.length; x++) {
              const $ = P[x],
                k = "" + A + x;
              N.push(k), (E[k] = { node: $, lastCount: 0 }), (C[k] = {});
              for (let F = 0; F < O.length; F++) {
                const j = O[F];
                E[j] && E[j].node.mode === $.mode
                  ? ((C[j][k] =
                      d(E[j].lastCount + $.length, $.mode) -
                      d(E[j].lastCount, $.mode)),
                    (E[j].lastCount += $.length))
                  : (E[j] && (E[j].lastCount = $.length),
                    (C[j][k] =
                      d($.length, $.mode) +
                      4 +
                      e.getCharCountIndicator($.mode, y)));
              }
            }
            O = N;
          }
          for (let A = 0; A < O.length; A++) C[O[A]].end = 0;
          return { map: C, table: E };
        }
        function f(m, y) {
          let E;
          const C = e.getBestModeForData(m);
          if (((E = e.from(y, C)), E !== e.BYTE && E.bit < C.bit))
            throw new Error(
              '"' +
                m +
                '" cannot be encoded with mode ' +
                e.toString(E) +
                `.
 Suggested mode is: ` +
                e.toString(C)
            );
          switch (
            (E === e.KANJI && !a.isKanjiModeEnabled() && (E = e.BYTE), E)
          ) {
            case e.NUMERIC:
              return new r(m);
            case e.ALPHANUMERIC:
              return new i(m);
            case e.KANJI:
              return new n(m);
            case e.BYTE:
              return new s(m);
          }
        }
        (t.fromArray = function (m) {
          return m.reduce(function (y, E) {
            return (
              typeof E == "string"
                ? y.push(f(E, null))
                : E.data && y.push(f(E.data, E.mode)),
              y
            );
          }, []);
        }),
          (t.fromString = function (m, y) {
            const E = h(m, a.isKanjiModeEnabled()),
              C = p(E),
              O = w(C, y),
              A = c.find_path(O.map, "start", "end"),
              P = [];
            for (let N = 1; N < A.length - 1; N++) P.push(O.table[A[N]].node);
            return t.fromArray(g(P));
          }),
          (t.rawSplit = function (m) {
            return t.fromArray(h(m, a.isKanjiModeEnabled()));
          });
      })(S_);
    const H0 = Si,
      Hb = U0,
      xue = rue,
      Iue = iue,
      _ue = w_,
      Aue = m_,
      Vb = b_,
      Wb = D0,
      Sue = nue,
      V0 = C_,
      Pue = I_,
      Oue = Ao,
      Kb = S_;
    function Nue(t, e) {
      const r = t.size,
        i = Aue.getPositions(e);
      for (let s = 0; s < i.length; s++) {
        const n = i[s][0],
          o = i[s][1];
        for (let a = -1; a <= 7; a++)
          if (!(n + a <= -1 || r <= n + a))
            for (let c = -1; c <= 7; c++)
              o + c <= -1 ||
                r <= o + c ||
                ((a >= 0 && a <= 6 && (c === 0 || c === 6)) ||
                (c >= 0 && c <= 6 && (a === 0 || a === 6)) ||
                (a >= 2 && a <= 4 && c >= 2 && c <= 4)
                  ? t.set(n + a, o + c, !0, !0)
                  : t.set(n + a, o + c, !1, !0));
      }
    }
    function Tue(t) {
      const e = t.size;
      for (let r = 8; r < e - 8; r++) {
        const i = r % 2 === 0;
        t.set(r, 6, i, !0), t.set(6, r, i, !0);
      }
    }
    function kue(t, e) {
      const r = _ue.getPositions(e);
      for (let i = 0; i < r.length; i++) {
        const s = r[i][0],
          n = r[i][1];
        for (let o = -2; o <= 2; o++)
          for (let a = -2; a <= 2; a++)
            o === -2 || o === 2 || a === -2 || a === 2 || (o === 0 && a === 0)
              ? t.set(s + o, n + a, !0, !0)
              : t.set(s + o, n + a, !1, !0);
      }
    }
    function Rue(t, e) {
      const r = t.size,
        i = V0.getEncodedBits(e);
      let s, n, o;
      for (let a = 0; a < 18; a++)
        (s = Math.floor(a / 3)),
          (n = (a % 3) + r - 8 - 3),
          (o = ((i >> a) & 1) === 1),
          t.set(s, n, o, !0),
          t.set(n, s, o, !0);
    }
    function Gb(t, e, r) {
      const i = t.size,
        s = Pue.getEncodedBits(e, r);
      let n, o;
      for (n = 0; n < 15; n++)
        (o = ((s >> n) & 1) === 1),
          n < 6
            ? t.set(n, 8, o, !0)
            : n < 8
            ? t.set(n + 1, 8, o, !0)
            : t.set(i - 15 + n, 8, o, !0),
          n < 8
            ? t.set(8, i - n - 1, o, !0)
            : n < 9
            ? t.set(8, 15 - n - 1 + 1, o, !0)
            : t.set(8, 15 - n - 1, o, !0);
      t.set(i - 8, 8, 1, !0);
    }
    function $ue(t, e) {
      const r = t.size;
      let i = -1,
        s = r - 1,
        n = 7,
        o = 0;
      for (let a = r - 1; a > 0; a -= 2)
        for (a === 6 && a--; ; ) {
          for (let c = 0; c < 2; c++)
            if (!t.isReserved(s, a - c)) {
              let l = !1;
              o < e.length && (l = ((e[o] >>> n) & 1) === 1),
                t.set(s, a - c, l),
                n--,
                n === -1 && (o++, (n = 7));
            }
          if (((s += i), s < 0 || r <= s)) {
            (s -= i), (i = -i);
            break;
          }
        }
    }
    function Fue(t, e, r) {
      const i = new xue();
      r.forEach(function (c) {
        i.put(c.mode.bit, 4),
          i.put(c.getLength(), Oue.getCharCountIndicator(c.mode, t)),
          c.write(i);
      });
      const s = H0.getSymbolTotalCodewords(t),
        n = Wb.getTotalCodewordsCount(t, e),
        o = (s - n) * 8;
      for (
        i.getLengthInBits() + 4 <= o && i.put(0, 4);
        i.getLengthInBits() % 8 !== 0;

      )
        i.putBit(0);
      const a = (o - i.getLengthInBits()) / 8;
      for (let c = 0; c < a; c++) i.put(c % 2 ? 17 : 236, 8);
      return Bue(i, t, e);
    }
    function Bue(t, e, r) {
      const i = H0.getSymbolTotalCodewords(e),
        s = Wb.getTotalCodewordsCount(e, r),
        n = i - s,
        o = Wb.getBlocksCount(e, r),
        a = i % o,
        c = o - a,
        l = Math.floor(i / o),
        u = Math.floor(n / o),
        h = u + 1,
        d = l - u,
        g = new Sue(d);
      let p = 0;
      const w = new Array(o),
        f = new Array(o);
      let m = 0;
      const y = new Uint8Array(t.buffer);
      for (let P = 0; P < o; P++) {
        const N = P < c ? u : h;
        (w[P] = y.slice(p, p + N)),
          (f[P] = g.encode(w[P])),
          (p += N),
          (m = Math.max(m, N));
      }
      const E = new Uint8Array(i);
      let C = 0,
        O,
        A;
      for (O = 0; O < m; O++)
        for (A = 0; A < o; A++) O < w[A].length && (E[C++] = w[A][O]);
      for (O = 0; O < d; O++) for (A = 0; A < o; A++) E[C++] = f[A][O];
      return E;
    }
    function Lue(t, e, r, i) {
      let s;
      if (Array.isArray(t)) s = Kb.fromArray(t);
      else if (typeof t == "string") {
        let l = e;
        if (!l) {
          const u = Kb.rawSplit(t);
          l = V0.getBestVersionForData(u, r);
        }
        s = Kb.fromString(t, l || 40);
      } else throw new Error("Invalid data");
      const n = V0.getBestVersionForData(s, r);
      if (!n)
        throw new Error(
          "The amount of data is too big to be stored in a QR Code"
        );
      if (!e) e = n;
      else if (e < n)
        throw new Error(
          `
The chosen QR Code version cannot contain this amount of data.
Minimum version required to store current data is: ` +
            n +
            `.
`
        );
      const o = Fue(e, r, s),
        a = H0.getSymbolSize(e),
        c = new Iue(a);
      return (
        Nue(c, e),
        Tue(c),
        kue(c, e),
        Gb(c, r, 0),
        e >= 7 && Rue(c, e),
        $ue(c, o),
        isNaN(i) && (i = Vb.getBestMask(c, Gb.bind(null, c, r))),
        Vb.applyMask(i, c),
        Gb(c, r, i),
        {
          modules: c,
          version: e,
          errorCorrectionLevel: r,
          maskPattern: i,
          segments: s,
        }
      );
    }
    f_.create = function (t, e) {
      if (typeof t > "u" || t === "") throw new Error("No input text");
      let r = Hb.M,
        i,
        s;
      return (
        typeof e < "u" &&
          ((r = Hb.from(e.errorCorrectionLevel, Hb.M)),
          (i = V0.from(e.version)),
          (s = Vb.from(e.maskPattern)),
          e.toSJISFunc && H0.setToSJISFunction(e.toSJISFunc)),
        Lue(t, i, r, s)
      );
    };
    var O_ = {},
      Zb = {};
    (function (t) {
      function e(r) {
        if ((typeof r == "number" && (r = r.toString()), typeof r != "string"))
          throw new Error("Color should be defined as hex string");
        let i = r.slice().replace("#", "").split("");
        if (i.length < 3 || i.length === 5 || i.length > 8)
          throw new Error("Invalid hex color: " + r);
        (i.length === 3 || i.length === 4) &&
          (i = Array.prototype.concat.apply(
            [],
            i.map(function (n) {
              return [n, n];
            })
          )),
          i.length === 6 && i.push("F", "F");
        const s = parseInt(i.join(""), 16);
        return {
          r: (s >> 24) & 255,
          g: (s >> 16) & 255,
          b: (s >> 8) & 255,
          a: s & 255,
          hex: "#" + i.slice(0, 6).join(""),
        };
      }
      (t.getOptions = function (r) {
        r || (r = {}), r.color || (r.color = {});
        const i =
            typeof r.margin > "u" || r.margin === null || r.margin < 0
              ? 4
              : r.margin,
          s = r.width && r.width >= 21 ? r.width : void 0,
          n = r.scale || 4;
        return {
          width: s,
          scale: s ? 4 : n,
          margin: i,
          color: {
            dark: e(r.color.dark || "#000000ff"),
            light: e(r.color.light || "#ffffffff"),
          },
          type: r.type,
          rendererOpts: r.rendererOpts || {},
        };
      }),
        (t.getScale = function (r, i) {
          return i.width && i.width >= r + i.margin * 2
            ? i.width / (r + i.margin * 2)
            : i.scale;
        }),
        (t.getImageWidth = function (r, i) {
          const s = t.getScale(r, i);
          return Math.floor((r + i.margin * 2) * s);
        }),
        (t.qrToImageData = function (r, i, s) {
          const n = i.modules.size,
            o = i.modules.data,
            a = t.getScale(n, s),
            c = Math.floor((n + s.margin * 2) * a),
            l = s.margin * a,
            u = [s.color.light, s.color.dark];
          for (let h = 0; h < c; h++)
            for (let d = 0; d < c; d++) {
              let g = (h * c + d) * 4,
                p = s.color.light;
              if (h >= l && d >= l && h < c - l && d < c - l) {
                const w = Math.floor((h - l) / a),
                  f = Math.floor((d - l) / a);
                p = u[o[w * n + f] ? 1 : 0];
              }
              (r[g++] = p.r), (r[g++] = p.g), (r[g++] = p.b), (r[g] = p.a);
            }
        });
    })(Zb),
      (function (t) {
        const e = Zb;
        function r(s, n, o) {
          s.clearRect(0, 0, n.width, n.height),
            n.style || (n.style = {}),
            (n.height = o),
            (n.width = o),
            (n.style.height = o + "px"),
            (n.style.width = o + "px");
        }
        function i() {
          try {
            return document.createElement("canvas");
          } catch {
            throw new Error("You need to specify a canvas element");
          }
        }
        (t.render = function (s, n, o) {
          let a = o,
            c = n;
          typeof a > "u" && (!n || !n.getContext) && ((a = n), (n = void 0)),
            n || (c = i()),
            (a = e.getOptions(a));
          const l = e.getImageWidth(s.modules.size, a),
            u = c.getContext("2d"),
            h = u.createImageData(l, l);
          return (
            e.qrToImageData(h.data, s, a),
            r(u, c, l),
            u.putImageData(h, 0, 0),
            c
          );
        }),
          (t.renderToDataURL = function (s, n, o) {
            let a = o;
            typeof a > "u" && (!n || !n.getContext) && ((a = n), (n = void 0)),
              a || (a = {});
            const c = t.render(s, n, a),
              l = a.type || "image/png",
              u = a.rendererOpts || {};
            return c.toDataURL(l, u.quality);
          });
      })(O_);
    var N_ = {};
    const Uue = Zb;
    function T_(t, e) {
      const r = t.a / 255,
        i = e + '="' + t.hex + '"';
      return r < 1
        ? i + " " + e + '-opacity="' + r.toFixed(2).slice(1) + '"'
        : i;
    }
    function Yb(t, e, r) {
      let i = t + e;
      return typeof r < "u" && (i += " " + r), i;
    }
    function Due(t, e, r) {
      let i = "",
        s = 0,
        n = !1,
        o = 0;
      for (let a = 0; a < t.length; a++) {
        const c = Math.floor(a % e),
          l = Math.floor(a / e);
        !c && !n && (n = !0),
          t[a]
            ? (o++,
              (a > 0 && c > 0 && t[a - 1]) ||
                ((i += n ? Yb("M", c + r, 0.5 + l + r) : Yb("m", s, 0)),
                (s = 0),
                (n = !1)),
              (c + 1 < e && t[a + 1]) || ((i += Yb("h", o)), (o = 0)))
            : s++;
      }
      return i;
    }
    N_.render = function (t, e, r) {
      const i = Uue.getOptions(e),
        s = t.modules.size,
        n = t.modules.data,
        o = s + i.margin * 2,
        a = i.color.light.a
          ? "<path " +
            T_(i.color.light, "fill") +
            ' d="M0 0h' +
            o +
            "v" +
            o +
            'H0z"/>'
          : "",
        c =
          "<path " +
          T_(i.color.dark, "stroke") +
          ' d="' +
          Due(n, s, i.margin) +
          '"/>',
        l = 'viewBox="0 0 ' + o + " " + o + '"',
        u =
          '<svg xmlns="http://www.w3.org/2000/svg" ' +
          (i.width ? 'width="' + i.width + '" height="' + i.width + '" ' : "") +
          l +
          ' shape-rendering="crispEdges">' +
          a +
          c +
          `</svg>
`;
      return typeof r == "function" && r(null, u), u;
    };
    const jue = eue,
      Jb = f_,
      k_ = O_,
      Mue = N_;
    function Xb(t, e, r, i, s) {
      const n = [].slice.call(arguments, 1),
        o = n.length,
        a = typeof n[o - 1] == "function";
      if (!a && !jue()) throw new Error("Callback required as last argument");
      if (a) {
        if (o < 2) throw new Error("Too few arguments provided");
        o === 2
          ? ((s = r), (r = e), (e = i = void 0))
          : o === 3 &&
            (e.getContext && typeof s > "u"
              ? ((s = i), (i = void 0))
              : ((s = i), (i = r), (r = e), (e = void 0)));
      } else {
        if (o < 1) throw new Error("Too few arguments provided");
        return (
          o === 1
            ? ((r = e), (e = i = void 0))
            : o === 2 && !e.getContext && ((i = r), (r = e), (e = void 0)),
          new Promise(function (c, l) {
            try {
              const u = Jb.create(r, i);
              c(t(u, e, i));
            } catch (u) {
              l(u);
            }
          })
        );
      }
      try {
        const c = Jb.create(r, i);
        s(null, t(c, e, i));
      } catch (c) {
        s(c);
      }
    }
    (Pd.create = Jb.create),
      (Pd.toCanvas = Xb.bind(null, k_.render)),
      (Pd.toDataURL = Xb.bind(null, k_.renderToDataURL)),
      (Pd.toString = Xb.bind(null, function (t, e, r) {
        return Mue.render(t, r);
      }));
    const zue = 0.1,
      R_ = 2.5,
      kn = 7;
    function Qb(t, e, r) {
      return t === e ? !1 : (t - e < 0 ? e - t : t - e) <= r + zue;
    }
    function que(t, e) {
      const r = Array.prototype.slice.call(
          Pd.create(t, { errorCorrectionLevel: e }).modules.data,
          0
        ),
        i = Math.sqrt(r.length);
      return r.reduce(
        (s, n, o) => (o % i === 0 ? s.push([n]) : s[s.length - 1].push(n)) && s,
        []
      );
    }
    const Hue = {
      generate({ uri: t, size: e, logoSize: r, dotColor: i = "#141414" }) {
        const s = "transparent",
          n = [],
          o = que(t, "Q"),
          a = e / o.length,
          c = [
            { x: 0, y: 0 },
            { x: 1, y: 0 },
            { x: 0, y: 1 },
          ];
        c.forEach(({ x: p, y: w }) => {
          const f = (o.length - kn) * a * p,
            m = (o.length - kn) * a * w,
            y = 0.45;
          for (let E = 0; E < c.length; E += 1) {
            const C = a * (kn - E * 2);
            n.push(ee`
            <rect
              fill=${E === 2 ? i : s}
              width=${E === 0 ? C - 5 : C}
              rx= ${E === 0 ? (C - 5) * y : C * y}
              ry= ${E === 0 ? (C - 5) * y : C * y}
              stroke=${i}
              stroke-width=${E === 0 ? 5 : 0}
              height=${E === 0 ? C - 5 : C}
              x= ${E === 0 ? m + a * E + 5 / 2 : m + a * E}
              y= ${E === 0 ? f + a * E + 5 / 2 : f + a * E}
            />
          `);
          }
        });
        const l = Math.floor((r + 25) / a),
          u = o.length / 2 - l / 2,
          h = o.length / 2 + l / 2 - 1,
          d = [];
        o.forEach((p, w) => {
          p.forEach((f, m) => {
            if (
              o[w][m] &&
              !(
                (w < kn && m < kn) ||
                (w > o.length - (kn + 1) && m < kn) ||
                (w < kn && m > o.length - (kn + 1))
              ) &&
              !(w > u && w < h && m > u && m < h)
            ) {
              const y = w * a + a / 2,
                E = m * a + a / 2;
              d.push([y, E]);
            }
          });
        });
        const g = {};
        return (
          d.forEach(([p, w]) => {
            g[p] ? g[p]?.push(w) : (g[p] = [w]);
          }),
          Object.entries(g)
            .map(([p, w]) => {
              const f = w.filter((m) => w.every((y) => !Qb(m, y, a)));
              return [Number(p), f];
            })
            .forEach(([p, w]) => {
              w.forEach((f) => {
                n.push(ee`<circle cx=${p} cy=${f} fill=${i} r=${a / R_} />`);
              });
            }),
          Object.entries(g)
            .filter(([p, w]) => w.length > 1)
            .map(([p, w]) => {
              const f = w.filter((m) => w.some((y) => Qb(m, y, a)));
              return [Number(p), f];
            })
            .map(([p, w]) => {
              w.sort((m, y) => (m < y ? -1 : 1));
              const f = [];
              for (const m of w) {
                const y = f.find((E) => E.some((C) => Qb(m, C, a)));
                y ? y.push(m) : f.push([m]);
              }
              return [p, f.map((m) => [m[0], m[m.length - 1]])];
            })
            .forEach(([p, w]) => {
              w.forEach(([f, m]) => {
                n.push(ee`
              <line
                x1=${p}
                x2=${p}
                y1=${f}
                y2=${m}
                stroke=${i}
                stroke-width=${a / (R_ / 2)}
                stroke-linecap="round"
              />
            `);
              });
            }),
          n
        );
      },
    };
    var Vue = ge`
  :host {
    position: relative;
    user-select: none;
    display: block;
    overflow: hidden;
    aspect-ratio: 1 / 1;
    width: var(--local-size);
  }

  :host([data-theme='dark']) {
    border-radius: clamp(0px, var(--wui-border-radius-l), 40px);
    background-color: var(--wui-color-inverse-100);
    padding: var(--wui-spacing-l);
  }

  :host([data-theme='light']) {
    box-shadow: 0 0 0 1px var(--wui-color-bg-125);
    background-color: var(--wui-color-bg-125);
  }

  :host([data-clear='true']) > wui-icon {
    display: none;
  }

  svg:first-child,
  wui-image,
  wui-icon {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translateY(-50%) translateX(-50%);
  }

  wui-image {
    width: 25%;
    height: 25%;
    border-radius: var(--wui-border-radius-xs);
  }

  wui-icon {
    width: 100%;
    height: 100%;
    color: var(--local-icon-color) !important;
    transform: translateY(-50%) translateX(-50%) scale(0.25);
  }
`,
      Rn = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    const Wue = "#3396ff";
    let ps = class extends ue {
      constructor() {
        super(...arguments),
          (this.uri = ""),
          (this.size = 0),
          (this.theme = "dark"),
          (this.imageSrc = void 0),
          (this.alt = void 0),
          (this.arenaClear = void 0),
          (this.farcaster = void 0);
      }
      render() {
        return (
          (this.dataset.theme = this.theme),
          (this.dataset.clear = String(this.arenaClear)),
          (this.style.cssText = `
     --local-size: ${this.size}px;
     --local-icon-color: ${this.color ?? Wue}
    `),
          L`${this.templateVisual()} ${this.templateSvg()}`
        );
      }
      templateSvg() {
        const t = this.theme === "light" ? this.size : this.size - 32;
        return ee`
      <svg height=${t} width=${t}>
        ${Hue.generate({
          uri: this.uri,
          size: t,
          logoSize: this.arenaClear ? 0 : t / 4,
          dotColor: this.color,
        })}
      </svg>
    `;
      }
      templateVisual() {
        return this.imageSrc
          ? L`<wui-image src=${this.imageSrc} alt=${
              this.alt ?? "logo"
            }></wui-image>`
          : this.farcaster
          ? L`<wui-icon
        class="farcaster"
        size="inherit"
        color="inherit"
        name="farcaster"
      ></wui-icon>`
          : L`<wui-icon size="inherit" color="inherit" name="walletConnect"></wui-icon>`;
      }
    };
    (ps.styles = [qe, Vue]),
      Rn([M()], ps.prototype, "uri", void 0),
      Rn([M({ type: Number })], ps.prototype, "size", void 0),
      Rn([M()], ps.prototype, "theme", void 0),
      Rn([M()], ps.prototype, "imageSrc", void 0),
      Rn([M()], ps.prototype, "alt", void 0),
      Rn([M()], ps.prototype, "color", void 0),
      Rn([M({ type: Boolean })], ps.prototype, "arenaClear", void 0),
      Rn([M({ type: Boolean })], ps.prototype, "farcaster", void 0),
      (ps = Rn([ce("wui-qr-code")], ps));
    var Kue = ge`
  :host {
    display: block;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
    background: linear-gradient(
      120deg,
      var(--wui-color-bg-200) 5%,
      var(--wui-color-bg-200) 48%,
      var(--wui-color-bg-300) 55%,
      var(--wui-color-bg-300) 60%,
      var(--wui-color-bg-300) calc(60% + 10px),
      var(--wui-color-bg-200) calc(60% + 12px),
      var(--wui-color-bg-200) 100%
    );
    background-size: 250%;
    animation: shimmer 3s linear infinite reverse;
  }

  :host([variant='light']) {
    background: linear-gradient(
      120deg,
      var(--wui-color-bg-150) 5%,
      var(--wui-color-bg-150) 48%,
      var(--wui-color-bg-200) 55%,
      var(--wui-color-bg-200) 60%,
      var(--wui-color-bg-200) calc(60% + 10px),
      var(--wui-color-bg-150) calc(60% + 12px),
      var(--wui-color-bg-150) 100%
    );
    background-size: 250%;
  }

  @keyframes shimmer {
    from {
      background-position: -250% 0;
    }
    to {
      background-position: 250% 0;
    }
  }
`,
      kd = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let $a = class extends ue {
      constructor() {
        super(...arguments),
          (this.width = ""),
          (this.height = ""),
          (this.borderRadius = "m"),
          (this.variant = "default");
      }
      render() {
        return (
          (this.style.cssText = `
      width: ${this.width};
      height: ${this.height};
      border-radius: ${`clamp(0px,var(--wui-border-radius-${this.borderRadius}), 40px)`};
    `),
          L`<slot></slot>`
        );
      }
    };
    ($a.styles = [Kue]),
      kd([M()], $a.prototype, "width", void 0),
      kd([M()], $a.prototype, "height", void 0),
      kd([M()], $a.prototype, "borderRadius", void 0),
      kd([M()], $a.prototype, "variant", void 0),
      ($a = kd([ce("wui-shimmer")], $a));
    var Gue = ge`
  .reown-logo {
    height: var(--wui-spacing-xxl);
  }
`,
      Zue = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let ev = class extends ue {
      render() {
        return L`
      <wui-flex
        justifyContent="center"
        alignItems="center"
        gap="xs"
        .padding=${["0", "0", "l", "0"]}
      >
        <wui-text variant="small-500" color="fg-100"> UX by </wui-text>
        <wui-icon name="reown" size="xxxl" class="reown-logo"></wui-icon>
      </wui-flex>
    `;
      }
    };
    (ev.styles = [qe, Cr, Gue]), (ev = Zue([ce("wui-ux-by-reown")], ev));
    var Yue = ge`
  @keyframes fadein {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  wui-shimmer {
    width: 100%;
    aspect-ratio: 1 / 1;
    border-radius: clamp(0px, var(--wui-border-radius-l), 40px) !important;
  }

  wui-qr-code {
    opacity: 0;
    animation-duration: 200ms;
    animation-timing-function: ease;
    animation-name: fadein;
    animation-fill-mode: forwards;
  }
`,
      Jue = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let tv = class extends xr {
      constructor() {
        super(),
          (this.forceUpdate = () => {
            this.requestUpdate();
          }),
          window.addEventListener("resize", this.forceUpdate),
          Se.sendEvent({
            type: "track",
            event: "SELECT_WALLET",
            properties: {
              name: this.wallet?.name ?? "WalletConnect",
              platform: "qrcode",
            },
          });
      }
      disconnectedCallback() {
        super.disconnectedCallback(),
          this.unsubscribe?.forEach((t) => t()),
          window.removeEventListener("resize", this.forceUpdate);
      }
      render() {
        return (
          this.onRenderProxy(),
          L`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["0", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-shimmer borderRadius="l" width="100%"> ${this.qrCodeTemplate()} </wui-shimmer>

        <wui-text variant="paragraph-500" color="fg-100">
          Scan this QR Code with your phone
        </wui-text>
        ${this.copyTemplate()}
      </wui-flex>
      <w3m-mobile-download-links .wallet=${
        this.wallet
      }></w3m-mobile-download-links>
    `
        );
      }
      onRenderProxy() {
        !this.ready &&
          this.uri &&
          (this.timeout = setTimeout(() => {
            this.ready = !0;
          }, 200));
      }
      qrCodeTemplate() {
        if (!this.uri || !this.ready) return null;
        const t = this.getBoundingClientRect().width - 40,
          e = this.wallet ? this.wallet.name : void 0;
        return (
          pe.setWcLinking(void 0),
          pe.setRecentWallet(this.wallet),
          L` <wui-qr-code
      size=${t}
      theme=${Dt.state.themeMode}
      uri=${this.uri}
      imageSrc=${we(Ut.getWalletImage(this.wallet))}
      color=${we(Dt.state.themeVariables["--w3m-qr-color"])}
      alt=${we(e)}
      data-testid="wui-qr-code"
    ></wui-qr-code>`
        );
      }
      copyTemplate() {
        const t = !this.uri || !this.ready;
        return L`<wui-link
      .disabled=${t}
      @click=${this.onCopyUri}
      color="fg-200"
      data-testid="copy-wc2-uri"
    >
      <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
      Copy link
    </wui-link>`;
      }
    };
    (tv.styles = Yue), (tv = Jue([ce("w3m-connecting-wc-qrcode")], tv));
    var Xue = function (t, e, r, i) {
      var s = arguments.length,
        n =
          s < 3
            ? e
            : i === null
            ? (i = Object.getOwnPropertyDescriptor(e, r))
            : i,
        o;
      if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        n = Reflect.decorate(t, e, r, i);
      else
        for (var a = t.length - 1; a >= 0; a--)
          (o = t[a]) &&
            (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
      return s > 3 && n && Object.defineProperty(e, r, n), n;
    };
    let $_ = class extends ue {
      constructor() {
        if ((super(), (this.wallet = ie.state.data?.wallet), !this.wallet))
          throw new Error("w3m-connecting-wc-unsupported: No wallet provided");
        Se.sendEvent({
          type: "track",
          event: "SELECT_WALLET",
          properties: { name: this.wallet.name, platform: "browser" },
        });
      }
      render() {
        return L`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-wallet-image
          size="lg"
          imageSrc=${we(Ut.getWalletImage(this.wallet))}
        ></wui-wallet-image>

        <wui-text variant="paragraph-500" color="fg-100">Not Detected</wui-text>
      </wui-flex>

      <w3m-mobile-download-links .wallet=${
        this.wallet
      }></w3m-mobile-download-links>
    `;
      }
    };
    $_ = Xue([ce("w3m-connecting-wc-unsupported")], $_);
    var F_ = function (t, e, r, i) {
      var s = arguments.length,
        n =
          s < 3
            ? e
            : i === null
            ? (i = Object.getOwnPropertyDescriptor(e, r))
            : i,
        o;
      if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        n = Reflect.decorate(t, e, r, i);
      else
        for (var a = t.length - 1; a >= 0; a--)
          (o = t[a]) &&
            (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
      return s > 3 && n && Object.defineProperty(e, r, n), n;
    };
    let rv = class extends xr {
      constructor() {
        if ((super(), (this.isLoading = !0), !this.wallet))
          throw new Error("w3m-connecting-wc-web: No wallet provided");
        (this.onConnect = this.onConnectProxy.bind(this)),
          (this.secondaryBtnLabel = "Open"),
          (this.secondaryLabel = "Open and continue in a new browser tab"),
          (this.secondaryBtnIcon = "externalLink"),
          this.updateLoadingState(),
          this.unsubscribe.push(
            pe.subscribeKey("wcUri", () => {
              this.updateLoadingState();
            })
          ),
          Se.sendEvent({
            type: "track",
            event: "SELECT_WALLET",
            properties: { name: this.wallet.name, platform: "web" },
          });
      }
      updateLoadingState() {
        this.isLoading = !this.uri;
      }
      onConnectProxy() {
        if (this.wallet?.webapp_link && this.uri)
          try {
            this.error = !1;
            const { webapp_link: t, name: e } = this.wallet,
              { redirect: r, href: i } = X.formatUniversalUrl(t, this.uri);
            pe.setWcLinking({ name: e, href: i }),
              pe.setRecentWallet(this.wallet),
              X.openHref(r, "_blank");
          } catch {
            this.error = !0;
          }
      }
    };
    F_([le()], rv.prototype, "isLoading", void 0),
      (rv = F_([ce("w3m-connecting-wc-web")], rv));
    var W0 = function (t, e, r, i) {
      var s = arguments.length,
        n =
          s < 3
            ? e
            : i === null
            ? (i = Object.getOwnPropertyDescriptor(e, r))
            : i,
        o;
      if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        n = Reflect.decorate(t, e, r, i);
      else
        for (var a = t.length - 1; a >= 0; a--)
          (o = t[a]) &&
            (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
      return s > 3 && n && Object.defineProperty(e, r, n), n;
    };
    let Rd = class extends ue {
      constructor() {
        super(),
          (this.wallet = ie.state.data?.wallet),
          (this.platform = void 0),
          (this.platforms = []),
          (this.isSiwxEnabled = !!G.state.siwx),
          this.determinePlatforms(),
          this.initializeConnection();
      }
      render() {
        return L`
      ${this.headerTemplate()}
      <div>${this.platformTemplate()}</div>
      <wui-ux-by-reown></wui-ux-by-reown>
    `;
      }
      async initializeConnection(t = !1) {
        if (!(this.platform === "browser" || (G.state.manualWCControl && !t)))
          try {
            const { wcPairingExpiry: e, status: r } = pe.state;
            (t ||
              G.state.enableEmbedded ||
              X.isPairingExpired(e) ||
              r === "connecting") &&
              (await pe.connectWalletConnect(),
              this.isSiwxEnabled || $e.close());
          } catch (e) {
            Se.sendEvent({
              type: "track",
              event: "CONNECT_ERROR",
              properties: { message: e?.message ?? "Unknown" },
            }),
              pe.setWcError(!0),
              at.showError(e.message ?? "Connection error"),
              pe.resetWcConnection(),
              ie.goBack();
          }
      }
      determinePlatforms() {
        if (!this.wallet) {
          this.platforms.push("qrcode"), (this.platform = "qrcode");
          return;
        }
        if (this.platform) return;
        const {
            mobile_link: t,
            desktop_link: e,
            webapp_link: r,
            injected: i,
            rdns: s,
          } = this.wallet,
          n = i?.map(({ injected_id: g }) => g).filter(Boolean),
          o = [...(s ? [s] : n ?? [])],
          a = G.state.isUniversalProvider ? !1 : o.length,
          c = t,
          l = r,
          u = pe.checkInstalled(o),
          h = a && u,
          d = e && !X.isMobile();
        h && !B.state.noAdapters && this.platforms.push("browser"),
          c && this.platforms.push(X.isMobile() ? "mobile" : "qrcode"),
          l && this.platforms.push("web"),
          d && this.platforms.push("desktop"),
          !h && a && !B.state.noAdapters && this.platforms.push("unsupported"),
          (this.platform = this.platforms[0]);
      }
      platformTemplate() {
        switch (this.platform) {
          case "browser":
            return L`<w3m-connecting-wc-browser></w3m-connecting-wc-browser>`;
          case "web":
            return L`<w3m-connecting-wc-web></w3m-connecting-wc-web>`;
          case "desktop":
            return L`
          <w3m-connecting-wc-desktop .onRetry=${() =>
            this.initializeConnection(!0)}>
          </w3m-connecting-wc-desktop>
        `;
          case "mobile":
            return L`
          <w3m-connecting-wc-mobile isMobile .onRetry=${() =>
            this.initializeConnection(!0)}>
          </w3m-connecting-wc-mobile>
        `;
          case "qrcode":
            return L`<w3m-connecting-wc-qrcode></w3m-connecting-wc-qrcode>`;
          default:
            return L`<w3m-connecting-wc-unsupported></w3m-connecting-wc-unsupported>`;
        }
      }
      headerTemplate() {
        return this.platforms.length > 1
          ? L`
      <w3m-connecting-header
        .platforms=${this.platforms}
        .onSelectPlatfrom=${this.onSelectPlatform.bind(this)}
      >
      </w3m-connecting-header>
    `
          : null;
      }
      async onSelectPlatform(t) {
        const e = this.shadowRoot?.querySelector("div");
        e &&
          (await e.animate([{ opacity: 1 }, { opacity: 0 }], {
            duration: 200,
            fill: "forwards",
            easing: "ease",
          }).finished,
          (this.platform = t),
          e.animate([{ opacity: 0 }, { opacity: 1 }], {
            duration: 200,
            fill: "forwards",
            easing: "ease",
          }));
      }
    };
    W0([le()], Rd.prototype, "platform", void 0),
      W0([le()], Rd.prototype, "platforms", void 0),
      W0([le()], Rd.prototype, "isSiwxEnabled", void 0),
      (Rd = W0([ce("w3m-connecting-wc-view")], Rd));
    var B_ = function (t, e, r, i) {
      var s = arguments.length,
        n =
          s < 3
            ? e
            : i === null
            ? (i = Object.getOwnPropertyDescriptor(e, r))
            : i,
        o;
      if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        n = Reflect.decorate(t, e, r, i);
      else
        for (var a = t.length - 1; a >= 0; a--)
          (o = t[a]) &&
            (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
      return s > 3 && n && Object.defineProperty(e, r, n), n;
    };
    let K0 = class extends ue {
      constructor() {
        super(...arguments), (this.isMobile = X.isMobile());
      }
      render() {
        if (this.isMobile) {
          const { featured: t, recommended: e } = ne.state,
            { customWallets: r } = G.state,
            i = de.getRecentWallets(),
            s = t.length || e.length || r?.length || i.length;
          return L`<wui-flex
        flexDirection="column"
        gap="xs"
        .margin=${["3xs", "s", "s", "s"]}
      >
        ${s ? L`<w3m-connector-list></w3m-connector-list>` : null}
        <w3m-all-wallets-widget></w3m-all-wallets-widget>
      </wui-flex>`;
        }
        return L`<wui-flex flexDirection="column" .padding=${[
          "0",
          "0",
          "l",
          "0",
        ]}>
      <w3m-connecting-wc-view></w3m-connecting-wc-view>
      <wui-flex flexDirection="column" .padding=${["0", "m", "0", "m"]}>
        <w3m-all-wallets-widget></w3m-all-wallets-widget> </wui-flex
    ></wui-flex>`;
      }
    };
    B_([le()], K0.prototype, "isMobile", void 0),
      (K0 = B_([ce("w3m-connecting-wc-basic-view")], K0));
    /**
     * @license
     * Copyright 2020 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */ const iv = () => new Que();
    class Que {}
    const sv = new WeakMap(),
      nv = Ob(
        class extends r_ {
          render(t) {
            return Ot;
          }
          update(t, [e]) {
            const r = e !== this.G;
            return (
              r && this.G !== void 0 && this.rt(void 0),
              (r || this.lt !== this.ct) &&
                ((this.G = e),
                (this.ht = t.options?.host),
                this.rt((this.ct = t.element))),
              Ot
            );
          }
          rt(t) {
            if (
              (this.isConnected || (t = void 0), typeof this.G == "function")
            ) {
              const e = this.ht ?? globalThis;
              let r = sv.get(e);
              r === void 0 && ((r = new WeakMap()), sv.set(e, r)),
                r.get(this.G) !== void 0 && this.G.call(this.ht, void 0),
                r.set(this.G, t),
                t !== void 0 && this.G.call(this.ht, t);
            } else this.G.value = t;
          }
          get lt() {
            return typeof this.G == "function"
              ? sv.get(this.ht ?? globalThis)?.get(this.G)
              : this.G?.value;
          }
          disconnected() {
            this.lt === this.ct && this.rt(void 0);
          }
          reconnected() {
            this.rt(this.ct);
          }
        }
      );
    var ehe = ge`
  :host {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  label {
    position: relative;
    display: inline-block;
    width: 32px;
    height: 22px;
  }

  input {
    width: 0;
    height: 0;
    opacity: 0;
  }

  span {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: var(--wui-color-blue-100);
    border-width: 1px;
    border-style: solid;
    border-color: var(--wui-color-gray-glass-002);
    border-radius: 999px;
    transition:
      background-color var(--wui-ease-inout-power-1) var(--wui-duration-md),
      border-color var(--wui-ease-inout-power-1) var(--wui-duration-md);
    will-change: background-color, border-color;
  }

  span:before {
    position: absolute;
    content: '';
    height: 16px;
    width: 16px;
    left: 3px;
    top: 2px;
    background-color: var(--wui-color-inverse-100);
    transition: transform var(--wui-ease-inout-power-1) var(--wui-duration-lg);
    will-change: transform;
    border-radius: 50%;
  }

  input:checked + span {
    border-color: var(--wui-color-gray-glass-005);
    background-color: var(--wui-color-blue-100);
  }

  input:not(:checked) + span {
    background-color: var(--wui-color-gray-glass-010);
  }

  input:checked + span:before {
    transform: translateX(calc(100% - 7px));
  }
`,
      L_ = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let G0 = class extends ue {
      constructor() {
        super(...arguments),
          (this.inputElementRef = iv()),
          (this.checked = void 0);
      }
      render() {
        return L`
      <label>
        <input
          ${nv(this.inputElementRef)}
          type="checkbox"
          ?checked=${we(this.checked)}
          @change=${this.dispatchChangeEvent.bind(this)}
        />
        <span></span>
      </label>
    `;
      }
      dispatchChangeEvent() {
        this.dispatchEvent(
          new CustomEvent("switchChange", {
            detail: this.inputElementRef.value?.checked,
            bubbles: !0,
            composed: !0,
          })
        );
      }
    };
    (G0.styles = [qe, Cr, hd, ehe]),
      L_([M({ type: Boolean })], G0.prototype, "checked", void 0),
      (G0 = L_([ce("wui-switch")], G0));
    var the = ge`
  :host {
    height: 100%;
  }

  button {
    display: flex;
    align-items: center;
    justify-content: center;
    column-gap: var(--wui-spacing-1xs);
    padding: var(--wui-spacing-xs) var(--wui-spacing-s);
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: background-color;
    cursor: pointer;
  }

  wui-switch {
    pointer-events: none;
  }
`,
      U_ = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let Z0 = class extends ue {
      constructor() {
        super(...arguments), (this.checked = void 0);
      }
      render() {
        return L`
      <button>
        <wui-icon size="xl" name="walletConnectBrown"></wui-icon>
        <wui-switch ?checked=${we(this.checked)}></wui-switch>
      </button>
    `;
      }
    };
    (Z0.styles = [qe, Cr, the]),
      U_([M({ type: Boolean })], Z0.prototype, "checked", void 0),
      (Z0 = U_([ce("wui-certified-switch")], Z0));
    var rhe = ge`
  button {
    background-color: var(--wui-color-fg-300);
    border-radius: var(--wui-border-radius-4xs);
    width: 16px;
    height: 16px;
  }

  button:disabled {
    background-color: var(--wui-color-bg-300);
  }

  wui-icon {
    color: var(--wui-color-bg-200) !important;
  }

  button:focus-visible {
    background-color: var(--wui-color-fg-250);
    border: 1px solid var(--wui-color-accent-100);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-fg-250);
    }

    button:active:enabled {
      background-color: var(--wui-color-fg-225);
    }
  }
`,
      D_ = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let Y0 = class extends ue {
      constructor() {
        super(...arguments), (this.icon = "copy");
      }
      render() {
        return L`
      <button>
        <wui-icon color="inherit" size="xxs" name=${this.icon}></wui-icon>
      </button>
    `;
      }
    };
    (Y0.styles = [qe, Cr, rhe]),
      D_([M()], Y0.prototype, "icon", void 0),
      (Y0 = D_([ce("wui-input-element")], Y0));
    var ihe = ge`
  :host {
    position: relative;
    width: 100%;
    display: inline-block;
    color: var(--wui-color-fg-275);
  }

  input {
    width: 100%;
    border-radius: var(--wui-border-radius-xs);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
    background: var(--wui-color-gray-glass-002);
    font-size: var(--wui-font-size-paragraph);
    letter-spacing: var(--wui-letter-spacing-paragraph);
    color: var(--wui-color-fg-100);
    transition:
      background-color var(--wui-ease-inout-power-1) var(--wui-duration-md),
      border-color var(--wui-ease-inout-power-1) var(--wui-duration-md),
      box-shadow var(--wui-ease-inout-power-1) var(--wui-duration-md);
    will-change: background-color, border-color, box-shadow;
    caret-color: var(--wui-color-accent-100);
  }

  input:disabled {
    cursor: not-allowed;
    border: 1px solid var(--wui-color-gray-glass-010);
  }

  input:disabled::placeholder,
  input:disabled + wui-icon {
    color: var(--wui-color-fg-300);
  }

  input::placeholder {
    color: var(--wui-color-fg-275);
  }

  input:focus:enabled {
    background-color: var(--wui-color-gray-glass-005);
    -webkit-box-shadow:
      inset 0 0 0 1px var(--wui-color-accent-100),
      0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow:
      inset 0 0 0 1px var(--wui-color-accent-100),
      0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-accent-100),
      0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  input:hover:enabled {
    background-color: var(--wui-color-gray-glass-005);
  }

  wui-icon {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    pointer-events: none;
  }

  .wui-size-sm {
    padding: 9px var(--wui-spacing-m) 10px var(--wui-spacing-s);
  }

  wui-icon + .wui-size-sm {
    padding: 9px var(--wui-spacing-m) 10px 36px;
  }

  wui-icon[data-input='sm'] {
    left: var(--wui-spacing-s);
  }

  .wui-size-md {
    padding: 15px var(--wui-spacing-m) var(--wui-spacing-l) var(--wui-spacing-m);
  }

  wui-icon + .wui-size-md,
  wui-loading-spinner + .wui-size-md {
    padding: 10.5px var(--wui-spacing-3xl) 10.5px var(--wui-spacing-3xl);
  }

  wui-icon[data-input='md'] {
    left: var(--wui-spacing-l);
  }

  .wui-size-lg {
    padding: var(--wui-spacing-s) var(--wui-spacing-s) var(--wui-spacing-s) var(--wui-spacing-l);
    letter-spacing: var(--wui-letter-spacing-medium-title);
    font-size: var(--wui-font-size-medium-title);
    font-weight: var(--wui-font-weight-light);
    line-height: 130%;
    color: var(--wui-color-fg-100);
    height: 64px;
  }

  .wui-padding-right-xs {
    padding-right: var(--wui-spacing-xs);
  }

  .wui-padding-right-s {
    padding-right: var(--wui-spacing-s);
  }

  .wui-padding-right-m {
    padding-right: var(--wui-spacing-m);
  }

  .wui-padding-right-l {
    padding-right: var(--wui-spacing-l);
  }

  .wui-padding-right-xl {
    padding-right: var(--wui-spacing-xl);
  }

  .wui-padding-right-2xl {
    padding-right: var(--wui-spacing-2xl);
  }

  .wui-padding-right-3xl {
    padding-right: var(--wui-spacing-3xl);
  }

  .wui-padding-right-4xl {
    padding-right: var(--wui-spacing-4xl);
  }

  .wui-padding-right-5xl {
    padding-right: var(--wui-spacing-5xl);
  }

  wui-icon + .wui-size-lg,
  wui-loading-spinner + .wui-size-lg {
    padding-left: 50px;
  }

  wui-icon[data-input='lg'] {
    left: var(--wui-spacing-l);
  }

  .wui-size-mdl {
    padding: 17.25px var(--wui-spacing-m) 17.25px var(--wui-spacing-m);
  }
  wui-icon + .wui-size-mdl,
  wui-loading-spinner + .wui-size-mdl {
    padding: 17.25px var(--wui-spacing-3xl) 17.25px 40px;
  }
  wui-icon[data-input='mdl'] {
    left: var(--wui-spacing-m);
  }

  input:placeholder-shown ~ ::slotted(wui-input-element),
  input:placeholder-shown ~ ::slotted(wui-icon) {
    opacity: 0;
    pointer-events: none;
  }

  input::-webkit-outer-spin-button,
  input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  input[type='number'] {
    -moz-appearance: textfield;
  }

  ::slotted(wui-input-element),
  ::slotted(wui-icon) {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
  }

  ::slotted(wui-input-element) {
    right: var(--wui-spacing-m);
  }

  ::slotted(wui-icon) {
    right: 0px;
  }
`,
      Ds = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let Vi = class extends ue {
      constructor() {
        super(...arguments),
          (this.inputElementRef = iv()),
          (this.size = "md"),
          (this.disabled = !1),
          (this.placeholder = ""),
          (this.type = "text"),
          (this.value = "");
      }
      render() {
        const t = `wui-padding-right-${this.inputRightPadding}`,
          e = { [`wui-size-${this.size}`]: !0, [t]: !!this.inputRightPadding };
        return L`${this.templateIcon()}
      <input
        data-testid="wui-input-text"
        ${nv(this.inputElementRef)}
        class=${o_(e)}
        type=${this.type}
        enterkeyhint=${we(this.enterKeyHint)}
        ?disabled=${this.disabled}
        placeholder=${this.placeholder}
        @input=${this.dispatchInputChangeEvent.bind(this)}
        .value=${this.value || ""}
        tabindex=${we(this.tabIdx)}
      />
      <slot></slot>`;
      }
      templateIcon() {
        return this.icon
          ? L`<wui-icon
        data-input=${this.size}
        size=${this.size}
        color="inherit"
        name=${this.icon}
      ></wui-icon>`
          : null;
      }
      dispatchInputChangeEvent() {
        this.dispatchEvent(
          new CustomEvent("inputChange", {
            detail: this.inputElementRef.value?.value,
            bubbles: !0,
            composed: !0,
          })
        );
      }
    };
    (Vi.styles = [qe, Cr, ihe]),
      Ds([M()], Vi.prototype, "size", void 0),
      Ds([M()], Vi.prototype, "icon", void 0),
      Ds([M({ type: Boolean })], Vi.prototype, "disabled", void 0),
      Ds([M()], Vi.prototype, "placeholder", void 0),
      Ds([M()], Vi.prototype, "type", void 0),
      Ds([M()], Vi.prototype, "keyHint", void 0),
      Ds([M()], Vi.prototype, "value", void 0),
      Ds([M()], Vi.prototype, "inputRightPadding", void 0),
      Ds([M()], Vi.prototype, "tabIdx", void 0),
      (Vi = Ds([ce("wui-input-text")], Vi));
    var she = ge`
  :host {
    position: relative;
    display: inline-block;
    width: 100%;
  }
`,
      nhe = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let ov = class extends ue {
      constructor() {
        super(...arguments), (this.inputComponentRef = iv());
      }
      render() {
        return L`
      <wui-input-text
        ${nv(this.inputComponentRef)}
        placeholder="Search wallet"
        icon="search"
        type="search"
        enterKeyHint="search"
        size="sm"
      >
        <wui-input-element @click=${
          this.clearValue
        } icon="close"></wui-input-element>
      </wui-input-text>
    `;
      }
      clearValue() {
        const t = this.inputComponentRef.value?.inputElementRef.value;
        t && ((t.value = ""), t.focus(), t.dispatchEvent(new Event("input")));
      }
    };
    (ov.styles = [qe, she]), (ov = nhe([ce("wui-search-bar")], ov));
    const ohe = ee`<svg  viewBox="0 0 48 54" fill="none">
  <path
    d="M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z"
  />
</svg>`;
    var ahe = ge`
  :host {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 104px;
    row-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xs) 10px;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: clamp(0px, var(--wui-border-radius-xs), 20px);
    position: relative;
  }

  wui-shimmer[data-type='network'] {
    border: none;
    -webkit-clip-path: var(--wui-path-network);
    clip-path: var(--wui-path-network);
  }

  svg {
    position: absolute;
    width: 48px;
    height: 54px;
    z-index: 1;
  }

  svg > path {
    stroke: var(--wui-color-gray-glass-010);
    stroke-width: 1px;
  }

  @media (max-width: 350px) {
    :host {
      width: 100%;
    }
  }
`,
      j_ = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let J0 = class extends ue {
      constructor() {
        super(...arguments), (this.type = "wallet");
      }
      render() {
        return L`
      ${this.shimmerTemplate()}
      <wui-shimmer width="56px" height="20px" borderRadius="xs"></wui-shimmer>
    `;
      }
      shimmerTemplate() {
        return this.type === "network"
          ? L` <wui-shimmer
          data-type=${this.type}
          width="48px"
          height="54px"
          borderRadius="xs"
        ></wui-shimmer>
        ${ohe}`
          : L`<wui-shimmer width="56px" height="56px" borderRadius="xs"></wui-shimmer>`;
      }
    };
    (J0.styles = [qe, Cr, ahe]),
      j_([M()], J0.prototype, "type", void 0),
      (J0 = j_([ce("wui-card-select-loader")], J0));
    var che = ge`
  :host {
    display: grid;
    width: inherit;
    height: inherit;
  }
`,
      Wi = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let ii = class extends ue {
      render() {
        return (
          (this.style.cssText = `
      grid-template-rows: ${this.gridTemplateRows};
      grid-template-columns: ${this.gridTemplateColumns};
      justify-items: ${this.justifyItems};
      align-items: ${this.alignItems};
      justify-content: ${this.justifyContent};
      align-content: ${this.alignContent};
      column-gap: ${this.columnGap && `var(--wui-spacing-${this.columnGap})`};
      row-gap: ${this.rowGap && `var(--wui-spacing-${this.rowGap})`};
      gap: ${this.gap && `var(--wui-spacing-${this.gap})`};
      padding-top: ${this.padding && ar.getSpacingStyles(this.padding, 0)};
      padding-right: ${this.padding && ar.getSpacingStyles(this.padding, 1)};
      padding-bottom: ${this.padding && ar.getSpacingStyles(this.padding, 2)};
      padding-left: ${this.padding && ar.getSpacingStyles(this.padding, 3)};
      margin-top: ${this.margin && ar.getSpacingStyles(this.margin, 0)};
      margin-right: ${this.margin && ar.getSpacingStyles(this.margin, 1)};
      margin-bottom: ${this.margin && ar.getSpacingStyles(this.margin, 2)};
      margin-left: ${this.margin && ar.getSpacingStyles(this.margin, 3)};
    `),
          L`<slot></slot>`
        );
      }
    };
    (ii.styles = [qe, che]),
      Wi([M()], ii.prototype, "gridTemplateRows", void 0),
      Wi([M()], ii.prototype, "gridTemplateColumns", void 0),
      Wi([M()], ii.prototype, "justifyItems", void 0),
      Wi([M()], ii.prototype, "alignItems", void 0),
      Wi([M()], ii.prototype, "justifyContent", void 0),
      Wi([M()], ii.prototype, "alignContent", void 0),
      Wi([M()], ii.prototype, "columnGap", void 0),
      Wi([M()], ii.prototype, "rowGap", void 0),
      Wi([M()], ii.prototype, "gap", void 0),
      Wi([M()], ii.prototype, "padding", void 0),
      Wi([M()], ii.prototype, "margin", void 0),
      (ii = Wi([ce("wui-grid")], ii));
    var lhe = ge`
  button {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    width: 104px;
    row-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-s) var(--wui-spacing-0);
    background-color: var(--wui-color-gray-glass-002);
    border-radius: clamp(0px, var(--wui-border-radius-xs), 20px);
    transition:
      color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      background-color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: background-color, color, border-radius;
    outline: none;
    border: none;
  }

  button > wui-flex > wui-text {
    color: var(--wui-color-fg-100);
    max-width: 86px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    justify-content: center;
  }

  button > wui-flex > wui-text.certified {
    max-width: 66px;
  }

  button:hover:enabled {
    background-color: var(--wui-color-gray-glass-005);
  }

  button:disabled > wui-flex > wui-text {
    color: var(--wui-color-gray-glass-015);
  }

  [data-selected='true'] {
    background-color: var(--wui-color-accent-glass-020);
  }

  @media (hover: hover) and (pointer: fine) {
    [data-selected='true']:hover:enabled {
      background-color: var(--wui-color-accent-glass-015);
    }
  }

  [data-selected='true']:active:enabled {
    background-color: var(--wui-color-accent-glass-010);
  }

  @media (max-width: 350px) {
    button {
      width: 100%;
    }
  }
`,
      $d = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let Fa = class extends ue {
      constructor() {
        super(),
          (this.observer = new IntersectionObserver(() => {})),
          (this.visible = !1),
          (this.imageSrc = void 0),
          (this.imageLoading = !1),
          (this.wallet = void 0),
          (this.observer = new IntersectionObserver(
            (t) => {
              t.forEach((e) => {
                e.isIntersecting
                  ? ((this.visible = !0), this.fetchImageSrc())
                  : (this.visible = !1);
              });
            },
            { threshold: 0.01 }
          ));
      }
      firstUpdated() {
        this.observer.observe(this);
      }
      disconnectedCallback() {
        this.observer.disconnect();
      }
      render() {
        const t = this.wallet?.badge_type === "certified";
        return L`
      <button>
        ${this.imageTemplate()}
        <wui-flex flexDirection="row" alignItems="center" justifyContent="center" gap="3xs">
          <wui-text
            variant="tiny-500"
            color="inherit"
            class=${we(t ? "certified" : void 0)}
            >${this.wallet?.name}</wui-text
          >
          ${
            t
              ? L`<wui-icon size="sm" name="walletConnectBrown"></wui-icon>`
              : null
          }
        </wui-flex>
      </button>
    `;
      }
      imageTemplate() {
        return (!this.visible && !this.imageSrc) || this.imageLoading
          ? this.shimmerTemplate()
          : L`
      <wui-wallet-image
        size="md"
        imageSrc=${we(this.imageSrc)}
        name=${this.wallet?.name}
        .installed=${this.wallet?.installed}
        badgeSize="sm"
      >
      </wui-wallet-image>
    `;
      }
      shimmerTemplate() {
        return L`<wui-shimmer width="56px" height="56px" borderRadius="xs"></wui-shimmer>`;
      }
      async fetchImageSrc() {
        this.wallet &&
          ((this.imageSrc = Ut.getWalletImage(this.wallet)),
          !this.imageSrc &&
            ((this.imageLoading = !0),
            (this.imageSrc = await Ut.fetchWalletImage(this.wallet.image_id)),
            (this.imageLoading = !1)));
      }
    };
    (Fa.styles = lhe),
      $d([le()], Fa.prototype, "visible", void 0),
      $d([le()], Fa.prototype, "imageSrc", void 0),
      $d([le()], Fa.prototype, "imageLoading", void 0),
      $d([M()], Fa.prototype, "wallet", void 0),
      (Fa = $d([ce("w3m-all-wallets-list-item")], Fa));
    var uhe = ge`
  wui-grid {
    max-height: clamp(360px, 400px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
    grid-auto-rows: min-content;
    grid-template-columns: repeat(auto-fill, 104px);
  }

  @media (max-width: 350px) {
    wui-grid {
      grid-template-columns: repeat(2, 1fr);
    }
  }

  wui-grid[data-scroll='false'] {
    overflow: hidden;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  wui-loading-spinner {
    padding-top: var(--wui-spacing-l);
    padding-bottom: var(--wui-spacing-l);
    justify-content: center;
    grid-column: 1 / span 4;
  }
`,
      Fd = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    const M_ = "local-paginator";
    let Ba = class extends ue {
      constructor() {
        super(),
          (this.unsubscribe = []),
          (this.paginationObserver = void 0),
          (this.loading = !ne.state.wallets.length),
          (this.wallets = ne.state.wallets),
          (this.recommended = ne.state.recommended),
          (this.featured = ne.state.featured),
          this.unsubscribe.push(
            ne.subscribeKey("wallets", (t) => (this.wallets = t)),
            ne.subscribeKey("recommended", (t) => (this.recommended = t)),
            ne.subscribeKey("featured", (t) => (this.featured = t))
          );
      }
      firstUpdated() {
        this.initialFetch(), this.createPaginationObserver();
      }
      disconnectedCallback() {
        this.unsubscribe.forEach((t) => t()),
          this.paginationObserver?.disconnect();
      }
      render() {
        return L`
      <wui-grid
        data-scroll=${!this.loading}
        .padding=${["0", "s", "s", "s"]}
        columnGap="xxs"
        rowGap="l"
        justifyContent="space-between"
      >
        ${this.loading ? this.shimmerTemplate(16) : this.walletsTemplate()}
        ${this.paginationLoaderTemplate()}
      </wui-grid>
    `;
      }
      async initialFetch() {
        this.loading = !0;
        const t = this.shadowRoot?.querySelector("wui-grid");
        t &&
          (await ne.fetchWalletsByPage({ page: 1 }),
          await t.animate([{ opacity: 1 }, { opacity: 0 }], {
            duration: 200,
            fill: "forwards",
            easing: "ease",
          }).finished,
          (this.loading = !1),
          t.animate([{ opacity: 0 }, { opacity: 1 }], {
            duration: 200,
            fill: "forwards",
            easing: "ease",
          }));
      }
      shimmerTemplate(t, e) {
        return [...Array(t)].map(
          () => L`
        <wui-card-select-loader type="wallet" id=${we(
          e
        )}></wui-card-select-loader>
      `
        );
      }
      walletsTemplate() {
        const t = X.uniqueBy(
          [...this.featured, ...this.recommended, ...this.wallets],
          "id"
        );
        return _a.markWalletsAsInstalled(t).map(
          (e) => L`
        <w3m-all-wallets-list-item
          @click=${() => this.onConnectWallet(e)}
          .wallet=${e}
        ></w3m-all-wallets-list-item>
      `
        );
      }
      paginationLoaderTemplate() {
        const { wallets: t, recommended: e, featured: r, count: i } = ne.state,
          s = window.innerWidth < 352 ? 3 : 4,
          n = t.length + e.length;
        let o = Math.ceil(n / s) * s - n + s;
        return (
          (o -= t.length ? r.length % s : 0),
          i === 0 && r.length > 0
            ? null
            : i === 0 || [...r, ...t, ...e].length < i
            ? this.shimmerTemplate(o, M_)
            : null
        );
      }
      createPaginationObserver() {
        const t = this.shadowRoot?.querySelector(`#${M_}`);
        t &&
          ((this.paginationObserver = new IntersectionObserver(([e]) => {
            if (e?.isIntersecting && !this.loading) {
              const { page: r, count: i, wallets: s } = ne.state;
              s.length < i && ne.fetchWalletsByPage({ page: r + 1 });
            }
          })),
          this.paginationObserver.observe(t));
      }
      onConnectWallet(t) {
        oe.selectWalletConnector(t);
      }
    };
    (Ba.styles = uhe),
      Fd([le()], Ba.prototype, "loading", void 0),
      Fd([le()], Ba.prototype, "wallets", void 0),
      Fd([le()], Ba.prototype, "recommended", void 0),
      Fd([le()], Ba.prototype, "featured", void 0),
      (Ba = Fd([ce("w3m-all-wallets-list")], Ba));
    var hhe = ge`
  wui-grid,
  wui-loading-spinner,
  wui-flex {
    height: 360px;
  }

  wui-grid {
    overflow: scroll;
    scrollbar-width: none;
    grid-auto-rows: min-content;
    grid-template-columns: repeat(auto-fill, 104px);
  }

  wui-grid[data-scroll='false'] {
    overflow: hidden;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  wui-loading-spinner {
    justify-content: center;
    align-items: center;
  }

  @media (max-width: 350px) {
    wui-grid {
      grid-template-columns: repeat(2, 1fr);
    }
  }
`,
      X0 = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let Jl = class extends ue {
      constructor() {
        super(...arguments),
          (this.prevQuery = ""),
          (this.prevBadge = void 0),
          (this.loading = !0),
          (this.query = "");
      }
      render() {
        return (
          this.onSearch(),
          this.loading
            ? L`<wui-loading-spinner color="accent-100"></wui-loading-spinner>`
            : this.walletsTemplate()
        );
      }
      async onSearch() {
        (this.query.trim() !== this.prevQuery.trim() ||
          this.badge !== this.prevBadge) &&
          ((this.prevQuery = this.query),
          (this.prevBadge = this.badge),
          (this.loading = !0),
          await ne.searchWallet({ search: this.query, badge: this.badge }),
          (this.loading = !1));
      }
      walletsTemplate() {
        const { search: t } = ne.state,
          e = _a.markWalletsAsInstalled(t);
        return t.length
          ? L`
      <wui-grid
        data-testid="wallet-list"
        .padding=${["0", "s", "s", "s"]}
        rowGap="l"
        columnGap="xs"
        justifyContent="space-between"
      >
        ${e.map(
          (r) => L`
            <w3m-all-wallets-list-item
              @click=${() => this.onConnectWallet(r)}
              .wallet=${r}
              data-testid="wallet-search-item-${r.id}"
            ></w3m-all-wallets-list-item>
          `
        )}
      </wui-grid>
    `
          : L`
        <wui-flex
          data-testid="no-wallet-found"
          justifyContent="center"
          alignItems="center"
          gap="s"
          flexDirection="column"
        >
          <wui-icon-box
            size="lg"
            iconColor="fg-200"
            backgroundColor="fg-300"
            icon="wallet"
            background="transparent"
          ></wui-icon-box>
          <wui-text data-testid="no-wallet-found-text" color="fg-200" variant="paragraph-500">
            No Wallet found
          </wui-text>
        </wui-flex>
      `;
      }
      onConnectWallet(t) {
        oe.selectWalletConnector(t);
      }
    };
    (Jl.styles = hhe),
      X0([le()], Jl.prototype, "loading", void 0),
      X0([M()], Jl.prototype, "query", void 0),
      X0([M()], Jl.prototype, "badge", void 0),
      (Jl = X0([ce("w3m-all-wallets-search")], Jl));
    var av = function (t, e, r, i) {
      var s = arguments.length,
        n =
          s < 3
            ? e
            : i === null
            ? (i = Object.getOwnPropertyDescriptor(e, r))
            : i,
        o;
      if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        n = Reflect.decorate(t, e, r, i);
      else
        for (var a = t.length - 1; a >= 0; a--)
          (o = t[a]) &&
            (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
      return s > 3 && n && Object.defineProperty(e, r, n), n;
    };
    let Bd = class extends ue {
      constructor() {
        super(...arguments),
          (this.search = ""),
          (this.onDebouncedSearch = X.debounce((t) => {
            this.search = t;
          }));
      }
      render() {
        const t = this.search.length >= 2;
        return L`
      <wui-flex .padding=${["0", "s", "s", "s"]} gap="xs">
        <wui-search-bar @inputChange=${this.onInputChange.bind(
          this
        )}></wui-search-bar>
        <wui-certified-switch
          ?checked=${this.badge}
          @click=${this.onClick.bind(this)}
          data-testid="wui-certified-switch"
        ></wui-certified-switch>
        ${this.qrButtonTemplate()}
      </wui-flex>
      ${
        t || this.badge
          ? L`<w3m-all-wallets-search
            query=${this.search}
            badge=${we(this.badge)}
          ></w3m-all-wallets-search>`
          : L`<w3m-all-wallets-list badge=${we(
              this.badge
            )}></w3m-all-wallets-list>`
      }
    `;
      }
      onInputChange(t) {
        this.onDebouncedSearch(t.detail);
      }
      onClick() {
        if (this.badge === "certified") {
          this.badge = void 0;
          return;
        }
        (this.badge = "certified"),
          at.showSvg("Only WalletConnect certified", {
            icon: "walletConnectBrown",
            iconColor: "accent-100",
          });
      }
      qrButtonTemplate() {
        return X.isMobile()
          ? L`
        <wui-icon-box
          size="lg"
          iconSize="xl"
          iconColor="accent-100"
          backgroundColor="accent-100"
          icon="qrCode"
          background="transparent"
          border
          borderColor="wui-accent-glass-010"
          @click=${this.onWalletConnectQr.bind(this)}
        ></wui-icon-box>
      `
          : null;
      }
      onWalletConnectQr() {
        ie.push("ConnectingWalletConnect");
      }
    };
    av([le()], Bd.prototype, "search", void 0),
      av([le()], Bd.prototype, "badge", void 0),
      (Bd = av([ce("w3m-all-wallets-view")], Bd));
    var dhe = ge`
  button {
    column-gap: var(--wui-spacing-s);
    padding: 11px 18px 11px var(--wui-spacing-s);
    width: 100%;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
    transition:
      color var(--wui-ease-out-power-1) var(--wui-duration-md),
      background-color var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: color, background-color;
  }

  button[data-iconvariant='square'],
  button[data-iconvariant='square-blue'] {
    padding: 6px 18px 6px 9px;
  }

  button > wui-flex {
    flex: 1;
  }

  button > wui-image {
    width: 32px;
    height: 32px;
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-005);
    border-radius: var(--wui-border-radius-3xl);
  }

  button > wui-icon {
    width: 36px;
    height: 36px;
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: opacity;
  }

  button > wui-icon-box[data-variant='blue'] {
    box-shadow: 0 0 0 2px var(--wui-color-accent-glass-005);
  }

  button > wui-icon-box[data-variant='overlay'] {
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-005);
  }

  button > wui-icon-box[data-variant='square-blue'] {
    border-radius: var(--wui-border-radius-3xs);
    position: relative;
    border: none;
    width: 36px;
    height: 36px;
  }

  button > wui-icon-box[data-variant='square-blue']::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-color-accent-glass-010);
    pointer-events: none;
  }

  button > wui-icon:last-child {
    width: 14px;
    height: 14px;
  }

  button:disabled {
    color: var(--wui-color-gray-glass-020);
  }

  button[data-loading='true'] > wui-icon {
    opacity: 0;
  }

  wui-loading-spinner {
    position: absolute;
    right: 18px;
    top: 50%;
    transform: translateY(-50%);
  }
`,
      fs = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let Pi = class extends ue {
      constructor() {
        super(...arguments),
          (this.tabIdx = void 0),
          (this.variant = "icon"),
          (this.disabled = !1),
          (this.imageSrc = void 0),
          (this.alt = void 0),
          (this.chevron = !1),
          (this.loading = !1);
      }
      render() {
        return L`
      <button
        ?disabled=${this.loading ? !0 : !!this.disabled}
        data-loading=${this.loading}
        data-iconvariant=${we(this.iconVariant)}
        tabindex=${we(this.tabIdx)}
      >
        ${this.loadingTemplate()} ${this.visualTemplate()}
        <wui-flex gap="3xs">
          <slot></slot>
        </wui-flex>
        ${this.chevronTemplate()}
      </button>
    `;
      }
      visualTemplate() {
        if (this.variant === "image" && this.imageSrc)
          return L`<wui-image src=${this.imageSrc} alt=${
            this.alt ?? "list item"
          }></wui-image>`;
        if (
          this.iconVariant === "square" &&
          this.icon &&
          this.variant === "icon"
        )
          return L`<wui-icon name=${this.icon}></wui-icon>`;
        if (this.variant === "icon" && this.icon && this.iconVariant) {
          const t = ["blue", "square-blue"].includes(this.iconVariant)
              ? "accent-100"
              : "fg-200",
            e = this.iconVariant === "square-blue" ? "mdl" : "md",
            r = this.iconSize ? this.iconSize : e;
          return L`
        <wui-icon-box
          data-variant=${this.iconVariant}
          icon=${this.icon}
          iconSize=${r}
          background="transparent"
          iconColor=${t}
          backgroundColor=${t}
          size=${e}
        ></wui-icon-box>
      `;
        }
        return null;
      }
      loadingTemplate() {
        return this.loading
          ? L`<wui-loading-spinner
        data-testid="wui-list-item-loading-spinner"
        color="fg-300"
      ></wui-loading-spinner>`
          : L``;
      }
      chevronTemplate() {
        return this.chevron
          ? L`<wui-icon size="inherit" color="fg-200" name="chevronRight"></wui-icon>`
          : null;
      }
    };
    (Pi.styles = [qe, Cr, dhe]),
      fs([M()], Pi.prototype, "icon", void 0),
      fs([M()], Pi.prototype, "iconSize", void 0),
      fs([M()], Pi.prototype, "tabIdx", void 0),
      fs([M()], Pi.prototype, "variant", void 0),
      fs([M()], Pi.prototype, "iconVariant", void 0),
      fs([M({ type: Boolean })], Pi.prototype, "disabled", void 0),
      fs([M()], Pi.prototype, "imageSrc", void 0),
      fs([M()], Pi.prototype, "alt", void 0),
      fs([M({ type: Boolean })], Pi.prototype, "chevron", void 0),
      fs([M({ type: Boolean })], Pi.prototype, "loading", void 0),
      (Pi = fs([ce("wui-list-item")], Pi));
    var phe = function (t, e, r, i) {
      var s = arguments.length,
        n =
          s < 3
            ? e
            : i === null
            ? (i = Object.getOwnPropertyDescriptor(e, r))
            : i,
        o;
      if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        n = Reflect.decorate(t, e, r, i);
      else
        for (var a = t.length - 1; a >= 0; a--)
          (o = t[a]) &&
            (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
      return s > 3 && n && Object.defineProperty(e, r, n), n;
    };
    let cv = class extends ue {
      constructor() {
        super(...arguments), (this.wallet = ie.state.data?.wallet);
      }
      render() {
        if (!this.wallet) throw new Error("w3m-downloads-view");
        return L`
      <wui-flex gap="xs" flexDirection="column" .padding=${[
        "s",
        "s",
        "l",
        "s",
      ]}>
        ${this.chromeTemplate()} ${this.iosTemplate()} ${this.androidTemplate()}
        ${this.homepageTemplate()}
      </wui-flex>
    `;
      }
      chromeTemplate() {
        return this.wallet?.chrome_store
          ? L`<wui-list-item
      variant="icon"
      icon="chromeStore"
      iconVariant="square"
      @click=${this.onChromeStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">Chrome Extension</wui-text>
    </wui-list-item>`
          : null;
      }
      iosTemplate() {
        return this.wallet?.app_store
          ? L`<wui-list-item
      variant="icon"
      icon="appStore"
      iconVariant="square"
      @click=${this.onAppStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">iOS App</wui-text>
    </wui-list-item>`
          : null;
      }
      androidTemplate() {
        return this.wallet?.play_store
          ? L`<wui-list-item
      variant="icon"
      icon="playStore"
      iconVariant="square"
      @click=${this.onPlayStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">Android App</wui-text>
    </wui-list-item>`
          : null;
      }
      homepageTemplate() {
        return this.wallet?.homepage
          ? L`
      <wui-list-item
        variant="icon"
        icon="browser"
        iconVariant="square-blue"
        @click=${this.onHomePage.bind(this)}
        chevron
      >
        <wui-text variant="paragraph-500" color="fg-100">Website</wui-text>
      </wui-list-item>
    `
          : null;
      }
      onChromeStore() {
        this.wallet?.chrome_store &&
          X.openHref(this.wallet.chrome_store, "_blank");
      }
      onAppStore() {
        this.wallet?.app_store && X.openHref(this.wallet.app_store, "_blank");
      }
      onPlayStore() {
        this.wallet?.play_store && X.openHref(this.wallet.play_store, "_blank");
      }
      onHomePage() {
        this.wallet?.homepage && X.openHref(this.wallet.homepage, "_blank");
      }
    };
    cv = phe([ce("w3m-downloads-view")], cv);
    var fhe = Object.freeze({
        __proto__: null,
        get W3mConnectingWcBasicView() {
          return K0;
        },
        get W3mAllWalletsView() {
          return Bd;
        },
        get W3mDownloadsView() {
          return cv;
        },
      }),
      ghe = ge`
  :host {
    display: block;
    border-radius: clamp(0px, var(--wui-border-radius-l), 44px);
    box-shadow: 0 0 0 1px var(--wui-color-gray-glass-005);
    background-color: var(--wui-color-modal-bg);
    overflow: hidden;
  }

  :host([data-embedded='true']) {
    box-shadow:
      0 0 0 1px var(--wui-color-gray-glass-005),
      0px 4px 12px 4px var(--w3m-card-embedded-shadow-color);
  }
`,
      whe = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let lv = class extends ue {
      render() {
        return L`<slot></slot>`;
      }
    };
    (lv.styles = [qe, ghe]), (lv = whe([ce("wui-card")], lv));
    var mhe = ge`
  :host {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-s);
    border: 1px solid var(--wui-color-dark-glass-100);
    box-sizing: border-box;
    background-color: var(--wui-color-bg-325);
    box-shadow: 0px 0px 16px 0px rgba(0, 0, 0, 0.25);
  }

  wui-flex {
    width: 100%;
  }

  wui-text {
    word-break: break-word;
    flex: 1;
  }

  .close {
    cursor: pointer;
  }

  .icon-box {
    height: 40px;
    width: 40px;
    border-radius: var(--wui-border-radius-3xs);
    background-color: var(--local-icon-bg-value);
  }
`,
      Ld = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let La = class extends ue {
      constructor() {
        super(...arguments),
          (this.message = ""),
          (this.backgroundColor = "accent-100"),
          (this.iconColor = "accent-100"),
          (this.icon = "info");
      }
      render() {
        return (
          (this.style.cssText = `
      --local-icon-bg-value: var(--wui-color-${this.backgroundColor});
   `),
          L`
      <wui-flex flexDirection="row" justifyContent="space-between" alignItems="center">
        <wui-flex columnGap="xs" flexDirection="row" alignItems="center">
          <wui-flex
            flexDirection="row"
            alignItems="center"
            justifyContent="center"
            class="icon-box"
          >
            <wui-icon color=${this.iconColor} size="md" name=${this.icon}></wui-icon>
          </wui-flex>
          <wui-text variant="small-500" color="bg-350" data-testid="wui-alertbar-text"
            >${this.message}</wui-text
          >
        </wui-flex>
        <wui-icon
          class="close"
          color="bg-350"
          size="sm"
          name="close"
          @click=${this.onClose}
        ></wui-icon>
      </wui-flex>
    `
        );
      }
      onClose() {
        ro.close();
      }
    };
    (La.styles = [qe, mhe]),
      Ld([M()], La.prototype, "message", void 0),
      Ld([M()], La.prototype, "backgroundColor", void 0),
      Ld([M()], La.prototype, "iconColor", void 0),
      Ld([M()], La.prototype, "icon", void 0),
      (La = Ld([ce("wui-alertbar")], La));
    var yhe = ge`
  :host {
    display: block;
    position: absolute;
    top: var(--wui-spacing-s);
    left: var(--wui-spacing-l);
    right: var(--wui-spacing-l);
    opacity: 0;
    pointer-events: none;
  }
`,
      z_ = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    const bhe = {
      info: { backgroundColor: "fg-350", iconColor: "fg-325", icon: "info" },
      success: {
        backgroundColor: "success-glass-reown-020",
        iconColor: "success-125",
        icon: "checkmark",
      },
      warning: {
        backgroundColor: "warning-glass-reown-020",
        iconColor: "warning-100",
        icon: "warningCircle",
      },
      error: {
        backgroundColor: "error-glass-reown-020",
        iconColor: "error-125",
        icon: "exclamationTriangle",
      },
    };
    let Q0 = class extends ue {
      constructor() {
        super(),
          (this.unsubscribe = []),
          (this.open = ro.state.open),
          this.onOpen(!0),
          this.unsubscribe.push(
            ro.subscribeKey("open", (t) => {
              (this.open = t), this.onOpen(!1);
            })
          );
      }
      disconnectedCallback() {
        this.unsubscribe.forEach((t) => t());
      }
      render() {
        const { message: t, variant: e } = ro.state,
          r = bhe[e];
        return L`
      <wui-alertbar
        message=${t}
        backgroundColor=${r?.backgroundColor}
        iconColor=${r?.iconColor}
        icon=${r?.icon}
      ></wui-alertbar>
    `;
      }
      onOpen(t) {
        this.open
          ? (this.animate(
              [
                { opacity: 0, transform: "scale(0.85)" },
                { opacity: 1, transform: "scale(1)" },
              ],
              { duration: 150, fill: "forwards", easing: "ease" }
            ),
            (this.style.cssText = "pointer-events: auto"))
          : t ||
            (this.animate(
              [
                { opacity: 1, transform: "scale(1)" },
                { opacity: 0, transform: "scale(0.85)" },
              ],
              { duration: 150, fill: "forwards", easing: "ease" }
            ),
            (this.style.cssText = "pointer-events: none"));
      }
    };
    (Q0.styles = yhe),
      z_([le()], Q0.prototype, "open", void 0),
      (Q0 = z_([ce("w3m-alertbar")], Q0));
    var vhe = ge`
  button {
    border-radius: var(--local-border-radius);
    color: var(--wui-color-fg-100);
    padding: var(--local-padding);
  }

  @media (max-width: 700px) {
    button {
      padding: var(--wui-spacing-s);
    }
  }

  button > wui-icon {
    pointer-events: none;
  }

  button:disabled > wui-icon {
    color: var(--wui-color-bg-300) !important;
  }

  button:disabled {
    background-color: transparent;
  }
`,
      Ud = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let Ua = class extends ue {
      constructor() {
        super(...arguments),
          (this.size = "md"),
          (this.disabled = !1),
          (this.icon = "copy"),
          (this.iconColor = "inherit");
      }
      render() {
        const t =
            this.size === "lg"
              ? "--wui-border-radius-xs"
              : "--wui-border-radius-xxs",
          e = this.size === "lg" ? "--wui-spacing-1xs" : "--wui-spacing-2xs";
        return (
          (this.style.cssText = `
    --local-border-radius: var(${t});
    --local-padding: var(${e});
`),
          L`
      <button ?disabled=${this.disabled}>
        <wui-icon color=${this.iconColor} size=${this.size} name=${this.icon}></wui-icon>
      </button>
    `
        );
      }
    };
    (Ua.styles = [qe, Cr, hd, vhe]),
      Ud([M()], Ua.prototype, "size", void 0),
      Ud([M({ type: Boolean })], Ua.prototype, "disabled", void 0),
      Ud([M()], Ua.prototype, "icon", void 0),
      Ud([M()], Ua.prototype, "iconColor", void 0),
      (Ua = Ud([ce("wui-icon-link")], Ua));
    var Ehe = ge`
  button {
    display: block;
    display: flex;
    align-items: center;
    padding: var(--wui-spacing-xxs);
    gap: var(--wui-spacing-xxs);
    transition: all var(--wui-ease-out-power-1) var(--wui-duration-md);
    border-radius: var(--wui-border-radius-xxs);
  }

  wui-image {
    border-radius: 100%;
    width: var(--wui-spacing-xl);
    height: var(--wui-spacing-xl);
  }

  wui-icon-box {
    width: var(--wui-spacing-xl);
    height: var(--wui-spacing-xl);
  }

  button:hover {
    background-color: var(--wui-color-gray-glass-002);
  }

  button:active {
    background-color: var(--wui-color-gray-glass-005);
  }
`,
      q_ = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let eg = class extends ue {
      constructor() {
        super(...arguments), (this.imageSrc = "");
      }
      render() {
        return L`<button>
      ${this.imageTemplate()}
      <wui-icon size="xs" color="fg-200" name="chevronBottom"></wui-icon>
    </button>`;
      }
      imageTemplate() {
        return this.imageSrc
          ? L`<wui-image src=${this.imageSrc} alt="select visual"></wui-image>`
          : L`<wui-icon-box
      size="xxs"
      iconColor="fg-200"
      backgroundColor="fg-100"
      background="opaque"
      icon="networkPlaceholder"
    ></wui-icon-box>`;
      }
    };
    (eg.styles = [qe, Cr, hd, Ehe]),
      q_([M()], eg.prototype, "imageSrc", void 0),
      (eg = q_([ce("wui-select")], eg));
    var Che = ge`
  :host {
    height: 64px;
  }

  wui-text {
    text-transform: capitalize;
  }

  wui-flex.w3m-header-title {
    transform: translateY(0);
    opacity: 1;
  }

  wui-flex.w3m-header-title[view-direction='prev'] {
    animation:
      slide-down-out 120ms forwards var(--wui-ease-out-power-2),
      slide-down-in 120ms forwards var(--wui-ease-out-power-2);
    animation-delay: 0ms, 200ms;
  }

  wui-flex.w3m-header-title[view-direction='next'] {
    animation:
      slide-up-out 120ms forwards var(--wui-ease-out-power-2),
      slide-up-in 120ms forwards var(--wui-ease-out-power-2);
    animation-delay: 0ms, 200ms;
  }

  wui-icon-link[data-hidden='true'] {
    opacity: 0 !important;
    pointer-events: none;
  }

  @keyframes slide-up-out {
    from {
      transform: translateY(0px);
      opacity: 1;
    }
    to {
      transform: translateY(3px);
      opacity: 0;
    }
  }

  @keyframes slide-up-in {
    from {
      transform: translateY(-3px);
      opacity: 0;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }

  @keyframes slide-down-out {
    from {
      transform: translateY(0px);
      opacity: 1;
    }
    to {
      transform: translateY(-3px);
      opacity: 0;
    }
  }

  @keyframes slide-down-in {
    from {
      transform: translateY(3px);
      opacity: 0;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }
`,
      js = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    const xhe = ["SmartSessionList"];
    function uv() {
      const t = ie.state.data?.connector?.name,
        e = ie.state.data?.wallet?.name,
        r = ie.state.data?.network?.name,
        i = e ?? t,
        s = oe.getConnectors();
      return {
        Connect: `Connect ${
          s.length === 1 && s[0]?.id === "w3m-email" ? "Email" : ""
        } Wallet`,
        Create: "Create Wallet",
        ChooseAccountName: void 0,
        Account: void 0,
        AccountSettings: void 0,
        AllWallets: "All Wallets",
        ApproveTransaction: "Approve Transaction",
        BuyInProgress: "Buy",
        ConnectingExternal: i ?? "Connect Wallet",
        ConnectingWalletConnect: i ?? "WalletConnect",
        ConnectingWalletConnectBasic: "WalletConnect",
        ConnectingSiwe: "Sign In",
        Convert: "Convert",
        ConvertSelectToken: "Select token",
        ConvertPreview: "Preview convert",
        Downloads: i ? `Get ${i}` : "Downloads",
        EmailLogin: "Email Login",
        EmailVerifyOtp: "Confirm Email",
        EmailVerifyDevice: "Register Device",
        GetWallet: "Get a wallet",
        Networks: "Choose Network",
        OnRampProviders: "Choose Provider",
        OnRampActivity: "Activity",
        OnRampTokenSelect: "Select Token",
        OnRampFiatSelect: "Select Currency",
        Profile: void 0,
        SwitchNetwork: r ?? "Switch Network",
        SwitchAddress: "Switch Address",
        Transactions: "Activity",
        UnsupportedChain: "Switch Network",
        UpgradeEmailWallet: "Upgrade your Wallet",
        UpdateEmailWallet: "Edit Email",
        UpdateEmailPrimaryOtp: "Confirm Current Email",
        UpdateEmailSecondaryOtp: "Confirm New Email",
        WhatIsABuy: "What is Buy?",
        RegisterAccountName: "Choose name",
        RegisterAccountNameSuccess: "",
        WalletReceive: "Receive",
        WalletCompatibleNetworks: "Compatible Networks",
        Swap: "Swap",
        SwapSelectToken: "Select token",
        SwapPreview: "Preview swap",
        WalletSend: "Send",
        WalletSendPreview: "Review send",
        WalletSendSelectToken: "Select Token",
        WhatIsANetwork: "What is a network?",
        WhatIsAWallet: "What is a wallet?",
        ConnectWallets: "Connect wallet",
        ConnectSocials: "All socials",
        ConnectingSocial: fe.state.socialProvider
          ? fe.state.socialProvider
          : "Connect Social",
        ConnectingMultiChain: "Select chain",
        ConnectingFarcaster: "Farcaster",
        SwitchActiveChain: "Switch chain",
        SmartSessionCreated: void 0,
        SmartSessionList: "Smart Sessions",
        SIWXSignMessage: "Sign In",
      };
    }
    let Ki = class extends ue {
      constructor() {
        super(),
          (this.unsubscribe = []),
          (this.heading = uv()[ie.state.view]),
          (this.network = B.state.activeCaipNetwork),
          (this.networkImage = Ut.getNetworkImage(this.network)),
          (this.buffering = !1),
          (this.showBack = !1),
          (this.prevHistoryLength = 1),
          (this.view = ie.state.view),
          (this.viewDirection = ""),
          (this.headerText = uv()[ie.state.view]),
          this.unsubscribe.push(
            Gr.subscribeNetworkImages(() => {
              this.networkImage = Ut.getNetworkImage(this.network);
            }),
            ie.subscribeKey("view", (t) => {
              setTimeout(() => {
                (this.view = t), (this.headerText = uv()[t]);
              }, bo.ANIMATION_DURATIONS.HeaderText),
                this.onViewChange(),
                this.onHistoryChange();
            }),
            pe.subscribeKey("buffering", (t) => (this.buffering = t)),
            B.subscribeKey("activeCaipNetwork", (t) => {
              (this.network = t),
                (this.networkImage = Ut.getNetworkImage(this.network));
            })
          );
      }
      disconnectCallback() {
        this.unsubscribe.forEach((t) => t());
      }
      render() {
        return L`
      <wui-flex .padding=${this.getPadding()} justifyContent="space-between" alignItems="center">
        ${this.leftHeaderTemplate()} ${this.titleTemplate()} ${this.rightHeaderTemplate()}
      </wui-flex>
    `;
      }
      onWalletHelp() {
        Se.sendEvent({ type: "track", event: "CLICK_WALLET_HELP" }),
          ie.push("WhatIsAWallet");
      }
      async onClose() {
        ie.state.view === "UnsupportedChain" || (await ao.isSIWXCloseDisabled())
          ? $e.shake()
          : $e.close();
      }
      rightHeaderTemplate() {
        const t = G?.state?.features?.smartSessions;
        return ie.state.view !== "Account" || !t
          ? this.closeButtonTemplate()
          : L`<wui-flex>
      <wui-icon-link
        icon="clock"
        @click=${() => ie.push("SmartSessionList")}
        data-testid="w3m-header-smart-sessions"
      ></wui-icon-link>
      ${this.closeButtonTemplate()}
    </wui-flex> `;
      }
      closeButtonTemplate() {
        return L`
      <wui-icon-link
        ?disabled=${this.buffering}
        icon="close"
        @click=${this.onClose.bind(this)}
        data-testid="w3m-header-close"
      ></wui-icon-link>
    `;
      }
      titleTemplate() {
        const t = xhe.includes(this.view);
        return L`
      <wui-flex
        view-direction="${this.viewDirection}"
        class="w3m-header-title"
        alignItems="center"
        gap="xs"
      >
        <wui-text variant="paragraph-700" color="fg-100" data-testid="w3m-header-text"
          >${this.headerText}</wui-text
        >
        ${t ? L`<wui-tag variant="main">Beta</wui-tag>` : null}
      </wui-flex>
    `;
      }
      leftHeaderTemplate() {
        const { view: t } = ie.state,
          e = t === "Connect",
          r = G.state.enableEmbedded,
          i = t === "ApproveTransaction",
          s = t === "ConnectingSiwe",
          n = t === "Account",
          o = G.state.enableNetworkSwitch,
          a = i || s || (e && r);
        return n && o
          ? L`<wui-select
        id="dynamic"
        data-testid="w3m-account-select-network"
        active-network=${we(this.network?.name)}
        @click=${this.onNetworks.bind(this)}
        imageSrc=${we(this.networkImage)}
      ></wui-select>`
          : this.showBack && !a
          ? L`<wui-icon-link
        data-testid="header-back"
        id="dynamic"
        icon="chevronLeft"
        ?disabled=${this.buffering}
        @click=${this.onGoBack.bind(this)}
      ></wui-icon-link>`
          : L`<wui-icon-link
      data-hidden=${!e}
      id="dynamic"
      icon="helpCircle"
      @click=${this.onWalletHelp.bind(this)}
    ></wui-icon-link>`;
      }
      onNetworks() {
        this.isAllowedNetworkSwitch() &&
          (Se.sendEvent({ type: "track", event: "CLICK_NETWORKS" }),
          ie.push("Networks"));
      }
      isAllowedNetworkSwitch() {
        const t = B.getAllRequestedCaipNetworks(),
          e = t ? t.length > 1 : !1,
          r = t?.find(({ id: i }) => i === this.network?.id);
        return e || !r;
      }
      getPadding() {
        return this.heading ? ["l", "2l", "l", "2l"] : ["0", "2l", "0", "2l"];
      }
      onViewChange() {
        const { history: t } = ie.state;
        let e = bo.VIEW_DIRECTION.Next;
        t.length < this.prevHistoryLength && (e = bo.VIEW_DIRECTION.Prev),
          (this.prevHistoryLength = t.length),
          (this.viewDirection = e);
      }
      async onHistoryChange() {
        const { history: t } = ie.state,
          e = this.shadowRoot?.querySelector("#dynamic");
        t.length > 1 && !this.showBack && e
          ? (await e.animate([{ opacity: 1 }, { opacity: 0 }], {
              duration: 200,
              fill: "forwards",
              easing: "ease",
            }).finished,
            (this.showBack = !0),
            e.animate([{ opacity: 0 }, { opacity: 1 }], {
              duration: 200,
              fill: "forwards",
              easing: "ease",
            }))
          : t.length <= 1 &&
            this.showBack &&
            e &&
            (await e.animate([{ opacity: 1 }, { opacity: 0 }], {
              duration: 200,
              fill: "forwards",
              easing: "ease",
            }).finished,
            (this.showBack = !1),
            e.animate([{ opacity: 0 }, { opacity: 1 }], {
              duration: 200,
              fill: "forwards",
              easing: "ease",
            }));
      }
      onGoBack() {
        ie.goBack();
      }
    };
    (Ki.styles = Che),
      js([le()], Ki.prototype, "heading", void 0),
      js([le()], Ki.prototype, "network", void 0),
      js([le()], Ki.prototype, "networkImage", void 0),
      js([le()], Ki.prototype, "buffering", void 0),
      js([le()], Ki.prototype, "showBack", void 0),
      js([le()], Ki.prototype, "prevHistoryLength", void 0),
      js([le()], Ki.prototype, "view", void 0),
      js([le()], Ki.prototype, "viewDirection", void 0),
      js([le()], Ki.prototype, "headerText", void 0),
      (Ki = js([ce("w3m-header")], Ki));
    var Ihe = ge`
  :host {
    display: flex;
    column-gap: var(--wui-spacing-s);
    align-items: center;
    padding: var(--wui-spacing-xs) var(--wui-spacing-m) var(--wui-spacing-xs) var(--wui-spacing-xs);
    border-radius: var(--wui-border-radius-s);
    border: 1px solid var(--wui-color-gray-glass-005);
    box-sizing: border-box;
    background-color: var(--wui-color-bg-175);
    box-shadow:
      0px 14px 64px -4px rgba(0, 0, 0, 0.15),
      0px 8px 22px -6px rgba(0, 0, 0, 0.15);

    max-width: 300px;
  }

  :host wui-loading-spinner {
    margin-left: var(--wui-spacing-3xs);
  }
`,
      Da = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let $n = class extends ue {
      constructor() {
        super(...arguments),
          (this.backgroundColor = "accent-100"),
          (this.iconColor = "accent-100"),
          (this.icon = "checkmark"),
          (this.message = ""),
          (this.loading = !1),
          (this.iconType = "default");
      }
      render() {
        return L`
      ${this.templateIcon()}
      <wui-text variant="paragraph-500" color="fg-100" data-testid="wui-snackbar-message"
        >${this.message}</wui-text
      >
    `;
      }
      templateIcon() {
        return this.loading
          ? L`<wui-loading-spinner size="md" color="accent-100"></wui-loading-spinner>`
          : this.iconType === "default"
          ? L`<wui-icon size="xl" color=${this.iconColor} name=${this.icon}></wui-icon>`
          : L`<wui-icon-box
      size="sm"
      iconSize="xs"
      iconColor=${this.iconColor}
      backgroundColor=${this.backgroundColor}
      icon=${this.icon}
      background="opaque"
    ></wui-icon-box>`;
      }
    };
    ($n.styles = [qe, Ihe]),
      Da([M()], $n.prototype, "backgroundColor", void 0),
      Da([M()], $n.prototype, "iconColor", void 0),
      Da([M()], $n.prototype, "icon", void 0),
      Da([M()], $n.prototype, "message", void 0),
      Da([M()], $n.prototype, "loading", void 0),
      Da([M()], $n.prototype, "iconType", void 0),
      ($n = Da([ce("wui-snackbar")], $n));
    var _he = ge`
  :host {
    display: block;
    position: absolute;
    opacity: 0;
    pointer-events: none;
    top: 11px;
    left: 50%;
    width: max-content;
  }
`,
      H_ = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    const Ahe = {
      loading: void 0,
      success: {
        backgroundColor: "success-100",
        iconColor: "success-100",
        icon: "checkmark",
      },
      error: {
        backgroundColor: "error-100",
        iconColor: "error-100",
        icon: "close",
      },
    };
    let tg = class extends ue {
      constructor() {
        super(),
          (this.unsubscribe = []),
          (this.timeout = void 0),
          (this.open = at.state.open),
          this.unsubscribe.push(
            at.subscribeKey("open", (t) => {
              (this.open = t), this.onOpen();
            })
          );
      }
      disconnectedCallback() {
        clearTimeout(this.timeout), this.unsubscribe.forEach((t) => t());
      }
      render() {
        const { message: t, variant: e, svg: r } = at.state,
          i = Ahe[e],
          { icon: s, iconColor: n } = r ?? i ?? {};
        return L`
      <wui-snackbar
        message=${t}
        backgroundColor=${i?.backgroundColor}
        iconColor=${n}
        icon=${s}
        .loading=${e === "loading"}
      ></wui-snackbar>
    `;
      }
      onOpen() {
        clearTimeout(this.timeout),
          this.open
            ? (this.animate(
                [
                  { opacity: 0, transform: "translateX(-50%) scale(0.85)" },
                  { opacity: 1, transform: "translateX(-50%) scale(1)" },
                ],
                { duration: 150, fill: "forwards", easing: "ease" }
              ),
              this.timeout && clearTimeout(this.timeout),
              at.state.autoClose &&
                (this.timeout = setTimeout(() => at.hide(), 2500)))
            : this.animate(
                [
                  { opacity: 1, transform: "translateX(-50%) scale(1)" },
                  { opacity: 0, transform: "translateX(-50%) scale(0.85)" },
                ],
                { duration: 150, fill: "forwards", easing: "ease" }
              );
      }
    };
    (tg.styles = _he),
      H_([le()], tg.prototype, "open", void 0),
      (tg = H_([ce("w3m-snackbar")], tg));
    var She = ge`
  :host {
    pointer-events: none;
  }

  :host > wui-flex {
    display: var(--w3m-tooltip-display);
    opacity: var(--w3m-tooltip-opacity);
    padding: 9px var(--wui-spacing-s) 10px var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xxs);
    color: var(--wui-color-bg-100);
    position: fixed;
    top: var(--w3m-tooltip-top);
    left: var(--w3m-tooltip-left);
    transform: translate(calc(-50% + var(--w3m-tooltip-parent-width)), calc(-100% - 8px));
    max-width: calc(var(--w3m-modal-width) - var(--wui-spacing-xl));
    transition: opacity 0.2s var(--wui-ease-out-power-2);
    will-change: opacity;
  }

  :host([data-variant='shade']) > wui-flex {
    background-color: var(--wui-color-bg-150);
    border: 1px solid var(--wui-color-gray-glass-005);
  }

  :host([data-variant='shade']) > wui-flex > wui-text {
    color: var(--wui-color-fg-150);
  }

  :host([data-variant='fill']) > wui-flex {
    background-color: var(--wui-color-fg-100);
    border: none;
  }

  wui-icon {
    position: absolute;
    width: 12px !important;
    height: 4px !important;
    color: var(--wui-color-bg-150);
  }

  wui-icon[data-placement='top'] {
    bottom: 0px;
    left: 50%;
    transform: translate(-50%, 95%);
  }

  wui-icon[data-placement='bottom'] {
    top: 0;
    left: 50%;
    transform: translate(-50%, -95%) rotate(180deg);
  }

  wui-icon[data-placement='right'] {
    top: 50%;
    left: 0;
    transform: translate(-65%, -50%) rotate(90deg);
  }

  wui-icon[data-placement='left'] {
    top: 50%;
    right: 0%;
    transform: translate(65%, -50%) rotate(270deg);
  }
`,
      Dd = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let ja = class extends ue {
      constructor() {
        super(),
          (this.unsubscribe = []),
          (this.open = al.state.open),
          (this.message = al.state.message),
          (this.triggerRect = al.state.triggerRect),
          (this.variant = al.state.variant),
          this.unsubscribe.push(
            al.subscribe((t) => {
              (this.open = t.open),
                (this.message = t.message),
                (this.triggerRect = t.triggerRect),
                (this.variant = t.variant);
            })
          );
      }
      disconnectedCallback() {
        this.unsubscribe.forEach((t) => t());
      }
      render() {
        this.dataset.variant = this.variant;
        const t = this.triggerRect.top,
          e = this.triggerRect.left;
        return (
          (this.style.cssText = `
    --w3m-tooltip-top: ${t}px;
    --w3m-tooltip-left: ${e}px;
    --w3m-tooltip-parent-width: ${this.triggerRect.width / 2}px;
    --w3m-tooltip-display: ${this.open ? "flex" : "none"};
    --w3m-tooltip-opacity: ${this.open ? 1 : 0};
    `),
          L`<wui-flex>
      <wui-icon data-placement="top" color="fg-100" size="inherit" name="cursor"></wui-icon>
      <wui-text color="inherit" variant="small-500">${this.message}</wui-text>
    </wui-flex>`
        );
      }
    };
    (ja.styles = [She]),
      Dd([le()], ja.prototype, "open", void 0),
      Dd([le()], ja.prototype, "message", void 0),
      Dd([le()], ja.prototype, "triggerRect", void 0),
      Dd([le()], ja.prototype, "variant", void 0),
      (ja = Dd([ce("w3m-tooltip"), ce("w3m-tooltip")], ja));
    var Phe = ge`
  :host {
    --prev-height: 0px;
    --new-height: 0px;
    display: block;
  }

  div.w3m-router-container {
    transform: translateY(0);
    opacity: 1;
  }

  div.w3m-router-container[view-direction='prev'] {
    animation:
      slide-left-out 150ms forwards ease,
      slide-left-in 150ms forwards ease;
    animation-delay: 0ms, 200ms;
  }

  div.w3m-router-container[view-direction='next'] {
    animation:
      slide-right-out 150ms forwards ease,
      slide-right-in 150ms forwards ease;
    animation-delay: 0ms, 200ms;
  }

  @keyframes slide-left-out {
    from {
      transform: translateX(0px);
      opacity: 1;
    }
    to {
      transform: translateX(10px);
      opacity: 0;
    }
  }

  @keyframes slide-left-in {
    from {
      transform: translateX(-10px);
      opacity: 0;
    }
    to {
      transform: translateX(0);
      opacity: 1;
    }
  }

  @keyframes slide-right-out {
    from {
      transform: translateX(0px);
      opacity: 1;
    }
    to {
      transform: translateX(-10px);
      opacity: 0;
    }
  }

  @keyframes slide-right-in {
    from {
      transform: translateX(10px);
      opacity: 0;
    }
    to {
      transform: translateX(0);
      opacity: 1;
    }
  }
`,
      hv = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    let jd = class extends ue {
      constructor() {
        super(),
          (this.resizeObserver = void 0),
          (this.prevHeight = "0px"),
          (this.prevHistoryLength = 1),
          (this.unsubscribe = []),
          (this.view = ie.state.view),
          (this.viewDirection = ""),
          this.unsubscribe.push(
            ie.subscribeKey("view", (t) => this.onViewChange(t))
          );
      }
      firstUpdated() {
        (this.resizeObserver = new ResizeObserver(([t]) => {
          const e = `${t?.contentRect.height}px`;
          this.prevHeight !== "0px" &&
            (this.style.setProperty("--prev-height", this.prevHeight),
            this.style.setProperty("--new-height", e),
            (this.style.animation = "w3m-view-height 150ms forwards ease"),
            (this.style.height = "auto")),
            setTimeout(() => {
              (this.prevHeight = e), (this.style.animation = "unset");
            }, bo.ANIMATION_DURATIONS.ModalHeight);
        })),
          this.resizeObserver?.observe(this.getWrapper());
      }
      disconnectedCallback() {
        this.resizeObserver?.unobserve(this.getWrapper()),
          this.unsubscribe.forEach((t) => t());
      }
      render() {
        return L`<div class="w3m-router-container" view-direction="${
          this.viewDirection
        }">
      ${this.viewTemplate()}
    </div>`;
      }
      viewTemplate() {
        switch (this.view) {
          case "AccountSettings":
            return L`<w3m-account-settings-view></w3m-account-settings-view>`;
          case "Account":
            return L`<w3m-account-view></w3m-account-view>`;
          case "AllWallets":
            return L`<w3m-all-wallets-view></w3m-all-wallets-view>`;
          case "ApproveTransaction":
            return L`<w3m-approve-transaction-view></w3m-approve-transaction-view>`;
          case "BuyInProgress":
            return L`<w3m-buy-in-progress-view></w3m-buy-in-progress-view>`;
          case "ChooseAccountName":
            return L`<w3m-choose-account-name-view></w3m-choose-account-name-view>`;
          case "Connect":
            return L`<w3m-connect-view></w3m-connect-view>`;
          case "Create":
            return L`<w3m-connect-view walletGuide="explore"></w3m-connect-view>`;
          case "ConnectingWalletConnect":
            return L`<w3m-connecting-wc-view></w3m-connecting-wc-view>`;
          case "ConnectingWalletConnectBasic":
            return L`<w3m-connecting-wc-basic-view></w3m-connecting-wc-basic-view>`;
          case "ConnectingExternal":
            return L`<w3m-connecting-external-view></w3m-connecting-external-view>`;
          case "ConnectingSiwe":
            return L`<w3m-connecting-siwe-view></w3m-connecting-siwe-view>`;
          case "ConnectWallets":
            return L`<w3m-connect-wallets-view></w3m-connect-wallets-view>`;
          case "ConnectSocials":
            return L`<w3m-connect-socials-view></w3m-connect-socials-view>`;
          case "ConnectingSocial":
            return L`<w3m-connecting-social-view></w3m-connecting-social-view>`;
          case "Downloads":
            return L`<w3m-downloads-view></w3m-downloads-view>`;
          case "EmailLogin":
            return L`<w3m-email-login-view></w3m-email-login-view>`;
          case "EmailVerifyOtp":
            return L`<w3m-email-verify-otp-view></w3m-email-verify-otp-view>`;
          case "EmailVerifyDevice":
            return L`<w3m-email-verify-device-view></w3m-email-verify-device-view>`;
          case "GetWallet":
            return L`<w3m-get-wallet-view></w3m-get-wallet-view>`;
          case "Networks":
            return L`<w3m-networks-view></w3m-networks-view>`;
          case "SwitchNetwork":
            return L`<w3m-network-switch-view></w3m-network-switch-view>`;
          case "Profile":
            return L`<w3m-profile-view></w3m-profile-view>`;
          case "SwitchAddress":
            return L`<w3m-switch-address-view></w3m-switch-address-view>`;
          case "Transactions":
            return L`<w3m-transactions-view></w3m-transactions-view>`;
          case "OnRampProviders":
            return L`<w3m-onramp-providers-view></w3m-onramp-providers-view>`;
          case "OnRampActivity":
            return L`<w3m-onramp-activity-view></w3m-onramp-activity-view>`;
          case "OnRampTokenSelect":
            return L`<w3m-onramp-token-select-view></w3m-onramp-token-select-view>`;
          case "OnRampFiatSelect":
            return L`<w3m-onramp-fiat-select-view></w3m-onramp-fiat-select-view>`;
          case "UpgradeEmailWallet":
            return L`<w3m-upgrade-wallet-view></w3m-upgrade-wallet-view>`;
          case "UpdateEmailWallet":
            return L`<w3m-update-email-wallet-view></w3m-update-email-wallet-view>`;
          case "UpdateEmailPrimaryOtp":
            return L`<w3m-update-email-primary-otp-view></w3m-update-email-primary-otp-view>`;
          case "UpdateEmailSecondaryOtp":
            return L`<w3m-update-email-secondary-otp-view></w3m-update-email-secondary-otp-view>`;
          case "UnsupportedChain":
            return L`<w3m-unsupported-chain-view></w3m-unsupported-chain-view>`;
          case "Swap":
            return L`<w3m-swap-view></w3m-swap-view>`;
          case "SwapSelectToken":
            return L`<w3m-swap-select-token-view></w3m-swap-select-token-view>`;
          case "SwapPreview":
            return L`<w3m-swap-preview-view></w3m-swap-preview-view>`;
          case "WalletSend":
            return L`<w3m-wallet-send-view></w3m-wallet-send-view>`;
          case "WalletSendSelectToken":
            return L`<w3m-wallet-send-select-token-view></w3m-wallet-send-select-token-view>`;
          case "WalletSendPreview":
            return L`<w3m-wallet-send-preview-view></w3m-wallet-send-preview-view>`;
          case "WhatIsABuy":
            return L`<w3m-what-is-a-buy-view></w3m-what-is-a-buy-view>`;
          case "WalletReceive":
            return L`<w3m-wallet-receive-view></w3m-wallet-receive-view>`;
          case "WalletCompatibleNetworks":
            return L`<w3m-wallet-compatible-networks-view></w3m-wallet-compatible-networks-view>`;
          case "WhatIsAWallet":
            return L`<w3m-what-is-a-wallet-view></w3m-what-is-a-wallet-view>`;
          case "ConnectingMultiChain":
            return L`<w3m-connecting-multi-chain-view></w3m-connecting-multi-chain-view>`;
          case "WhatIsANetwork":
            return L`<w3m-what-is-a-network-view></w3m-what-is-a-network-view>`;
          case "ConnectingFarcaster":
            return L`<w3m-connecting-farcaster-view></w3m-connecting-farcaster-view>`;
          case "SwitchActiveChain":
            return L`<w3m-switch-active-chain-view></w3m-switch-active-chain-view>`;
          case "RegisterAccountName":
            return L`<w3m-register-account-name-view></w3m-register-account-name-view>`;
          case "RegisterAccountNameSuccess":
            return L`<w3m-register-account-name-success-view></w3m-register-account-name-success-view>`;
          case "SmartSessionCreated":
            return L`<w3m-smart-session-created-view></w3m-smart-session-created-view>`;
          case "SmartSessionList":
            return L`<w3m-smart-session-list-view></w3m-smart-session-list-view>`;
          case "SIWXSignMessage":
            return L`<w3m-siwx-sign-message-view></w3m-siwx-sign-message-view>`;
          default:
            return L`<w3m-connect-view></w3m-connect-view>`;
        }
      }
      onViewChange(t) {
        al.hide();
        let e = bo.VIEW_DIRECTION.Next;
        const { history: r } = ie.state;
        r.length < this.prevHistoryLength && (e = bo.VIEW_DIRECTION.Prev),
          (this.prevHistoryLength = r.length),
          (this.viewDirection = e),
          setTimeout(() => {
            this.view = t;
          }, bo.ANIMATION_DURATIONS.ViewTransition);
      }
      getWrapper() {
        return this.shadowRoot?.querySelector("div");
      }
    };
    (jd.styles = Phe),
      hv([le()], jd.prototype, "view", void 0),
      hv([le()], jd.prototype, "viewDirection", void 0),
      (jd = hv([ce("w3m-router")], jd));
    var Ohe = ge`
  :host {
    z-index: var(--w3m-z-index);
    display: block;
    backface-visibility: hidden;
    will-change: opacity;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
    opacity: 0;
    background-color: var(--wui-cover);
    transition: opacity 0.2s var(--wui-ease-out-power-2);
    will-change: opacity;
  }

  :host(.open) {
    opacity: 1;
  }

  :host(.embedded) {
    position: relative;
    pointer-events: unset;
    background: none;
    width: 100%;
    opacity: 1;
  }

  wui-card {
    max-width: var(--w3m-modal-width);
    width: 100%;
    position: relative;
    animation: zoom-in 0.2s var(--wui-ease-out-power-2);
    animation-fill-mode: backwards;
    outline: none;
    transition:
      border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1),
      background-color var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: border-radius, background-color;
  }

  :host(.embedded) wui-card {
    max-width: 400px;
  }

  wui-card[shake='true'] {
    animation:
      zoom-in 0.2s var(--wui-ease-out-power-2),
      w3m-shake 0.5s var(--wui-ease-out-power-2);
  }

  wui-flex {
    overflow-x: hidden;
    overflow-y: auto;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
  }

  @media (max-height: 700px) and (min-width: 431px) {
    wui-flex {
      align-items: flex-start;
    }

    wui-card {
      margin: var(--wui-spacing-xxl) 0px;
    }
  }

  @media (max-width: 430px) {
    wui-flex {
      align-items: flex-end;
    }

    wui-card {
      max-width: 100%;
      border-bottom-left-radius: var(--local-border-bottom-mobile-radius);
      border-bottom-right-radius: var(--local-border-bottom-mobile-radius);
      border-bottom: none;
      animation: slide-in 0.2s var(--wui-ease-out-power-2);
    }

    wui-card[shake='true'] {
      animation:
        slide-in 0.2s var(--wui-ease-out-power-2),
        w3m-shake 0.5s var(--wui-ease-out-power-2);
    }
  }

  @keyframes zoom-in {
    0% {
      transform: scale(0.95) translateY(0);
    }
    100% {
      transform: scale(1) translateY(0);
    }
  }

  @keyframes slide-in {
    0% {
      transform: scale(1) translateY(50px);
    }
    100% {
      transform: scale(1) translateY(0);
    }
  }

  @keyframes w3m-shake {
    0% {
      transform: scale(1) rotate(0deg);
    }
    20% {
      transform: scale(1) rotate(-1deg);
    }
    40% {
      transform: scale(1) rotate(1.5deg);
    }
    60% {
      transform: scale(1) rotate(-1.5deg);
    }
    80% {
      transform: scale(1) rotate(1deg);
    }
    100% {
      transform: scale(1) rotate(0deg);
    }
  }

  @keyframes w3m-view-height {
    from {
      height: var(--prev-height);
    }
    to {
      height: var(--new-height);
    }
  }
`,
      Ma = function (t, e, r, i) {
        var s = arguments.length,
          n =
            s < 3
              ? e
              : i === null
              ? (i = Object.getOwnPropertyDescriptor(e, r))
              : i,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n = Reflect.decorate(t, e, r, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) &&
              (n = (s < 3 ? o(n) : s > 3 ? o(e, r, n) : o(e, r)) || n);
        return s > 3 && n && Object.defineProperty(e, r, n), n;
      };
    const V_ = "scroll-lock";
    let Ms = class extends ue {
      constructor() {
        super(),
          (this.unsubscribe = []),
          (this.abortController = void 0),
          (this.hasPrefetched = !1),
          (this.enableEmbedded = G.state.enableEmbedded),
          (this.open = $e.state.open),
          (this.caipAddress = B.state.activeCaipAddress),
          (this.caipNetwork = B.state.activeCaipNetwork),
          (this.shake = $e.state.shake),
          (this.filterByNamespace = oe.state.filterByNamespace),
          this.initializeTheming(),
          ne.prefetchAnalyticsConfig(),
          this.unsubscribe.push(
            $e.subscribeKey("open", (t) =>
              t ? this.onOpen() : this.onClose()
            ),
            $e.subscribeKey("shake", (t) => (this.shake = t)),
            B.subscribeKey("activeCaipNetwork", (t) => this.onNewNetwork(t)),
            B.subscribeKey("activeCaipAddress", (t) => this.onNewAddress(t)),
            G.subscribeKey("enableEmbedded", (t) => (this.enableEmbedded = t)),
            oe.subscribeKey("filterByNamespace", (t) => {
              this.filterByNamespace !== t &&
                !B.getAccountData(t)?.caipAddress &&
                (ne.fetchRecommendedWallets(), (this.filterByNamespace = t));
            })
          );
      }
      firstUpdated() {
        if (this.caipAddress) {
          if (this.enableEmbedded) {
            $e.close(), this.prefetch();
            return;
          }
          this.onNewAddress(this.caipAddress);
        }
        this.open && this.onOpen(), this.enableEmbedded && this.prefetch();
      }
      disconnectedCallback() {
        this.unsubscribe.forEach((t) => t()), this.onRemoveKeyboardListener();
      }
      render() {
        return (
          (this.style.cssText = `
      --local-border-bottom-mobile-radius: ${
        this.enableEmbedded
          ? "clamp(0px, var(--wui-border-radius-l), 44px)"
          : "0px"
      };
    `),
          this.enableEmbedded
            ? L`${this.contentTemplate()}
        <w3m-tooltip></w3m-tooltip> `
            : this.open
            ? L`
          <wui-flex @click=${this.onOverlayClick.bind(
            this
          )} data-testid="w3m-modal-overlay">
            ${this.contentTemplate()}
          </wui-flex>
          <w3m-tooltip></w3m-tooltip>
        `
            : null
        );
      }
      contentTemplate() {
        return L` <wui-card
      shake="${this.shake}"
      data-embedded="${we(this.enableEmbedded)}"
      role="alertdialog"
      aria-modal="true"
      tabindex="0"
      data-testid="w3m-modal-card"
    >
      <w3m-header></w3m-header>
      <w3m-router></w3m-router>
      <w3m-snackbar></w3m-snackbar>
      <w3m-alertbar></w3m-alertbar>
    </wui-card>`;
      }
      async onOverlayClick(t) {
        t.target === t.currentTarget && (await this.handleClose());
      }
      async handleClose() {
        ie.state.view === "UnsupportedChain" || (await ao.isSIWXCloseDisabled())
          ? $e.shake()
          : $e.close();
      }
      initializeTheming() {
        const { themeVariables: t, themeMode: e } = Dt.state,
          r = ar.getColorTheme(e);
        Rce(t, r);
      }
      onClose() {
        (this.open = !1),
          this.classList.remove("open"),
          this.onScrollUnlock(),
          at.hide(),
          this.onRemoveKeyboardListener();
      }
      onOpen() {
        (this.open = !0),
          this.classList.add("open"),
          this.onScrollLock(),
          this.onAddKeyboardListener();
      }
      onScrollLock() {
        const t = document.createElement("style");
        (t.dataset.w3m = V_),
          (t.textContent = `
      body {
        touch-action: none;
        overflow: hidden;
        overscroll-behavior: contain;
      }
      w3m-modal {
        pointer-events: auto;
      }
    `),
          document.head.appendChild(t);
      }
      onScrollUnlock() {
        const t = document.head.querySelector(`style[data-w3m="${V_}"]`);
        t && t.remove();
      }
      onAddKeyboardListener() {
        this.abortController = new AbortController();
        const t = this.shadowRoot?.querySelector("wui-card");
        t?.focus(),
          window.addEventListener(
            "keydown",
            (e) => {
              if (e.key === "Escape") this.handleClose();
              else if (e.key === "Tab") {
                const { tagName: r } = e.target;
                r && !r.includes("W3M-") && !r.includes("WUI-") && t?.focus();
              }
            },
            this.abortController
          );
      }
      onRemoveKeyboardListener() {
        this.abortController?.abort(), (this.abortController = void 0);
      }
      async onNewAddress(t) {
        const e = B.state.isSwitchingNamespace,
          r = X.getPlainAddress(t);
        !r && !e ? $e.close() : e && r && ie.goBack(),
          await ao.initializeIfEnabled(),
          (this.caipAddress = t),
          B.setIsSwitchingNamespace(!1);
      }
      onNewNetwork(t) {
        const e = this.caipNetwork,
          r = e?.caipNetworkId?.toString(),
          i = e?.chainNamespace,
          s = t?.caipNetworkId?.toString(),
          n = t?.chainNamespace,
          o = r !== s,
          a = o && i === n,
          c = e?.name === he.UNSUPPORTED_NETWORK_NAME,
          l = ie.state.view === "ConnectingExternal",
          u = !this.caipAddress,
          h = ie.state.view === "UnsupportedChain",
          d = $e.state.open;
        let g = !1;
        d && !l && (u ? o && (g = !0) : (h || (a && !c)) && (g = !0)),
          g && ie.state.view !== "SIWXSignMessage" && ie.goBack(),
          (this.caipNetwork = t);
      }
      prefetch() {
        this.hasPrefetched ||
          (ne.prefetch(),
          ne.fetchWalletsByPage({ page: 1 }),
          (this.hasPrefetched = !0));
      }
    };
    (Ms.styles = Ohe),
      Ma([M({ type: Boolean })], Ms.prototype, "enableEmbedded", void 0),
      Ma([le()], Ms.prototype, "open", void 0),
      Ma([le()], Ms.prototype, "caipAddress", void 0),
      Ma([le()], Ms.prototype, "caipNetwork", void 0),
      Ma([le()], Ms.prototype, "shake", void 0),
      Ma([le()], Ms.prototype, "filterByNamespace", void 0),
      (Ms = Ma([ce("w3m-modal")], Ms));
    var Nhe = Object.freeze({
      __proto__: null,
      get W3mModal() {
        return Ms;
      },
    });
    const The = ee`<svg
  width="14"
  height="14"
  viewBox="0 0 14 14"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill="currentColor"
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M7.0023 0.875C7.48571 0.875 7.8776 1.26675 7.8776 1.75V6.125H12.2541C12.7375 6.125 13.1294 6.51675 13.1294 7C13.1294 7.48325 12.7375 7.875 12.2541 7.875H7.8776V12.25C7.8776 12.7332 7.48571 13.125 7.0023 13.125C6.51889 13.125 6.12701 12.7332 6.12701 12.25V7.875H1.75054C1.26713 7.875 0.875244 7.48325 0.875244 7C0.875244 6.51675 1.26713 6.125 1.75054 6.125H6.12701V1.75C6.12701 1.26675 6.51889 0.875 7.0023 0.875Z"
    fill="#667dff"
  /></svg
>`;
    var khe = Object.freeze({ __proto__: null, addSvg: The });
    const Rhe = ee`<svg fill="none" viewBox="0 0 24 24">
  <path
    style="fill: var(--wui-color-accent-100);"
    d="M10.2 6.6a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM21 6.6a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM10.2 17.4a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM21 17.4a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0Z"
  />
</svg>`;
    var $he = Object.freeze({ __proto__: null, allWalletsSvg: Rhe });
    const Fhe = ee`<svg
  fill="none"
  viewBox="0 0 21 20"
>
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M10.5 2.42908C6.31875 2.42908 2.92859 5.81989 2.92859 10.0034C2.92859 14.1869 6.31875 17.5777 10.5 17.5777C14.6813 17.5777 18.0714 14.1869 18.0714 10.0034C18.0714 5.81989 14.6813 2.42908 10.5 2.42908ZM0.928589 10.0034C0.928589 4.71596 5.21355 0.429077 10.5 0.429077C15.7865 0.429077 20.0714 4.71596 20.0714 10.0034C20.0714 15.2908 15.7865 19.5777 10.5 19.5777C5.21355 19.5777 0.928589 15.2908 0.928589 10.0034ZM10.5 5.75003C11.0523 5.75003 11.5 6.19774 11.5 6.75003L11.5 10.8343L12.7929 9.54137C13.1834 9.15085 13.8166 9.15085 14.2071 9.54137C14.5976 9.9319 14.5976 10.5651 14.2071 10.9556L11.2071 13.9556C10.8166 14.3461 10.1834 14.3461 9.79291 13.9556L6.79291 10.9556C6.40239 10.5651 6.40239 9.9319 6.79291 9.54137C7.18343 9.15085 7.8166 9.15085 8.20712 9.54137L9.50002 10.8343L9.50002 6.75003C9.50002 6.19774 9.94773 5.75003 10.5 5.75003Z"
    clip-rule="evenodd"
  /></svg
>`;
    var Bhe = Object.freeze({ __proto__: null, arrowBottomCircleSvg: Fhe });
    const Lhe = ee`
<svg width="36" height="36">
  <path
    d="M28.724 0H7.271A7.269 7.269 0 0 0 0 7.272v21.46A7.268 7.268 0 0 0 7.271 36H28.73A7.272 7.272 0 0 0 36 28.728V7.272A7.275 7.275 0 0 0 28.724 0Z"
    fill="url(#a)"
  />
  <path
    d="m17.845 8.271.729-1.26a1.64 1.64 0 1 1 2.843 1.638l-7.023 12.159h5.08c1.646 0 2.569 1.935 1.853 3.276H6.434a1.632 1.632 0 0 1-1.638-1.638c0-.909.73-1.638 1.638-1.638h4.176l5.345-9.265-1.67-2.898a1.642 1.642 0 0 1 2.844-1.638l.716 1.264Zm-6.317 17.5-1.575 2.732a1.64 1.64 0 1 1-2.844-1.638l1.17-2.025c1.323-.41 2.398-.095 3.249.931Zm13.56-4.954h4.262c.909 0 1.638.729 1.638 1.638 0 .909-.73 1.638-1.638 1.638h-2.367l1.597 2.772c.45.788.185 1.782-.602 2.241a1.642 1.642 0 0 1-2.241-.603c-2.69-4.666-4.711-8.159-6.052-10.485-1.372-2.367-.391-4.743.576-5.549 1.075 1.846 2.682 4.631 4.828 8.348Z"
    fill="#fff"
  />
  <defs>
    <linearGradient id="a" x1="18" y1="0" x2="18" y2="36" gradientUnits="userSpaceOnUse">
      <stop stop-color="#18BFFB" />
      <stop offset="1" stop-color="#2072F3" />
    </linearGradient>
  </defs>
</svg>`;
    var Uhe = Object.freeze({ __proto__: null, appStoreSvg: Lhe });
    const Dhe = ee`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#000" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M28.77 23.3c-.69 1.99-2.75 5.52-4.87 5.56-1.4.03-1.86-.84-3.46-.84-1.61 0-2.12.81-3.45.86-2.25.1-5.72-5.1-5.72-9.62 0-4.15 2.9-6.2 5.42-6.25 1.36-.02 2.64.92 3.47.92.83 0 2.38-1.13 4.02-.97.68.03 2.6.28 3.84 2.08-3.27 2.14-2.76 6.61.75 8.25ZM24.2 7.88c-2.47.1-4.49 2.69-4.2 4.84 2.28.17 4.47-2.39 4.2-4.84Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;
    var jhe = Object.freeze({ __proto__: null, appleSvg: Dhe });
    const Mhe = ee`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 1.99a1 1 0 0 1 1 1v7.58l2.46-2.46a1 1 0 0 1 1.41 1.42L7.7 13.69a1 1 0 0 1-1.41 0L2.12 9.53A1 1 0 0 1 3.54 8.1L6 10.57V3a1 1 0 0 1 1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
    var zhe = Object.freeze({ __proto__: null, arrowBottomSvg: Mhe });
    const qhe = ee`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M13 7.99a1 1 0 0 1-1 1H4.4l2.46 2.46a1 1 0 1 1-1.41 1.41L1.29 8.7a1 1 0 0 1 0-1.41L5.46 3.1a1 1 0 0 1 1.41 1.42L4.41 6.99H12a1 1 0 0 1 1 1Z"
    clip-rule="evenodd"
  />
</svg>`;
    var Hhe = Object.freeze({ __proto__: null, arrowLeftSvg: qhe });
    const Vhe = ee`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M1 7.99a1 1 0 0 1 1-1h7.58L7.12 4.53A1 1 0 1 1 8.54 3.1l4.16 4.17a1 1 0 0 1 0 1.41l-4.16 4.17a1 1 0 1 1-1.42-1.41l2.46-2.46H2a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
    var Whe = Object.freeze({ __proto__: null, arrowRightSvg: Vhe });
    const Khe = ee`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 13.99a1 1 0 0 1-1-1V5.4L3.54 7.86a1 1 0 0 1-1.42-1.41L6.3 2.28a1 1 0 0 1 1.41 0l4.17 4.17a1 1 0 1 1-1.41 1.41L8 5.4v7.59a1 1 0 0 1-1 1Z"
    clip-rule="evenodd"
  />
</svg>`;
    var Ghe = Object.freeze({ __proto__: null, arrowTopSvg: Khe });
    const Zhe = ee`<svg
  xmlns="http://www.w3.org/2000/svg"
  width="12"
  height="13"
  viewBox="0 0 12 13"
  fill="none"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M5.61391 1.57124C5.85142 1.42873 6.14813 1.42873 6.38564 1.57124L11.0793 4.38749C11.9179 4.89067 11.5612 6.17864 10.5832 6.17864H9.96398V10.0358H10.2854C10.6996 10.0358 11.0354 10.3716 11.0354 10.7858C11.0354 11.2 10.6996 11.5358 10.2854 11.5358H1.71416C1.29995 11.5358 0.964172 11.2 0.964172 10.7858C0.964172 10.3716 1.29995 10.0358 1.71416 10.0358H2.03558L2.03558 6.17864H1.41637C0.438389 6.17864 0.0816547 4.89066 0.920263 4.38749L5.61391 1.57124ZM3.53554 6.17864V10.0358H5.24979V6.17864H3.53554ZM6.74976 6.17864V10.0358H8.46401V6.17864H6.74976ZM8.64913 4.67864H3.35043L5.99978 3.089L8.64913 4.67864Z"
    fill="currentColor"
  /></svg
>`;
    var Yhe = Object.freeze({ __proto__: null, bankSvg: Zhe });
    const Jhe = ee`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4 6.4a1 1 0 0 1-.46.89 6.98 6.98 0 0 0 .38 6.18A7 7 0 0 0 16.46 7.3a1 1 0 0 1-.47-.92 7 7 0 0 0-12 .03Zm-2.02-.5a9 9 0 1 1 16.03 8.2A9 9 0 0 1 1.98 5.9Z"
    clip-rule="evenodd"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.03 8.63c-1.46-.3-2.72-.75-3.6-1.35l-.02-.01-.14-.11a1 1 0 0 1 1.2-1.6l.1.08c.6.4 1.52.74 2.69 1 .16-.99.39-1.88.67-2.65.3-.79.68-1.5 1.15-2.02A2.58 2.58 0 0 1 9.99 1c.8 0 1.45.44 1.92.97.47.52.84 1.23 1.14 2.02.29.77.52 1.66.68 2.64a8 8 0 0 0 2.7-1l.26-.18h.48a1 1 0 0 1 .12 2c-.86.51-2.01.91-3.34 1.18a22.24 22.24 0 0 1-.03 3.19c1.45.29 2.7.73 3.58 1.31a1 1 0 0 1-1.1 1.68c-.6-.4-1.56-.76-2.75-1-.15.8-.36 1.55-.6 2.2-.3.79-.67 1.5-1.14 2.02-.47.53-1.12.97-1.92.97-.8 0-1.45-.44-1.91-.97a6.51 6.51 0 0 1-1.15-2.02c-.24-.65-.44-1.4-.6-2.2-1.18.24-2.13.6-2.73.99a1 1 0 1 1-1.1-1.67c.88-.58 2.12-1.03 3.57-1.31a22.03 22.03 0 0 1-.04-3.2Zm2.2-1.7c.15-.86.34-1.61.58-2.24.24-.65.51-1.12.76-1.4.25-.28.4-.29.42-.29.03 0 .17.01.42.3.25.27.52.74.77 1.4.23.62.43 1.37.57 2.22a19.96 19.96 0 0 1-3.52 0Zm-.18 4.6a20.1 20.1 0 0 1-.03-2.62 21.95 21.95 0 0 0 3.94 0 20.4 20.4 0 0 1-.03 2.63 21.97 21.97 0 0 0-3.88 0Zm.27 2c.13.66.3 1.26.49 1.78.24.65.51 1.12.76 1.4.25.28.4.29.42.29.03 0 .17-.01.42-.3.25-.27.52-.74.77-1.4.19-.5.36-1.1.49-1.78a20.03 20.03 0 0 0-3.35 0Z"
    clip-rule="evenodd"
  />
</svg>`;
    var Xhe = Object.freeze({ __proto__: null, browserSvg: Jhe });
    const Qhe = ee`<svg
  xmlns="http://www.w3.org/2000/svg"
  width="12"
  height="13"
  viewBox="0 0 12 13"
  fill="none"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M4.16072 2C4.17367 2 4.18665 2 4.19968 2L7.83857 2C8.36772 1.99998 8.82398 1.99996 9.19518 2.04018C9.5895 2.0829 9.97577 2.17811 10.3221 2.42971C10.5131 2.56849 10.6811 2.73647 10.8198 2.92749C11.0714 3.27379 11.1666 3.66007 11.2094 4.0544C11.2496 4.42561 11.2496 4.88188 11.2495 5.41105V7.58896C11.2496 8.11812 11.2496 8.57439 11.2094 8.94561C11.1666 9.33994 11.0714 9.72621 10.8198 10.0725C10.6811 10.2635 10.5131 10.4315 10.3221 10.5703C9.97577 10.8219 9.5895 10.9171 9.19518 10.9598C8.82398 11 8.36772 11 7.83856 11H4.16073C3.63157 11 3.17531 11 2.80411 10.9598C2.40979 10.9171 2.02352 10.8219 1.67722 10.5703C1.48621 10.4315 1.31824 10.2635 1.17946 10.0725C0.927858 9.72621 0.832652 9.33994 0.78993 8.94561C0.749713 8.5744 0.749733 8.11813 0.749757 7.58896L0.749758 5.45C0.749758 5.43697 0.749758 5.42399 0.749757 5.41104C0.749733 4.88188 0.749713 4.42561 0.78993 4.0544C0.832652 3.66007 0.927858 3.27379 1.17946 2.92749C1.31824 2.73647 1.48621 2.56849 1.67722 2.42971C2.02352 2.17811 2.40979 2.0829 2.80411 2.04018C3.17531 1.99996 3.63157 1.99998 4.16072 2ZM2.96567 3.53145C2.69897 3.56034 2.60687 3.60837 2.55888 3.64324C2.49521 3.6895 2.43922 3.74549 2.39296 3.80916C2.35809 3.85715 2.31007 3.94926 2.28117 4.21597C2.26629 4.35335 2.25844 4.51311 2.25431 4.70832H9.74498C9.74085 4.51311 9.733 4.35335 9.71812 4.21597C9.68922 3.94926 9.6412 3.85715 9.60633 3.80916C9.56007 3.74549 9.50408 3.6895 9.44041 3.64324C9.39242 3.60837 9.30031 3.56034 9.03362 3.53145C8.75288 3.50103 8.37876 3.5 7.79961 3.5H4.19968C3.62053 3.5 3.24641 3.50103 2.96567 3.53145ZM9.74956 6.20832H2.24973V7.55C2.24973 8.12917 2.25076 8.5033 2.28117 8.78404C2.31007 9.05074 2.35809 9.14285 2.39296 9.19084C2.43922 9.25451 2.49521 9.31051 2.55888 9.35677C2.60687 9.39163 2.69897 9.43966 2.96567 9.46856C3.24641 9.49897 3.62053 9.5 4.19968 9.5H7.79961C8.37876 9.5 8.75288 9.49897 9.03362 9.46856C9.30032 9.43966 9.39242 9.39163 9.44041 9.35677C9.50408 9.31051 9.56007 9.25451 9.60633 9.19084C9.6412 9.14285 9.68922 9.05075 9.71812 8.78404C9.74854 8.5033 9.74956 8.12917 9.74956 7.55V6.20832ZM6.74963 8C6.74963 7.58579 7.08541 7.25 7.49961 7.25H8.2496C8.6638 7.25 8.99958 7.58579 8.99958 8C8.99958 8.41422 8.6638 8.75 8.2496 8.75H7.49961C7.08541 8.75 6.74963 8.41422 6.74963 8Z"
    fill="currentColor"
  /></svg
>`;
    var ede = Object.freeze({ __proto__: null, cardSvg: Qhe });
    const tde = ee`<svg
  width="28"
  height="28"
  viewBox="0 0 28 28" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M25.5297 4.92733C26.1221 5.4242 26.1996 6.30724 25.7027 6.89966L12.2836 22.8997C12.0316 23.2001 11.6652 23.3811 11.2735 23.3986C10.8817 23.4161 10.5006 23.2686 10.2228 22.9919L2.38218 15.1815C1.83439 14.6358 1.83268 13.7494 2.37835 13.2016C2.92403 12.6538 3.81046 12.6521 4.35825 13.1978L11.1183 19.9317L23.5573 5.10036C24.0542 4.50794 24.9372 4.43047 25.5297 4.92733Z"
    fill="currentColor"/>
</svg>
`;
    var rde = Object.freeze({ __proto__: null, checkmarkSvg: tde });
    const ide = ee`<svg fill="none" viewBox="0 0 14 14">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M12.9576 2.23383C13.3807 2.58873 13.4361 3.21947 13.0812 3.64263L6.37159 11.6426C6.19161 11.8572 5.92989 11.9865 5.65009 11.999C5.3703 12.0115 5.09808 11.9062 4.89965 11.7085L0.979321 7.80331C0.588042 7.41354 0.586817 6.78038 0.976585 6.3891C1.36635 5.99782 1.99952 5.99659 2.3908 6.38636L5.53928 9.52268L11.5488 2.35742C11.9037 1.93426 12.5344 1.87893 12.9576 2.23383Z"
    clip-rule="evenodd"
  />
</svg>`;
    var sde = Object.freeze({ __proto__: null, checkmarkBoldSvg: ide });
    const nde = ee`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M1.46 4.96a1 1 0 0 1 1.41 0L8 10.09l5.13-5.13a1 1 0 1 1 1.41 1.41l-5.83 5.84a1 1 0 0 1-1.42 0L1.46 6.37a1 1 0 0 1 0-1.41Z"
    clip-rule="evenodd"
  />
</svg>`;
    var ode = Object.freeze({ __proto__: null, chevronBottomSvg: nde });
    const ade = ee`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M11.04 1.46a1 1 0 0 1 0 1.41L5.91 8l5.13 5.13a1 1 0 1 1-1.41 1.41L3.79 8.71a1 1 0 0 1 0-1.42l5.84-5.83a1 1 0 0 1 1.41 0Z"
    clip-rule="evenodd"
  />
</svg>`;
    var cde = Object.freeze({ __proto__: null, chevronLeftSvg: ade });
    const lde = ee`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.96 14.54a1 1 0 0 1 0-1.41L10.09 8 4.96 2.87a1 1 0 0 1 1.41-1.41l5.84 5.83a1 1 0 0 1 0 1.42l-5.84 5.83a1 1 0 0 1-1.41 0Z"
    clip-rule="evenodd"
  />
</svg>`;
    var ude = Object.freeze({ __proto__: null, chevronRightSvg: lde });
    const hde = ee`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M14.54 11.04a1 1 0 0 1-1.41 0L8 5.92l-5.13 5.12a1 1 0 1 1-1.41-1.41l5.83-5.84a1 1 0 0 1 1.42 0l5.83 5.84a1 1 0 0 1 0 1.41Z"
    clip-rule="evenodd"
  />
</svg>`;
    var dde = Object.freeze({ __proto__: null, chevronTopSvg: hde });
    const pde = ee`<svg width="36" height="36" fill="none">
  <path
    fill="#fff"
    fill-opacity=".05"
    d="M0 14.94c0-5.55 0-8.326 1.182-10.4a9 9 0 0 1 3.359-3.358C6.614 0 9.389 0 14.94 0h6.12c5.55 0 8.326 0 10.4 1.182a9 9 0 0 1 3.358 3.359C36 6.614 36 9.389 36 14.94v6.12c0 5.55 0 8.326-1.182 10.4a9 9 0 0 1-3.359 3.358C29.386 36 26.611 36 21.06 36h-6.12c-5.55 0-8.326 0-10.4-1.182a9 9 0 0 1-3.358-3.359C0 29.386 0 26.611 0 21.06v-6.12Z"
  />
  <path
    stroke="#fff"
    stroke-opacity=".05"
    d="M14.94.5h6.12c2.785 0 4.84 0 6.46.146 1.612.144 2.743.43 3.691.97a8.5 8.5 0 0 1 3.172 3.173c.541.948.826 2.08.971 3.692.145 1.62.146 3.675.146 6.459v6.12c0 2.785 0 4.84-.146 6.46-.145 1.612-.43 2.743-.97 3.691a8.5 8.5 0 0 1-3.173 3.172c-.948.541-2.08.826-3.692.971-1.62.145-3.674.146-6.459.146h-6.12c-2.784 0-4.84 0-6.46-.146-1.612-.145-2.743-.43-3.691-.97a8.5 8.5 0 0 1-3.172-3.173c-.541-.948-.827-2.08-.971-3.692C.5 25.9.5 23.845.5 21.06v-6.12c0-2.784 0-4.84.146-6.46.144-1.612.43-2.743.97-3.691A8.5 8.5 0 0 1 4.79 1.617C5.737 1.076 6.869.79 8.48.646 10.1.5 12.156.5 14.94.5Z"
  />
  <path
    fill="url(#a)"
    d="M17.998 10.8h12.469a14.397 14.397 0 0 0-24.938.001l6.234 10.798.006-.001a7.19 7.19 0 0 1 6.23-10.799Z"
  />
  <path
    fill="url(#b)"
    d="m24.237 21.598-6.234 10.798A14.397 14.397 0 0 0 30.47 10.798H18.002l-.002.006a7.191 7.191 0 0 1 6.237 10.794Z"
  />
  <path
    fill="url(#c)"
    d="M11.765 21.601 5.531 10.803A14.396 14.396 0 0 0 18.001 32.4l6.235-10.798-.004-.004a7.19 7.19 0 0 1-12.466.004Z"
  />
  <path fill="#fff" d="M18 25.2a7.2 7.2 0 1 0 0-14.4 7.2 7.2 0 0 0 0 14.4Z" />
  <path fill="#1A73E8" d="M18 23.7a5.7 5.7 0 1 0 0-11.4 5.7 5.7 0 0 0 0 11.4Z" />
  <defs>
    <linearGradient
      id="a"
      x1="6.294"
      x2="41.1"
      y1="5.995"
      y2="5.995"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#D93025" />
      <stop offset="1" stop-color="#EA4335" />
    </linearGradient>
    <linearGradient
      id="b"
      x1="20.953"
      x2="37.194"
      y1="32.143"
      y2="2.701"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#FCC934" />
      <stop offset="1" stop-color="#FBBC04" />
    </linearGradient>
    <linearGradient
      id="c"
      x1="25.873"
      x2="9.632"
      y1="31.2"
      y2="1.759"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#1E8E3E" />
      <stop offset="1" stop-color="#34A853" />
    </linearGradient>
  </defs>
</svg>`;
    var fde = Object.freeze({ __proto__: null, chromeStoreSvg: pde });
    const gde = ee`<svg width="14" height="14" viewBox="0 0 14 14" fill="none">
  <path 
    fill-rule="evenodd" 
    clip-rule="evenodd" 
    d="M7.00235 2C4.24 2 2.00067 4.23858 2.00067 7C2.00067 9.76142 4.24 12 7.00235 12C9.7647 12 12.004 9.76142 12.004 7C12.004 4.23858 9.7647 2 7.00235 2ZM0 7C0 3.13401 3.13506 0 7.00235 0C10.8696 0 14.0047 3.13401 14.0047 7C14.0047 10.866 10.8696 14 7.00235 14C3.13506 14 0 10.866 0 7ZM7.00235 3C7.55482 3 8.00269 3.44771 8.00269 4V6.58579L9.85327 8.43575C10.2439 8.82627 10.2439 9.45944 9.85327 9.84996C9.46262 10.2405 8.82924 10.2405 8.43858 9.84996L6.29501 7.70711C6.10741 7.51957 6.00201 7.26522 6.00201 7V4C6.00201 3.44771 6.44988 3 7.00235 3Z" 
    fill="currentColor"
  />
</svg>`;
    var wde = Object.freeze({ __proto__: null, clockSvg: gde });
    const mde = ee`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M2.54 2.54a1 1 0 0 1 1.42 0L8 6.6l4.04-4.05a1 1 0 1 1 1.42 1.42L9.4 8l4.05 4.04a1 1 0 0 1-1.42 1.42L8 9.4l-4.04 4.05a1 1 0 0 1-1.42-1.42L6.6 8 2.54 3.96a1 1 0 0 1 0-1.42Z"
    clip-rule="evenodd"
  />
</svg>`;
    var yde = Object.freeze({ __proto__: null, closeSvg: mde });
    const bde = ee`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M8 2a6 6 0 1 0 0 12A6 6 0 0 0 8 2ZM0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm10.66-2.65a1 1 0 0 1 .23 1.06L9.83 9.24a1 1 0 0 1-.59.58l-2.83 1.06A1 1 0 0 1 5.13 9.6l1.06-2.82a1 1 0 0 1 .58-.59L9.6 5.12a1 1 0 0 1 1.06.23ZM7.9 7.89l-.13.35.35-.13.12-.35-.34.13Z"
    clip-rule="evenodd"
  />
</svg>`;
    var vde = Object.freeze({ __proto__: null, compassSvg: bde });
    const Ede = ee`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M10 3a7 7 0 0 0-6.85 8.44l8.29-8.3C10.97 3.06 10.49 3 10 3Zm3.49.93-9.56 9.56c.32.55.71 1.06 1.16 1.5L15 5.1a7.03 7.03 0 0 0-1.5-1.16Zm2.7 2.8-9.46 9.46a7 7 0 0 0 9.46-9.46ZM1.99 5.9A9 9 0 1 1 18 14.09 9 9 0 0 1 1.98 5.91Z"
    clip-rule="evenodd"
  />
</svg>`;
    var Cde = Object.freeze({ __proto__: null, coinPlaceholderSvg: Ede });
    const xde = ee`<svg
  xmlns="http://www.w3.org/2000/svg"
  width="16"
  height="16"
  viewBox="0 0 16 16"
  fill="none"
>
  <path
    fill="currentColor"
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M9.21498 1.28565H10.5944C11.1458 1.28562 11.6246 1.2856 12.0182 1.32093C12.4353 1.35836 12.853 1.44155 13.2486 1.66724C13.7005 1.92498 14.0749 2.29935 14.3326 2.75122C14.5583 3.14689 14.6415 3.56456 14.6789 3.9817C14.7143 4.37531 14.7142 4.85403 14.7142 5.40545V6.78489C14.7142 7.33631 14.7143 7.81503 14.6789 8.20865C14.6415 8.62578 14.5583 9.04345 14.3326 9.43912C14.0749 9.89099 13.7005 10.2654 13.2486 10.5231C12.853 10.7488 12.4353 10.832 12.0182 10.8694C11.7003 10.8979 11.3269 10.9034 10.9045 10.9045C10.9034 11.3269 10.8979 11.7003 10.8694 12.0182C10.832 12.4353 10.7488 12.853 10.5231 13.2486C10.2654 13.7005 9.89099 14.0749 9.43912 14.3326C9.04345 14.5583 8.62578 14.6415 8.20865 14.6789C7.81503 14.7143 7.33631 14.7142 6.78489 14.7142H5.40545C4.85403 14.7142 4.37531 14.7143 3.9817 14.6789C3.56456 14.6415 3.14689 14.5583 2.75122 14.3326C2.29935 14.0749 1.92498 13.7005 1.66724 13.2486C1.44155 12.853 1.35836 12.4353 1.32093 12.0182C1.2856 11.6246 1.28562 11.1458 1.28565 10.5944V9.21498C1.28562 8.66356 1.2856 8.18484 1.32093 7.79122C1.35836 7.37409 1.44155 6.95642 1.66724 6.56074C1.92498 6.10887 2.29935 5.73451 2.75122 5.47677C3.14689 5.25108 3.56456 5.16789 3.9817 5.13045C4.2996 5.10192 4.67301 5.09645 5.09541 5.09541C5.09645 4.67302 5.10192 4.2996 5.13045 3.9817C5.16789 3.56456 5.25108 3.14689 5.47676 2.75122C5.73451 2.29935 6.10887 1.92498 6.56074 1.66724C6.95642 1.44155 7.37409 1.35836 7.79122 1.32093C8.18484 1.2856 8.66356 1.28562 9.21498 1.28565ZM5.09541 7.09552C4.68397 7.09667 4.39263 7.10161 4.16046 7.12245C3.88053 7.14757 3.78516 7.18949 3.74214 7.21403C3.60139 7.29431 3.48478 7.41091 3.4045 7.55166C3.37997 7.59468 3.33804 7.69005 3.31292 7.96999C3.28659 8.26345 3.28565 8.65147 3.28565 9.25708V10.5523C3.28565 11.1579 3.28659 11.5459 3.31292 11.8394C3.33804 12.1193 3.37997 12.2147 3.4045 12.2577C3.48478 12.3985 3.60139 12.5151 3.74214 12.5954C3.78516 12.6199 3.88053 12.6618 4.16046 12.6869C4.45393 12.7133 4.84195 12.7142 5.44755 12.7142H6.74279C7.3484 12.7142 7.73641 12.7133 8.02988 12.6869C8.30981 12.6618 8.40518 12.6199 8.44821 12.5954C8.58895 12.5151 8.70556 12.3985 8.78584 12.2577C8.81038 12.2147 8.8523 12.1193 8.87742 11.8394C8.89825 11.6072 8.90319 11.3159 8.90435 10.9045C8.48219 10.9034 8.10898 10.8979 7.79122 10.8694C7.37409 10.832 6.95641 10.7488 6.56074 10.5231C6.10887 10.2654 5.73451 9.89099 5.47676 9.43912C5.25108 9.04345 5.16789 8.62578 5.13045 8.20865C5.10194 7.89089 5.09645 7.51767 5.09541 7.09552ZM7.96999 3.31292C7.69005 3.33804 7.59468 3.37997 7.55166 3.4045C7.41091 3.48478 7.29431 3.60139 7.21403 3.74214C7.18949 3.78516 7.14757 3.88053 7.12245 4.16046C7.09611 4.45393 7.09517 4.84195 7.09517 5.44755V6.74279C7.09517 7.3484 7.09611 7.73641 7.12245 8.02988C7.14757 8.30981 7.18949 8.40518 7.21403 8.4482C7.29431 8.58895 7.41091 8.70556 7.55166 8.78584C7.59468 8.81038 7.69005 8.8523 7.96999 8.87742C8.26345 8.90376 8.65147 8.9047 9.25708 8.9047H10.5523C11.1579 8.9047 11.5459 8.90376 11.8394 8.87742C12.1193 8.8523 12.2147 8.81038 12.2577 8.78584C12.3985 8.70556 12.5151 8.58895 12.5954 8.4482C12.6199 8.40518 12.6618 8.30981 12.6869 8.02988C12.7133 7.73641 12.7142 7.3484 12.7142 6.74279V5.44755C12.7142 4.84195 12.7133 4.45393 12.6869 4.16046C12.6618 3.88053 12.6199 3.78516 12.5954 3.74214C12.5151 3.60139 12.3985 3.48478 12.2577 3.4045C12.2147 3.37997 12.1193 3.33804 11.8394 3.31292C11.5459 3.28659 11.1579 3.28565 10.5523 3.28565H9.25708C8.65147 3.28565 8.26345 3.28659 7.96999 3.31292Z"
    fill="#788181"
  /></svg
>`;
    var Ide = Object.freeze({ __proto__: null, copySvg: xde });
    const _de = ee` <svg fill="none" viewBox="0 0 13 4">
  <path fill="currentColor" d="M.5 0h12L8.9 3.13a3.76 3.76 0 0 1-4.8 0L.5 0Z" />
</svg>`;
    var Ade = Object.freeze({ __proto__: null, cursorSvg: _de });
    const Sde = ee`<svg fill="none" viewBox="0 0 14 6">
  <path style="fill: var(--wui-color-bg-150);" d="M0 1h14L9.21 5.12a3.31 3.31 0 0 1-4.49 0L0 1Z" />
  <path
    style="stroke: var(--wui-color-inverse-100);"
    stroke-opacity=".05"
    d="M1.33 1.5h11.32L8.88 4.75l-.01.01a2.81 2.81 0 0 1-3.8 0l-.02-.01L1.33 1.5Z"
  />
  <path
    style="fill: var(--wui-color-bg-150);"
    d="M1.25.71h11.5L9.21 3.88a3.31 3.31 0 0 1-4.49 0L1.25.71Z"
  />
</svg> `;
    var Pde = Object.freeze({ __proto__: null, cursorTransparentSvg: Sde });
    const Ode = ee`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M13.66 2H6.34c-1.07 0-1.96 0-2.68.08-.74.08-1.42.25-2.01.68a4 4 0 0 0-.89.89c-.43.6-.6 1.27-.68 2.01C0 6.38 0 7.26 0 8.34v.89c0 1.07 0 1.96.08 2.68.08.74.25 1.42.68 2.01a4 4 0 0 0 .89.89c.6.43 1.27.6 2.01.68a27 27 0 0 0 2.68.08h7.32a27 27 0 0 0 2.68-.08 4.03 4.03 0 0 0 2.01-.68 4 4 0 0 0 .89-.89c.43-.6.6-1.27.68-2.01.08-.72.08-1.6.08-2.68v-.89c0-1.07 0-1.96-.08-2.68a4.04 4.04 0 0 0-.68-2.01 4 4 0 0 0-.89-.89c-.6-.43-1.27-.6-2.01-.68C15.62 2 14.74 2 13.66 2ZM2.82 4.38c.2-.14.48-.25 1.06-.31C4.48 4 5.25 4 6.4 4h7.2c1.15 0 1.93 0 2.52.07.58.06.86.17 1.06.31a2 2 0 0 1 .44.44c.14.2.25.48.31 1.06.07.6.07 1.37.07 2.52v.77c0 1.15 0 1.93-.07 2.52-.06.58-.17.86-.31 1.06a2 2 0 0 1-.44.44c-.2.14-.48.25-1.06.32-.6.06-1.37.06-2.52.06H6.4c-1.15 0-1.93 0-2.52-.06-.58-.07-.86-.18-1.06-.32a2 2 0 0 1-.44-.44c-.14-.2-.25-.48-.31-1.06C2 11.1 2 10.32 2 9.17V8.4c0-1.15 0-1.93.07-2.52.06-.58.17-.86.31-1.06a2 2 0 0 1 .44-.44Z"
    clip-rule="evenodd"
  />
  <path fill="currentColor" d="M6.14 17.57a1 1 0 1 0 0 2h7.72a1 1 0 1 0 0-2H6.14Z" />
</svg>`;
    var Nde = Object.freeze({ __proto__: null, desktopSvg: Ode });
    const Tde = ee`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.07 1h.57a1 1 0 0 1 0 2h-.52c-.98 0-1.64 0-2.14.06-.48.05-.7.14-.84.24-.13.1-.25.22-.34.35-.1.14-.2.35-.25.83-.05.5-.05 1.16-.05 2.15v2.74c0 .99 0 1.65.05 2.15.05.48.14.7.25.83.1.14.2.25.34.35.14.1.36.2.84.25.5.05 1.16.05 2.14.05h.52a1 1 0 0 1 0 2h-.57c-.92 0-1.69 0-2.3-.07a3.6 3.6 0 0 1-1.8-.61c-.3-.22-.57-.49-.8-.8a3.6 3.6 0 0 1-.6-1.79C.5 11.11.5 10.35.5 9.43V6.58c0-.92 0-1.7.06-2.31a3.6 3.6 0 0 1 .62-1.8c.22-.3.48-.57.79-.79a3.6 3.6 0 0 1 1.8-.61C4.37 1 5.14 1 6.06 1ZM9.5 3a1 1 0 0 1 1.42 0l4.28 4.3a1 1 0 0 1 0 1.4L10.93 13a1 1 0 0 1-1.42-1.42L12.1 9H6.8a1 1 0 1 1 0-2h5.3L9.51 4.42a1 1 0 0 1 0-1.41Z"
    clip-rule="evenodd"
  />
</svg>`;
    var kde = Object.freeze({ __proto__: null, disconnectSvg: Tde });
    const Rde = ee`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#5865F2" />
      <path
        fill="#fff"
        fill-rule="evenodd"
        d="M25.71 28.15C30.25 28 32 25.02 32 25.02c0-6.61-2.96-11.98-2.96-11.98-2.96-2.22-5.77-2.15-5.77-2.15l-.29.32c3.5 1.07 5.12 2.61 5.12 2.61a16.75 16.75 0 0 0-10.34-1.93l-.35.04a15.43 15.43 0 0 0-5.88 1.9s1.71-1.63 5.4-2.7l-.2-.24s-2.81-.07-5.77 2.15c0 0-2.96 5.37-2.96 11.98 0 0 1.73 2.98 6.27 3.13l1.37-1.7c-2.6-.79-3.6-2.43-3.6-2.43l.58.35.09.06.08.04.02.01.08.05a17.25 17.25 0 0 0 4.52 1.58 14.4 14.4 0 0 0 8.3-.86c.72-.27 1.52-.66 2.37-1.21 0 0-1.03 1.68-3.72 2.44.61.78 1.35 1.67 1.35 1.67Zm-9.55-9.6c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28.01-1.25-.93-2.28-2.1-2.28Zm7.5 0c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28 0-1.25-.93-2.28-2.1-2.28Z"
        clip-rule="evenodd"
      />
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
  </defs>
</svg>`;
    var $de = Object.freeze({ __proto__: null, discordSvg: Rde });
    const Fde = ee`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="M4.25 7a.63.63 0 0 0-.63.63v3.97c0 .28-.2.51-.47.54l-.75.07a.93.93 0 0 1-.9-.47A7.51 7.51 0 0 1 5.54.92a7.5 7.5 0 0 1 9.54 4.62c.12.35.06.72-.16 1-.74.97-1.68 1.78-2.6 2.44V4.44a.64.64 0 0 0-.63-.64h-1.06c-.35 0-.63.3-.63.64v5.5c0 .23-.12.42-.32.5l-.52.23V6.05c0-.36-.3-.64-.64-.64H7.45c-.35 0-.64.3-.64.64v4.97c0 .25-.17.46-.4.52a5.8 5.8 0 0 0-.45.11v-4c0-.36-.3-.65-.64-.65H4.25ZM14.07 12.4A7.49 7.49 0 0 1 3.6 14.08c4.09-.58 9.14-2.5 11.87-6.6v.03a7.56 7.56 0 0 1-1.41 4.91Z"
  />
</svg>`;
    var Bde = Object.freeze({ __proto__: null, etherscanSvg: Fde });
    const Lde = ee`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.71 2.99a.57.57 0 0 0-.57.57 1 1 0 0 1-1 1c-.58 0-.96 0-1.24.03-.27.03-.37.07-.42.1a.97.97 0 0 0-.36.35c-.04.08-.09.21-.11.67a2.57 2.57 0 0 1 0 5.13c.02.45.07.6.11.66.09.15.21.28.36.36.07.04.21.1.67.12a2.57 2.57 0 0 1 5.12 0c.46-.03.6-.08.67-.12a.97.97 0 0 0 .36-.36c.03-.04.07-.14.1-.41.02-.29.03-.66.03-1.24a1 1 0 0 1 1-1 .57.57 0 0 0 0-1.15 1 1 0 0 1-1-1c0-.58 0-.95-.03-1.24a1.04 1.04 0 0 0-.1-.42.97.97 0 0 0-.36-.36 1.04 1.04 0 0 0-.42-.1c-.28-.02-.65-.02-1.24-.02a1 1 0 0 1-1-1 .57.57 0 0 0-.57-.57ZM5.15 13.98a1 1 0 0 0 .99-1v-.78a.57.57 0 0 1 1.14 0v.78a1 1 0 0 0 .99 1H8.36a66.26 66.26 0 0 0 .73 0 3.78 3.78 0 0 0 1.84-.38c.46-.26.85-.64 1.1-1.1.23-.4.32-.8.36-1.22.02-.2.03-.4.03-.63a2.57 2.57 0 0 0 0-4.75c0-.23-.01-.44-.03-.63a2.96 2.96 0 0 0-.35-1.22 2.97 2.97 0 0 0-1.1-1.1c-.4-.22-.8-.31-1.22-.35a8.7 8.7 0 0 0-.64-.04 2.57 2.57 0 0 0-4.74 0c-.23 0-.44.02-.63.04-.42.04-.83.13-1.22.35-.46.26-.84.64-1.1 1.1-.33.57-.37 1.2-.39 1.84a21.39 21.39 0 0 0 0 .72v.1a1 1 0 0 0 1 .99h.78a.57.57 0 0 1 0 1.15h-.77a1 1 0 0 0-1 .98v.1a63.87 63.87 0 0 0 0 .73c0 .64.05 1.27.38 1.83.26.47.64.85 1.1 1.11.56.32 1.2.37 1.84.38a20.93 20.93 0 0 0 .72 0h.1Z"
    clip-rule="evenodd"
  />
</svg>`;
    var Ude = Object.freeze({ __proto__: null, extensionSvg: Lde });
    const Dde = ee`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.74 3.99a1 1 0 0 1 1-1H11a1 1 0 0 1 1 1v6.26a1 1 0 0 1-2 0V6.4l-6.3 6.3a1 1 0 0 1-1.4-1.42l6.29-6.3H4.74a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
    var jde = Object.freeze({ __proto__: null, externalLinkSvg: Dde });
    const Mde = ee`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#1877F2" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M26 12.38h-2.89c-.92 0-1.61.38-1.61 1.34v1.66H26l-.36 4.5H21.5v12H17v-12h-3v-4.5h3V12.5c0-3.03 1.6-4.62 5.2-4.62H26v4.5Z"
        />
      </g>
    </g>
    <path
      fill="#1877F2"
      d="M40 20a20 20 0 1 0-23.13 19.76V25.78H11.8V20h5.07v-4.4c0-5.02 3-7.79 7.56-7.79 2.19 0 4.48.4 4.48.4v4.91h-2.53c-2.48 0-3.25 1.55-3.25 3.13V20h5.54l-.88 5.78h-4.66v13.98A20 20 0 0 0 40 20Z"
    />
    <path
      fill="#fff"
      d="m27.79 25.78.88-5.78h-5.55v-3.75c0-1.58.78-3.13 3.26-3.13h2.53V8.2s-2.3-.39-4.48-.39c-4.57 0-7.55 2.77-7.55 7.78V20H11.8v5.78h5.07v13.98a20.15 20.15 0 0 0 6.25 0V25.78h4.67Z"
    />
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;
    var zde = Object.freeze({ __proto__: null, facebookSvg: Mde });
    const qde = ee`<svg style="border-radius: 9999px; overflow: hidden;"  fill="none" viewBox="0 0 1000 1000">
  <rect width="1000" height="1000" rx="9999" ry="9999" fill="#855DCD"/>
  <path fill="#855DCD" d="M0 0h1000v1000H0V0Z" />
  <path
    fill="#fff"
    d="M320 248h354v504h-51.96V521.13h-.5c-5.76-63.8-59.31-113.81-124.54-113.81s-118.78 50-124.53 113.81h-.5V752H320V248Z"
  />
  <path
    fill="#fff"
    d="m225 320 21.16 71.46h17.9v289.09a16.29 16.29 0 0 0-16.28 16.24v19.49h-3.25a16.3 16.3 0 0 0-16.28 16.24V752h182.26v-19.48a16.22 16.22 0 0 0-16.28-16.24h-3.25v-19.5a16.22 16.22 0 0 0-16.28-16.23h-19.52V320H225Zm400.3 360.55a16.3 16.3 0 0 0-15.04 10.02 16.2 16.2 0 0 0-1.24 6.22v19.49h-3.25a16.29 16.29 0 0 0-16.27 16.24V752h182.24v-19.48a16.23 16.23 0 0 0-16.27-16.24h-3.25v-19.5a16.2 16.2 0 0 0-10.04-15 16.3 16.3 0 0 0-6.23-1.23v-289.1h17.9L775 320H644.82v360.55H625.3Z"
  />
</svg>`;
    var Hde = Object.freeze({ __proto__: null, farcasterSvg: qde });
    const Vde = ee`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 3a1 1 0 0 1 1-1h14a1 1 0 1 1 0 2H1a1 1 0 0 1-1-1Zm2.63 5.25a1 1 0 0 1 1-1h8.75a1 1 0 1 1 0 2H3.63a1 1 0 0 1-1-1Zm2.62 5.25a1 1 0 0 1 1-1h3.5a1 1 0 0 1 0 2h-3.5a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
    var Wde = Object.freeze({ __proto__: null, filtersSvg: Vde });
    const Kde = ee`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#1B1F23" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M8 19.89a12 12 0 1 1 15.8 11.38c-.6.12-.8-.26-.8-.57v-3.3c0-1.12-.4-1.85-.82-2.22 2.67-.3 5.48-1.31 5.48-5.92 0-1.31-.47-2.38-1.24-3.22.13-.3.54-1.52-.12-3.18 0 0-1-.32-3.3 1.23a11.54 11.54 0 0 0-6 0c-2.3-1.55-3.3-1.23-3.3-1.23a4.32 4.32 0 0 0-.12 3.18 4.64 4.64 0 0 0-1.24 3.22c0 4.6 2.8 5.63 5.47 5.93-.34.3-.65.83-.76 1.6-.69.31-2.42.84-3.5-1 0 0-.63-1.15-1.83-1.23 0 0-1.18-.02-.09.73 0 0 .8.37 1.34 1.76 0 0 .7 2.14 4.03 1.41v2.24c0 .31-.2.68-.8.57A12 12 0 0 1 8 19.9Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;
    var Gde = Object.freeze({ __proto__: null, githubSvg: Kde });
    const Zde = ee`<svg fill="none" viewBox="0 0 40 40">
  <path
    fill="#4285F4"
    d="M32.74 20.3c0-.93-.08-1.81-.24-2.66H20.26v5.03h7a6 6 0 0 1-2.62 3.91v3.28h4.22c2.46-2.27 3.88-5.6 3.88-9.56Z"
  />
  <path
    fill="#34A853"
    d="M20.26 33a12.4 12.4 0 0 0 8.6-3.14l-4.22-3.28a7.74 7.74 0 0 1-4.38 1.26 7.76 7.76 0 0 1-7.28-5.36H8.65v3.36A12.99 12.99 0 0 0 20.26 33Z"
  />
  <path
    fill="#FBBC05"
    d="M12.98 22.47a7.79 7.79 0 0 1 0-4.94v-3.36H8.65a12.84 12.84 0 0 0 0 11.66l3.37-2.63.96-.73Z"
  />
  <path
    fill="#EA4335"
    d="M20.26 12.18a7.1 7.1 0 0 1 4.98 1.93l3.72-3.72A12.47 12.47 0 0 0 20.26 7c-5.08 0-9.47 2.92-11.6 7.17l4.32 3.36a7.76 7.76 0 0 1 7.28-5.35Z"
  />
</svg>`;
    var Yde = Object.freeze({ __proto__: null, googleSvg: Zde });
    const Jde = ee`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="M8.51 5.66a.83.83 0 0 0-.57-.2.83.83 0 0 0-.52.28.8.8 0 0 0-.25.52 1 1 0 0 1-2 0c0-.75.34-1.43.81-1.91a2.75 2.75 0 0 1 4.78 1.92c0 1.24-.8 1.86-1.25 2.2l-.04.03c-.47.36-.5.43-.5.65a1 1 0 1 1-2 0c0-1.25.8-1.86 1.24-2.2l.04-.04c.47-.36.5-.43.5-.65 0-.3-.1-.49-.24-.6ZM9.12 11.87a1.13 1.13 0 1 1-2.25 0 1.13 1.13 0 0 1 2.25 0Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6a6 6 0 1 0 0 12A6 6 0 0 0 8 2Z"
    clip-rule="evenodd"
  />
</svg>`;
    var Xde = Object.freeze({ __proto__: null, helpCircleSvg: Jde });
    const Qde = ee`<svg width="14" height="14" viewBox="0 0 14 14" fill="none">
  <path d="M4.98926 3.73932C4.2989 3.73932 3.73926 4.29896 3.73926 4.98932C3.73926 5.67968 4.2989 6.23932 4.98926 6.23932C5.67962 6.23932 6.23926 5.67968 6.23926 4.98932C6.23926 4.29896 5.67962 3.73932 4.98926 3.73932Z" fill="currentColor"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M7.60497 0.500001H6.39504C5.41068 0.499977 4.59185 0.499958 3.93178 0.571471C3.24075 0.64634 2.60613 0.809093 2.04581 1.21619C1.72745 1.44749 1.44749 1.72745 1.21619 2.04581C0.809093 2.60613 0.64634 3.24075 0.571471 3.93178C0.499958 4.59185 0.499977 5.41065 0.500001 6.39501V7.57815C0.499998 8.37476 0.499995 9.05726 0.534869 9.62725C0.570123 10.2034 0.644114 10.7419 0.828442 11.2302C0.925651 11.4877 1.05235 11.7287 1.21619 11.9542C1.44749 12.2726 1.72745 12.5525 2.04581 12.7838C2.60613 13.1909 3.24075 13.3537 3.93178 13.4285C4.59185 13.5001 5.41066 13.5 6.39503 13.5H7.60496C8.58933 13.5 9.40815 13.5001 10.0682 13.4285C10.7593 13.3537 11.3939 13.1909 11.9542 12.7838C12.2726 12.5525 12.5525 12.2726 12.7838 11.9542C13.1909 11.3939 13.3537 10.7593 13.4285 10.0682C13.5 9.40816 13.5 8.58935 13.5 7.60497V6.39505C13.5 5.41068 13.5 4.59185 13.4285 3.93178C13.3537 3.24075 13.1909 2.60613 12.7838 2.04581C12.5525 1.72745 12.2726 1.44749 11.9542 1.21619C11.3939 0.809093 10.7593 0.64634 10.0682 0.571471C9.40816 0.499958 8.58933 0.499977 7.60497 0.500001ZM3.22138 2.83422C3.38394 2.71612 3.62634 2.61627 4.14721 2.55984C4.68679 2.50138 5.39655 2.5 6.45 2.5H7.55C8.60345 2.5 9.31322 2.50138 9.8528 2.55984C10.3737 2.61627 10.6161 2.71612 10.7786 2.83422C10.9272 2.94216 11.0578 3.07281 11.1658 3.22138C11.2839 3.38394 11.3837 3.62634 11.4402 4.14721C11.4986 4.68679 11.5 5.39655 11.5 6.45V6.49703C10.9674 6.11617 10.386 5.84936 9.74213 5.81948C8.40536 5.75745 7.3556 6.73051 6.40509 7.84229C6.33236 7.92737 6.27406 7.98735 6.22971 8.02911L6.1919 8.00514L6.17483 7.99427C6.09523 7.94353 5.98115 7.87083 5.85596 7.80302C5.56887 7.64752 5.18012 7.4921 4.68105 7.4921C4.66697 7.4921 4.6529 7.49239 4.63884 7.49299C3.79163 7.52878 3.09922 8.1106 2.62901 8.55472C2.58751 8.59392 2.54594 8.6339 2.50435 8.6745C2.50011 8.34653 2.5 7.97569 2.5 7.55V6.45C2.5 5.39655 2.50138 4.68679 2.55984 4.14721C2.61627 3.62634 2.71612 3.38394 2.83422 3.22138C2.94216 3.07281 3.07281 2.94216 3.22138 2.83422ZM10.3703 8.14825C10.6798 8.37526 11.043 8.71839 11.4832 9.20889C11.4744 9.44992 11.4608 9.662 11.4402 9.8528C11.3837 10.3737 11.2839 10.6161 11.1658 10.7786C11.0578 10.9272 10.9272 11.0578 10.7786 11.1658C10.6161 11.2839 10.3737 11.3837 9.8528 11.4402C9.31322 11.4986 8.60345 11.5 7.55 11.5H6.45C5.39655 11.5 4.68679 11.4986 4.14721 11.4402C3.62634 11.3837 3.38394 11.2839 3.22138 11.1658C3.15484 11.1174 3.0919 11.0645 3.03298 11.0075C3.10126 10.9356 3.16806 10.8649 3.23317 10.7959L3.29772 10.7276C3.55763 10.4525 3.78639 10.2126 4.00232 10.0087C4.22016 9.80294 4.39412 9.66364 4.53524 9.57742C4.63352 9.51738 4.69022 9.49897 4.71275 9.49345C4.76387 9.49804 4.81803 9.51537 4.90343 9.56162C4.96409 9.59447 5.02355 9.63225 5.11802 9.69238L5.12363 9.69595C5.20522 9.74789 5.32771 9.82587 5.46078 9.89278C5.76529 10.0459 6.21427 10.186 6.74977 10.0158C7.21485 9.86796 7.59367 9.52979 7.92525 9.14195C8.91377 7.98571 9.38267 7.80495 9.64941 7.81733C9.7858 7.82366 10.0101 7.884 10.3703 8.14825Z" fill="currentColor"/>
</svg>`;
    var epe = Object.freeze({ __proto__: null, imageSvg: Qde });
    const tpe = ee`<svg
 xmlns="http://www.w3.org/2000/svg"
 width="28"
 height="28"
 viewBox="0 0 28 28"
 fill="none">
  <path
    fill="#949E9E"
    fill-rule="evenodd"
    d="M7.974 2.975h12.052c1.248 0 2.296 0 3.143.092.89.096 1.723.307 2.461.844a4.9 4.9 0 0 1 1.084 1.084c.537.738.748 1.57.844 2.461.092.847.092 1.895.092 3.143v6.802c0 1.248 0 2.296-.092 3.143-.096.89-.307 1.723-.844 2.461a4.9 4.9 0 0 1-1.084 1.084c-.738.537-1.57.748-2.461.844-.847.092-1.895.092-3.143.092H7.974c-1.247 0-2.296 0-3.143-.092-.89-.096-1.723-.307-2.461-.844a4.901 4.901 0 0 1-1.084-1.084c-.537-.738-.748-1.571-.844-2.461C.35 19.697.35 18.649.35 17.4v-6.802c0-1.248 0-2.296.092-3.143.096-.89.307-1.723.844-2.461A4.9 4.9 0 0 1 2.37 3.91c.738-.537 1.571-.748 2.461-.844.847-.092 1.895-.092 3.143-.092ZM5.133 5.85c-.652.071-.936.194-1.117.326a2.1 2.1 0 0 0-.465.465c-.132.181-.255.465-.325 1.117-.074.678-.076 1.573-.076 2.917v6.65c0 1.344.002 2.239.076 2.917.07.652.193.936.325 1.117a2.1 2.1 0 0 0 .465.465c.181.132.465.255 1.117.326.678.073 1.574.075 2.917.075h11.9c1.344 0 2.239-.002 2.917-.075.652-.071.936-.194 1.117-.326.179-.13.335-.286.465-.465.132-.181.255-.465.326-1.117.073-.678.075-1.573.075-2.917v-6.65c0-1.344-.002-2.239-.075-2.917-.071-.652-.194-.936-.326-1.117a2.1 2.1 0 0 0-.465-.465c-.181-.132-.465-.255-1.117-.326-.678-.073-1.573-.075-2.917-.075H8.05c-1.343 0-2.239.002-2.917.075Zm.467 7.275a3.15 3.15 0 1 1 6.3 0 3.15 3.15 0 0 1-6.3 0Zm8.75-1.75a1.4 1.4 0 0 1 1.4-1.4h3.5a1.4 1.4 0 0 1 0 2.8h-3.5a1.4 1.4 0 0 1-1.4-1.4Zm0 5.25a1.4 1.4 0 0 1 1.4-1.4H21a1.4 1.4 0 1 1 0 2.8h-5.25a1.4 1.4 0 0 1-1.4-1.4Z"
    clip-rule="evenodd"/>
</svg>`;
    var rpe = Object.freeze({ __proto__: null, idSvg: tpe });
    const ipe = ee`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    d="M6 10.49a1 1 0 1 0 2 0v-2a1 1 0 0 0-2 0v2ZM7 4.49a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 14.99a7 7 0 1 0 0-14 7 7 0 0 0 0 14Zm5-7a5 5 0 1 1-10 0 5 5 0 0 1 10 0Z"
    clip-rule="evenodd"
  />
</svg>`;
    var spe = Object.freeze({ __proto__: null, infoCircleSvg: ipe });
    const npe = ee`<svg width="10" height="10" viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M5.00177 1.78569C3.8179 1.78569 2.85819 2.74508 2.85819 3.92855C2.85819 4.52287 3.09928 5.05956 3.49077 5.4485L3.5005 5.45817C3.64381 5.60054 3.76515 5.72108 3.85631 5.81845C3.93747 5.90512 4.05255 6.03218 4.12889 6.1805C4.16999 6.26034 4.19 6.30843 4.21768 6.39385C4.22145 6.40546 4.22499 6.41703 4.22833 6.42855H5.77521C5.77854 6.41703 5.78208 6.40547 5.78585 6.39385C5.81353 6.30843 5.83354 6.26034 5.87464 6.1805C5.95098 6.03218 6.06606 5.90512 6.14722 5.81845C6.23839 5.72108 6.35973 5.60053 6.50304 5.45816L6.51276 5.4485C6.90425 5.05956 7.14534 4.52287 7.14534 3.92855C7.14534 2.74508 6.18563 1.78569 5.00177 1.78569ZM5.71629 7.85712H4.28724C4.28724 8.21403 4.28876 8.40985 4.30703 8.54571C4.30727 8.54748 4.30751 8.54921 4.30774 8.55091C4.30944 8.55115 4.31118 8.55138 4.31295 8.55162C4.44884 8.56989 4.64474 8.5714 5.00177 8.5714C5.3588 8.5714 5.55469 8.56989 5.69059 8.55162C5.69236 8.55138 5.69409 8.55115 5.69579 8.55091C5.69603 8.54921 5.69627 8.54748 5.6965 8.54571C5.71477 8.40985 5.71629 8.21403 5.71629 7.85712ZM2.85819 7.14283C2.85819 6.9948 2.85796 6.91114 2.8548 6.85032C2.85461 6.84656 2.85441 6.84309 2.85421 6.83988C2.84393 6.8282 2.83047 6.81334 2.81301 6.79469C2.74172 6.71856 2.63908 6.61643 2.48342 6.46178C1.83307 5.81566 1.42914 4.91859 1.42914 3.92855C1.42914 1.9561 3.02866 0.357117 5.00177 0.357117C6.97487 0.357117 8.57439 1.9561 8.57439 3.92855C8.57439 4.91859 8.17047 5.81566 7.52012 6.46178C7.36445 6.61643 7.26182 6.71856 7.19053 6.79469C7.17306 6.81334 7.1596 6.8282 7.14932 6.83988C7.14912 6.84309 7.14892 6.84656 7.14873 6.85032C7.14557 6.91114 7.14534 6.9948 7.14534 7.14283V7.85712C7.14534 7.87009 7.14535 7.88304 7.14535 7.89598C7.14541 8.19889 7.14547 8.49326 7.11281 8.73606C7.076 9.00978 6.98631 9.32212 6.72678 9.58156C6.46726 9.841 6.15481 9.93065 5.881 9.96745C5.63813 10.0001 5.34365 10 5.04064 9.99998C5.0277 9.99998 5.01474 9.99998 5.00177 9.99998C4.98879 9.99998 4.97583 9.99998 4.96289 9.99998C4.65988 10 4.36541 10.0001 4.12253 9.96745C3.84872 9.93065 3.53628 9.841 3.27675 9.58156C3.01722 9.32212 2.92753 9.00978 2.89072 8.73606C2.85807 8.49326 2.85812 8.19889 2.85818 7.89598C2.85819 7.88304 2.85819 7.87008 2.85819 7.85712V7.14283ZM7.1243 6.86977C7.12366 6.87069 7.1233 6.87116 7.12327 6.87119C7.12323 6.87123 7.12356 6.87076 7.1243 6.86977ZM2.88027 6.8712C2.88025 6.87119 2.87988 6.8707 2.87921 6.86975C2.87995 6.87072 2.88028 6.8712 2.88027 6.8712Z" fill="#949E9E"/>
</svg>`;
    var ope = Object.freeze({ __proto__: null, lightbulbSvg: npe });
    const ape = ee`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.83 1.34h6.34c.68 0 1.26 0 1.73.04.5.05.97.15 1.42.4.52.3.95.72 1.24 1.24.26.45.35.92.4 1.42.04.47.04 1.05.04 1.73v3.71c0 .69 0 1.26-.04 1.74-.05.5-.14.97-.4 1.41-.3.52-.72.95-1.24 1.25-.45.25-.92.35-1.42.4-.47.03-1.05.03-1.73.03H4.83c-.68 0-1.26 0-1.73-.04-.5-.04-.97-.14-1.42-.4-.52-.29-.95-.72-1.24-1.24a3.39 3.39 0 0 1-.4-1.41A20.9 20.9 0 0 1 0 9.88v-3.7c0-.7 0-1.27.04-1.74.05-.5.14-.97.4-1.42.3-.52.72-.95 1.24-1.24.45-.25.92-.35 1.42-.4.47-.04 1.05-.04 1.73-.04ZM3.28 3.38c-.36.03-.51.08-.6.14-.21.11-.39.29-.5.5a.8.8 0 0 0-.08.19l5.16 3.44c.45.3 1.03.3 1.48 0L13.9 4.2a.79.79 0 0 0-.08-.2c-.11-.2-.29-.38-.5-.5-.09-.05-.24-.1-.6-.13-.37-.04-.86-.04-1.6-.04H4.88c-.73 0-1.22 0-1.6.04ZM14 6.54 9.85 9.31a3.33 3.33 0 0 1-3.7 0L2 6.54v3.3c0 .74 0 1.22.03 1.6.04.36.1.5.15.6.11.2.29.38.5.5.09.05.24.1.6.14.37.03.86.03 1.6.03h6.25c.73 0 1.22 0 1.6-.03.35-.03.5-.09.6-.14.2-.12.38-.3.5-.5.05-.1.1-.24.14-.6.03-.38.03-.86.03-1.6v-3.3Z"
    clip-rule="evenodd"
  />
</svg>`;
    var cpe = Object.freeze({ __proto__: null, mailSvg: ape });
    const lpe = ee`<svg fill="none" viewBox="0 0 20 20">
  <path fill="currentColor" d="M10.81 5.81a2 2 0 1 1-4 0 2 2 0 0 1 4 0Z" />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3 4.75A4.75 4.75 0 0 1 7.75 0h4.5A4.75 4.75 0 0 1 17 4.75v10.5A4.75 4.75 0 0 1 12.25 20h-4.5A4.75 4.75 0 0 1 3 15.25V4.75ZM7.75 2A2.75 2.75 0 0 0 5 4.75v10.5A2.75 2.75 0 0 0 7.75 18h4.5A2.75 2.75 0 0 0 15 15.25V4.75A2.75 2.75 0 0 0 12.25 2h-4.5Z"
    clip-rule="evenodd"
  />
</svg>`;
    var upe = Object.freeze({ __proto__: null, mobileSvg: lpe });
    const hpe = ee`<svg fill="none" viewBox="0 0 41 40">
  <path
    style="fill: var(--wui-color-fg-100);"
    fill-opacity=".05"
    d="M.6 20a20 20 0 1 1 40 0 20 20 0 0 1-40 0Z"
  />
  <path
    fill="#949E9E"
    d="M15.6 20.31a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0ZM23.1 20.31a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0ZM28.1 22.81a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5Z"
  />
</svg>`;
    var dpe = Object.freeze({ __proto__: null, moreSvg: hpe });
    const ppe = ee`<svg fill="none" viewBox="0 0 22 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M16.32 13.62a3.14 3.14 0 1 1-.99 1.72l-1.6-.93a3.83 3.83 0 0 1-3.71 1 3.66 3.66 0 0 1-1.74-1l-1.6.94a3.14 3.14 0 1 1-1-1.73l1.6-.94a3.7 3.7 0 0 1 0-2 3.81 3.81 0 0 1 1.8-2.33c.29-.17.6-.3.92-.38V6.1a3.14 3.14 0 1 1 2 0l-.01.02v1.85H12a3.82 3.82 0 0 1 2.33 1.8 3.7 3.7 0 0 1 .39 2.91l1.6.93ZM2.6 16.54a1.14 1.14 0 0 0 1.98-1.14 1.14 1.14 0 0 0-1.98 1.14ZM11 2.01a1.14 1.14 0 1 0 0 2.28 1.14 1.14 0 0 0 0-2.28Zm1.68 10.45c.08-.19.14-.38.16-.58v-.05l.02-.13v-.13a1.92 1.92 0 0 0-.24-.8l-.11-.15a1.89 1.89 0 0 0-.74-.6 1.86 1.86 0 0 0-.77-.17h-.19a1.97 1.97 0 0 0-.89.34 1.98 1.98 0 0 0-.61.74 1.99 1.99 0 0 0-.16.9v.05a1.87 1.87 0 0 0 .24.74l.1.15c.12.16.26.3.42.42l.16.1.13.07.04.02a1.84 1.84 0 0 0 .76.17h.17a2 2 0 0 0 .91-.35 1.78 1.78 0 0 0 .52-.58l.03-.05a.84.84 0 0 0 .05-.11Zm5.15 4.5a1.14 1.14 0 0 0 1.14-1.97 1.13 1.13 0 0 0-1.55.41c-.32.55-.13 1.25.41 1.56Z"
    clip-rule="evenodd"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.63 9.43a1.5 1.5 0 1 0 1.5-2.6 1.5 1.5 0 0 0-1.5 2.6Zm.32-1.55a.5.5 0 0 1 .68-.19.5.5 0 0 1 .18.68.5.5 0 0 1-.68.19.5.5 0 0 1-.18-.68ZM17.94 8.88a1.5 1.5 0 1 1-2.6-1.5 1.5 1.5 0 1 1 2.6 1.5ZM16.9 7.69a.5.5 0 0 0-.68.19.5.5 0 0 0 .18.68.5.5 0 0 0 .68-.19.5.5 0 0 0-.18-.68ZM9.75 17.75a1.5 1.5 0 1 1 2.6 1.5 1.5 1.5 0 1 1-2.6-1.5Zm1.05 1.18a.5.5 0 0 0 .68-.18.5.5 0 0 0-.18-.68.5.5 0 0 0-.68.18.5.5 0 0 0 .18.68Z"
    clip-rule="evenodd"
  />
</svg>`;
    var fpe = Object.freeze({ __proto__: null, networkPlaceholderSvg: ppe });
    const gpe = ee`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M9.13 1h1.71c1.46 0 2.63 0 3.56.1.97.1 1.8.33 2.53.85a5 5 0 0 1 1.1 1.11c.53.73.75 1.56.86 2.53.1.93.1 2.1.1 3.55v1.72c0 1.45 0 2.62-.1 3.55-.1.97-.33 1.8-.86 2.53a5 5 0 0 1-1.1 1.1c-.73.53-1.56.75-2.53.86-.93.1-2.1.1-3.55.1H9.13c-1.45 0-2.62 0-3.56-.1-.96-.1-1.8-.33-2.52-.85a5 5 0 0 1-1.1-1.11 5.05 5.05 0 0 1-.86-2.53c-.1-.93-.1-2.1-.1-3.55V9.14c0-1.45 0-2.62.1-3.55.1-.97.33-1.8.85-2.53a5 5 0 0 1 1.1-1.1 5.05 5.05 0 0 1 2.53-.86C6.51 1 7.67 1 9.13 1ZM5.79 3.09a3.1 3.1 0 0 0-1.57.48 3 3 0 0 0-.66.67c-.24.32-.4.77-.48 1.56-.1.82-.1 1.88-.1 3.4v1.6c0 1.15 0 2.04.05 2.76l.41-.42c.5-.5.93-.92 1.32-1.24.41-.33.86-.6 1.43-.7a3 3 0 0 1 .94 0c.35.06.66.2.95.37a17.11 17.11 0 0 0 .8.45c.1-.08.2-.2.41-.4l.04-.03a27 27 0 0 1 1.95-1.84 4.03 4.03 0 0 1 1.91-.94 4 4 0 0 1 1.25 0c.73.11 1.33.46 1.91.94l.64.55V9.2c0-1.52 0-2.58-.1-3.4a3.1 3.1 0 0 0-.48-1.56 3 3 0 0 0-.66-.67 3.1 3.1 0 0 0-1.56-.48C13.37 3 12.3 3 10.79 3h-1.6c-1.52 0-2.59 0-3.4.09Zm11.18 10-.04-.05a26.24 26.24 0 0 0-1.83-1.74c-.45-.36-.73-.48-.97-.52a2 2 0 0 0-.63 0c-.24.04-.51.16-.97.52-.46.38-1.01.93-1.83 1.74l-.02.02c-.17.18-.34.34-.49.47a2.04 2.04 0 0 1-1.08.5 1.97 1.97 0 0 1-1.25-.27l-.79-.46-.02-.02a.65.65 0 0 0-.24-.1 1 1 0 0 0-.31 0c-.08.02-.21.06-.49.28-.3.24-.65.59-1.2 1.14l-.56.56-.65.66a3 3 0 0 0 .62.6c.33.24.77.4 1.57.49.81.09 1.88.09 3.4.09h1.6c1.52 0 2.58 0 3.4-.09a3.1 3.1 0 0 0 1.56-.48 3 3 0 0 0 .66-.67c.24-.32.4-.77.49-1.56l.07-1.12Zm-8.02-1.03ZM4.99 7a2 2 0 1 1 4 0 2 2 0 0 1-4 0Z"
    clip-rule="evenodd"
  />
</svg>`;
    var wpe = Object.freeze({ __proto__: null, nftPlaceholderSvg: gpe });
    const mpe = ee`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M8 0a1 1 0 0 1 1 1v5.38a1 1 0 0 1-2 0V1a1 1 0 0 1 1-1ZM5.26 2.6a1 1 0 0 1-.28 1.39 5.46 5.46 0 1 0 6.04 0 1 1 0 1 1 1.1-1.67 7.46 7.46 0 1 1-8.25 0 1 1 0 0 1 1.4.28Z"
    clip-rule="evenodd"
  />
</svg>`;
    var ype = Object.freeze({ __proto__: null, offSvg: mpe });
    const bpe = ee` <svg
  width="36"
  height="36"
  fill="none"
>
  <path
    d="M0 8a8 8 0 0 1 8-8h20a8 8 0 0 1 8 8v20a8 8 0 0 1-8 8H8a8 8 0 0 1-8-8V8Z"
    fill="#fff"
    fill-opacity=".05"
  />
  <path
    d="m18.262 17.513-8.944 9.49v.01a2.417 2.417 0 0 0 3.56 1.452l.026-.017 10.061-5.803-4.703-5.132Z"
    fill="#EA4335"
  />
  <path
    d="m27.307 15.9-.008-.008-4.342-2.52-4.896 4.36 4.913 4.912 4.325-2.494a2.42 2.42 0 0 0 .008-4.25Z"
    fill="#FBBC04"
  />
  <path
    d="M9.318 8.997c-.05.202-.084.403-.084.622V26.39c0 .218.025.42.084.621l9.246-9.247-9.246-8.768Z"
    fill="#4285F4"
  />
  <path
    d="m18.33 18 4.627-4.628-10.053-5.828a2.427 2.427 0 0 0-3.586 1.444L18.329 18Z"
    fill="#34A853"
  />
  <path
    d="M8 .5h20A7.5 7.5 0 0 1 35.5 8v20a7.5 7.5 0 0 1-7.5 7.5H8A7.5 7.5 0 0 1 .5 28V8A7.5 7.5 0 0 1 8 .5Z"
    stroke="#fff"
    stroke-opacity=".05"
  />
</svg>`;
    var vpe = Object.freeze({ __proto__: null, playStoreSvg: bpe });
    const Epe = ee`<svg
  width="13"
  height="12"
  viewBox="0 0 13 12"
  fill="none"
>
  <path
    fill="currentColor"
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M0.794373 5.99982C0.794373 5.52643 1.17812 5.14268 1.6515 5.14268H5.643V1.15109C5.643 0.677701 6.02675 0.293946 6.50012 0.293945C6.9735 0.293946 7.35725 0.677701 7.35725 1.15109V5.14268H11.3488C11.8221 5.14268 12.2059 5.52643 12.2059 5.99982C12.2059 6.47321 11.8221 6.85696 11.3488 6.85696H7.35725V10.8486C7.35725 11.3219 6.9735 11.7057 6.50012 11.7057C6.02675 11.7057 5.643 11.3219 5.643 10.8486V6.85696H1.6515C1.17812 6.85696 0.794373 6.47321 0.794373 5.99982Z"
  /></svg
>`;
    var Cpe = Object.freeze({ __proto__: null, plusSvg: Epe });
    const xpe = ee`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    d="M3 6a3 3 0 0 1 3-3h1a1 1 0 1 0 0-2H6a5 5 0 0 0-5 5v1a1 1 0 0 0 2 0V6ZM13 1a1 1 0 1 0 0 2h1a3 3 0 0 1 3 3v1a1 1 0 1 0 2 0V6a5 5 0 0 0-5-5h-1ZM3 13a1 1 0 1 0-2 0v1a5 5 0 0 0 5 5h1a1 1 0 1 0 0-2H6a3 3 0 0 1-3-3v-1ZM19 13a1 1 0 1 0-2 0v1a3 3 0 0 1-3 3h-1a1 1 0 1 0 0 2h1.01a5 5 0 0 0 5-5v-1ZM5.3 6.36c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05A1.5 1.5 0 0 0 9.2 8.14c.06-.2.06-.43.06-.89s0-.7-.06-.89A1.5 1.5 0 0 0 8.14 5.3c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06ZM10.8 6.36c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05a1.5 1.5 0 0 0 1.06-1.06c.06-.2.06-.43.06-.89s0-.7-.06-.89a1.5 1.5 0 0 0-1.06-1.06c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06ZM5.26 12.75c0-.46 0-.7.05-.89a1.5 1.5 0 0 1 1.06-1.06c.19-.05.42-.05.89-.05.46 0 .7 0 .88.05.52.14.93.54 1.06 1.06.06.2.06.43.06.89s0 .7-.06.89a1.5 1.5 0 0 1-1.06 1.06c-.19.05-.42.05-.88.05-.47 0-.7 0-.9-.05a1.5 1.5 0 0 1-1.05-1.06c-.05-.2-.05-.43-.05-.89ZM10.8 11.86c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05a1.5 1.5 0 0 0 1.06-1.06c.06-.2.06-.43.06-.89s0-.7-.06-.89a1.5 1.5 0 0 0-1.06-1.06c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06Z"
  />
</svg>`;
    var Ipe = Object.freeze({ __proto__: null, qrCodeIcon: xpe });
    const _pe = ee`<svg
  fill="none"
  viewBox="0 0 21 20"
>
  <path
    fill="currentColor"
    d="M8.8071 0.292893C9.19763 0.683417 9.19763 1.31658 8.8071 1.70711L6.91421 3.6H11.8404C14.3368 3.6 16.5533 5.1975 17.3427 7.56588L17.4487 7.88377C17.6233 8.40772 17.3402 8.97404 16.8162 9.14868C16.2923 9.32333 15.726 9.04017 15.5513 8.51623L15.4453 8.19834C14.9281 6.64664 13.476 5.6 11.8404 5.6H6.91421L8.8071 7.49289C9.19763 7.88342 9.19763 8.51658 8.8071 8.90711C8.41658 9.29763 7.78341 9.29763 7.39289 8.90711L3.79289 5.30711C3.40236 4.91658 3.40236 4.28342 3.79289 3.89289L7.39289 0.292893C7.78341 -0.0976311 8.41658 -0.0976311 8.8071 0.292893ZM4.18377 10.8513C4.70771 10.6767 5.27403 10.9598 5.44868 11.4838L5.55464 11.8017C6.07188 13.3534 7.52401 14.4 9.15964 14.4L14.0858 14.4L12.1929 12.5071C11.8024 12.1166 11.8024 11.4834 12.1929 11.0929C12.5834 10.7024 13.2166 10.7024 13.6071 11.0929L17.2071 14.6929C17.5976 15.0834 17.5976 15.7166 17.2071 16.1071L13.6071 19.7071C13.2166 20.0976 12.5834 20.0976 12.1929 19.7071C11.8024 19.3166 11.8024 18.6834 12.1929 18.2929L14.0858 16.4L9.15964 16.4C6.66314 16.4 4.44674 14.8025 3.65728 12.4341L3.55131 12.1162C3.37667 11.5923 3.65983 11.026 4.18377 10.8513Z"
  /></svg
>`;
    var Ape = Object.freeze({ __proto__: null, recycleHorizontalSvg: _pe });
    const Spe = ee`<svg fill="none" viewBox="0 0 14 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.94 1.04a1 1 0 0 1 .7 1.23l-.48 1.68a5.85 5.85 0 0 1 8.53 4.32 5.86 5.86 0 0 1-11.4 2.56 1 1 0 0 1 1.9-.57 3.86 3.86 0 1 0 1.83-4.5l1.87.53a1 1 0 0 1-.55 1.92l-4.1-1.15a1 1 0 0 1-.69-1.23l1.16-4.1a1 1 0 0 1 1.23-.7Z"
    clip-rule="evenodd"
  />
</svg>`;
    var Ppe = Object.freeze({ __proto__: null, refreshSvg: Spe });
    const Ope = ee`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M9.36 4.21a5.14 5.14 0 1 0 0 10.29 5.14 5.14 0 0 0 0-10.29ZM1.64 9.36a7.71 7.71 0 1 1 14 4.47l2.52 2.5a1.29 1.29 0 1 1-1.82 1.83l-2.51-2.51A7.71 7.71 0 0 1 1.65 9.36Z"
    clip-rule="evenodd"
  />
</svg>`;
    var Npe = Object.freeze({ __proto__: null, searchSvg: Ope });
    const Tpe = ee`<svg fill="none" viewBox="0 0 21 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M14.3808 4.34812C13.72 4.47798 12.8501 4.7587 11.5748 5.17296L9.00869 6.00646C6.90631 6.68935 5.40679 7.17779 4.38121 7.63178C3.87166 7.85734 3.5351 8.05091 3.32022 8.22035C3.11183 8.38466 3.07011 8.48486 3.05969 8.51817C2.98058 8.77103 2.98009 9.04195 3.05831 9.29509C3.06861 9.32844 3.10998 9.42878 3.31777 9.59384C3.53205 9.76404 3.86792 9.95881 4.37667 10.1862C5.29287 10.5957 6.58844 11.0341 8.35529 11.6164L10.8876 8.59854C11.2426 8.17547 11.8733 8.12028 12.2964 8.47528C12.7195 8.83029 12.7746 9.46104 12.4196 9.88412L9.88738 12.9019C10.7676 14.5408 11.4244 15.7406 11.9867 16.5718C12.299 17.0333 12.5491 17.3303 12.7539 17.5117C12.9526 17.6877 13.0586 17.711 13.0932 17.7154C13.3561 17.7484 13.6228 17.7009 13.8581 17.5791C13.8891 17.563 13.9805 17.5046 14.1061 17.2708C14.2357 17.0298 14.3679 16.6647 14.5015 16.1237C14.7705 15.0349 14.9912 13.4733 15.2986 11.2843L15.6738 8.61249C15.8603 7.28456 15.9857 6.37917 15.9989 5.7059C16.012 5.03702 15.9047 4.8056 15.8145 4.69183C15.7044 4.55297 15.5673 4.43792 15.4114 4.35365C15.2837 4.28459 15.0372 4.2191 14.3808 4.34812ZM7.99373 13.603C6.11919 12.9864 4.6304 12.4902 3.5606 12.0121C2.98683 11.7557 2.4778 11.4808 2.07383 11.1599C1.66337 10.8339 1.31312 10.4217 1.14744 9.88551C0.949667 9.24541 0.950886 8.56035 1.15094 7.92096C1.31852 7.38534 1.67024 6.97442 2.08185 6.64985C2.48697 6.33041 2.99697 6.05734 3.57166 5.80295C4.70309 5.3021 6.30179 4.78283 8.32903 4.12437L11.0196 3.25042C12.2166 2.86159 13.2017 2.54158 13.9951 2.38566C14.8065 2.22618 15.6202 2.19289 16.3627 2.59437C16.7568 2.80747 17.1035 3.09839 17.3818 3.4495C17.9062 4.111 18.0147 4.91815 17.9985 5.74496C17.9827 6.55332 17.8386 7.57903 17.6636 8.82534L17.2701 11.6268C16.9737 13.7376 16.7399 15.4022 16.4432 16.6034C16.2924 17.2135 16.1121 17.7632 15.8678 18.2176C15.6197 18.6794 15.2761 19.0971 14.7777 19.3551C14.1827 19.6632 13.5083 19.7833 12.8436 19.6997C12.2867 19.6297 11.82 19.3563 11.4277 19.0087C11.0415 18.6666 10.6824 18.213 10.3302 17.6925C9.67361 16.722 8.92648 15.342 7.99373 13.603Z"
    clip-rule="evenodd"
  />
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="21"
    height="20"
    viewBox="0 0 21 20"
    fill="none"
  ></svg></svg
>`;
    var kpe = Object.freeze({ __proto__: null, sendSvg: Tpe });
    const Rpe = ee`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.76.3a1 1 0 0 1 0 1.4L4.07 4.4h9a1 1 0 1 1 0 2h-9l2.69 2.68a1 1 0 1 1-1.42 1.42L.95 6.09a1 1 0 0 1 0-1.4l4.4-4.4a1 1 0 0 1 1.4 0Zm6.49 9.21a1 1 0 0 1 1.41 0l4.39 4.4a1 1 0 0 1 0 1.4l-4.39 4.4a1 1 0 0 1-1.41-1.42l2.68-2.68h-9a1 1 0 0 1 0-2h9l-2.68-2.68a1 1 0 0 1 0-1.42Z"
    clip-rule="evenodd"
  />
</svg>`;
    var $pe = Object.freeze({ __proto__: null, swapHorizontalSvg: Rpe });
    const Fpe = ee`<svg
  width="14"
  height="14"
  viewBox="0 0 14 14"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M13.7306 3.24213C14.0725 3.58384 14.0725 4.13786 13.7306 4.47957L10.7418 7.46737C10.4 7.80908 9.84581 7.80908 9.50399 7.46737C9.16216 7.12567 9.16216 6.57165 9.50399 6.22994L10.9986 4.73585H5.34082C4.85741 4.73585 4.46553 4.3441 4.46553 3.86085C4.46553 3.3776 4.85741 2.98585 5.34082 2.98585L10.9986 2.98585L9.50399 1.49177C9.16216 1.15006 9.16216 0.596037 9.50399 0.254328C9.84581 -0.0873803 10.4 -0.0873803 10.7418 0.254328L13.7306 3.24213ZM9.52515 10.1352C9.52515 10.6185 9.13327 11.0102 8.64986 11.0102L2.9921 11.0102L4.48669 12.5043C4.82852 12.846 4.82852 13.4001 4.48669 13.7418C4.14487 14.0835 3.59066 14.0835 3.24884 13.7418L0.26003 10.754C0.0958806 10.5899 0.0036621 10.3673 0.00366211 10.1352C0.00366212 9.90318 0.0958806 9.68062 0.26003 9.51652L3.24884 6.52872C3.59066 6.18701 4.14487 6.18701 4.48669 6.52872C4.82851 6.87043 4.82851 7.42445 4.48669 7.76616L2.9921 9.26024L8.64986 9.26024C9.13327 9.26024 9.52515 9.65199 9.52515 10.1352Z"
    fill="currentColor"
  />
</svg>

`;
    var Bpe = Object.freeze({ __proto__: null, swapHorizontalMediumSvg: Fpe });
    const Lpe = ee`<svg width="10" height="10" viewBox="0 0 10 10">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.77986 0.566631C4.0589 0.845577 4.0589 1.29784 3.77986 1.57678L3.08261 2.2738H6.34184C6.73647 2.2738 7.05637 2.5936 7.05637 2.98808C7.05637 3.38257 6.73647 3.70237 6.34184 3.70237H3.08261L3.77986 4.39938C4.0589 4.67833 4.0589 5.13059 3.77986 5.40954C3.50082 5.68848 3.04841 5.68848 2.76937 5.40954L0.852346 3.49316C0.573306 3.21421 0.573306 2.76195 0.852346 2.48301L2.76937 0.566631C3.04841 0.287685 3.50082 0.287685 3.77986 0.566631ZM6.22 4.59102C6.49904 4.31208 6.95145 4.31208 7.23049 4.59102L9.14751 6.5074C9.42655 6.78634 9.42655 7.23861 9.14751 7.51755L7.23049 9.43393C6.95145 9.71287 6.49904 9.71287 6.22 9.43393C5.94096 9.15498 5.94096 8.70272 6.22 8.42377L6.91725 7.72676L3.65802 7.72676C3.26339 7.72676 2.94349 7.40696 2.94349 7.01247C2.94349 6.61798 3.26339 6.29819 3.65802 6.29819L6.91725 6.29819L6.22 5.60117C5.94096 5.32223 5.94096 4.86997 6.22 4.59102Z"
    clip-rule="evenodd"
  />
</svg>`;
    var Upe = Object.freeze({ __proto__: null, swapHorizontalBoldSvg: Lpe });
    const Dpe = ee`<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20" fill="none">
  <path 
    fill="currentColor"
    fill-rule="evenodd" 
    clip-rule="evenodd" 
    d="M8.3071 0.292893C8.69763 0.683417 8.69763 1.31658 8.3071 1.70711L6.41421 3.6H11.3404C13.8368 3.6 16.0533 5.1975 16.8427 7.56588L16.9487 7.88377C17.1233 8.40772 16.8402 8.97404 16.3162 9.14868C15.7923 9.32333 15.226 9.04017 15.0513 8.51623L14.9453 8.19834C14.4281 6.64664 12.976 5.6 11.3404 5.6H6.41421L8.3071 7.49289C8.69763 7.88342 8.69763 8.51658 8.3071 8.90711C7.91658 9.29763 7.28341 9.29763 6.89289 8.90711L3.29289 5.30711C2.90236 4.91658 2.90236 4.28342 3.29289 3.89289L6.89289 0.292893C7.28341 -0.0976311 7.91658 -0.0976311 8.3071 0.292893ZM3.68377 10.8513C4.20771 10.6767 4.77403 10.9598 4.94868 11.4838L5.05464 11.8017C5.57188 13.3534 7.024 14.4 8.65964 14.4L13.5858 14.4L11.6929 12.5071C11.3024 12.1166 11.3024 11.4834 11.6929 11.0929C12.0834 10.7024 12.7166 10.7024 13.1071 11.0929L16.7071 14.6929C17.0976 15.0834 17.0976 15.7166 16.7071 16.1071L13.1071 19.7071C12.7166 20.0976 12.0834 20.0976 11.6929 19.7071C11.3024 19.3166 11.3024 18.6834 11.6929 18.2929L13.5858 16.4L8.65964 16.4C6.16314 16.4 3.94674 14.8025 3.15728 12.4341L3.05131 12.1162C2.87667 11.5923 3.15983 11.026 3.68377 10.8513Z" 
  />
</svg>`;
    var jpe = Object.freeze({
      __proto__: null,
      swapHorizontalRoundedBoldSvg: Dpe,
    });
    const Mpe = ee`<svg fill="none" viewBox="0 0 14 14">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.48 2.18a1 1 0 0 1 1.41 0l2.68 2.68a1 1 0 1 1-1.41 1.42l-.98-.98v4.56a1 1 0 0 1-2 0V5.3l-.97.98A1 1 0 0 1 .79 4.86l2.69-2.68Zm6.34 2.93a1 1 0 0 1 1 1v4.56l.97-.98a1 1 0 1 1 1.42 1.42l-2.69 2.68a1 1 0 0 1-1.41 0l-2.68-2.68a1 1 0 0 1 1.41-1.42l.98.98V6.1a1 1 0 0 1 1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
    var zpe = Object.freeze({ __proto__: null, swapVerticalSvg: Mpe });
    const qpe = ee`<svg width="32" height="32" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
  <g clip-path="url(#a)">
    <path fill="url(#b)" d="M0 0h32v32H0z"/>
    <path fill-rule="evenodd" clip-rule="evenodd" d="M7.034 15.252c4.975-2.167 8.293-3.596 9.953-4.287 4.74-1.971 5.725-2.314 6.366-2.325.142-.002.457.033.662.198.172.14.22.33.243.463.022.132.05.435.028.671-.257 2.7-1.368 9.248-1.933 12.27-.24 1.28-.71 1.708-1.167 1.75-.99.091-1.743-.655-2.703-1.284-1.502-.985-2.351-1.598-3.81-2.558-1.684-1.11-.592-1.721.368-2.718.252-.261 4.619-4.233 4.703-4.594.01-.045.02-.213-.08-.301-.1-.09-.246-.059-.353-.035-.15.034-2.55 1.62-7.198 4.758-.682.468-1.298.696-1.851.684-.61-.013-1.782-.344-2.653-.628-1.069-.347-1.918-.53-1.845-1.12.039-.308.462-.623 1.27-.944Z" fill="#fff"/>
  </g>
  <path d="M.5 16C.5 7.44 7.44.5 16 .5 24.56.5 31.5 7.44 31.5 16c0 8.56-6.94 15.5-15.5 15.5C7.44 31.5.5 24.56.5 16Z" stroke="#141414" stroke-opacity=".05"/>
  <defs>
    <linearGradient id="b" x1="1600" y1="0" x2="1600" y2="3176.27" gradientUnits="userSpaceOnUse">
      <stop stop-color="#2AABEE"/>
      <stop offset="1" stop-color="#229ED9"/>
    </linearGradient>
    <clipPath id="a">
      <path d="M0 16C0 7.163 7.163 0 16 0s16 7.163 16 16-7.163 16-16 16S0 24.837 0 16Z" fill="#fff"/>
    </clipPath>
  </defs>
</svg>`;
    var Hpe = Object.freeze({ __proto__: null, telegramSvg: qpe });
    const Vpe = ee`<svg width="14" height="15" viewBox="0 0 14 15" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M7 3.71875C6.0335 3.71875 5.25 2.93525 5.25 1.96875C5.25 1.00225 6.0335 0.21875 7 0.21875C7.9665 0.21875 8.75 1.00225 8.75 1.96875C8.75 2.93525 7.9665 3.71875 7 3.71875Z" fill="#949E9E"/>
  <path d="M7 8.96875C6.0335 8.96875 5.25 8.18525 5.25 7.21875C5.25 6.25225 6.0335 5.46875 7 5.46875C7.9665 5.46875 8.75 6.25225 8.75 7.21875C8.75 8.18525 7.9665 8.96875 7 8.96875Z" fill="#949E9E"/>
  <path d="M5.25 12.4688C5.25 13.4352 6.0335 14.2187 7 14.2187C7.9665 14.2187 8.75 13.4352 8.75 12.4688C8.75 11.5023 7.9665 10.7188 7 10.7188C6.0335 10.7188 5.25 11.5023 5.25 12.4688Z" fill="#949E9E"/>
</svg>`;
    var Wpe = Object.freeze({ __proto__: null, threeDotsSvg: Vpe });
    const Kpe = ee`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#5A3E85" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M18.22 25.7 20 23.91h3.34l2.1-2.1v-6.68H15.4v8.78h2.82v1.77Zm3.87-8.16h1.25v3.66H22.1v-3.66Zm-3.34 0H20v3.66h-1.25v-3.66ZM20 7.9a12 12 0 1 0 0 24 12 12 0 0 0 0-24Zm6.69 14.56-3.66 3.66h-2.72l-1.77 1.78h-1.88V26.1H13.3v-9.82l.94-2.4H26.7v8.56Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;
    var Gpe = Object.freeze({ __proto__: null, twitchSvg: Kpe });
    const Zpe = ee`<svg fill="none" viewBox="0 0 41 40">
  <g clip-path="url(#a)">
    <path fill="#000" d="M.8 0h40v40H.8z" />
    <path
      fill="#fff"
      d="m22.63 18.46 7.14-8.3h-1.69l-6.2 7.2-4.96-7.2H11.2l7.5 10.9-7.5 8.71h1.7l6.55-7.61 5.23 7.61h5.72l-7.77-11.31Zm-9.13-7.03h2.6l11.98 17.13h-2.6L13.5 11.43Z"
    />
  </g>
  <defs>
    <clipPath id="a"><path fill="#fff" d="M.8 20a20 20 0 1 1 40 0 20 20 0 0 1-40 0Z" /></clipPath>
  </defs>
</svg>`;
    var W_ = Object.freeze({ __proto__: null, xSvg: Zpe });
    const Ype = ee`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="m14.36 4.74.01.42c0 4.34-3.3 9.34-9.34 9.34A9.3 9.3 0 0 1 0 13.03a6.6 6.6 0 0 0 4.86-1.36 3.29 3.29 0 0 1-3.07-2.28c.5.1 1 .07 1.48-.06A3.28 3.28 0 0 1 .64 6.11v-.04c.46.26.97.4 1.49.41A3.29 3.29 0 0 1 1.11 2.1a9.32 9.32 0 0 0 6.77 3.43 3.28 3.28 0 0 1 5.6-3 6.59 6.59 0 0 0 2.08-.8 3.3 3.3 0 0 1-1.45 1.82A6.53 6.53 0 0 0 16 3.04c-.44.66-1 1.23-1.64 1.7Z"
  />
</svg>`;
    var Jpe = Object.freeze({ __proto__: null, twitterIconSvg: Ype });
    const Xpe = ee`<svg fill="none" viewBox="0 0 28 28">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M18.1 4.76c-.42-.73-1.33-1.01-2.09-.66l-1.42.66c-.37.18-.8.18-1.18 0l-1.4-.65a1.63 1.63 0 0 0-2.1.66l-.84 1.45c-.2.34-.53.59-.92.67l-1.7.35c-.83.17-1.39.94-1.3 1.78l.19 1.56c.04.39-.08.78-.33 1.07l-1.12 1.3c-.52.6-.52 1.5 0 2.11L5 16.38c.25.3.37.68.33 1.06l-.18 1.57c-.1.83.46 1.6 1.28 1.78l1.7.35c.4.08.73.32.93.66l.84 1.43a1.63 1.63 0 0 0 2.09.66l1.41-.66c.37-.17.8-.17 1.18 0l1.43.67c.76.35 1.66.07 2.08-.65l.86-1.45c.2-.34.54-.58.92-.66l1.68-.35A1.63 1.63 0 0 0 22.84 19l-.18-1.57a1.4 1.4 0 0 1 .33-1.06l1.12-1.32c.52-.6.52-1.5 0-2.11l-1.12-1.3a1.4 1.4 0 0 1-.33-1.07l.18-1.57c.1-.83-.46-1.6-1.28-1.77l-1.68-.35a1.4 1.4 0 0 1-.92-.66l-.86-1.47Zm-3.27-3.2a4.43 4.43 0 0 1 5.69 1.78l.54.93 1.07.22a4.43 4.43 0 0 1 3.5 4.84l-.11.96.7.83a4.43 4.43 0 0 1 .02 5.76l-.72.85.1.96a4.43 4.43 0 0 1-3.5 4.84l-1.06.22-.54.92a4.43 4.43 0 0 1-5.68 1.77l-.84-.4-.82.39a4.43 4.43 0 0 1-5.7-1.79l-.51-.89-1.09-.22a4.43 4.43 0 0 1-3.5-4.84l.1-.96-.72-.85a4.43 4.43 0 0 1 .01-5.76l.71-.83-.1-.95a4.43 4.43 0 0 1 3.5-4.84l1.08-.23.53-.9a4.43 4.43 0 0 1 5.7-1.8l.81.38.83-.39ZM18.2 9.4c.65.42.84 1.28.42 1.93l-4.4 6.87a1.4 1.4 0 0 1-2.26.14L9.5 15.39a1.4 1.4 0 0 1 2.15-1.8l1.23 1.48 3.38-5.26a1.4 1.4 0 0 1 1.93-.42Z"
    clip-rule="evenodd"
  />
</svg>`;
    var Qpe = Object.freeze({ __proto__: null, verifySvg: Xpe });
    const efe = ee`<svg fill="none" viewBox="0 0 14 14">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="m4.1 12.43-.45-.78-.93-.2a1.65 1.65 0 0 1-1.31-1.8l.1-.86-.61-.71a1.65 1.65 0 0 1 0-2.16l.6-.7-.09-.85c-.1-.86.47-1.64 1.3-1.81l.94-.2.45-.78A1.65 1.65 0 0 1 6.23.9l.77.36.78-.36c.77-.36 1.69-.07 2.12.66l.47.8.91.2c.84.17 1.4.95 1.31 1.8l-.1.86.6.7c.54.62.54 1.54.01 2.16l-.6.71.09.86c.1.85-.47 1.63-1.3 1.8l-.92.2-.47.79a1.65 1.65 0 0 1-2.12.66L7 12.74l-.77.36c-.78.35-1.7.07-2.13-.67Zm5.74-6.9a1 1 0 1 0-1.68-1.07L6.32 7.3l-.55-.66a1 1 0 0 0-1.54 1.28l1.43 1.71a1 1 0 0 0 1.61-.1l2.57-4Z"
    clip-rule="evenodd"
  />
</svg>`;
    var tfe = Object.freeze({ __proto__: null, verifyFilledSvg: efe });
    const rfe = ee`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 5.5c0-1.8 1.46-3.25 3.25-3.25H14.5c1.8 0 3.25 1.46 3.25 3.25v.28A3.25 3.25 0 0 1 20 8.88v2.24c0 1.45-.94 2.68-2.25 3.1v.28c0 1.8-1.46 3.25-3.25 3.25H3.25A3.25 3.25 0 0 1 0 14.5v-9Zm15.75 8.88h-2.38a4.38 4.38 0 0 1 0-8.76h2.38V5.5c0-.69-.56-1.25-1.25-1.25H3.25C2.56 4.25 2 4.81 2 5.5v9c0 .69.56 1.25 1.25 1.25H14.5c.69 0 1.25-.56 1.25-1.25v-.13Zm-2.38-6.76a2.37 2.37 0 1 0 0 4.75h3.38c.69 0 1.25-.55 1.25-1.24V8.87c0-.69-.56-1.24-1.25-1.24h-3.38Z"
    clip-rule="evenodd"
  />
</svg>`;
    var ife = Object.freeze({ __proto__: null, walletSvg: rfe });
    const sfe = ee`<svg fill="none" viewBox="0 0 96 67">
  <path
    fill="currentColor"
    d="M25.32 18.8a32.56 32.56 0 0 1 45.36 0l1.5 1.47c.63.62.63 1.61 0 2.22l-5.15 5.05c-.31.3-.82.3-1.14 0l-2.07-2.03a22.71 22.71 0 0 0-31.64 0l-2.22 2.18c-.31.3-.82.3-1.14 0l-5.15-5.05a1.55 1.55 0 0 1 0-2.22l1.65-1.62Zm56.02 10.44 4.59 4.5c.63.6.63 1.6 0 2.21l-20.7 20.26c-.62.61-1.63.61-2.26 0L48.28 41.83a.4.4 0 0 0-.56 0L33.03 56.21c-.63.61-1.64.61-2.27 0L10.07 35.95a1.55 1.55 0 0 1 0-2.22l4.59-4.5a1.63 1.63 0 0 1 2.27 0L31.6 43.63a.4.4 0 0 0 .57 0l14.69-14.38a1.63 1.63 0 0 1 2.26 0l14.69 14.38a.4.4 0 0 0 .57 0l14.68-14.38a1.63 1.63 0 0 1 2.27 0Z"
  />
  <path
    stroke="#000"
    stroke-opacity=".1"
    d="M25.67 19.15a32.06 32.06 0 0 1 44.66 0l1.5 1.48c.43.42.43 1.09 0 1.5l-5.15 5.05a.31.31 0 0 1-.44 0l-2.07-2.03a23.21 23.21 0 0 0-32.34 0l-2.22 2.18a.31.31 0 0 1-.44 0l-5.15-5.05a1.05 1.05 0 0 1 0-1.5l1.65-1.63ZM81 29.6l4.6 4.5c.42.41.42 1.09 0 1.5l-20.7 20.26c-.43.43-1.14.43-1.57 0L48.63 41.47a.9.9 0 0 0-1.26 0L32.68 55.85c-.43.43-1.14.43-1.57 0L10.42 35.6a1.05 1.05 0 0 1 0-1.5l4.59-4.5a1.13 1.13 0 0 1 1.57 0l14.68 14.38a.9.9 0 0 0 1.27 0l-.35-.35.35.35L47.22 29.6a1.13 1.13 0 0 1 1.56 0l14.7 14.38a.9.9 0 0 0 1.26 0L79.42 29.6a1.13 1.13 0 0 1 1.57 0Z"
  />
</svg>`,
      nfe = ee`
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_22274_4692)">
<path d="M0 6.64C0 4.17295 0 2.93942 0.525474 2.01817C0.880399 1.39592 1.39592 0.880399 2.01817 0.525474C2.93942 0 4.17295 0 6.64 0H9.36C11.8271 0 13.0606 0 13.9818 0.525474C14.6041 0.880399 15.1196 1.39592 15.4745 2.01817C16 2.93942 16 4.17295 16 6.64V9.36C16 11.8271 16 13.0606 15.4745 13.9818C15.1196 14.6041 14.6041 15.1196 13.9818 15.4745C13.0606 16 11.8271 16 9.36 16H6.64C4.17295 16 2.93942 16 2.01817 15.4745C1.39592 15.1196 0.880399 14.6041 0.525474 13.9818C0 13.0606 0 11.8271 0 9.36V6.64Z" fill="#C7B994"/>
<path d="M4.49038 5.76609C6.42869 3.86833 9.5713 3.86833 11.5096 5.76609L11.7429 5.99449C11.8398 6.08938 11.8398 6.24323 11.7429 6.33811L10.9449 7.11942C10.8964 7.16686 10.8179 7.16686 10.7694 7.11942L10.4484 6.80512C9.09617 5.48119 6.90381 5.48119 5.5516 6.80512L5.20782 7.14171C5.15936 7.18915 5.08079 7.18915 5.03234 7.14171L4.23434 6.3604C4.13742 6.26552 4.13742 6.11167 4.23434 6.01678L4.49038 5.76609ZM13.1599 7.38192L13.8702 8.07729C13.9671 8.17217 13.9671 8.32602 13.8702 8.4209L10.6677 11.5564C10.5708 11.6513 10.4137 11.6513 10.3168 11.5564L8.04388 9.33105C8.01965 9.30733 7.98037 9.30733 7.95614 9.33105L5.6833 11.5564C5.58638 11.6513 5.42925 11.6513 5.33234 11.5564L2.12982 8.42087C2.0329 8.32598 2.0329 8.17213 2.12982 8.07724L2.84004 7.38188C2.93695 7.28699 3.09408 7.28699 3.191 7.38188L5.46392 9.60726C5.48815 9.63098 5.52743 9.63098 5.55166 9.60726L7.82447 7.38188C7.92138 7.28699 8.07851 7.28699 8.17543 7.38187L10.4484 9.60726C10.4726 9.63098 10.5119 9.63098 10.5361 9.60726L12.809 7.38192C12.9059 7.28703 13.063 7.28703 13.1599 7.38192Z" fill="#202020"/>
</g>
<defs>
<clipPath id="clip0_22274_4692">
<path d="M0 8C0 3.58172 3.58172 0 8 0C12.4183 0 16 3.58172 16 8C16 12.4183 12.4183 16 8 16C3.58172 16 0 12.4183 0 8Z" fill="white"/>
</clipPath>
</defs>
</svg>
`,
      ofe = ee`
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<circle cx="11" cy="11" r="11" transform="matrix(-1 0 0 1 23 1)" fill="#202020"/>
<circle cx="11" cy="11" r="11.5" transform="matrix(-1 0 0 1 23 1)" stroke="#C7B994" stroke-opacity="0.7"/>
<path d="M15.4523 11.0686L16.7472 9.78167C13.8205 6.87297 10.1838 6.87297 7.25708 9.78167L8.55201 11.0686C10.7779 8.85645 13.2279 8.85645 15.4538 11.0686H15.4523Z" fill="#C7B994"/>
<path d="M15.0199 14.067L12 11.0656L8.98 14.067L5.96004 11.0656L4.66663 12.3511L8.98 16.6393L12 13.638L15.0199 16.6393L19.3333 12.3511L18.0399 11.0656L15.0199 14.067Z" fill="#C7B994"/>
</svg>
`;
    var dv = Object.freeze({
      __proto__: null,
      walletConnectSvg: sfe,
      walletConnectLightBrownSvg: nfe,
      walletConnectBrownSvg: ofe,
    });
    const afe = ee`
  <svg fill="none" viewBox="0 0 48 44">
    <path
      style="fill: var(--wui-color-bg-300);"
      d="M4.56 8.64c-1.23 1.68-1.23 4.08-1.23 8.88v8.96c0 4.8 0 7.2 1.23 8.88.39.55.87 1.02 1.41 1.42C7.65 38 10.05 38 14.85 38h14.3c4.8 0 7.2 0 8.88-1.22a6.4 6.4 0 0 0 1.41-1.42c.83-1.14 1.1-2.6 1.19-4.92a6.4 6.4 0 0 0 5.16-4.65c.21-.81.21-1.8.21-3.79 0-1.98 0-2.98-.22-3.79a6.4 6.4 0 0 0-5.15-4.65c-.1-2.32-.36-3.78-1.19-4.92a6.4 6.4 0 0 0-1.41-1.42C36.35 6 33.95 6 29.15 6h-14.3c-4.8 0-7.2 0-8.88 1.22a6.4 6.4 0 0 0-1.41 1.42Z"
    />
    <path
      style="fill: var(--wui-color-fg-200);"
      fill-rule="evenodd"
      d="M2.27 11.33a6.4 6.4 0 0 1 6.4-6.4h26.66a6.4 6.4 0 0 1 6.4 6.4v1.7a6.4 6.4 0 0 1 5.34 6.3v5.34a6.4 6.4 0 0 1-5.34 6.3v1.7a6.4 6.4 0 0 1-6.4 6.4H8.67a6.4 6.4 0 0 1-6.4-6.4V11.33ZM39.6 31.07h-6.93a9.07 9.07 0 1 1 0-18.14h6.93v-1.6a4.27 4.27 0 0 0-4.27-4.26H8.67a4.27 4.27 0 0 0-4.27 4.26v21.34a4.27 4.27 0 0 0 4.27 4.26h26.66a4.27 4.27 0 0 0 4.27-4.26v-1.6Zm-6.93-16a6.93 6.93 0 0 0 0 13.86h8a4.27 4.27 0 0 0 4.26-4.26v-5.34a4.27 4.27 0 0 0-4.26-4.26h-8Z"
      clip-rule="evenodd"
    />
  </svg>
`;
    var cfe = Object.freeze({ __proto__: null, walletPlaceholderSvg: afe });
    const lfe = ee`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    d="M11 6.67a1 1 0 1 0-2 0v2.66a1 1 0 0 0 2 0V6.67ZM10 14.5a1.25 1.25 0 1 0 0-2.5 1.25 1.25 0 0 0 0 2.5Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M10 1a9 9 0 1 0 0 18 9 9 0 0 0 0-18Zm-7 9a7 7 0 1 1 14 0 7 7 0 0 1-14 0Z"
    clip-rule="evenodd"
  />
</svg>`;
    var ufe = Object.freeze({ __proto__: null, warningCircleSvg: lfe });
    const hfe = ee`<svg width="22" height="22" viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M9.125 6.875C9.125 6.57833 9.21298 6.28832 9.3778 6.04165C9.54262 5.79497 9.77689 5.60271 10.051 5.48918C10.3251 5.37565 10.6267 5.34594 10.9176 5.40382C11.2086 5.4617 11.4759 5.60456 11.6857 5.81434C11.8954 6.02412 12.0383 6.29139 12.0962 6.58236C12.1541 6.87334 12.1244 7.17494 12.0108 7.44903C11.8973 7.72311 11.705 7.95738 11.4584 8.1222C11.2117 8.28703 10.9217 8.375 10.625 8.375C10.2272 8.375 9.84565 8.21696 9.56434 7.93566C9.28304 7.65436 9.125 7.27282 9.125 6.875ZM21.125 11C21.125 13.0025 20.5312 14.9601 19.4186 16.6251C18.3061 18.2902 16.7248 19.5879 14.8747 20.3543C13.0246 21.1206 10.9888 21.3211 9.02471 20.9305C7.06066 20.5398 5.25656 19.5755 3.84055 18.1595C2.42454 16.7435 1.46023 14.9393 1.06955 12.9753C0.678878 11.0112 0.879387 8.97543 1.64572 7.12533C2.41206 5.27523 3.70981 3.69392 5.37486 2.58137C7.0399 1.46882 8.99747 0.875 11 0.875C13.6844 0.877978 16.258 1.94567 18.1562 3.84383C20.0543 5.74199 21.122 8.3156 21.125 11ZM18.875 11C18.875 9.44247 18.4131 7.91992 17.5478 6.62488C16.6825 5.32985 15.4526 4.32049 14.0136 3.72445C12.5747 3.12841 10.9913 2.97246 9.46367 3.27632C7.93607 3.58017 6.53288 4.3302 5.43154 5.43153C4.3302 6.53287 3.58018 7.93606 3.27632 9.46366C2.97246 10.9913 3.12841 12.5747 3.72445 14.0136C4.32049 15.4526 5.32985 16.6825 6.62489 17.5478C7.91993 18.4131 9.44248 18.875 11 18.875C13.0879 18.8728 15.0896 18.0424 16.566 16.566C18.0424 15.0896 18.8728 13.0879 18.875 11ZM12.125 14.4387V11.375C12.125 10.8777 11.9275 10.4008 11.5758 10.0492C11.2242 9.69754 10.7473 9.5 10.25 9.5C9.98433 9.4996 9.72708 9.59325 9.52383 9.76435C9.32058 9.93544 9.18444 10.173 9.13952 10.4348C9.09461 10.6967 9.14381 10.966 9.27843 11.195C9.41304 11.4241 9.62438 11.5981 9.875 11.6863V14.75C9.875 15.2473 10.0725 15.7242 10.4242 16.0758C10.7758 16.4275 11.2527 16.625 11.75 16.625C12.0157 16.6254 12.2729 16.5318 12.4762 16.3607C12.6794 16.1896 12.8156 15.952 12.8605 15.6902C12.9054 15.4283 12.8562 15.159 12.7216 14.93C12.587 14.7009 12.3756 14.5269 12.125 14.4387Z" fill="currentColor"/>
</svg>`;
    var dfe = Object.freeze({ __proto__: null, infoSvg: hfe });
    const pfe = ee`<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M15.0162 11.6312L9.55059 2.13937C9.39228 1.86862 9.16584 1.64405 8.8938 1.48798C8.62176 1.33192 8.3136 1.2498 7.99997 1.2498C7.68634 1.2498 7.37817 1.33192 7.10613 1.48798C6.83409 1.64405 6.60765 1.86862 6.44934 2.13937L0.983716 11.6312C0.830104 11.894 0.749146 12.1928 0.749146 12.4972C0.749146 12.8015 0.830104 13.1004 0.983716 13.3631C1.14027 13.6352 1.3664 13.8608 1.63889 14.0166C1.91139 14.1725 2.22044 14.253 2.53434 14.25H13.4656C13.7793 14.2528 14.0881 14.1721 14.3603 14.0163C14.6326 13.8604 14.8585 13.635 15.015 13.3631C15.1688 13.1005 15.2499 12.8017 15.2502 12.4973C15.2504 12.193 15.1696 11.8941 15.0162 11.6312ZM13.7162 12.6125C13.6908 12.6558 13.6541 12.6914 13.6101 12.7157C13.5661 12.7399 13.5164 12.7517 13.4662 12.75H2.53434C2.48415 12.7517 2.43442 12.7399 2.39042 12.7157C2.34641 12.6914 2.30976 12.6558 2.28434 12.6125C2.26278 12.5774 2.25137 12.5371 2.25137 12.4959C2.25137 12.4548 2.26278 12.4144 2.28434 12.3794L7.74997 2.88749C7.77703 2.84583 7.81408 2.8116 7.85774 2.7879C7.9014 2.7642 7.95029 2.75178 7.99997 2.75178C8.04964 2.75178 8.09854 2.7642 8.1422 2.7879C8.18586 2.8116 8.2229 2.84583 8.24997 2.88749L13.715 12.3794C13.7367 12.4143 13.7483 12.4546 13.7486 12.4958C13.7488 12.5369 13.7376 12.5773 13.7162 12.6125ZM7.24997 8.49999V6.49999C7.24997 6.30108 7.32898 6.11031 7.46964 5.96966C7.61029 5.82901 7.80105 5.74999 7.99997 5.74999C8.19888 5.74999 8.38964 5.82901 8.5303 5.96966C8.67095 6.11031 8.74997 6.30108 8.74997 6.49999V8.49999C8.74997 8.6989 8.67095 8.88967 8.5303 9.03032C8.38964 9.17097 8.19888 9.24999 7.99997 9.24999C7.80105 9.24999 7.61029 9.17097 7.46964 9.03032C7.32898 8.88967 7.24997 8.6989 7.24997 8.49999ZM8.99997 11C8.99997 11.1978 8.94132 11.3911 8.83144 11.5556C8.72155 11.72 8.56538 11.8482 8.38265 11.9239C8.19992 11.9996 7.99886 12.0194 7.80488 11.9808C7.6109 11.9422 7.43271 11.847 7.29286 11.7071C7.15301 11.5672 7.05777 11.3891 7.01918 11.1951C6.9806 11.0011 7.0004 10.8 7.07609 10.6173C7.15177 10.4346 7.27995 10.2784 7.4444 10.1685C7.60885 10.0586 7.80219 9.99999 7.99997 9.99999C8.26518 9.99999 8.51954 10.1053 8.70707 10.2929C8.89461 10.4804 8.99997 10.7348 8.99997 11Z" fill="currentColor"/>
</svg>
`;
    var ffe = Object.freeze({ __proto__: null, exclamationTriangleSvg: pfe });
    const gfe = ee`<svg width="60" height="16" viewBox="0 0 60 16" fill="none"">
  <path d="M9.3335 4.66667C9.3335 2.08934 11.4229 0 14.0002 0H20.6669C23.2442 0 25.3335 2.08934 25.3335 4.66667V11.3333C25.3335 13.9106 23.2442 16 20.6669 16H14.0002C11.4229 16 9.3335 13.9106 9.3335 11.3333V4.66667Z" fill="#363636"/>
  <path d="M15.6055 11.0003L17.9448 4.66699H18.6316L16.2923 11.0003H15.6055Z" fill="#F6F6F6"/>
  <path d="M0 4.33333C0 1.9401 1.9401 0 4.33333 0C6.72657 0 8.66669 1.9401 8.66669 4.33333V11.6667C8.66669 14.0599 6.72657 16 4.33333 16C1.9401 16 0 14.0599 0 11.6667V4.33333Z" fill="#363636"/>
  <path d="M3.9165 9.99934V9.16602H4.74983V9.99934H3.9165Z" fill="#F6F6F6"/>
  <path d="M26 8C26 3.58172 29.3517 0 33.4863 0H52.5137C56.6483 0 60 3.58172 60 8C60 12.4183 56.6483 16 52.5137 16H33.4863C29.3517 16 26 12.4183 26 8Z" fill="#363636"/>
  <path d="M49.3687 9.95834V6.26232H50.0213V6.81966C50.256 6.40899 50.7326 6.16699 51.2606 6.16699C52.0599 6.16699 52.6173 6.67299 52.6173 7.65566V9.95834H51.972V7.69234C51.972 7.04696 51.6053 6.70966 51.07 6.70966C50.4906 6.70966 50.0213 7.17168 50.0213 7.82433V9.95834H49.3687Z" fill="#F6F6F6"/>
  <path d="M45.2538 9.95773L44.5718 6.26172H45.1877L45.6717 9.31242L46.3098 7.30306H46.9184L47.5491 9.29041L48.0404 6.26172H48.6564L47.9744 9.95773H47.2411L46.6178 8.03641L45.9871 9.95773H45.2538Z" fill="#F6F6F6"/>
  <path d="M42.3709 10.0536C41.2489 10.0536 40.5889 9.21765 40.5889 8.1103C40.5889 7.01035 41.2489 6.16699 42.3709 6.16699C43.4929 6.16699 44.1529 7.01035 44.1529 8.1103C44.1529 9.21765 43.4929 10.0536 42.3709 10.0536ZM42.3709 9.51096C43.1775 9.51096 43.4856 8.82164 43.4856 8.10296C43.4856 7.39163 43.1775 6.70966 42.3709 6.70966C41.5642 6.70966 41.2562 7.39163 41.2562 8.10296C41.2562 8.82164 41.5642 9.51096 42.3709 9.51096Z" fill="#F6F6F6"/>
  <path d="M38.2805 10.0536C37.1952 10.0536 36.5132 9.22499 36.5132 8.1103C36.5132 7.00302 37.1952 6.16699 38.2805 6.16699C39.1972 6.16699 40.0038 6.68766 39.9159 8.27896H37.1805C37.2319 8.96103 37.5472 9.5183 38.2805 9.5183C38.7718 9.5183 39.0945 9.21765 39.2045 8.87299H39.8499C39.7472 9.48903 39.1679 10.0536 38.2805 10.0536ZM37.1952 7.78765H39.2852C39.2338 7.04696 38.8892 6.70232 38.2805 6.70232C37.6132 6.70232 37.2832 7.18635 37.1952 7.78765Z" fill="#F6F6F6"/>
  <path d="M33.3828 9.95773V6.26172H34.0501V6.88506C34.2848 6.47439 34.6882 6.26172 35.1061 6.26172H35.9935V6.88506H35.0548C34.4682 6.88506 34.0501 7.26638 34.0501 8.00706V9.95773H33.3828Z" fill="#F6F6F6"/>
</svg>`;
    var wfe = Object.freeze({ __proto__: null, reownSvg: gfe });
    (Oi.EthereumProvider = OV),
      (Oi.OPTIONAL_EVENTS = W8),
      (Oi.OPTIONAL_METHODS = V8),
      (Oi.REQUIRED_EVENTS = Yp),
      (Oi.REQUIRED_METHODS = Zp),
      (Oi.default = Qp),
      Object.defineProperty(Oi, "__esModule", { value: !0 });
  });
})(rg, rg.exports);
const Pfe = Ife(rg.exports),
  Nfe = Afe({ __proto__: null, default: Pfe }, [rg.exports]);
export { Nfe as i };
